# ----------------------------------------------------------------------------
# Flask + SocketIO Setup
# ----------------------------------------------------------------------------
app = Flask(__name__)
app.config["SECRET_KEY"] = os.environ.get("SECRET_KEY", "neurogenserver")
app.config["UPLOAD_FOLDER"] = os.environ.get("UPLOAD_FOLDER", tempfile.mkdtemp())

import logging
socketio_logger = logging.getLogger('socketio')
socketio_logger.setLevel(logging.DEBUG)
handler = logging.StreamHandler()
handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
socketio_logger.addHandler(handler)

socketio = SocketIO(
    app, 
    cors_allowed_origins="*",  # Adjust this for production
    logger=socketio_logger,
    engineio_logger=socketio_logger,
    ping_timeout=60,  # Increase ping timeout
    ping_interval=25,  # More frequent pings
    max_http_buffer_size=10e6  # 10MB buffer for large transfers
)

# Connection event handlers
@socketio.on('connect')
def handle_connect():
    """Handle client connection establishment."""
    logger.info(f"Client connected: {request.sid}")
    emit('connection_established', {
        'status': 'connected', 
        'sid': request.sid, 
        'timestamp': time.time(),
        'server_version': '1.2.0'  # Include version for client compatibility checks
    })

@socketio.on('disconnect')
def handle_disconnect():
    """Handle client disconnection."""
    logger.info(f"Client disconnected: {request.sid}")
    # Don't perform cleanup yet - client might reconnect

@socketio.on('ping_from_client')
def handle_ping_from_client(data):
    """
    Handle ping messages from clients to maintain connection and measure latency.
    
    Args:
        data: Client data with optional client_timestamp
    """
    logger.debug(f"Ping received from {request.sid}: {data}")
    response = {
        'timestamp': time.time(),
        'server_received_at': time.time(),
        'original_data': data
    }
    
    # Calculate round-trip time if client timestamp was provided
    if isinstance(data, dict) and 'client_timestamp' in data:
        response['client_server_diff'] = time.time() - data['client_timestamp']
        
    emit('pong_to_client', response)

@socketio.on('request_task_status')
def handle_status_request(data):
    """
    Handle requests for task status updates.
    
    Args:
        data: Dict with task_id to request status for
    """
    task_id = data.get('task_id')
    if not task_id:
        emit('task_error', {
            'error': "Task ID missing in status request", 
            'task_id': None, 
            'sid': request.sid
        })
        return

    logger.info(f"Status request for task {task_id} from {request.sid}")
    task = get_task(task_id)
    if task:
        try:
            # Call the task's own status reporting method if available
            if hasattr(task, 'get_status') and callable(task.get_status):
                status_data = task.get_status()
                emit('progress_update', status_data)
            else:
                # Fallback for tasks without get_status method
                status_data = {
                    'task_id': task_id,
                    'task_type': getattr(task, 'task_type', 'unknown'),
                    'status': getattr(task, 'status', 'unknown'),
                    'progress': getattr(task, 'progress', 0),
                    'message': getattr(task, 'message', 'Task status retrieved'),
                    'stats': getattr(task, 'stats', {}),
                    'timestamp': time.time()
                }
                
                # If stats object has to_dict method, use it
                if hasattr(status_data['stats'], 'to_dict'):
                    status_data['stats'] = status_data['stats'].to_dict()
                    
                emit('progress_update', status_data)
        except Exception as e:
            logger.error(f"Error retrieving task status for {task_id}: {e}", exc_info=True)
            emit('task_error', {
                'task_id': task_id,
                'error': f"Error retrieving task status: {str(e)}",
                'sid': request.sid
            })
    else:
        emit('task_error', {
            'task_id': task_id,
            'error': f"Task with ID {task_id} not found",
            'sid': request.sid
        })


def emit_task_started(task_id, task_type, message=None, stats=None, details=None):
    """
    Emit a task started event via Socket.IO.
    
    Args:
        task_id: Unique identifier for the task
        task_type: Type of task (e.g., "file_processing", "web_scraping")
        message: Optional message for the UI
        stats: Optional initial statistics
        details: Optional additional details for the UI
    """
    try:
        payload = {
            'task_id': task_id,
            'task_type': task_type,
            'status': 'processing',
            'message': message or f"{task_type.replace('_', ' ').title()} started",
            'timestamp': time.time()
        }
        
        # Include optional elements if provided
        if stats:
            payload['stats'] = stats if isinstance(stats, dict) else stats.__dict__
            
        if details:
            payload['details'] = details
            
        socketio.emit('task_started', payload)
        logger.info(f"Emitted task_started for task {task_id} ({task_type})")
    except Exception as e:
        logger.error(f"Error emitting task_started: {e}")

def emit_progress_update(task_id, progress, status="processing", message=None, stats=None, details=None):
    """
    Emit a progress update event via Socket.IO.
    
    Args:
        task_id: Unique identifier for the task
        progress: Progress value (0-100)
        status: Task status string
        message: Optional message for the UI
        stats: Optional statistics object or dict
        details: Optional additional details
    """
    try:
        # Validate progress value
        progress = min(max(0, progress), 100)
        
        payload = {
            'task_id': task_id,
            'progress': progress,
            'status': status,
            'message': message or f"Progress: {progress}%",
            'timestamp': time.time()
        }
        
        # Process stats for serialization
        if stats:
            if hasattr(stats, 'to_dict') and callable(stats.to_dict):
                payload['stats'] = stats.to_dict()
            elif isinstance(stats, dict):
                payload['stats'] = stats
            else:
                # Try to convert object to dict
                try:
                    payload['stats'] = stats.__dict__
                except (AttributeError, TypeError):
                    # Last resort: try to serialize the object if possible
                    payload['stats'] = {'raw_stats': str(stats)}
        
        # Include additional details if provided
        if details:
            payload['details'] = details
            
        socketio.emit('progress_update', payload)
        logger.debug(f"Emitted progress_update for task {task_id}: {progress}%")
    except Exception as e:
        logger.error(f"Error emitting progress_update: {e}")

def emit_task_completion(task_id, task_type="generic", output_file=None, stats=None, details=None):
    """
    Emit a task completion event via Socket.IO.
    
    Args:
        task_id: Unique identifier for the task
        task_type: Type of task 
        output_file: Optional path to the output file
        stats: Optional final statistics object or dict
        details: Optional additional details
    """
    try:
        payload = {
            'task_id': task_id,
            'task_type': task_type,
            'status': 'completed',
            'progress': 100,
            'message': f"{task_type.replace('_', ' ').title()} completed successfully",
            'timestamp': time.time()
        }
        
        # Include output file if provided
        if output_file:
            payload['output_file'] = output_file
            
        # Process stats for serialization
        if stats:
            if hasattr(stats, 'to_dict') and callable(stats.to_dict):
                payload['stats'] = stats.to_dict()
            elif isinstance(stats, dict):
                payload['stats'] = stats
            else:
                # Try to convert object to dict
                try:
                    payload['stats'] = stats.__dict__
                except (AttributeError, TypeError):
                    payload['stats'] = {'raw_stats': str(stats)}
        
        # Include additional details if provided
        if details:
            payload['details'] = details
            
        socketio.emit('task_completed', payload)
        logger.info(f"Emitted task_completed for task {task_id}")
    except Exception as e:
        logger.error(f"Error emitting task_completed: {e}")

def emit_task_error(task_id, error_message, error_details=None, stats=None):
    """
    Emit a task error event via Socket.IO.
    
    Args:
        task_id: Unique identifier for the task
        error_message: Error message string
        error_details: Optional additional error details
        stats: Optional statistics at time of error
    """
    try:
        payload = {
            'task_id': task_id,
            'status': 'failed',
            'error': error_message,
            'timestamp': time.time()
        }
        
        # Include error details if provided
        if error_details:
            payload['error_details'] = error_details
            
        # Process stats for serialization
        if stats:
            if hasattr(stats, 'to_dict') and callable(stats.to_dict):
                payload['stats'] = stats.to_dict()
            elif isinstance(stats, dict):
                payload['stats'] = stats
            else:
                try:
                    payload['stats'] = stats.__dict__
                except (AttributeError, TypeError):
                    payload['stats'] = {'raw_stats': str(stats)}
                    
        socketio.emit('task_error', payload)
        logger.info(f"Emitted task_error for task {task_id}: {error_message}")
    except Exception as e:
        logger.error(f"Error emitting task_error: {e}")

def emit_task_cancelled(task_id, reason=None):
    """
    Emit a task cancellation event via Socket.IO.
    
    Args:
        task_id: Unique identifier for the task
        reason: Optional reason for cancellation
    """
    try:
        payload = {
            'task_id': task_id,
            'status': 'cancelled',
            'message': 'Task cancelled by user' if not reason else f"Task cancelled: {reason}",
            'timestamp': time.time()
        }
        
        socketio.emit('task_cancelled', payload)
        logger.info(f"Emitted task_cancelled for task {task_id}")
    except Exception as e:
        logger.error(f"Error emitting task_cancelled: {e}")
# ----------------------------------------------------------------------------
# Error Handlers
# ----------------------------------------------------------------------------
@app.errorhandler(404)
def not_found(error):
    return structured_error_response("NOT_FOUND", "The requested resource was not found.", 404)

@app.errorhandler(413)
def request_entity_too_large(error):
    return structured_error_response("REQUEST_TOO_LARGE", f"File exceeds maximum allowed size of {MAX_UPLOAD_SIZE/(1024*1024)}MB.", 413)

@app.errorhandler(500)
def internal_server_error(error):
    return structured_error_response("SERVER_ERROR", "An internal server error occurred.", 500)

# ----------------------------------------------------------------------------
# Socket.IO Events
# ----------------------------------------------------------------------------

@socketio.on('pdf_download_start')
def handle_pdf_download_start(data):
    """Handle PDF download start event."""
    logger.debug(f"PDF download start: {data}")
    
    url = data.get('url')
    task_id = data.get('task_id')
    
    if not url or not task_id:
        emit('pdf_download_error', {
            'error': 'Missing URL or task ID',
            'task_id': task_id
        })
        return
    
    # Get the task
    task = get_task(task_id)
    if not task:
        emit('pdf_download_error', {
            'error': 'Task not found',
            'task_id': task_id
        })
        return
    
    # Emit progress update
    emit('pdf_download_progress', {
        'task_id': task_id,
        'url': url,
        'progress': 0,
        'status': 'downloading',
        'message': 'Starting PDF download...'
    })

@socketio.on('pdf_download_progress')
def handle_pdf_download_progress(data):
    """Handle PDF download progress event."""
    logger.debug(f"PDF download progress: {data}")
    
    url = data.get('url')
    task_id = data.get('task_id')
    progress = data.get('progress', 0)
    
    if not url or not task_id:
        return
    
    # Emit progress update
    emit('pdf_download_progress', {
        'task_id': task_id,
        'url': url,
        'progress': progress,
        'status': 'downloading',
        'message': f'Downloading PDF: {progress}%'
    })

@socketio.on('pdf_download_complete')
def handle_pdf_download_complete(data):
    """Handle PDF download complete event."""
    logger.debug(f"PDF download complete: {data}")
    
    url = data.get('url')
    task_id = data.get('task_id')
    file_path = data.get('file_path')
    
    if not url or not task_id:
        return
    
    emit('pdf_download_progress', {
        'task_id': task_id,
        'url': url,
        'progress': 100,
        'status': 'success',
        'message': 'PDF download complete',
        'file_path': file_path
    })

@socketio.on('pdf_download_error')
def handle_pdf_download_error(data):
    """Handle PDF download error event."""
    logger.debug(f"PDF download error: {data}")
    
    url = data.get('url')
    task_id = data.get('task_id')
    error = data.get('error', 'Unknown error')
    
    if not url or not task_id:
        return
    
    # Emit error update
    emit('pdf_download_progress', {
        'task_id': task_id,
        'url': url,
        'progress': 0,
        'status': 'error',
        'message': f'PDF download failed: {error}'
    })

def emit_progress(self, progress, message=None, stats=None, pdf_downloads=None):
    """Emit progress with rate limiting, memory efficiency, and enhanced PDF statistics."""
    now = time.time()
    if (now - self.last_emit_time) > self.emit_interval or progress >= 100:
        self.progress = min(progress, 100)
        
        # Build minimal data payload
        data = {
            "task_id": self.task_id,
            "progress": self.progress,
            "status": self.status
        }
        
        if message:
            data["message"] = message
            
        if stats:
            data["stats"] = stats
            
        if pdf_downloads:
            pdf_stats = {
                "total": len(pdf_downloads),
                "downloading": sum(1 for pdf in pdf_downloads if pdf.get("status") == "downloading"),
                "processing": sum(1 for pdf in pdf_downloads if pdf.get("status") == "processing"),
                "completed": sum(1 for pdf in pdf_downloads if pdf.get("status") == "success"),
                "failed": sum(1 for pdf in pdf_downloads if pdf.get("status") == "error")
            }
            data["pdf_stats"] = pdf_stats
            
            if len(pdf_downloads) > 50:
                active_pdfs = [pdf for pdf in pdf_downloads if pdf["status"] in ("downloading", "processing", "error")]
                completed_pdfs = [pdf for pdf in pdf_downloads if pdf["status"] == "success"]
                
                first_pdfs = pdf_downloads[:10]
                last_pdfs = pdf_downloads[-10:] if len(pdf_downloads) > 10 else []
                
                selected_pdfs = list(set(first_pdfs + last_pdfs + active_pdfs))
                
                pdf_indices = {pdf["url"]: i for i, pdf in enumerate(pdf_downloads)}
                selected_pdfs.sort(key=lambda pdf: pdf_indices.get(pdf.get("url", ""), 0))
                
                data["pdf_downloads"] = selected_pdfs
                data["pdf_downloads_summary"] = {
                    "total": len(pdf_downloads),
                    "completed": len(completed_pdfs),
                    "active": len(active_pdfs),
                    "showing": len(selected_pdfs)
                }
            else:
                data["pdf_downloads"] = pdf_downloads
        
        try:
            socketio.emit("progress_update", data)
            self.last_emit_time = now
            self.last_update_time = now
        except Exception as e:
            logger.debug(f"Socket.IO emission failed: {e}")
            
@socketio.on('pdf_processing_request')
def handle_pdf_processing_request(data):
    """Handle a request to process a PDF file via Socket.IO."""
    if not data or 'pdf_path' not in data:
        emit('pdf_processing_error', {
            'error': 'PDF path is required'
        })
        return
    
    pdf_path = data['pdf_path']
    output_dir = data.get('output_dir')
    extract_tables = data.get('extract_tables', True)
    use_ocr = data.get('use_ocr', True)
    
    try:
        # Validate the PDF file
        validation = validate_pdf(pdf_path)
        if not validation['valid']:
            emit('pdf_processing_error', {
                'error': validation['error'],
                'pdf_path': pdf_path
            })
            return
            
        # Generate a task ID
        task_id = str(uuid.uuid4())
        
        # Create a PDF processing task
        task = {
            "type": "pdf_processing",
            "pdf_path": pdf_path,
            "output_dir": output_dir,
            "extract_tables": extract_tables,
            "use_ocr": use_ocr,
            "task_id": task_id,
            "status": "pending",
            "start_time": time.time(),
            "validation": validation
        }
        
        # Add task to active tasks
        with tasks_lock:
            active_tasks[task_id] = task
        
        # Emit initial status
        emit('pdf_processing_started', {
            'task_id': task_id,
            'pdf_path': pdf_path,
            'validation': validation
        })
        
        # Start processing in a background thread
        def process_thread():
            try:
                # Update status to processing
                with tasks_lock:
                    active_tasks[task_id]["status"] = "processing"
                
                # Emit processing update
                socketio.emit('pdf_processing_update', {
                    'task_id': task_id,
                    'status': 'processing',
                    'message': 'Processing started'
                })
                
                # Process the PDF
                if pdf_extractor_available:
                    result = pdf_extractor.process_pdf(
                        pdf_path=pdf_path,
                        output_path=output_dir,
                        extract_tables=extract_tables,
                        use_ocr=use_ocr,
                        return_data=True
                    )
                elif structify_available and hasattr(structify_module, 'process_pdf'):
                    result = structify_module.process_pdf(
                        pdf_path=pdf_path,
                        output_path=output_dir,
                        max_chunk_size=4096,
                        extract_tables=extract_tables,
                        use_ocr=use_ocr,
                        return_data=True
                    )
                else:
                    result = {"status": "error", "error": "No PDF processing module available"}
                
                # Update task with result
                with tasks_lock:
                    active_tasks[task_id]["status"] = "completed" if result.get("status") == "success" else "error"
                    active_tasks[task_id]["result"] = result
                    active_tasks[task_id]["end_time"] = time.time()
                
                # Emit completion or error
                if result.get("status") == "success":
                    socketio.emit('pdf_processing_complete', {
                        'task_id': task_id,
                        'status': 'completed',
                        'result': result,
                        'processing_time': time.time() - task["start_time"]
                    })
                else:
                    socketio.emit('pdf_processing_error', {
                        'task_id': task_id,
                        'status': 'error',
                        'error': result.get("error", "Unknown error")
                    })
            except Exception as e:
                logger.error(f"Error processing PDF {pdf_path}: {e}", exc_info=True)
                
                # Update task with error
                with tasks_lock:
                    active_tasks[task_id]["status"] = "error"
                    active_tasks[task_id]["error"] = str(e)
                    active_tasks[task_id]["end_time"] = time.time()
                
                # Emit error
                socketio.emit('pdf_processing_error', {
                    'task_id': task_id,
                    'status': 'error',
                    'error': str(e)
                })
        
        # Start processing thread
        thread = threading.Thread(target=process_thread)
        thread.daemon = True
        thread.start()
        
    except Exception as e:
        logger.error(f"Error initiating PDF processing: {e}", exc_info=True)
        emit('pdf_processing_error', {
            'error': str(e),
            'pdf_path': pdf_path
        })
def emit_pdf_download_progress(task_id, url, progress, status, file_path=None, error=None, details=None):
    """
    Emit PDF download progress via Socket.IO.
    
    Args:
        task_id: Task ID for the PDF download (can be subtask ID)
        url: URL being downloaded
        progress: Progress percentage (0-100)
        status: Status string (downloading, success, error)
        file_path: Optional path to saved file
        error: Optional error message if status is error
        details: Optional additional details
    """
    try:
        payload = {
            'task_id': task_id,
            'url': url,
            'progress': min(max(0, progress), 100),
            'status': status,
            'timestamp': time.time()
        }
        
        # Include optional data
        if file_path:
            payload['file_path'] = file_path
            
        if error:
            payload['error'] = error
            
        if details:
            payload['details'] = details
            
        socketio.emit('pdf_download_progress', payload)
        if progress == 100 and status == 'success':
            logger.info(f"PDF download completed: {url} -> {file_path}")
        elif status == 'error':
            logger.warning(f"PDF download error for {url}: {error}")
        else:
            logger.debug(f"PDF download progress for {url}: {progress}%")
    except Exception as e:
        logger.error(f"Error emitting pdf_download_progress: {e}")

# --- PDF processing progress events ---

def emit_pdf_processing_progress(task_id, file_path, stage, progress, output_path=None, error=None):
    """
    Emit PDF processing progress via Socket.IO.
    
    Args:
        task_id: Task ID for processing
        file_path: Path to PDF being processed
        stage: Processing stage (e.g., "text_extraction", "table_extraction")
        progress: Progress percentage (0-100)
        output_path: Optional path to output file
        error: Optional error message
    """
    try:
        payload = {
            'task_id': task_id,
            'file_path': file_path,
            'stage': stage,
            'progress': min(max(0, progress), 100),
            'timestamp': time.time()
        }
        
        # Include optional data
        if output_path:
            payload['output_path'] = output_path
            
        if error:
            payload['error'] = error
            payload['status'] = 'error'
        else:
            payload['status'] = 'processing' if progress < 100 else 'completed'
            
        socketio.emit('pdf_processing_progress', payload)
    except Exception as e:
        logger.error(f"Error emitting pdf_processing_progress: {e}") 