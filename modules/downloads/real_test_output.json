{"training_corpus":{"document_count":49,"created":"2025-06-03","documents":[{"content":"/**\n * Global Constants Configuration for Blueprint Architecture\n * \n * Central configuration for the NeuroGenServer Blueprint system.\n * All constants are frozen to prevent accidental modifications.\n * Optimized for Linux server → Windows client production deployment.\n * \n * @module config/constants\n * @version 3.0.0\n */\n\n// Determine environment\nconst ENV = (() => {\n  const hostname = window.location.hostname;\n  if (hostname === 'localhost' || hostname === '127.0.0.1') {\n    return 'development';\n  }\n  if (hostname.includes('staging') || hostname.includes('test')) {\n    return 'staging';\n  }\n  return 'production';\n})();\n\n// Base configuration that other constants depend on\nconst BASE_CONFIG = {\n  ENV,\n  DEVELOPMENT: ENV === 'development',\n  STAGING: ENV === 'staging',\n  PRODUCTION: ENV === 'production',\n  DEBUG_MODE: ENV === 'development' || window.location.search.includes('debug=true'),\n  APP_VERSION: '3.0.0',\n  APP_NAME: 'NeuroGenServer',\n  BLUEPRINT_ARCHITECTURE: true\n};\n\n// API Configuration aligned with Flask Blueprint structure\nconst API_CONFIG = {\n  API_BASE_URL: '/api',\n  API_TIMEOUT: 30000, // 30 seconds\n  API_RETRY_ATTEMPTS: 3,\n  API_RETRY_DELAY: 1000, // 1 second\n  API_RETRY_BACKOFF_MULTIPLIER: 2,\n  API_MAX_RETRY_DELAY: 10000, // 10 seconds\n  API_CONCURRENT_REQUESTS: 8, // Increased for Blueprint parallel processing\n  API_RATE_LIMIT_PER_SECOND: 15,\n  \n  // Blueprint-specific timeouts\n  BLUEPRINT_TIMEOUTS: {\n    file_processor: 600000, // 10 minutes for file processing\n    playlist_downloader: 1800000, // 30 minutes for playlists\n    web_scraper: 900000, // 15 minutes for web scraping\n    academic_search: 120000, // 2 minutes for academic searches\n    pdf_processor: 300000, // 5 minutes for PDF processing\n    management: 30000 // 30 seconds for management operations\n  }\n};\n\n// Socket.IO Configuration optimized for Blueprint real-time communication\nconst SOCKET_CONFIG = {\n  SOCKET_URL: window.location.origin,\n  SOCKET_PATH: '/socket.io/',\n  SOCKET_RECONNECTION_ATTEMPTS: 15, // Increased for production stability\n  SOCKET_RECONNECTION_DELAY: 1000,\n  SOCKET_RECONNECTION_DELAY_MAX: 8000, // Increased max delay\n  SOCKET_TIMEOUT: 25000, // Increased timeout\n  SOCKET_TRANSPORTS: ['websocket', 'polling'],\n  SOCKET_UPGRADE_TIMEOUT: 15000,\n  SOCKET_PING_INTERVAL: 25000,\n  SOCKET_PING_TIMEOUT: 60000,\n  SOCKET_PROGRESS_THROTTLE_MS: 250, // Optimized for Blueprint progress updates\n  SOCKET_PROGRESS_DEDUPE_WINDOW: 100,\n  \n  // Blueprint-specific event namespaces\n  BLUEPRINT_NAMESPACES: {\n    file_processor: '/file-processor',\n    playlist_downloader: '/playlist',\n    web_scraper: '/scraper',\n    academic_search: '/academic',\n    pdf_processor: '/pdf',\n    task_management: '/tasks'\n  }\n};\n\n// Task Configuration for Blueprint task management\nconst TASK_CONFIG = {\n  TASK_TIMEOUT_DEFAULT: 600000, // 10 minutes\n  TASK_TIMEOUT_FILE_PROCESSING: 1800000, // 30 minutes\n  TASK_TIMEOUT_PLAYLIST_DOWNLOAD: 3600000, // 1 hour\n  TASK_TIMEOUT_WEB_SCRAPING: 1200000, // 20 minutes\n  TASK_TIMEOUT_ACADEMIC_SEARCH: 300000, // 5 minutes\n  TASK_TIMEOUT_PDF_PROCESSING: 900000, // 15 minutes\n  \n  TASK_PROGRESS_UPDATE_INTERVAL: 500, // 500ms for smoother updates\n  TASK_STATUS_CHECK_INTERVAL: 2000, // 2 seconds\n  TASK_MAX_RETRIES: 5, // Increased for production reliability\n  TASK_RETRY_DELAY: 3000,\n  TASK_CLEANUP_DELAY: 120000, // 2 minutes after completion\n  TASK_HISTORY_MAX_SIZE: 200, // Increased for better tracking\n  TASK_HISTORY_PERSIST: true,\n  \n  // Blueprint-specific task priorities\n  TASK_PRIORITIES: {\n    file_processor: 'high',\n    playlist_downloader: 'medium',\n    web_scraper: 'medium',\n    academic_search: 'high',  // Elevated to high priority\n    pdf_processor: 'high',\n    management: 'critical'\n  },\n\n  // Academic Search Configuration - Complete source integration\n  ACADEMIC_SEARCH: {\n    // Supported academic sources\n    SEARCH_SOURCES: ['arxiv', 'semantic_scholar', 'openalex', 'pubmed', 'ieee', 'acm'],\n    DEFAULT_SOURCE: 'all',\n    MAX_RESULTS: 100,  // Increased for production\n    DEFAULT_LIMIT: 20,\n    RESULTS_PER_PAGE: 10,\n    \n    // Search operations\n    SUPPORTED_OPERATIONS: ['search', 'details', 'download', 'citations', 'recommendations', 'multi-source'],\n    \n    // Search types\n    SEARCH_TYPES: {\n      BASIC: 'basic',\n      ADVANCED: 'advanced',\n      CITATION: 'citation',\n      AUTHOR: 'author',\n      TITLE: 'title'\n    },\n    \n    // Result filtering\n    FILTERS: {\n      DATE_RANGES: ['all', 'last_year', 'last_5_years', 'last_10_years', 'custom'],\n      PUBLICATION_TYPES: ['all', 'journal', 'conference', 'preprint', 'book', 'thesis'],\n      SORT_OPTIONS: ['relevance', 'date', 'citations', 'title', 'author']\n    },\n    \n    // Source-specific limits\n    SOURCE_LIMITS: {\n      arxiv: 50,\n      semantic_scholar: 100,\n      openalex: 200,\n      pubmed: 50,\n      ieee: 25,\n      acm: 25\n    },\n\n    // API timeouts per source (ms)\n    SOURCE_TIMEOUTS: {\n      arxiv: 30000,\n      semantic_scholar: 45000,\n      openalex: 60000,\n      pubmed: 30000,\n      ieee: 45000,\n      acm: 45000\n    }\n  }\n};\n\n// File Processing Configuration optimized for cross-platform deployment\nconst FILE_CONFIG = {\n  MAX_FILE_SIZE: 500 * 1024 * 1024, // 500MB - increased for production\n  MAX_BATCH_SIZE: 2000, // Increased batch size\n  CHUNK_SIZE: 2 * 1024 * 1024, // 2MB chunks for better performance\n  \n  // Extended file support for production\n  ALLOWED_EXTENSIONS: [\n    // Programming languages\n    '.py', '.js', '.ts', '.jsx', '.tsx', '.vue', '.java', '.c', '.cpp', '.cs', '.php',\n    '.rb', '.go', '.rs', '.swift', '.kt', '.scala', '.r', '.m', '.h', '.hpp', '.dart',\n    '.perl', '.lua', '.bash', '.powershell', '.vb', '.fs', '.clj', '.elm', '.hs',\n    \n    // Web technologies\n    '.html', '.css', '.scss', '.sass', '.less', '.styl', '.xml', '.svg',\n    \n    // Configuration and data\n    '.json', '.yaml', '.yml', '.toml', '.ini', '.cfg', '.conf', '.env', '.properties',\n    '.csv', '.tsv', '.sql', '.db', '.sqlite', '.log',\n    \n    // Documentation\n    '.md', '.txt', '.rst', '.tex', '.rtf', '.adoc',\n    \n    // Office documents\n    '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx', '.odt', '.ods', '.odp',\n    \n    // Archives\n    '.zip', '.rar', '.7z', '.tar', '.gz', '.bz2', '.xz'\n  ],\n  \n  // Cross-platform path handling\n  PATH_SEPARATORS: {\n    windows: '\\\\\\\\',\n    linux: '/',\n    normalized: '/'\n  },\n  \n  // Windows compatibility\n  WINDOWS_RESERVED_NAMES: ['CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9'],\n  WINDOWS_INVALID_CHARS: /[<>:\"|?*]/g,\n  MAX_WINDOWS_PATH_LENGTH: 260,\n  MAX_FILENAME_LENGTH: 255,\n  \n  // Default output paths for cross-platform deployment\n  DEFAULT_OUTPUT_PATHS: {\n    windows: 'C:\\\\\\\\Users\\\\\\\\{username}\\\\\\\\Documents\\\\\\\\NeuroGenServer',\n    linux: '/home/{username}/Documents/NeuroGenServer',\n    mac: '/Users/{username}/Documents/NeuroGenServer',\n    fallback: './downloads'\n  }\n};\n\n// UI Configuration optimized for Blueprint frontend\nconst UI_CONFIG = {\n  TOAST_DURATION: 6000, // Increased for better user feedback\n  TOAST_POSITION: 'top-right',\n  MODAL_ANIMATION_DURATION: 250,\n  DEBOUNCE_DELAY: 250, // Optimized for responsive UI\n  THROTTLE_DELAY: 100,\n  PROGRESS_BAR_ANIMATION_DURATION: 150,\n  PROGRESS_BAR_UPDATE_THRESHOLD: 0.5, // More sensitive updates\n  TAB_ANIMATION_DURATION: 200,\n  LOADING_SPINNER_DELAY: 150,\n  ERROR_MESSAGE_MAX_LENGTH: 750, // Increased for detailed error messages\n  THEME_TRANSITION_DURATION: 300,\n  MAX_VISIBLE_ITEMS_IN_LIST: 150, // Increased for better UX\n  AUTOSAVE_INTERVAL: 20000, // 20 seconds for better data safety\n  IDLE_TIMEOUT: 1800000, // 30 minutes\n  \n  // Blueprint-specific UI settings\n  MODULE_LOAD_TIMEOUT: 15000, // 15 seconds for module loading\n  MODULE_RETRY_ATTEMPTS: 3,\n  BLUEPRINT_TAB_ORDER: [\n    'file_processor',\n    'web_scraper', \n    'academic_search',\n    'playlist_downloader',\n    'pdf_processor',\n    'task_history'\n  ]\n};\n\n// Storage Configuration for Blueprint state management\nconst STORAGE_CONFIG = {\n  STORAGE_PREFIX: 'neurogen_v3_',\n  STORAGE_VERSION: '3.0',\n  STORAGE_QUOTA_WARNING_THRESHOLD: 0.85, // Warning at 85% usage\n  \n  SESSION_STORAGE_KEYS: [\n    'current_task',\n    'active_blueprint',\n    'active_tab',\n    'temp_form_data',\n    'progress_state',\n    'socket_state'\n  ],\n  \n  LOCAL_STORAGE_KEYS: [\n    'theme',\n    'preferences',\n    'task_history',\n    'recent_paths',\n    'api_keys',\n    'debug_mode',\n    'blueprint_settings',\n    'cross_platform_paths'\n  ],\n  \n  INDEXED_DB_NAME: 'NeuroGenServerDB',\n  INDEXED_DB_VERSION: 3,\n  INDEXED_DB_STORES: ['tasks', 'files', 'cache', 'blueprints', 'analytics']\n};\n\n// Performance Configuration for production deployment\nconst PERFORMANCE_CONFIG = {\n  ENABLE_PERFORMANCE_MONITORING: BASE_CONFIG.DEVELOPMENT || BASE_CONFIG.STAGING,\n  PERFORMANCE_SAMPLE_RATE: BASE_CONFIG.PRODUCTION ? 0.05 : 0.1, // 5% in production\n  PERFORMANCE_BUFFER_SIZE: 200,\n  LONG_TASK_THRESHOLD: 50, // milliseconds\n  MEMORY_WARNING_THRESHOLD: 200 * 1024 * 1024, // 200MB\n  MEMORY_CHECK_INTERVAL: 90000, // 1.5 minutes\n  FPS_TARGET: 60,\n  FPS_WARNING_THRESHOLD: 45, // Higher threshold for production\n  \n  // Blueprint-specific performance settings\n  MODULE_CACHE_SIZE: 50, // Cache 50 modules\n  MODULE_PRELOAD: true, // Preload critical modules\n  LAZY_LOADING: true, // Enable lazy loading for non-critical modules\n  WORKER_THREADS: navigator.hardwareConcurrency || 4\n};\n\n// Feature Flags for Blueprint modules\nconst FEATURE_FLAGS = {\n  // Core Blueprint features\n  ENABLE_FILE_PROCESSING: true,\n  ENABLE_PLAYLIST_DOWNLOADER: true,\n  ENABLE_WEB_SCRAPER: true,\n  ENABLE_ACADEMIC_SEARCH: true,\n  ENABLE_PDF_PROCESSOR: true,\n  ENABLE_TASK_HISTORY: true,\n  \n  // Cross-platform features\n  ENABLE_CROSS_PLATFORM_PATHS: true,\n  ENABLE_WINDOWS_CLIENT_SUPPORT: true,\n  ENABLE_LINUX_SERVER_OPTIMIZATION: true,\n  \n  // UI features\n  ENABLE_DARK_MODE: true,\n  ENABLE_KEYBOARD_SHORTCUTS: true,\n  ENABLE_DRAG_DROP: true,\n  ENABLE_REAL_TIME_UPDATES: true,\n  ENABLE_PROGRESS_ANIMATIONS: true,\n  \n  // Advanced features\n  ENABLE_BATCH_PROCESSING: true,\n  ENABLE_CONCURRENT_DOWNLOADS: true,\n  ENABLE_EXPORT_IMPORT: true,\n  ENABLE_ANALYTICS: BASE_CONFIG.PRODUCTION,\n  ENABLE_ERROR_REPORTING: true,\n  ENABLE_SERVICE_WORKER: BASE_CONFIG.PRODUCTION,\n  ENABLE_PWA_FEATURES: BASE_CONFIG.PRODUCTION,\n  \n  // Experimental features\n  ENABLE_WEBGL_VISUALIZATIONS: false,\n  ENABLE_VOICE_COMMANDS: false,\n  ENABLE_COLLABORATION: false,\n  ENABLE_AI_ASSISTANCE: false\n};\n\n// Validation Rules optimized for cross-platform deployment\nconst VALIDATION_CONFIG = {\n  // Path validation for different platforms\n  WINDOWS_PATH_REGEX: /^[a-zA-Z]:[\\\\\\/](?:[^<>:\"|?*]+[\\\\\\/])*[^<>:\"|?*]*$/,\n  LINUX_PATH_REGEX: /^\\/(?:[^\\/\\0]+\\/)*[^\\/\\0]*$/,\n  GENERIC_PATH_REGEX: /^[^\\0]+$/,\n  \n  // URL validation\n  URL_REGEX: /^https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&//=]*)$/,\n  EMAIL_REGEX: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,\n  \n  // Platform-specific validation\n  YOUTUBE_PLAYLIST_REGEX: /(?:youtube\\.com\\/(?:playlist\\?list=|watch\\?.*&list=)|youtu\\.be\\/(?:playlist\\?list=))([a-zA-Z0-9_-]+)/,\n  ARXIV_PAPER_REGEX: /arxiv\\.org\\/(?:abs|pdf)\\/([0-9]{4}\\.[0-9]{4,5})/,\n  DOI_REGEX: /10\\.\\d{4,9}\\/[-._;()\\/:A-Z0-9]+/i,\n  \n  // File validation\n  FILENAME_REGEX: /^[^<>:\"/\\\\|?*\\x00-\\x1f]+$/,\n  SAFE_FILENAME_REGEX: /^[a-zA-Z0-9._-]+$/,\n  \n  // Limits\n  MAX_PATH_LENGTH: 260, // Windows MAX_PATH\n  MAX_FILENAME_LENGTH: 255,\n  MAX_URL_LENGTH: 2048,\n  MAX_PLAYLIST_URLS: 100, // Increased for production\n  MAX_SCRAPER_URLS: 200, // Increased for production\n  MAX_CONCURRENT_TASKS: 10,\n  \n  // Cross-platform limits\n  WINDOWS_MAX_PATH: 260,\n  LINUX_MAX_PATH: 4096,\n  MAX_DRIVE_LETTERS: 26\n};\n\n// Error Messages with cross-platform context\nconst ERROR_MESSAGES = {\n  // Network errors\n  NETWORK_ERROR: 'Network connection error. Please check your internet connection and try again.',\n  TIMEOUT_ERROR: 'The operation timed out. The server may be busy, please try again in a moment.',\n  SERVER_ERROR: 'Server error occurred. Our team has been notified. Please try again later.',\n  CONNECTION_LOST: 'Connection to server lost. Attempting to reconnect...',\n  \n  // Validation errors\n  VALIDATION_ERROR: 'Please check your input and try again.',\n  INVALID_PATH: 'Invalid file path. Please enter a valid path for your operating system.',\n  INVALID_WINDOWS_PATH: 'Invalid Windows path. Please use format: C:\\\\\\\\folder\\\\\\\\file.ext',\n  INVALID_LINUX_PATH: 'Invalid Linux path. Please use format: /home/user/folder/file.ext',\n  PATH_TOO_LONG: 'File path is too long. Maximum length is {maxLength} characters.',\n  \n  // File errors\n  FILE_NOT_FOUND: 'The requested file could not be found.',\n  FILE_TOO_LARGE: 'File is too large. Maximum size is {maxSize}.',\n  INVALID_FILE_TYPE: 'Invalid file type. Please select a supported file format.',\n  PERMISSION_DENIED: 'You do not have permission to access this file or directory.',\n  \n  // Task errors\n  TASK_CANCELLED: 'Task was cancelled by user.',\n  TASK_FAILED: 'Task failed. Please check the error details and try again.',\n  TASK_TIMEOUT: 'Task timed out. The operation took too long to complete.',\n  MAX_TASKS_EXCEEDED: 'Maximum number of concurrent tasks reached. Please wait for existing tasks to complete.',\n  \n  // Storage errors\n  QUOTA_EXCEEDED: 'Storage quota exceeded. Please free up some space or clear old data.',\n  STORAGE_ERROR: 'Unable to save data. Please check your browser storage settings.',\n  \n  // Cross-platform errors\n  PLATFORM_INCOMPATIBLE: 'This feature is not compatible with your operating system.',\n  PATH_CONVERSION_ERROR: 'Unable to convert path for your operating system.',\n  WINDOWS_CLIENT_ERROR: 'Error communicating with Windows client. Please check your system configuration.',\n  \n  // Generic errors\n  SESSION_EXPIRED: 'Your session has expired. Please refresh the page.',\n  BROWSER_NOT_SUPPORTED: 'Your browser is not supported. Please use a modern browser.',\n  GENERIC_ERROR: 'An unexpected error occurred. Please try again or contact support.'\n};\n\n// Success Messages\nconst SUCCESS_MESSAGES = {\n  TASK_COMPLETED: 'Task completed successfully!',\n  FILE_UPLOADED: 'File uploaded and processing started.',\n  FILE_PROCESSED: 'File processing completed successfully!',\n  DOWNLOAD_STARTED: 'Download started. You can monitor progress below.',\n  DOWNLOAD_COMPLETED: 'All downloads completed successfully!',\n  SETTINGS_SAVED: 'Settings saved successfully!',\n  CONNECTION_RESTORED: 'Connection to server restored.',\n  TASK_STARTED: 'Task started successfully. Monitor progress below.',\n  EXPORT_COMPLETE: 'Export completed! File is ready for download.',\n  IMPORT_COMPLETE: 'Import completed successfully!',\n  PATH_VALIDATED: 'Path validated and ready for use.',\n  CROSS_PLATFORM_SUCCESS: 'Cross-platform operation completed successfully!'\n};\n\n// Keyboard Shortcuts\nconst KEYBOARD_SHORTCUTS = {\n  // Global shortcuts\n  NEW_TASK: 'Ctrl+N',\n  CANCEL_TASK: 'Escape',\n  SUBMIT_FORM: 'Ctrl+Enter',\n  TOGGLE_THEME: 'Ctrl+Shift+T',\n  TOGGLE_DEBUG: 'Ctrl+Shift+D',\n  FOCUS_SEARCH: 'Ctrl+F',\n  HELP: 'F1',\n  REFRESH: 'F5',\n  FULLSCREEN: 'F11',\n  \n  // Blueprint navigation\n  NEXT_TAB: 'Ctrl+Tab',\n  PREV_TAB: 'Ctrl+Shift+Tab',\n  FILE_PROCESSOR: 'Ctrl+1',\n  WEB_SCRAPER: 'Ctrl+2',\n  ACADEMIC_SEARCH: 'Ctrl+3',\n  PLAYLIST_DOWNLOADER: 'Ctrl+4',\n  PDF_PROCESSOR: 'Ctrl+5',\n  TASK_HISTORY: 'Ctrl+6',\n  \n  // Task management\n  START_TASK: 'Ctrl+S',\n  PAUSE_TASK: 'Ctrl+P',\n  RESUME_TASK: 'Ctrl+R',\n  CANCEL_ALL: 'Ctrl+Shift+X'\n};\n\n// Analytics Events for production monitoring\nconst ANALYTICS_EVENTS = {\n  // Application lifecycle\n  APP_LOADED: 'app_loaded',\n  BLUEPRINT_LOADED: 'blueprint_loaded',\n  MODULE_INITIALIZED: 'module_initialized',\n  \n  // Task events\n  TASK_STARTED: 'task_started',\n  TASK_COMPLETED: 'task_completed',\n  TASK_FAILED: 'task_failed',\n  TASK_CANCELLED: 'task_cancelled',\n  TASK_TIMEOUT: 'task_timeout',\n  \n  // User interactions\n  TAB_SWITCHED: 'tab_switched',\n  THEME_CHANGED: 'theme_changed',\n  FEATURE_USED: 'feature_used',\n  SHORTCUT_USED: 'shortcut_used',\n  \n  // Performance events\n  PERFORMANCE_WARNING: 'performance_warning',\n  MEMORY_WARNING: 'memory_warning',\n  SLOW_OPERATION: 'slow_operation',\n  \n  // Cross-platform events\n  CROSS_PLATFORM_OPERATION: 'cross_platform_operation',\n  WINDOWS_CLIENT_INTERACTION: 'windows_client_interaction',\n  PATH_CONVERSION: 'path_conversion',\n  \n  // Error events\n  ERROR_OCCURRED: 'error_occurred',\n  NETWORK_ERROR: 'network_error',\n  VALIDATION_ERROR: 'validation_error'\n};\n\n// Combine all configurations\nconst CONSTANTS = Object.freeze({\n  ...BASE_CONFIG,\n  ...API_CONFIG,\n  ...SOCKET_CONFIG,\n  ...TASK_CONFIG,\n  ...FILE_CONFIG,\n  ...UI_CONFIG,\n  ...STORAGE_CONFIG,\n  ...PERFORMANCE_CONFIG,\n  FEATURE_FLAGS: Object.freeze(FEATURE_FLAGS),\n  VALIDATION: Object.freeze(VALIDATION_CONFIG),\n  ERROR_MESSAGES: Object.freeze(ERROR_MESSAGES),\n  SUCCESS_MESSAGES: Object.freeze(SUCCESS_MESSAGES),\n  KEYBOARD_SHORTCUTS: Object.freeze(KEYBOARD_SHORTCUTS),\n  ANALYTICS_EVENTS: Object.freeze(ANALYTICS_EVENTS)\n});\n\n// Error Handler Configuration (v4.0 Blueprint Module)\nconst ERROR_CONFIG = {\n  MAX_ERROR_HISTORY: 50,\n  LOG_TO_CONSOLE: true,\n  SAVE_TO_LOCAL_STORAGE: true,\n  EMIT_EVENTS: true,\n  SHOW_NOTIFICATIONS: true,\n  detailedLogForTypes: ['NETWORK', 'SERVER', 'PROCESSING', 'BLUEPRINT'],\n  debug: BASE_CONFIG.DEBUG_MODE\n};\n\n// App Module Configuration (v4.0 Blueprint Module)\nconst APP_CONFIG = {\n  DEBUG: BASE_CONFIG.DEBUG_MODE,\n  DEFAULT_THEME: 'light',\n  VERSION: '4.0.0',\n  INIT_TIMEOUT: 10000,\n  MODULE_LOAD_TIMEOUT: 5000,\n  CORE_MODULES: [\n    '/static/js/modules/core/errorHandler.js',\n    '/static/js/modules/core/uiRegistry.js',\n    '/static/js/modules/core/stateManager.js',\n    '/static/js/modules/core/eventRegistry.js',\n    '/static/js/modules/core/eventManager.js',\n    '/static/js/modules/core/themeManager.js',\n    '/static/js/modules/core/healthMonitor.js'\n  ]\n};\n\n// Debug Tools Configuration (v4.0 Blueprint Module)\nconst DEBUG_CONFIG = {\n  enabled: BASE_CONFIG.DEBUG_MODE,\n  logLevel: 'debug',\n  persistLogs: false,\n  maxLogEntries: 1000,\n  enablePerformanceMonitoring: BASE_CONFIG.DEVELOPMENT,\n  enableMemoryTracking: BASE_CONFIG.DEVELOPMENT,\n  showDetailedErrors: BASE_CONFIG.DEBUG_MODE,\n  enableDiagnostics: true\n};\n\n// Export the frozen constants\nexport { CONSTANTS };\n\n// Also export individual configurations for convenience\nexport {\n  ENV,\n  BASE_CONFIG,\n  API_CONFIG,\n  SOCKET_CONFIG,\n  TASK_CONFIG,\n  FILE_CONFIG,\n  UI_CONFIG,\n  STORAGE_CONFIG,\n  PERFORMANCE_CONFIG,\n  FEATURE_FLAGS,\n  VALIDATION_CONFIG,\n  ERROR_MESSAGES,\n  SUCCESS_MESSAGES,\n  KEYBOARD_SHORTCUTS,\n  ANALYTICS_EVENTS,\n  ERROR_CONFIG,\n  APP_CONFIG,\n  DEBUG_CONFIG\n};","source":"/workspace/modules/static/js/modules/config/constants.js","title":"constants.js","language":"en"},{"content":"/**\n * API Endpoints Configuration for Blueprint Architecture\n * \n * Central location for all API endpoint definitions aligned with Flask Blueprint structure.\n * Based on analysis of current Blueprint routes and production requirements.\n * \n * @module config/endpoints\n * @version 3.0.0\n */\n\n/**\n * API endpoint definitions organized by Blueprint feature\n */\nexport const API_ENDPOINTS = Object.freeze({\n  // File Processing Endpoints (features/file_processor.py)\n  FILE_PROCESSING: {\n    PROCESS: '/api/process',\n    STATUS: '/api/status/:taskId',\n    DOWNLOAD: '/api/download/:taskId',\n    OPEN: '/api/open/:taskId',\n    DETECT_PATH: '/api/detect-path',\n    VERIFY_PATH: '/api/verify-path',\n    CREATE_DIRECTORY: '/api/create-directory',\n    OPEN_FILE: '/api/open-file',\n    GET_OUTPUT_FILEPATH: '/api/get-output-filepath'\n  },\n\n  // Playlist Processing Endpoints (features/playlist_downloader.py)\n  PLAYLIST: {\n    START: '/api/start-playlists',\n    CANCEL: '/api/cancel-playlists/:taskId',\n    STATUS: '/api/status/:taskId',\n    HEALTH: '/api/health'\n  },\n\n  // Web Scraping Endpoints (features/web_scraper.py)\n  WEB_SCRAPER: {\n    SCRAPE: '/api/scrape2',\n    STATUS: '/api/scrape2/status/:taskId',\n    CANCEL: '/api/scrape2/cancel/:taskId',\n    HEALTH: '/api/health-enhanced',\n    DOWNLOAD_PDF: '/api/download-pdf',\n    DOWNLOAD_FILE: '/api/download-file/:filePath'\n  },\n\n  // Academic Search Endpoints (features/academic_search.py) - Complete integration\n  ACADEMIC: {\n    SEARCH: '/api/academic/search',\n    MULTI_SOURCE: '/api/academic/multi-source',\n    DETAILS: '/api/academic/details/:id',\n    DOWNLOAD: '/api/academic/download/:id',\n    DOWNLOAD_PDF: '/api/academic/download-pdf',\n    CITATIONS: '/api/academic/citations/:id',\n    RECOMMENDATIONS: '/api/academic/recommendations/:id',\n    HEALTH: '/api/academic/health',\n    STATUS: '/api/academic/status/:taskId',\n    CANCEL: '/api/academic/cancel/:taskId'\n  },\n\n  // PDF Processing Endpoints (features/pdf_processor.py)\n  PDF_PROCESSOR: {\n    PROCESS: '/api/pdf-process/process',\n    STATUS: '/api/pdf-process/status/:taskId',\n    EXTRACT: '/api/pdf-process/extract',\n    CAPABILITIES: '/api/pdf-process/capabilities',\n    ANALYZE: '/api/pdf-process/analyze'\n  },\n\n  // PDF Downloader Endpoints (features/pdf_downloader.py)\n  PDF_DOWNLOADER: {\n    DOWNLOAD: '/api/pdf/download',\n    BATCH_DOWNLOAD: '/api/pdf/batch-download',\n    STATUS: '/api/pdf/status/:taskId',\n    CANCEL: '/api/pdf/cancel/:taskId',\n    HEALTH: '/api/pdf/health'\n  },\n\n  // Task Management Endpoints (api/management.py + task_api_routes.py)\n  TASK: {\n    LIST: '/api/tasks',\n    CANCEL: '/api/cancel/:taskId',\n    ANALYTICS: '/api/analytics',\n    EXPORT: '/api/export/:taskId',\n    PROGRESS: '/api/progress/:taskId',\n    STATUS: '/api/status/:taskId',\n    TASK_STATUS: '/api/task/:taskId/status',\n    TASK_STATUS_ALT: '/api/task_status/:taskId',\n    CREATE: '/api/task/create',\n    UPDATE: '/api/task/:taskId/update',\n    COMPLETE: '/api/task/:taskId/complete',\n    FAIL: '/api/task/:taskId/fail',\n    HISTORY: '/api/history'\n  },\n\n  // API Key Management (api/management.py)\n  API_KEYS: {\n    LIST: '/api/keys',\n    CREATE: '/api/keys/create',\n    REVOKE: '/api/keys/revoke'\n  },\n\n  // System Endpoints (core/routes.py)\n  SYSTEM: {\n    HOME: '/',\n    HEALTH: '/health',\n    DIAGNOSTICS: '/diagnostics',\n    TEST_MODULES: '/test-modules',\n    VERSION: '/api/version'\n  },\n\n  // Download Endpoints (general)\n  DOWNLOAD: {\n    FILE: '/download/:filename',\n    TEMP: '/api/download/temp/:fileId'\n  }\n});\n\n/**\n * Blueprint-specific endpoint validation based on actual route implementations\n */\nexport const BLUEPRINT_ROUTES = Object.freeze({\n  // File Processor Blueprint\n  file_processor: {\n    endpoints: API_ENDPOINTS.FILE_PROCESSING,\n    blueprint_name: 'file_processor',\n    url_prefix: '/api',\n    methods: {\n      '/api/process': ['POST', 'HEAD'],\n      '/api/status/:taskId': ['GET'],\n      '/api/progress/:taskId': ['GET'],\n      '/api/task/:taskId/status': ['GET'],\n      '/api/task_status/:taskId': ['GET'],\n      '/api/download/:taskId': ['GET'],\n      '/api/open/:taskId': ['GET'],\n      '/api/detect-path': ['POST'],\n      '/api/verify-path': ['POST'],\n      '/api/create-directory': ['POST'],\n      '/api/open-file': ['POST']\n    }\n  },\n\n  // Playlist Downloader Blueprint\n  playlist_downloader: {\n    endpoints: API_ENDPOINTS.PLAYLIST,\n    blueprint_name: 'playlist_downloader',\n    url_prefix: '/api',\n    methods: {\n      '/api/start-playlists': ['POST', 'HEAD'],\n      '/api/cancel-playlists/:taskId': ['POST']\n    }\n  },\n\n  // Web Scraper Blueprint\n  web_scraper: {\n    endpoints: API_ENDPOINTS.WEB_SCRAPER,\n    blueprint_name: 'web_scraper',\n    url_prefix: '/api',\n    methods: {\n      '/api/scrape2': ['POST', 'HEAD'],\n      '/api/scrape2/status/:taskId': ['GET'],\n      '/api/scrape2/cancel/:taskId': ['POST'],\n      '/api/health-enhanced': ['GET'],\n      '/api/download-pdf': ['POST'],\n      '/api/download-file/:filePath': ['GET']\n    }\n  },\n\n  // Academic Search Blueprint\n  academic_search: {\n    endpoints: API_ENDPOINTS.ACADEMIC,\n    blueprint_name: 'academic_search',\n    url_prefix: '/api',\n    methods: {\n      '/api/academic/search': ['POST'],\n      '/api/academic/health': ['GET'],\n      '/api/academic/download': ['POST']\n    }\n  },\n\n  // PDF Processor Blueprint\n  pdf_processor: {\n    endpoints: API_ENDPOINTS.PDF_PROCESSOR,\n    blueprint_name: 'pdf_processor',\n    url_prefix: '/api/pdf-process',\n    methods: {\n      '/api/pdf-process/process': ['POST'],\n      '/api/pdf-process/status/:taskId': ['GET'],\n      '/api/pdf-process/extract': ['POST'],\n      '/api/pdf-process/capabilities': ['GET'],\n      '/api/pdf-process/analyze': ['POST']\n    }\n  },\n\n  // PDF Downloader Blueprint\n  pdf_downloader: {\n    endpoints: API_ENDPOINTS.PDF_DOWNLOADER,\n    blueprint_name: 'pdf_downloader',\n    url_prefix: '/api/pdf',\n    methods: {\n      '/api/pdf/download': ['POST'],\n      '/api/pdf/batch-download': ['POST'],\n      '/api/pdf/status/:taskId': ['GET'],\n      '/api/pdf/cancel/:taskId': ['POST'],\n      '/api/pdf/health': ['GET']\n    }\n  },\n\n  // Management Blueprint\n  management: {\n    endpoints: { ...API_ENDPOINTS.TASK, ...API_ENDPOINTS.API_KEYS },\n    blueprint_name: 'api_management',\n    url_prefix: '/api',\n    methods: {\n      '/api/tasks': ['GET'],\n      '/api/cancel/:taskId': ['POST'],\n      '/api/analytics': ['GET'],\n      '/api/keys': ['GET'],\n      '/api/keys/create': ['POST'],\n      '/api/keys/revoke': ['POST']\n    }\n  },\n\n  // Core Routes Blueprint\n  core: {\n    endpoints: API_ENDPOINTS.SYSTEM,\n    blueprint_name: 'core',\n    url_prefix: '',\n    methods: {\n      '/': ['GET'],\n      '/health': ['GET'],\n      '/diagnostics': ['GET'],\n      '/test-modules': ['GET']\n    }\n  }\n});\n\n/**\n * Cross-platform path handling for Linux server → Windows client downloads\n */\nexport const PATH_CONFIG = Object.freeze({\n  // Windows path conversion patterns\n  WINDOWS_DRIVE_PATTERN: /^[A-Za-z]:/,\n  WINDOWS_PATH_SEPARATOR: '\\\\\\\\',\n  LINUX_PATH_SEPARATOR: '/',\n  \n  // Default output paths by platform\n  DEFAULT_WINDOWS_PATH: 'C:\\\\\\\\Users\\\\\\\\{username}\\\\\\\\Documents\\\\\\\\NeuroGen',\n  DEFAULT_LINUX_PATH: '/home/{username}/Documents/NeuroGen',\n  DEFAULT_MAC_PATH: '/Users/{username}/Documents/NeuroGen',\n  \n  // File naming patterns for cross-platform compatibility\n  SAFE_FILENAME_REGEX: /[<>:\"|?*]/g,\n  MAX_FILENAME_LENGTH: 255,\n  RESERVED_WINDOWS_NAMES: ['CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9']\n});\n\n/**\n * Helper function to build endpoint URL with parameters\n * @param {string} endpoint - Endpoint template\n * @param {Object} params - Parameters to replace\n * @returns {string} Built endpoint URL\n */\nexport function buildEndpoint(endpoint, params = {}) {\n  let url = endpoint;\n  \n  // Replace path parameters\n  Object.entries(params).forEach(([key, value]) => {\n    url = url.replace(`:${key}`, encodeURIComponent(value));\n  });\n  \n  return url;\n}\n\n/**\n * Helper function to build URL with query parameters\n * @param {string} endpoint - Base endpoint\n * @param {Object} queryParams - Query parameters\n * @returns {string} URL with query string\n */\nexport function buildUrlWithQuery(endpoint, queryParams = {}) {\n  const params = new URLSearchParams();\n  \n  Object.entries(queryParams).forEach(([key, value]) => {\n    if (value !== null && value !== undefined) {\n      params.append(key, value);\n    }\n  });\n  \n  const queryString = params.toString();\n  return queryString ? `${endpoint}?${queryString}` : endpoint;\n}\n\n/**\n * Get all endpoints for a specific Blueprint\n * @param {string} blueprint - Blueprint name\n * @returns {Object} Blueprint endpoints\n */\nexport function getBlueprintEndpoints(blueprint) {\n  return BLUEPRINT_ROUTES[blueprint]?.endpoints || {};\n}\n\n/**\n * Get HTTP methods for a specific endpoint\n * @param {string} endpoint - Endpoint path\n * @returns {Array} HTTP methods\n */\nexport function getEndpointMethods(endpoint) {\n  for (const blueprint of Object.values(BLUEPRINT_ROUTES)) {\n    if (blueprint.methods[endpoint]) {\n      return blueprint.methods[endpoint];\n    }\n  }\n  \n  // Fallback to smart detection\n  if (endpoint.includes('/status/') || endpoint.includes('/health') || endpoint.includes('/download/')) {\n    return ['GET'];\n  }\n  \n  if (endpoint.includes('/cancel/') || endpoint.includes('/revoke')) {\n    return ['POST']; // Some cancellations use POST instead of DELETE\n  }\n  \n  return ['POST']; // Default for most processing endpoints\n}\n\n/**\n * Check if an endpoint requires authentication\n * @param {string} endpoint - Endpoint path\n * @returns {boolean} Requires authentication\n */\nexport function requiresAuth(endpoint) {\n  const authRequired = [\n    '/api/analytics',\n    '/api/keys',\n    '/api/tasks'\n  ];\n  \n  return authRequired.some(path => endpoint.startsWith(path));\n}\n\n/**\n * Check if an endpoint supports file upload\n * @param {string} endpoint - Endpoint path\n * @returns {boolean} Supports file upload\n */\nexport function supportsFileUpload(endpoint) {\n  const uploadEndpoints = [\n    API_ENDPOINTS.FILE_PROCESSING.PROCESS,\n    API_ENDPOINTS.PDF.PROCESS,\n    API_ENDPOINTS.PDF.EXTRACT\n  ];\n  \n  return uploadEndpoints.includes(endpoint);\n}\n\n/**\n * Get timeout for specific endpoint based on expected processing time\n * @param {string} endpoint - Endpoint path\n * @returns {number} Timeout in milliseconds\n */\nexport function getEndpointTimeout(endpoint) {\n  // Long timeouts for processing endpoints\n  if (endpoint.includes('/process') || endpoint.includes('/start-playlists') || endpoint.includes('/scrape')) {\n    return 300000; // 5 minutes\n  }\n  \n  if (endpoint.includes('/download/')) {\n    return 120000; // 2 minutes\n  }\n  \n  if (endpoint.includes('/status/')) {\n    return 10000; // 10 seconds\n  }\n  \n  // Default timeout\n  return 30000; // 30 seconds\n}\n\n/**\n * Validate endpoint exists in Blueprint routes\n * @param {string} endpoint - Endpoint path\n * @returns {Object} Validation result\n */\nexport function validateEndpoint(endpoint) {\n  for (const [blueprintName, blueprint] of Object.entries(BLUEPRINT_ROUTES)) {\n    const methods = blueprint.methods;\n    \n    // Check exact match\n    if (methods[endpoint]) {\n      return {\n        valid: true,\n        blueprint: blueprintName,\n        methods: methods[endpoint],\n        endpoint: endpoint\n      };\n    }\n    \n    // Check pattern match (for :taskId parameters)\n    for (const [pattern, methodList] of Object.entries(methods)) {\n      const regex = new RegExp('^' + pattern.replace(/:taskId/g, '[^/]+') + '$');\n      if (regex.test(endpoint)) {\n        return {\n          valid: true,\n          blueprint: blueprintName,\n          methods: methodList,\n          pattern: pattern,\n          endpoint: endpoint\n        };\n      }\n    }\n  }\n  \n  return {\n    valid: false,\n    endpoint: endpoint,\n    error: 'Endpoint not found in any Blueprint'\n  };\n}\n\n/**\n * Convert Windows path to cross-platform format for Linux server\n * @param {string} windowsPath - Windows-style path\n * @returns {string} Sanitized path for Linux server\n */\nexport function sanitizePathForLinuxServer(windowsPath) {\n  if (!windowsPath) return '';\n  \n  // Replace Windows path separators\n  let sanitized = windowsPath.replace(/\\\\/g, '/');\n  \n  // Handle drive letters (C: becomes /mnt/c or similar)\n  sanitized = sanitized.replace(/^([A-Za-z]):/, '/mnt/$1');\n  \n  // Remove invalid characters for Linux\n  sanitized = sanitized.replace(/[<>:\"|?*]/g, '_');\n  \n  return sanitized;\n}\n\n/**\n * Generate Windows-compatible filename from Linux server\n * @param {string} filename - Original filename\n * @returns {string} Windows-compatible filename\n */\nexport function sanitizeFilenameForWindows(filename) {\n  if (!filename) return '';\n  \n  // Replace invalid Windows characters\n  let sanitized = filename.replace(PATH_CONFIG.SAFE_FILENAME_REGEX, '_');\n  \n  // Check for reserved Windows names\n  const baseName = sanitized.split('.')[0].toUpperCase();\n  if (PATH_CONFIG.RESERVED_WINDOWS_NAMES.includes(baseName)) {\n    sanitized = `${sanitized}_file`;\n  }\n  \n  // Trim to max length\n  if (sanitized.length > PATH_CONFIG.MAX_FILENAME_LENGTH) {\n    const ext = sanitized.substring(sanitized.lastIndexOf('.'));\n    const name = sanitized.substring(0, PATH_CONFIG.MAX_FILENAME_LENGTH - ext.length);\n    sanitized = name + ext;\n  }\n  \n  return sanitized;\n}\n\n/**\n * Export individual endpoint groups for convenience\n */\nexport const FILE_ENDPOINTS = API_ENDPOINTS.FILE_PROCESSING;\nexport const PLAYLIST_ENDPOINTS = API_ENDPOINTS.PLAYLIST;\nexport const SCRAPER_ENDPOINTS = API_ENDPOINTS.WEB_SCRAPER;\nexport const PDF_ENDPOINTS = API_ENDPOINTS.PDF;\nexport const TASK_ENDPOINTS = API_ENDPOINTS.TASK;\nexport const ACADEMIC_ENDPOINTS = API_ENDPOINTS.ACADEMIC;\nexport const SYSTEM_ENDPOINTS = API_ENDPOINTS.SYSTEM;\n\n// Legacy compatibility exports for existing code\nexport const ENDPOINTS = {\n  // File processing\n  PROCESS: API_ENDPOINTS.FILE_PROCESSING.PROCESS,\n  STATUS: API_ENDPOINTS.FILE_PROCESSING.STATUS,\n  DOWNLOAD: API_ENDPOINTS.FILE_PROCESSING.DOWNLOAD,\n  \n  // Playlist\n  START_PLAYLISTS: API_ENDPOINTS.PLAYLIST.START,\n  CANCEL_PLAYLISTS: API_ENDPOINTS.PLAYLIST.CANCEL,\n  \n  // Web scraper\n  SCRAPE: API_ENDPOINTS.WEB_SCRAPER.SCRAPE,\n  SCRAPE_STATUS: API_ENDPOINTS.WEB_SCRAPER.STATUS,\n  SCRAPE_CANCEL: API_ENDPOINTS.WEB_SCRAPER.CANCEL,\n  SCRAPE_HEALTH: API_ENDPOINTS.WEB_SCRAPER.HEALTH,\n  SCRAPE_DOWNLOAD_PDF: API_ENDPOINTS.WEB_SCRAPER.DOWNLOAD_PDF,\n  \n  // Academic\n  ACADEMIC_SEARCH: API_ENDPOINTS.ACADEMIC.SEARCH,\n  ACADEMIC_HEALTH: API_ENDPOINTS.ACADEMIC.HEALTH,\n  \n  // System\n  HOME: API_ENDPOINTS.SYSTEM.HOME,\n  HEALTH: API_ENDPOINTS.SYSTEM.HEALTH\n};\n\n// Note: buildUrlWithQuery is already exported as a named export above","source":"/workspace/modules/static/js/modules/config/endpoints.js","title":"endpoints.js","language":"en"},{"content":"/**\n * Socket.IO Events Configuration for Blueprint Architecture\n * \n * Central location for all Socket.IO event names and payloads aligned with\n * Flask Blueprint real-time communication patterns.\n * \n * @module config/socketEvents\n * @version 3.0.0\n */\n\n/**\n * Socket.IO event names organized by Blueprint and direction\n */\nexport const SOCKET_EVENTS = Object.freeze({\n  // Connection Events\n  CONNECTION: {\n    CONNECT: 'connect',\n    DISCONNECT: 'disconnect',\n    CONNECT_ERROR: 'connect_error',\n    RECONNECT: 'reconnect',\n    RECONNECT_ATTEMPT: 'reconnect_attempt',\n    RECONNECT_ERROR: 'reconnect_error',\n    RECONNECT_FAILED: 'reconnect_failed',\n    CONNECTION_ESTABLISHED: 'connection_established'\n  },\n\n  // Client -> Server Events\n  CLIENT_TO_SERVER: {\n    // General communication\n    PING: 'ping',\n    REQUEST_TASK_STATUS: 'request_task_status',\n    CANCEL_TASK: 'cancel_task',\n    PAUSE_TASK: 'pause_task',\n    RESUME_TASK: 'resume_task',\n    \n    // File Processing Blueprint events\n    FILE_PROCESS_REQUEST: 'file_process_request',\n    \n    // Playlist Downloader Blueprint events\n    PLAYLIST_DOWNLOAD_REQUEST: 'playlist_download_request',\n    \n    // Web Scraper Blueprint events\n    SCRAPE_REQUEST: 'scrape_request',\n    \n    // Academic Search Blueprint events\n    ACADEMIC_SEARCH_REQUEST: 'academic_search_request',\n    \n    // PDF Processor Blueprint events\n    PDF_PROCESSING_REQUEST: 'pdf_processing_request',\n    \n    // System events\n    GET_SYSTEM_STATUS: 'get_system_status',\n    GET_BLUEPRINT_STATUS: 'get_blueprint_status'\n  },\n\n  // Server -> Client Events (from Blueprint backends)\n  SERVER_TO_CLIENT: {\n    // General server events\n    PONG: 'pong',\n    SERVER_ERROR: 'server_error',\n    BLUEPRINT_ERROR: 'blueprint_error',\n    \n    // Task Lifecycle Events (Blueprint agnostic)\n    TASK_QUEUED: 'task_queued',\n    TASK_STARTED: 'task_started',\n    PROGRESS_UPDATE: 'progress_update', // Main progress event\n    TASK_COMPLETED: 'task_completed',\n    TASK_ERROR: 'task_error', // Main error event\n    TASK_CANCELLED: 'task_cancelled',\n    TASK_PAUSED: 'task_paused',\n    TASK_RESUMED: 'task_resumed',\n    \n    // File Processing Blueprint Events\n    FILE_FOUND: 'file_found',\n    FILE_PROCESSED: 'file_processed',\n    FILE_SKIPPED: 'file_skipped',\n    FILE_ERROR: 'file_error',\n    FILE_PROCESSING_STAGE: 'file_processing_stage',\n    \n    // Playlist Downloader Blueprint Events\n    PLAYLIST_METADATA_FETCHED: 'playlist_metadata_fetched',\n    PLAYLIST_VIDEO_FOUND: 'playlist_video_found',\n    PLAYLIST_VIDEO_STARTED: 'video_started',\n    PLAYLIST_VIDEO_PROGRESS: 'video_progress',\n    PLAYLIST_VIDEO_COMPLETED: 'video_completed',\n    PLAYLIST_VIDEO_ERROR: 'playlist_video_error',\n    PLAYLIST_STAGE_PROGRESS: 'playlist_stage_progress',\n    PLAYLIST_STARTED: 'playlist_started',\n    PLAYLIST_COMPLETED: 'playlist_completed',\n    PLAYLIST_ERROR: 'playlist_error',\n    \n    // Web Scraper Blueprint Events\n    URL_SCRAPED: 'url_scraped',\n    PDF_FOUND: 'pdf_found',\n    PDF_DOWNLOAD_START: 'pdf_download_start',\n    PDF_DOWNLOAD_PROGRESS: 'pdf_download_progress',\n    PDF_DOWNLOAD_COMPLETE: 'pdf_download_complete',\n    PDF_DOWNLOAD_ERROR: 'pdf_download_error',\n    SCRAPER_STAGE_PROGRESS: 'scraper_stage_progress',\n    \n    // Academic Search Blueprint Events\n    ACADEMIC_SEARCH_STARTED: 'academic_search_started',\n    ACADEMIC_PAPER_FOUND: 'academic_paper_found',\n    ACADEMIC_SEARCH_PROGRESS: 'academic_search_progress',\n    ACADEMIC_SEARCH_COMPLETED: 'academic_search_completed',\n    ACADEMIC_SEARCH_ERROR: 'academic_search_error',\n    \n    // PDF Processor Blueprint Events\n    PDF_PROCESSING_STARTED: 'pdf_processing_started',\n    PDF_PROCESSING_PROGRESS: 'pdf_processing_progress',\n    PDF_TABLE_EXTRACTED: 'pdf_table_extracted',\n    PDF_TEXT_EXTRACTED: 'pdf_text_extracted',\n    PDF_PROCESSING_COMPLETED: 'pdf_processing_completed',\n    PDF_PROCESSING_ERROR: 'pdf_processing_error',\n    \n    // System Events\n    SYSTEM_STATUS: 'system_status',\n    BLUEPRINT_STATUS: 'blueprint_status',\n    MEMORY_WARNING: 'memory_warning',\n    RATE_LIMIT_WARNING: 'rate_limit_warning',\n    CROSS_PLATFORM_STATUS: 'cross_platform_status'\n  }\n});\n\n/**\n * Blueprint-specific event mappings for easy access\n */\nexport const BLUEPRINT_EVENTS = Object.freeze({\n  file_processor: {\n    // Events specific to file processing Blueprint\n    progress: SOCKET_EVENTS.SERVER_TO_CLIENT.PROGRESS_UPDATE,\n    started: SOCKET_EVENTS.SERVER_TO_CLIENT.TASK_STARTED,\n    completed: SOCKET_EVENTS.SERVER_TO_CLIENT.TASK_COMPLETED,\n    error: SOCKET_EVENTS.SERVER_TO_CLIENT.TASK_ERROR,\n    file_found: SOCKET_EVENTS.SERVER_TO_CLIENT.FILE_FOUND,\n    file_processed: SOCKET_EVENTS.SERVER_TO_CLIENT.FILE_PROCESSED,\n    file_error: SOCKET_EVENTS.SERVER_TO_CLIENT.FILE_ERROR\n  },\n  \n  playlist_downloader: {\n    // Events specific to playlist downloader Blueprint\n    progress: SOCKET_EVENTS.SERVER_TO_CLIENT.PROGRESS_UPDATE,\n    started: SOCKET_EVENTS.SERVER_TO_CLIENT.PLAYLIST_STARTED,\n    completed: SOCKET_EVENTS.SERVER_TO_CLIENT.PLAYLIST_COMPLETED,\n    error: SOCKET_EVENTS.SERVER_TO_CLIENT.PLAYLIST_ERROR,\n    video_started: SOCKET_EVENTS.SERVER_TO_CLIENT.PLAYLIST_VIDEO_STARTED,\n    video_progress: SOCKET_EVENTS.SERVER_TO_CLIENT.PLAYLIST_VIDEO_PROGRESS,\n    video_completed: SOCKET_EVENTS.SERVER_TO_CLIENT.PLAYLIST_VIDEO_COMPLETED,\n    stage_progress: SOCKET_EVENTS.SERVER_TO_CLIENT.PLAYLIST_STAGE_PROGRESS\n  },\n  \n  web_scraper: {\n    // Events specific to web scraper Blueprint\n    progress: SOCKET_EVENTS.SERVER_TO_CLIENT.PROGRESS_UPDATE,\n    started: SOCKET_EVENTS.SERVER_TO_CLIENT.TASK_STARTED,\n    completed: SOCKET_EVENTS.SERVER_TO_CLIENT.TASK_COMPLETED,\n    error: SOCKET_EVENTS.SERVER_TO_CLIENT.TASK_ERROR,\n    url_scraped: SOCKET_EVENTS.SERVER_TO_CLIENT.URL_SCRAPED,\n    pdf_found: SOCKET_EVENTS.SERVER_TO_CLIENT.PDF_FOUND,\n    pdf_download_start: SOCKET_EVENTS.SERVER_TO_CLIENT.PDF_DOWNLOAD_START,\n    pdf_download_progress: SOCKET_EVENTS.SERVER_TO_CLIENT.PDF_DOWNLOAD_PROGRESS,\n    pdf_download_complete: SOCKET_EVENTS.SERVER_TO_CLIENT.PDF_DOWNLOAD_COMPLETE\n  },\n  \n  academic_search: {\n    // Events specific to academic search Blueprint\n    progress: SOCKET_EVENTS.SERVER_TO_CLIENT.ACADEMIC_SEARCH_PROGRESS,\n    started: SOCKET_EVENTS.SERVER_TO_CLIENT.ACADEMIC_SEARCH_STARTED,\n    completed: SOCKET_EVENTS.SERVER_TO_CLIENT.ACADEMIC_SEARCH_COMPLETED,\n    error: SOCKET_EVENTS.SERVER_TO_CLIENT.ACADEMIC_SEARCH_ERROR,\n    paper_found: SOCKET_EVENTS.SERVER_TO_CLIENT.ACADEMIC_PAPER_FOUND\n  },\n  \n  pdf_processor: {\n    // Events specific to PDF processor Blueprint\n    progress: SOCKET_EVENTS.SERVER_TO_CLIENT.PDF_PROCESSING_PROGRESS,\n    started: SOCKET_EVENTS.SERVER_TO_CLIENT.PDF_PROCESSING_STARTED,\n    completed: SOCKET_EVENTS.SERVER_TO_CLIENT.PDF_PROCESSING_COMPLETED,\n    error: SOCKET_EVENTS.SERVER_TO_CLIENT.PDF_PROCESSING_ERROR,\n    table_extracted: SOCKET_EVENTS.SERVER_TO_CLIENT.PDF_TABLE_EXTRACTED,\n    text_extracted: SOCKET_EVENTS.SERVER_TO_CLIENT.PDF_TEXT_EXTRACTED\n  }\n});\n\n/**\n * Event payload schemas for Blueprint communication\n */\nexport const EVENT_PAYLOADS = Object.freeze({\n  // Client -> Server Payloads\n  PING: {\n    timestamp: 'number'\n  },\n  \n  REQUEST_TASK_STATUS: {\n    task_id: 'string',\n    blueprint: 'string?'\n  },\n  \n  CANCEL_TASK: {\n    task_id: 'string',\n    blueprint: 'string?',\n    reason: 'string?'\n  },\n  \n  FILE_PROCESS_REQUEST: {\n    input_dir: 'string',\n    output_file: 'string',\n    options: 'object?'\n  },\n  \n  PLAYLIST_DOWNLOAD_REQUEST: {\n    playlists: 'array',\n    root_directory: 'string',\n    output_file: 'string',\n    options: 'object?'\n  },\n  \n  SCRAPE_REQUEST: {\n    urls: 'array',\n    output_file: 'string',\n    download_pdfs: 'boolean?',\n    max_pdfs: 'number?',\n    recursive: 'boolean?',\n    max_depth: 'number?'\n  },\n  \n  ACADEMIC_SEARCH_REQUEST: {\n    query: 'string',\n    sources: 'array?',\n    max_results: 'number?',\n    download_pdfs: 'boolean?'\n  },\n  \n  PDF_PROCESSING_REQUEST: {\n    file_path: 'string',\n    extract_tables: 'boolean?',\n    extract_text: 'boolean?',\n    ocr_enabled: 'boolean?'\n  },\n  \n  // Server -> Client Payloads\n  TASK_STARTED: {\n    task_id: 'string',\n    task_type: 'string',\n    blueprint: 'string',\n    status: 'string',\n    message: 'string',\n    timestamp: 'number',\n    estimated_duration: 'number?'\n  },\n  \n  PROGRESS_UPDATE: {\n    task_id: 'string',\n    task_type: 'string',\n    blueprint: 'string',\n    progress: 'number', // 0-100\n    status: 'string',\n    message: 'string',\n    stats: 'object',\n    timestamp: 'number',\n    details: 'object?',\n    stage: 'string?',\n    estimated_remaining: 'number?'\n  },\n  \n  TASK_COMPLETED: {\n    task_id: 'string',\n    task_type: 'string',\n    blueprint: 'string',\n    status: 'string',\n    message: 'string',\n    progress: 'number', // Should be 100\n    stats: 'object',\n    output_file: 'string?',\n    output_files: 'array?', // For multiple files\n    duration_seconds: 'number',\n    timestamp: 'number',\n    success_count: 'number?',\n    error_count: 'number?'\n  },\n  \n  TASK_ERROR: {\n    task_id: 'string',\n    task_type: 'string',\n    blueprint: 'string',\n    status: 'string',\n    error: 'string',\n    error_code: 'string?',\n    error_details: 'object?',\n    stats: 'object',\n    progress: 'number',\n    timestamp: 'number',\n    retry_possible: 'boolean?',\n    suggested_action: 'string?'\n  },\n  \n  // Blueprint-specific payloads\n  FILE_PROCESSED: {\n    task_id: 'string',\n    file_path: 'string',\n    file_size: 'number',\n    processing_time: 'number',\n    chunks_created: 'number?',\n    timestamp: 'number'\n  },\n  \n  PLAYLIST_VIDEO_PROGRESS: {\n    task_id: 'string',\n    video_url: 'string',\n    video_title: 'string',\n    progress: 'number',\n    downloaded_bytes: 'number',\n    total_bytes: 'number',\n    speed_bps: 'number?',\n    eta_seconds: 'number?'\n  },\n  \n  PDF_DOWNLOAD_PROGRESS: {\n    task_id: 'string',\n    pdf_url: 'string',\n    pdf_title: 'string?',\n    progress: 'number',\n    downloaded_bytes: 'number',\n    total_bytes: 'number',\n    speed_bps: 'number?'\n  },\n  \n  ACADEMIC_PAPER_FOUND: {\n    task_id: 'string',\n    paper_id: 'string',\n    title: 'string',\n    authors: 'array',\n    source: 'string',\n    doi: 'string?',\n    arxiv_id: 'string?',\n    pdf_url: 'string?'\n  },\n  \n  CROSS_PLATFORM_STATUS: {\n    server_platform: 'string', // 'linux', 'windows', 'mac'\n    client_platform: 'string',\n    path_conversion_active: 'boolean',\n    windows_client_support: 'boolean'\n  }\n});\n\n/**\n * Helper to create event payload with validation\n * @param {string} eventType - Event type\n * @param {Object} data - Event data\n * @returns {Object} Validated payload\n */\nexport function createEventPayload(eventType, data) {\n  const schema = EVENT_PAYLOADS[eventType];\n  if (!schema) {\n    console.warn(`No schema defined for event type: ${eventType}`);\n    return data;\n  }\n  \n  const payload = {};\n  Object.keys(schema).forEach(key => {\n    const type = schema[key];\n    const isOptional = type.endsWith('?');\n    const actualType = isOptional ? type.slice(0, -1) : type;\n    \n    if (data[key] === undefined && !isOptional) {\n      console.warn(`Missing required field '${key}' for event ${eventType}`);\n    }\n    \n    if (data[key] !== undefined) {\n      const valueType = Array.isArray(data[key]) ? 'array' : typeof data[key];\n      if (valueType !== actualType && actualType !== 'object') {\n        console.warn(`Type mismatch for field '${key}' in event ${eventType}: expected ${actualType}, got ${valueType}`);\n      }\n      payload[key] = data[key];\n    }\n  });\n  \n  return payload;\n}\n\n/**\n * Get all events for a specific Blueprint\n * @param {string} blueprint - Blueprint name\n * @returns {Object} Blueprint events\n */\nexport function getBlueprintEvents(blueprint) {\n  return BLUEPRINT_EVENTS[blueprint] || {};\n}\n\n/**\n * Check if event is a progress event\n * @param {string} eventName - Event name\n * @returns {boolean} Is progress event\n */\nexport function isProgressEvent(eventName) {\n  return eventName.includes('progress') || \n         eventName === SOCKET_EVENTS.SERVER_TO_CLIENT.PROGRESS_UPDATE;\n}\n\n/**\n * Check if event is an error event\n * @param {string} eventName - Event name\n * @returns {boolean} Is error event\n */\nexport function isErrorEvent(eventName) {\n  return eventName.includes('error') || \n         eventName.includes('failed') ||\n         eventName === SOCKET_EVENTS.SERVER_TO_CLIENT.TASK_ERROR;\n}\n\n/**\n * Check if event is a completion event\n * @param {string} eventName - Event name\n * @returns {boolean} Is completion event\n */\nexport function isCompletionEvent(eventName) {\n  return eventName.includes('completed') || \n         eventName.includes('finished') ||\n         eventName === SOCKET_EVENTS.SERVER_TO_CLIENT.TASK_COMPLETED;\n}\n\n/**\n * Get Blueprint from task type\n * @param {string} taskType - Task type\n * @returns {string} Blueprint name\n */\nexport function getBlueprintFromTaskType(taskType) {\n  const taskToBlueprintMap = {\n    'file_processing': 'file_processor',\n    'playlist_download': 'playlist_downloader',\n    'web_scraping': 'web_scraper',\n    'academic_search': 'academic_search',\n    'pdf_processing': 'pdf_processor'\n  };\n  \n  return taskToBlueprintMap[taskType] || 'unknown';\n}\n\n/**\n * Get event category for routing\n * @param {string} eventName - Event name\n * @returns {string} Event category\n */\nexport function getEventCategory(eventName) {\n  if (eventName.includes('task') || eventName.includes('progress')) return 'task';\n  if (eventName.includes('file')) return 'file';\n  if (eventName.includes('playlist') || eventName.includes('video')) return 'playlist';\n  if (eventName.includes('pdf')) return 'pdf';\n  if (eventName.includes('scrape') || eventName.includes('url')) return 'scraper';\n  if (eventName.includes('academic') || eventName.includes('paper')) return 'academic';\n  if (eventName.includes('system') || eventName.includes('blueprint')) return 'system';\n  if (eventName.includes('connection') || eventName.includes('connect')) return 'connection';\n  return 'general';\n}\n\n/**\n * Create progress deduplication key\n * @param {string} taskId - Task ID\n * @param {number} progress - Progress value\n * @returns {string} Deduplication key\n */\nexport function createProgressDedupeKey(taskId, progress) {\n  // Round progress to avoid excessive updates\n  const roundedProgress = Math.floor(progress * 10) / 10; // Round to 1 decimal\n  return `${taskId}_${roundedProgress}`;\n}\n\n/**\n * Export individual event groups for convenience\n */\nexport const CONNECTION_EVENTS = SOCKET_EVENTS.CONNECTION;\nexport const CLIENT_EVENTS = SOCKET_EVENTS.CLIENT_TO_SERVER;\nexport const SERVER_EVENTS = SOCKET_EVENTS.SERVER_TO_CLIENT;\n\n// Commonly used events grouped by functionality\nexport const TASK_EVENTS = {\n  STARTED: SOCKET_EVENTS.SERVER_TO_CLIENT.TASK_STARTED,\n  PROGRESS: SOCKET_EVENTS.SERVER_TO_CLIENT.PROGRESS_UPDATE,\n  COMPLETED: SOCKET_EVENTS.SERVER_TO_CLIENT.TASK_COMPLETED,\n  ERROR: SOCKET_EVENTS.SERVER_TO_CLIENT.TASK_ERROR,\n  CANCELLED: SOCKET_EVENTS.SERVER_TO_CLIENT.TASK_CANCELLED\n};\n\n// Cross-platform specific events\nexport const CROSS_PLATFORM_EVENTS = {\n  STATUS: SOCKET_EVENTS.SERVER_TO_CLIENT.CROSS_PLATFORM_STATUS,\n  PATH_CONVERSION: 'path_conversion_status',\n  WINDOWS_CLIENT_READY: 'windows_client_ready',\n  LINUX_SERVER_STATUS: 'linux_server_status'\n};\n\n// Export Blueprint-specific event collections\nexport const FILE_PROCESSOR_EVENTS = BLUEPRINT_EVENTS.file_processor;\nexport const PLAYLIST_EVENTS = BLUEPRINT_EVENTS.playlist_downloader;\nexport const SCRAPER_EVENTS = BLUEPRINT_EVENTS.web_scraper;\nexport const ACADEMIC_EVENTS = BLUEPRINT_EVENTS.academic_search;\nexport const PDF_EVENTS = BLUEPRINT_EVENTS.pdf_processor;","source":"/workspace/modules/static/js/modules/config/socketEvents.js","title":"socketEvents.js","language":"en"},{"content":"/**\n * NeuroGen Server - Enhanced Main Application Module v4.0\n * \n * Central orchestration module optimized for the new Blueprint architecture.\n * Manages application initialization, module loading, and core functionality\n * with centralized configuration and integrated health monitoring.\n * \n * NEW v4.0 Features:\n * - Configuration-driven architecture using centralized endpoints\n * - Enhanced 4-method notification system (Toast + Console + System + Error)\n * - Backend connectivity testing with health checks\n * - ES6 module imports with centralized configuration\n * - Optimized for Blueprint architecture integration\n * - Cross-module coordination and health monitoring\n * - Enhanced error handling and recovery\n * \n * @module core/app\n * @version 4.0.0 - Blueprint Architecture Optimization\n */\n\n// Import dependencies from centralized config\nimport { API_ENDPOINTS, BLUEPRINT_ROUTES } from '../config/endpoints.js';\nimport { CONSTANTS, API_CONFIG, APP_CONFIG } from '../config/constants.js';\nimport { SOCKET_EVENTS, TASK_EVENTS } from '../config/socketEvents.js';\n\n// Global configuration for app module\nconst APP_MODULE_CONFIG = {\n  endpoints: {\n    health: API_ENDPOINTS.SYSTEM?.HEALTH || '/api/health',\n    moduleTest: API_ENDPOINTS.SYSTEM?.MODULE_TEST || '/api/test-modules',\n    ...API_ENDPOINTS\n  },\n  api: API_CONFIG,\n  constants: APP_CONFIG || {\n    DEBUG: true,\n    DEFAULT_THEME: 'light',\n    VERSION: '4.0.0',\n    INIT_TIMEOUT: 10000,\n    MODULE_LOAD_TIMEOUT: 5000\n  },\n  events: {\n    ...TASK_EVENTS,\n    app_ready: 'app_module_ready',\n    modules_loaded: 'core_modules_loaded',\n    features_loaded: 'feature_modules_loaded'\n  }\n};\n\n// Module state\nconst appState = {\n  initialized: false,\n  backendConnected: false,\n  coreModulesLoaded: false,\n  featureModulesLoaded: false,\n  lastHealthCheck: null,\n  loadingStats: {\n    coreModules: { loaded: 0, total: 0, failed: [] },\n    featureModules: { loaded: 0, total: 0, failed: [] },\n    utilityModules: { loaded: 0, total: 0, failed: [] }\n  }\n};\n\n/**\n * Main Application Module v4.0\n */\nconst app = {\n  // Configuration from centralized config\n  config: APP_MODULE_CONFIG.constants,\n  \n  // Loaded modules\n  core: {},\n  features: {},\n  utils: {},\n  \n  // Module state\n  state: appState,\n  \n  /**\n   * Initialize the application with v4.0 enhancements\n   * @param {Object} options - Initialization options\n   * @returns {Promise<boolean>} - Success status\n   */\n  async initialize(options = {}) {\n    if (this.state.initialized) {\n      this.showNotification('App already initialized', 'warning', 'Application');\n      return true;\n    }\n    \n    try {\n      this.showNotification('Initializing Application v4.0', 'info', 'Application');\n      \n      // Test backend connectivity on initialization\n      const connectivityResult = await this.testBackendConnectivity();\n      if (!connectivityResult.overall) {\n        console.warn('Application: Backend connectivity test failed, continuing with limited functionality');\n      }\n      \n      // Merge options with default config\n      this.config = { ...this.config, ...options };\n      \n      // Load core modules with progress tracking\n      await this.loadCoreModules();\n      \n      // Load and initialize features with progress tracking\n      await this.loadFeatureModules();\n      \n      // Load utilities in background with progress tracking\n      this.loadUtilityModules();\n      \n      // Apply theme settings\n      if (this.core.themeManager) {\n        await this.core.themeManager.setTheme(this.config.DEFAULT_THEME || this.config.defaultTheme);\n      }\n      \n      // Initialize health monitoring\n      if (this.core.healthMonitor) {\n        this.core.healthMonitor.initialize();\n      }\n      \n      // Mark as initialized\n      this.state.initialized = true;\n      \n      // Emit app ready event\n      if (window.NeuroGen?.eventRegistry) {\n        window.NeuroGen.eventRegistry.emit(APP_MODULE_CONFIG.events.app_ready, {\n          modules: this.getModuleStats(),\n          config: this.config,\n          timestamp: new Date().toISOString()\n        });\n      }\n      \n      this.showNotification('Application v4.0 initialized successfully', 'success', 'Application');\n      return true;\n    } catch (error) {\n      this.showNotification(`Application initialization failed: ${error.message}`, 'error', 'Application');\n      \n      // Enhanced error handling\n      if (this.core.errorHandler) {\n        this.core.errorHandler.handleError(error, 'MODULE', true, {\n          details: 'Error occurred during application initialization',\n          config: this.config,\n          state: this.state\n        });\n      }\n      \n      return false;\n    }\n  },\n  \n  /**\n   * Load core modules required for the application\n   * @returns {Promise<Object>} - Loaded core modules\n   */\n  async loadCoreModules() {\n    try {\n      console.log('Loading core modules...');\n      \n      // Core modules from centralized configuration\n      const coreModules = APP_MODULE_CONFIG.constants.CORE_MODULES || [\n        '/static/js/modules/core/errorHandler.js',\n        '/static/js/modules/core/uiRegistry.js',\n        '/static/js/modules/core/stateManager.js',\n        '/static/js/modules/core/eventRegistry.js',\n        '/static/js/modules/core/eventManager.js',\n        '/static/js/modules/core/themeManager.js',\n        '/static/js/modules/core/healthMonitor.js'\n      ];\n      \n      this.state.loadingStats.coreModules.total = coreModules.length;\n      \n      const loadedModules = {};\n      \n      // Import moduleLoader from window if already loaded\n      if (window.moduleLoader) {\n        // Load modules using moduleLoader\n        for (const modulePath of coreModules) {\n          try {\n            const module = await window.moduleLoader.importModule(modulePath, { required: true });\n            \n            // Get module name\n            const moduleName = window.moduleLoader.getModuleName(modulePath);\n            loadedModules[moduleName] = module;\n            \n            // Initialize if it has initialize method\n            if (module && typeof module.initialize === 'function') {\n              await module.initialize();\n            }\n          } catch (moduleError) {\n            console.error(`Failed to load core module ${modulePath}:`, moduleError);\n          }\n        }\n      } else {\n        // Fallback to direct imports if moduleLoader not available\n        for (const modulePath of coreModules) {\n          try {\n            const module = await import(modulePath);\n            \n            // Get module name from path\n            const moduleName = modulePath.split('/').pop().replace('.js', '');\n            \n            // Store module\n            loadedModules[moduleName] = module.default || module;\n            \n            // Initialize if it has initialize method\n            if (loadedModules[moduleName] && typeof loadedModules[moduleName].initialize === 'function') {\n              await loadedModules[moduleName].initialize();\n            }\n          } catch (moduleError) {\n            console.error(`Failed to load core module ${modulePath}:`, moduleError);\n          }\n        }\n      }\n      \n      // Store core modules for access\n      this.core = loadedModules;\n      console.log('Core modules loaded successfully');\n      \n      return loadedModules;\n    } catch (error) {\n      console.error('Error loading core modules:', error);\n      throw error;\n    }\n  },\n  \n  /**\n   * Load feature modules\n   * @returns {Promise<Object>} - Loaded feature modules\n   */\n  async loadFeatureModules() {\n    try {\n      console.log('Loading feature modules...');\n      \n      // These modules will be dynamically imported\n      const featureModules = [\n        '/static/js/modules/features/fileProcessor.js',\n        '/static/js/modules/features/webScraper.js',\n        '/static/js/modules/features/playlistDownloader.js',\n        '/static/js/modules/features/academicSearch.js',\n        '/static/js/modules/features/historyManager.js'\n      ];\n      \n      const loadedModules = {};\n      \n      // Load each module and initialize it\n      for (const modulePath of featureModules) {\n        try {\n          let module;\n          \n          // Use moduleLoader if available\n          if (window.moduleLoader) {\n            module = await window.moduleLoader.importModule(modulePath);\n          } else {\n            // Direct import otherwise\n            module = await import(modulePath);\n            module = module.default || module;\n          }\n          \n          // Get module name from path\n          const moduleName = modulePath.split('/').pop().replace('.js', '');\n          \n          // Store module\n          loadedModules[moduleName] = module;\n          \n          // Initialize if it has initialize method\n          if (module && typeof module.initialize === 'function') {\n            await module.initialize();\n          }\n          \n          console.log(`Feature module loaded: ${moduleName}`);\n        } catch (moduleError) {\n          console.warn(`Failed to load feature module ${modulePath}:`, moduleError);\n          \n          // Create a placeholder for this module\n          const moduleName = modulePath.split('/').pop().replace('.js', '');\n          loadedModules[moduleName] = {\n            __isFallback: true,\n            initialize: () => false,\n            moduleName\n          };\n        }\n      }\n      \n      // Store loaded modules\n      this.features = loadedModules;\n      console.log('Feature modules loaded successfully');\n      \n      return loadedModules;\n    } catch (error) {\n      console.error('Error loading feature modules:', error);\n      return {};\n    }\n  },\n  \n  /**\n   * Load utility modules in the background\n   * @returns {Promise<Object>} - Loaded utility modules\n   */\n  async loadUtilityModules() {\n    try {\n      console.log('Loading utility modules in background...');\n      \n      // These modules will be dynamically imported\n      const utilModules = [\n        '/static/js/modules/utils/utils.js',\n        '/static/js/modules/utils/ui.js',\n        '/static/js/modules/utils/fileHandler.js',\n        '/static/js/modules/utils/progressHandler.js',\n        '/static/js/modules/utils/socketHandler.js',\n        '/static/js/modules/utils/moduleDiagnostics.js'\n      ];\n      \n      const loadedModules = {};\n      \n      // Load each module in the background\n      const loadPromises = utilModules.map(async (modulePath) => {\n        try {\n          let module;\n          \n          // Use moduleLoader if available\n          if (window.moduleLoader) {\n            module = await window.moduleLoader.importModule(modulePath);\n          } else {\n            // Direct import otherwise\n            module = await import(modulePath);\n            module = module.default || module;\n          }\n          \n          // Get module name from path\n          const moduleName = modulePath.split('/').pop().replace('.js', '');\n          \n          // Store module\n          loadedModules[moduleName] = module;\n          \n          // Initialize if it has initialize method\n          if (module && typeof module.initialize === 'function') {\n            await module.initialize();\n          }\n          \n          console.log(`Utility module loaded: ${moduleName}`);\n          return { moduleName, success: true };\n        } catch (moduleError) {\n          console.warn(`Failed to load utility module ${modulePath}:`, moduleError);\n          return { modulePath, success: false, error: moduleError };\n        }\n      });\n      \n      // Wait for all modules to finish loading\n      const results = await Promise.allSettled(loadPromises);\n      \n      // Store loaded modules\n      this.utils = loadedModules;\n      console.log('Utility modules loaded successfully');\n      \n      return loadedModules;\n    } catch (error) {\n      console.error('Error loading utility modules:', error);\n      return {};\n    }\n  },\n  \n  /**\n   * Get a loaded module\n   * @param {string} moduleName - Name of the module to get\n   * @param {string} [category='core'] - Category of the module (core, features, utils)\n   * @returns {Object|null} - The module or null if not found\n   */\n  getModule(moduleName, category = 'core') {\n    if (!moduleName) return null;\n    \n    // Check if category exists\n    if (!this[category]) {\n      console.warn(`Invalid module category: ${category}`);\n      return null;\n    }\n    \n    // Get module from the specified category\n    const module = this[category][moduleName];\n    \n    if (!module) {\n      if (this.config.debug) {\n        console.warn(`Module not found: ${moduleName} in ${category}`);\n      }\n      return null;\n    }\n    \n    return module;\n  },\n  \n  /**\n   * Show a toast notification\n   * @param {string} message - Message to display\n   * @param {string} type - Notification type (success, error, warning, info)\n   * @param {number} duration - Display duration in ms\n   */\n  showToast(message, type = 'info', duration = 3000) {\n    // Try to use UI module if available\n    if (this.utils.ui && typeof this.utils.ui.showToast === 'function') {\n      this.utils.ui.showToast(message, type, duration);\n      return;\n    }\n    \n    // Try to use error handler if available\n    if (this.core.errorHandler && typeof this.core.errorHandler.showToast === 'function') {\n      this.core.errorHandler.showToast(message, type, { timeout: duration });\n      return;\n    }\n    \n    // Fallback implementation\n    console.log(`[${type.toUpperCase()}] ${message}`);\n    \n    // Try to create toast element\n    const toastContainer = document.getElementById('toast-container') || document.body;\n    if (!toastContainer) return;\n    \n    const toast = document.createElement('div');\n    toast.className = `toast toast-${type}`;\n    toast.textContent = message;\n    \n    toastContainer.appendChild(toast);\n    \n    // Auto-remove after duration\n    setTimeout(() => {\n      if (toast.parentNode) {\n        toast.parentNode.removeChild(toast);\n      }\n    }, duration);\n  },\n  \n  /**\n   * Show an error message\n   * @param {string|Error} error - Error message or object\n   */\n  showError(error) {\n    const errorMessage = error instanceof Error ? error.message : error;\n    \n    // Try to use errorHandler if available\n    if (this.core.errorHandler && typeof this.core.errorHandler.showError === 'function') {\n      this.core.errorHandler.showError(errorMessage);\n      return;\n    }\n    \n    // Fallback\n    this.showToast(errorMessage, 'error');\n    console.error(errorMessage);\n  },\n  \n  /**\n   * Show a success message\n   * @param {string} message - Success message\n   */\n  showSuccess(message) {\n    // Try to use errorHandler if available\n    if (this.core.errorHandler && typeof this.core.errorHandler.showSuccess === 'function') {\n      this.core.errorHandler.showSuccess(message);\n      return;\n    }\n    \n    // Fallback\n    this.showToast(message, 'success');\n    console.log(message);\n  },\n  \n  /**\n   * Get application version\n   * @returns {string} - Version string\n   */\n  getVersion() {\n    return this.config.version;\n  },\n  \n  /**\n   * Set debug mode\n   * @param {boolean} enabled - Whether debug mode is enabled\n   */\n  setDebugMode(enabled) {\n    this.config.debug = !!enabled;\n    console.log(`Debug mode ${enabled ? 'enabled' : 'disabled'}`);\n    \n    // Apply to all modules that support debug mode\n    Object.values(this.core).forEach(module => {\n      if (module && typeof module.config === 'object' && 'debug' in module.config) {\n        module.config.debug = enabled;\n      }\n    });\n    \n    Object.values(this.features).forEach(module => {\n      if (module && typeof module.config === 'object' && 'debug' in module.config) {\n        module.config.debug = enabled;\n      }\n    });\n    \n    Object.values(this.utils).forEach(module => {\n      if (module && typeof module.config === 'object' && 'debug' in module.config) {\n        module.config.debug = enabled;\n      }\n    });\n  },\n\n  /**\n   * Enhanced notification system with 4-method delivery (v4.0)\n   * @param {string} message - Notification message\n   * @param {string} type - Notification type (info, success, warning, error)\n   * @param {string} title - Notification title\n   */\n  showNotification(message, type = 'info', title = 'Application') {\n    // Method 1: Toast notifications\n    if (window.NeuroGen?.ui?.showToast) {\n      window.NeuroGen.ui.showToast(title, message, type);\n    }\n    \n    // Method 2: Console logging with styling\n    const styles = {\n      error: 'color: #dc3545; font-weight: bold;',\n      warning: 'color: #fd7e14; font-weight: bold;',\n      success: 'color: #198754; font-weight: bold;',\n      info: 'color: #0d6efd;'\n    };\n    console.log(`%c[${title}] ${message}`, styles[type] || styles.info);\n    \n    // Method 3: System notification (if available)\n    if (window.NeuroGen?.notificationHandler) {\n      window.NeuroGen.notificationHandler.show({\n        title, message, type, module: 'app'\n      });\n    }\n    \n    // Method 4: Error reporting to centralized handler\n    if (type === 'error' && window.NeuroGen?.errorHandler) {\n      window.NeuroGen.errorHandler.logError({\n        module: 'app', message, severity: type\n      });\n    }\n  },\n\n  /**\n   * Test backend connectivity for app module (v4.0)\n   * @returns {Promise<Object>} Backend connectivity status\n   */\n  async testBackendConnectivity() {\n    const results = {\n      overall: false,\n      details: {},\n      timestamp: new Date().toISOString(),\n      errors: []\n    };\n\n    try {\n      // Test main health endpoint\n      const healthResponse = await fetch(APP_MODULE_CONFIG.endpoints.health, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' }\n      });\n\n      results.details.health = {\n        status: healthResponse.status,\n        ok: healthResponse.ok,\n        endpoint: APP_MODULE_CONFIG.endpoints.health\n      };\n\n      if (healthResponse.ok) {\n        // Test module test endpoint\n        try {\n          const moduleTestResponse = await fetch(APP_MODULE_CONFIG.endpoints.moduleTest, {\n            method: 'GET',\n            headers: { 'Content-Type': 'application/json' }\n          });\n          results.details.moduleTest = {\n            status: moduleTestResponse.status,\n            ok: moduleTestResponse.status < 500,\n            endpoint: APP_MODULE_CONFIG.endpoints.moduleTest\n          };\n        } catch (error) {\n          results.details.moduleTest = {\n            error: error.message,\n            endpoint: APP_MODULE_CONFIG.endpoints.moduleTest\n          };\n        }\n        \n        results.overall = true;\n        this.state.backendConnected = true;\n        this.state.lastHealthCheck = new Date().toISOString();\n        this.showNotification('Backend connectivity verified', 'success', 'Application');\n      } else {\n        throw new Error(`Health endpoint returned ${healthResponse.status}`);\n      }\n\n    } catch (error) {\n      results.errors.push({\n        endpoint: APP_MODULE_CONFIG.endpoints.health,\n        error: error.message\n      });\n      this.state.backendConnected = false;\n      this.showNotification(`Backend connectivity failed: ${error.message}`, 'error', 'Application');\n    }\n\n    return results;\n  },\n\n  /**\n   * Get application health status (v4.0)\n   * @returns {Object} Health status information\n   */\n  getHealthStatus() {\n    return {\n      module: 'app',\n      version: '4.0.0',\n      status: this.state.initialized ? 'healthy' : 'initializing',\n      features: {\n        configurationDriven: true,\n        enhancedNotifications: true,\n        backendConnectivity: true,\n        moduleLoading: true,\n        themeManagement: true,\n        stateManagement: true\n      },\n      configuration: {\n        endpoints: APP_MODULE_CONFIG.endpoints,\n        constants: APP_MODULE_CONFIG.constants,\n        eventsConfigured: Object.keys(APP_MODULE_CONFIG.events).length\n      },\n      statistics: {\n        coreModulesLoaded: this.state.loadingStats.coreModules.loaded,\n        featureModulesLoaded: this.state.loadingStats.featureModules.loaded,\n        utilityModulesLoaded: this.state.loadingStats.utilityModules.loaded,\n        totalModules: Object.keys({...this.core, ...this.features, ...this.utils}).length,\n        lastHealthCheck: this.state.lastHealthCheck,\n        backendConnected: this.state.backendConnected\n      }\n    };\n  },\n\n  /**\n   * Get module loading statistics (v4.0)\n   * @returns {Object} Module statistics\n   */\n  getModuleStats() {\n    return {\n      core: {\n        loaded: Object.keys(this.core).length,\n        modules: Object.keys(this.core)\n      },\n      features: {\n        loaded: Object.keys(this.features).length,\n        modules: Object.keys(this.features)\n      },\n      utils: {\n        loaded: Object.keys(this.utils).length,\n        modules: Object.keys(this.utils)\n      },\n      total: Object.keys({...this.core, ...this.features, ...this.utils}).length,\n      loadingStats: this.state.loadingStats\n    };\n  }\n};\n\n// Export both default and named exports\nexport default app;\nexport const initialize = app.initialize.bind(app);\nexport const loadCoreModules = app.loadCoreModules.bind(app);\nexport const loadFeatureModules = app.loadFeatureModules.bind(app);\nexport const loadUtilityModules = app.loadUtilityModules.bind(app);\nexport const getModule = app.getModule.bind(app);\nexport const showToast = app.showToast.bind(app);\nexport const showError = app.showError.bind(app);\nexport const showSuccess = app.showSuccess.bind(app);\nexport const getVersion = app.getVersion.bind(app);\nexport const setDebugMode = app.setDebugMode.bind(app);\n\n// v4.0 Enhanced exports\nexport const showNotification = app.showNotification.bind(app);\nexport const testBackendConnectivity = app.testBackendConnectivity.bind(app);\nexport const getHealthStatus = app.getHealthStatus.bind(app);\nexport const getModuleStats = app.getModuleStats.bind(app);","source":"/workspace/modules/static/js/modules/core/app.js","title":"app.js","language":"en"},{"content":"/**\n * Blueprint Module Loader for Flask Blueprint Architecture\n * \n * Advanced module loading system designed specifically for the new Flask Blueprint backend.\n * Provides intelligent module initialization, dependency resolution, and Blueprint-aware\n * loading with cross-platform optimizations.\n * \n * @module core/blueprintModuleLoader\n * @version 3.0.0\n */\n\nimport { CONSTANTS, FEATURE_FLAGS, UI_CONFIG } from '../config/constants.js';\nimport { API_ENDPOINTS, BLUEPRINT_ROUTES, validateEndpoint } from '../config/endpoints.js';\nimport { SOCKET_EVENTS, getBlueprintEvents } from '../config/socketEvents.js';\nimport blueprintApi from '../services/blueprintApi.js';\n\n/**\n * Blueprint Module Loader Class\n */\nclass BlueprintModuleLoader {\n  constructor() {\n    this.modules = new Map();\n    this.loadingQueue = [];\n    this.dependencies = new Map();\n    this.loadingStates = new Map(); // 'pending', 'loading', 'loaded', 'error'\n    this.retryAttempts = new Map();\n    this.moduleConfigs = new Map();\n    \n    // Blueprint-specific settings\n    this.blueprintModules = new Map();\n    this.blueprintInitOrder = UI_CONFIG.BLUEPRINT_TAB_ORDER;\n    this.maxConcurrentLoads = 3;\n    this.loadTimeout = UI_CONFIG.MODULE_LOAD_TIMEOUT;\n    this.maxRetries = UI_CONFIG.MODULE_RETRY_ATTEMPTS;\n    \n    // Performance monitoring\n    this.loadTimes = new Map();\n    this.errorCounts = new Map();\n    this.debugMode = CONSTANTS.DEBUG_MODE;\n    \n    this.initializeBlueprintConfigs();\n  }\n\n  /**\n   * Initialize Blueprint-specific module configurations\n   */\n  initializeBlueprintConfigs() {\n    // Core modules that must load first\n    this.moduleConfigs.set('core', {\n      modules: [\n        'core/eventManager.js',\n        'core/stateManager.js',\n        'core/errorHandler.js',\n        'utils/socketHandler.js',\n        'utils/progressHandler.js'\n      ],\n      priority: 1,\n      required: true,\n      blueprint: 'core'\n    });\n\n    // Blueprint feature modules\n    this.blueprintInitOrder.forEach((blueprint, index) => {\n      const config = this.getBlueprintModuleConfig(blueprint);\n      if (config) {\n        this.moduleConfigs.set(blueprint, {\n          ...config,\n          priority: index + 2, // After core modules\n          blueprint: blueprint\n        });\n      }\n    });\n\n    // Utility modules\n    this.moduleConfigs.set('utils', {\n      modules: [\n        'utils/domUtils.js',\n        'utils/ui.js',\n        'utils/fileHandler.js',\n        'utils/debugTools.js'\n      ],\n      priority: 10,\n      required: false,\n      blueprint: 'core'\n    });\n  }\n\n  /**\n   * Get Blueprint-specific module configuration\n   * @param {string} blueprint - Blueprint name\n   * @returns {Object} Module configuration\n   */\n  getBlueprintModuleConfig(blueprint) {\n    const configs = {\n      file_processor: {\n        modules: [\n          'features/fileProcessor.js',\n          'features/safeFileProcessor.js'\n        ],\n        required: FEATURE_FLAGS.ENABLE_FILE_PROCESSING,\n        endpoints: API_ENDPOINTS.FILE_PROCESSING,\n        events: getBlueprintEvents('file_processor')\n      },\n      \n      playlist_downloader: {\n        modules: [\n          'features/playlistDownloader.js',\n          'features/playlistDownloader.module.js'\n        ],\n        required: FEATURE_FLAGS.ENABLE_PLAYLIST_DOWNLOADER,\n        endpoints: API_ENDPOINTS.PLAYLIST,\n        events: getBlueprintEvents('playlist_downloader')\n      },\n      \n      web_scraper: {\n        modules: [\n          'features/webScraper.js',\n          'features/webScraperUtils.js'\n        ],\n        required: FEATURE_FLAGS.ENABLE_WEB_SCRAPER,\n        endpoints: API_ENDPOINTS.WEB_SCRAPER,\n        events: getBlueprintEvents('web_scraper')\n      },\n      \n      academic_search: {\n        modules: [\n          'features/academicSearch.js',\n          'features/academicScraper.js',\n          'features/academicApiClient.js'\n        ],\n        required: FEATURE_FLAGS.ENABLE_ACADEMIC_SEARCH,\n        endpoints: API_ENDPOINTS.ACADEMIC,\n        events: getBlueprintEvents('academic_search')\n      },\n      \n      pdf_processor: {\n        modules: [\n          'features/pdfProcessor.js'\n        ],\n        required: FEATURE_FLAGS.ENABLE_PDF_PROCESSOR,\n        endpoints: API_ENDPOINTS.PDF,\n        events: getBlueprintEvents('pdf_processor')\n      }\n    };\n\n    return configs[blueprint];\n  }\n\n  /**\n   * Load all Blueprint modules in correct order\n   * @returns {Promise<Map>} Loaded modules\n   */\n  async loadAllModules() {\n    const startTime = performance.now();\n    this.log('Starting Blueprint module loading sequence...');\n\n    try {\n      // Load modules by priority order\n      const sortedConfigs = Array.from(this.moduleConfigs.entries())\n        .sort(([, a], [, b]) => a.priority - b.priority);\n\n      for (const [name, config] of sortedConfigs) {\n        if (config.required || this.shouldLoadModule(name, config)) {\n          await this.loadModuleGroup(name, config);\n        }\n      }\n\n      const loadTime = performance.now() - startTime;\n      this.log(`All Blueprint modules loaded in ${loadTime.toFixed(2)}ms`);\n      \n      // Emit completion event\n      this.emitModuleEvent('blueprint-modules-loaded', {\n        totalModules: this.modules.size,\n        loadTime: loadTime,\n        modules: Array.from(this.modules.keys())\n      });\n\n      return this.modules;\n\n    } catch (error) {\n      this.handleLoadError('global', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Load a group of modules for a specific Blueprint\n   * @param {string} groupName - Module group name\n   * @param {Object} config - Group configuration\n   */\n  async loadModuleGroup(groupName, config) {\n    this.log(`Loading ${groupName} module group...`);\n    const startTime = performance.now();\n\n    try {\n      // Validate Blueprint endpoints if applicable\n      if (config.endpoints) {\n        await this.validateBlueprintEndpoints(config.blueprint, config.endpoints);\n      }\n\n      // Load modules concurrently within the group\n      const modulePromises = config.modules.map(async (modulePath) => {\n        return this.loadModule(modulePath, {\n          blueprint: config.blueprint,\n          timeout: this.loadTimeout,\n          events: config.events\n        });\n      });\n\n      const loadedModules = await Promise.allSettled(modulePromises);\n      \n      // Process results\n      const successful = [];\n      const failed = [];\n\n      loadedModules.forEach((result, index) => {\n        const modulePath = config.modules[index];\n        if (result.status === 'fulfilled') {\n          successful.push(modulePath);\n          this.blueprintModules.set(modulePath, {\n            blueprint: config.blueprint,\n            module: result.value,\n            loadTime: performance.now() - startTime\n          });\n        } else {\n          failed.push({ path: modulePath, error: result.reason });\n          this.errorCounts.set(modulePath, (this.errorCounts.get(modulePath) || 0) + 1);\n        }\n      });\n\n      const loadTime = performance.now() - startTime;\n      this.loadTimes.set(groupName, loadTime);\n\n      this.log(`${groupName} group: ${successful.length} loaded, ${failed.length} failed (${loadTime.toFixed(2)}ms)`);\n\n      // Handle required module failures\n      if (config.required && failed.length > 0) {\n        const error = new Error(`Required ${groupName} modules failed to load: ${failed.map(f => f.path).join(', ')}`);\n        error.details = failed;\n        throw error;\n      }\n\n      // Emit group completion event\n      this.emitModuleEvent('blueprint-group-loaded', {\n        groupName,\n        blueprint: config.blueprint,\n        successful,\n        failed,\n        loadTime\n      });\n\n    } catch (error) {\n      this.handleLoadError(groupName, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Load individual module with Blueprint context\n   * @param {string} modulePath - Module path\n   * @param {Object} options - Loading options\n   * @returns {Promise<Object>} Loaded module\n   */\n  async loadModule(modulePath, options = {}) {\n    const fullPath = `/static/js/modules/${modulePath}`;\n    const moduleId = this.getModuleId(modulePath);\n\n    // Check if already loaded\n    if (this.modules.has(moduleId)) {\n      return this.modules.get(moduleId);\n    }\n\n    // Check loading state\n    if (this.loadingStates.get(moduleId) === 'loading') {\n      return this.waitForModule(moduleId);\n    }\n\n    this.loadingStates.set(moduleId, 'loading');\n    const startTime = performance.now();\n\n    try {\n      const module = await this.importWithTimeout(fullPath, options.timeout);\n      \n      // Initialize module with Blueprint context\n      if (module.default && typeof module.default.init === 'function') {\n        await this.initializeModule(module.default, {\n          blueprint: options.blueprint,\n          events: options.events,\n          api: blueprintApi\n        });\n      }\n\n      this.modules.set(moduleId, module);\n      this.loadingStates.set(moduleId, 'loaded');\n      \n      const loadTime = performance.now() - startTime;\n      this.loadTimes.set(moduleId, loadTime);\n\n      this.log(`Loaded ${modulePath} in ${loadTime.toFixed(2)}ms`);\n      \n      return module;\n\n    } catch (error) {\n      this.loadingStates.set(moduleId, 'error');\n      this.handleModuleError(moduleId, modulePath, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Import module with timeout support\n   * @param {string} path - Module path\n   * @param {number} timeout - Timeout in milliseconds\n   * @returns {Promise<Object>} Imported module\n   */\n  async importWithTimeout(path, timeout = this.loadTimeout) {\n    const importPromise = import(path);\n    \n    if (timeout) {\n      const timeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error(`Module load timeout: ${path}`)), timeout);\n      });\n      \n      return Promise.race([importPromise, timeoutPromise]);\n    }\n    \n    return importPromise;\n  }\n\n  /**\n   * Initialize module with Blueprint context\n   * @param {Object} module - Module to initialize\n   * @param {Object} context - Blueprint context\n   */\n  async initializeModule(module, context) {\n    try {\n      if (typeof module.init === 'function') {\n        await module.init(context);\n      }\n      \n      // Set Blueprint-specific configuration\n      if (module.setBlueprintConfig && typeof module.setBlueprintConfig === 'function') {\n        module.setBlueprintConfig(context.blueprint, {\n          endpoints: context.endpoints,\n          events: context.events,\n          api: context.api\n        });\n      }\n\n    } catch (error) {\n      this.log(`Module initialization failed: ${error.message}`);\n      throw error;\n    }\n  }\n\n  /**\n   * Validate Blueprint endpoints are available\n   * @param {string} blueprint - Blueprint name\n   * @param {Object} endpoints - Endpoint configuration\n   */\n  async validateBlueprintEndpoints(blueprint, endpoints) {\n    if (!blueprint || !endpoints) return;\n\n    try {\n      // Test health endpoint if available\n      if (endpoints.HEALTH) {\n        await blueprintApi.request(endpoints.HEALTH, { method: 'GET' }, blueprint);\n      }\n      \n      this.log(`Blueprint ${blueprint} endpoints validated`);\n      \n    } catch (error) {\n      this.log(`Blueprint ${blueprint} endpoint validation failed: ${error.message}`);\n      // Don't throw - endpoints might not be ready yet\n    }\n  }\n\n  /**\n   * Check if module should be loaded based on feature flags and conditions\n   * @param {string} name - Module name\n   * @param {Object} config - Module configuration\n   * @returns {boolean} Should load module\n   */\n  shouldLoadModule(name, config) {\n    // Check feature flags\n    if (config.blueprint && FEATURE_FLAGS[`ENABLE_${config.blueprint.toUpperCase()}`] === false) {\n      return false;\n    }\n\n    // Check error threshold\n    const errorCount = this.errorCounts.get(name) || 0;\n    if (errorCount >= this.maxRetries) {\n      this.log(`Skipping ${name} - max retries exceeded`);\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Wait for module to finish loading\n   * @param {string} moduleId - Module ID\n   * @returns {Promise<Object>} Loaded module\n   */\n  async waitForModule(moduleId) {\n    return new Promise((resolve, reject) => {\n      const checkInterval = setInterval(() => {\n        const state = this.loadingStates.get(moduleId);\n        \n        if (state === 'loaded') {\n          clearInterval(checkInterval);\n          resolve(this.modules.get(moduleId));\n        } else if (state === 'error') {\n          clearInterval(checkInterval);\n          reject(new Error(`Module ${moduleId} failed to load`));\n        }\n      }, 100);\n      \n      // Timeout after 30 seconds\n      setTimeout(() => {\n        clearInterval(checkInterval);\n        reject(new Error(`Timeout waiting for module ${moduleId}`));\n      }, 30000);\n    });\n  }\n\n  /**\n   * Handle module loading errors with retry logic\n   * @param {string} moduleId - Module ID\n   * @param {string} modulePath - Module path\n   * @param {Error} error - Error object\n   */\n  async handleModuleError(moduleId, modulePath, error) {\n    const retryCount = this.retryAttempts.get(moduleId) || 0;\n    \n    this.log(`Module load error ${modulePath}: ${error.message} (attempt ${retryCount + 1})`);\n    \n    if (retryCount < this.maxRetries) {\n      this.retryAttempts.set(moduleId, retryCount + 1);\n      \n      // Exponential backoff\n      const delay = Math.min(1000 * Math.pow(2, retryCount), 10000);\n      \n      setTimeout(async () => {\n        try {\n          this.log(`Retrying ${modulePath} (attempt ${retryCount + 2})`);\n          await this.loadModule(modulePath);\n        } catch (retryError) {\n          this.log(`Retry failed for ${modulePath}: ${retryError.message}`);\n        }\n      }, delay);\n    } else {\n      this.errorCounts.set(moduleId, (this.errorCounts.get(moduleId) || 0) + 1);\n    }\n  }\n\n  /**\n   * Handle global loading errors\n   * @param {string} context - Error context\n   * @param {Error} error - Error object\n   */\n  handleLoadError(context, error) {\n    this.log(`Loading error in ${context}: ${error.message}`);\n    \n    this.emitModuleEvent('blueprint-load-error', {\n      context,\n      error: error.message,\n      stack: error.stack\n    });\n  }\n\n  /**\n   * Get module ID from path\n   * @param {string} modulePath - Module path\n   * @returns {string} Module ID\n   */\n  getModuleId(modulePath) {\n    return modulePath.replace(/[./]/g, '_').replace(/_js$/, '');\n  }\n\n  /**\n   * Emit module loading events\n   * @param {string} eventName - Event name\n   * @param {Object} data - Event data\n   */\n  emitModuleEvent(eventName, data) {\n    if (typeof window !== 'undefined' && window.dispatchEvent) {\n      window.dispatchEvent(new CustomEvent(eventName, { detail: data }));\n    }\n    \n    this.log(`Event: ${eventName}`, data);\n  }\n\n  /**\n   * Logging with debug mode support\n   * @param {string} message - Log message\n   * @param {any} data - Additional data\n   */\n  log(message, data = null) {\n    if (this.debugMode) {\n      console.log(`[BlueprintModuleLoader] ${message}`, data || '');\n    }\n  }\n\n  /**\n   * Get loading statistics\n   * @returns {Object} Loading statistics\n   */\n  getLoadingStats() {\n    const totalModules = this.modules.size;\n    const totalLoadTime = Array.from(this.loadTimes.values()).reduce((sum, time) => sum + time, 0);\n    const avgLoadTime = totalModules > 0 ? totalLoadTime / totalModules : 0;\n    \n    return {\n      totalModules,\n      totalLoadTime: Math.round(totalLoadTime),\n      avgLoadTime: Math.round(avgLoadTime),\n      errorCounts: Object.fromEntries(this.errorCounts),\n      loadingStates: Object.fromEntries(this.loadingStates),\n      blueprintModules: this.blueprintModules.size\n    };\n  }\n\n  /**\n   * Get module by Blueprint\n   * @param {string} blueprint - Blueprint name\n   * @returns {Array} Modules for Blueprint\n   */\n  getModulesByBlueprint(blueprint) {\n    const modules = [];\n    \n    for (const [path, info] of this.blueprintModules.entries()) {\n      if (info.blueprint === blueprint) {\n        modules.push({\n          path,\n          module: info.module,\n          loadTime: info.loadTime\n        });\n      }\n    }\n    \n    return modules;\n  }\n\n  /**\n   * Reload module (for development)\n   * @param {string} modulePath - Module path\n   * @returns {Promise<Object>} Reloaded module\n   */\n  async reloadModule(modulePath) {\n    const moduleId = this.getModuleId(modulePath);\n    \n    // Clear from cache\n    this.modules.delete(moduleId);\n    this.loadingStates.delete(moduleId);\n    this.retryAttempts.delete(moduleId);\n    \n    // Force reload by adding timestamp\n    const fullPath = `/static/js/modules/${modulePath}?t=${Date.now()}`;\n    return this.importWithTimeout(fullPath);\n  }\n\n  /**\n   * Cleanup all modules and reset state\n   */\n  cleanup() {\n    // Call cleanup on modules that support it\n    for (const [moduleId, module] of this.modules.entries()) {\n      if (module.default && typeof module.default.cleanup === 'function') {\n        try {\n          module.default.cleanup();\n        } catch (error) {\n          this.log(`Cleanup error for ${moduleId}: ${error.message}`);\n        }\n      }\n    }\n\n    // Clear all state\n    this.modules.clear();\n    this.loadingQueue.length = 0;\n    this.dependencies.clear();\n    this.loadingStates.clear();\n    this.retryAttempts.clear();\n    this.blueprintModules.clear();\n    this.loadTimes.clear();\n    this.errorCounts.clear();\n  }\n}\n\n// Create singleton instance\nconst blueprintModuleLoader = new BlueprintModuleLoader();\n\n// Export singleton instance and class\nexport default blueprintModuleLoader;\nexport { BlueprintModuleLoader };\n\n// Export convenience methods\nexport const loadAllBlueprintModules = () => blueprintModuleLoader.loadAllModules();\nexport const loadBlueprintModule = (path, options) => blueprintModuleLoader.loadModule(path, options);\nexport const getBlueprintLoadingStats = () => blueprintModuleLoader.getLoadingStats();\nexport const getBlueprintModules = (blueprint) => blueprintModuleLoader.getModulesByBlueprint(blueprint);\nexport const reloadBlueprintModule = (path) => blueprintModuleLoader.reloadModule(path);\nexport const cleanupBlueprintModules = () => blueprintModuleLoader.cleanup();\n\n// Expose to global scope for debugging\nif (typeof window !== 'undefined' && CONSTANTS.DEBUG_MODE) {\n  window.blueprintModuleLoader = blueprintModuleLoader;\n  window.loadAllBlueprintModules = loadAllBlueprintModules;\n  window.getBlueprintLoadingStats = getBlueprintLoadingStats;\n}","source":"/workspace/modules/static/js/modules/core/blueprintModuleLoader.js","title":"blueprintModuleLoader.js","language":"en"},{"content":"/**\n * DOM Utilities Module - Centralized DOM manipulation functions\n * \n * This module provides common DOM manipulation functions to avoid\n * function redeclarations across multiple modules.\n */\n\n/**\n * Gets a DOM element by various selectors\n * @param {string|HTMLElement} selector - CSS selector, ID, or DOM element\n * @param {HTMLElement} [parent=document] - Parent element to search within\n * @returns {HTMLElement|null} The found element or null\n */\nexport function getElement(selector, parent = document) {\n  if (!selector) {\n    console.warn('No selector provided to getElement');\n    return null;\n  }\n\n  // If selector is already a DOM element, return it\n  if (selector instanceof HTMLElement) {\n    return selector;\n  }\n\n  // Handle ID selectors with or without # prefix\n  if (typeof selector === 'string') {\n    const cleanSelector = selector.trim();\n    \n    // Handle ID format without #\n    if (/^[a-zA-Z][\\w-]*$/.test(cleanSelector) && !cleanSelector.includes(' ')) {\n      const element = document.getElementById(cleanSelector);\n      if (element) return element;\n    }\n    \n    // Use querySelector for any other valid selector\n    try {\n      return parent.querySelector(cleanSelector);\n    } catch (error) {\n      console.error(`Invalid selector: ${cleanSelector}`, error);\n      return null;\n    }\n  }\n  \n  return null;\n}\n\n/**\n * Gets multiple DOM elements by selector\n * @param {string} selector - CSS selector\n * @param {HTMLElement} [parent=document] - Parent element to search within\n * @returns {Array<HTMLElement>} Array of elements (empty if none found)\n */\nexport function getElements(selector, parent = document) {\n  if (!selector) {\n    console.warn('No selector provided to getElements');\n    return [];\n  }\n\n  try {\n    const elements = parent.querySelectorAll(selector);\n    return Array.from(elements);\n  } catch (error) {\n    console.error(`Invalid selector: ${selector}`, error);\n    return [];\n  }\n}\n\n/**\n * Gets UI elements based on a configuration object\n * @param {Object} config - Configuration object with element selectors\n * @param {HTMLElement} [parent=document] - Parent element to search within\n * @returns {Object} Object with found UI elements\n */\nexport function getUIElements(config, parent = document) {\n  if (!config || typeof config !== 'object') {\n    console.error('Invalid UI elements configuration');\n    return {};\n  }\n\n  const elements = {};\n  \n  for (const [key, selector] of Object.entries(config)) {\n    if (Array.isArray(selector)) {\n      elements[key] = getElements(selector[0], parent);\n    } else {\n      elements[key] = getElement(selector, parent);\n    }\n  }\n  \n  return elements;\n}\n\n/**\n * Creates a DOM element with attributes and content\n * @param {string} tag - HTML tag name\n * @param {Object} [attributes={}] - Attributes to set on the element\n * @param {string|HTMLElement|Array} [content] - Content to append to the element\n * @returns {HTMLElement} The created element\n */\nexport function createElement(tag, attributes = {}, content) {\n  const element = document.createElement(tag);\n  \n  // Set attributes\n  Object.entries(attributes).forEach(([attr, value]) => {\n    if (attr === 'className') {\n      element.className = value;\n    } else if (attr === 'dataset') {\n      Object.entries(value).forEach(([dataKey, dataValue]) => {\n        element.dataset[dataKey] = dataValue;\n      });\n    } else {\n      element.setAttribute(attr, value);\n    }\n  });\n  \n  // Add content\n  if (content) {\n    if (typeof content === 'string') {\n      element.textContent = content;\n    } else if (content instanceof HTMLElement) {\n      element.appendChild(content);\n    } else if (Array.isArray(content)) {\n      content.forEach(item => {\n        if (typeof item === 'string') {\n          element.appendChild(document.createTextNode(item));\n        } else if (item instanceof HTMLElement) {\n          element.appendChild(item);\n        }\n      });\n    }\n  }\n  \n  return element;\n}\n/**\n * Toggle element visibility\n * @param {string|HTMLElement} selector - Element ID or element\n * @param {boolean} visible - Whether to show or hide\n */\nexport function toggleElementVisibility(selector, visible) {\n  const element = getElement(selector);\n  if (!element) return;\n  \n  if (visible) {\n    element.classList.remove('d-none');\n  } else {\n    element.classList.add('d-none');\n  }\n}\n\n/**\n * Add event listeners to one or more elements\n * @param {HTMLElement|Array<HTMLElement>} elements - Element(s) to add listeners to\n * @param {string|Array<string>} events - Event(s) to listen for\n * @param {Function} handler - Event handler function\n * @param {Object} [options] - AddEventListener options\n */\nexport function addEventListeners(elements, events, handler, options) {\n  const elementArray = Array.isArray(elements) ? elements : [elements];\n  const eventArray = Array.isArray(events) ? events : [events];\n  \n  elementArray.forEach(element => {\n    if (element) {\n      eventArray.forEach(event => {\n        element.addEventListener(event, handler, options);\n      });\n    }\n  });\n}\n// Make sure it's included in the exports\nexport default {\n  getElement,\n  getElements,\n  getUIElements,\n  createElement,\n  addEventListeners,\n  toggleElementVisibility\n};","source":"/workspace/modules/static/js/modules/core/domUtils.js","title":"domUtils.js","language":"en"},{"content":"/**\n * NeuroGen Server - Enhanced Error Handler Module v4.0\n * \n * Advanced error handling optimized for the new Blueprint architecture.\n * Centralizes error handling with Blueprint context awareness and\n * integrated health monitoring.\n * \n * NEW v4.0 Features:\n * - Configuration-driven error messages from centralized constants\n * - Enhanced 4-method notification system (Toast + Console + System + Error)\n * - Backend connectivity testing with health checks\n * - ES6 module imports with centralized configuration\n * - Blueprint-specific error categorization and context\n * - Integrated with systemHealth.js monitoring\n * - Cross-platform error handling\n * \n * Legacy Features (Enhanced):\n * - Structured error categorization\n * - Graceful UI error presentation\n * - Detailed error logging\n * - Comprehensive error history management\n * - API error handling utilities\n * - Stack trace parsing and visualization\n * \n * @module core/errorHandler\n * @version 4.0.0 - Blueprint Architecture Optimization\n */\n\n// Import dependencies from centralized config\nimport { API_ENDPOINTS, BLUEPRINT_ROUTES } from '../config/endpoints.js';\nimport { CONSTANTS, API_CONFIG, ERROR_CONFIG } from '../config/constants.js';\nimport { SOCKET_EVENTS, TASK_EVENTS } from '../config/socketEvents.js';\n\n// Global configuration for error handler\nconst ERROR_HANDLER_CONFIG = {\n  endpoints: {\n    health: API_ENDPOINTS.SYSTEM?.HEALTH || '/api/health',\n    errorReporting: API_ENDPOINTS.SYSTEM?.ERROR_REPORTING || '/api/errors',\n    ...API_ENDPOINTS\n  },\n  api: API_CONFIG,\n  constants: ERROR_CONFIG || {\n    MAX_ERROR_HISTORY: 50,\n    LOG_TO_CONSOLE: true,\n    SAVE_TO_LOCAL_STORAGE: true,\n    EMIT_EVENTS: true,\n    SHOW_NOTIFICATIONS: true\n  },\n  events: {\n    ...TASK_EVENTS,\n    error_occurred: 'error_occurred',\n    error_resolved: 'error_resolved',\n    critical_error: 'critical_error'\n  }\n};\n\n// Module state\nconst errorState = {\n  initialized: false,\n  backendConnected: false,\n  lastHealthCheck: null,\n  errorCounts: {\n    total: 0,\n    byType: {},\n    byModule: {},\n    critical: 0\n  }\n};\n\n// Import dependencies without circular references\nlet ui = null;\n\n/**\n * Error Handler module for centralized error management\n */\nconst errorHandler = {\n  // Error types and corresponding messages\n  ERROR_TYPES: {\n    NETWORK: {\n      code: 'NETWORK_ERROR',\n      message: 'Network connection issue. Please check your internet connection and try again.'\n    },\n    SERVER: {\n      code: 'SERVER_ERROR',\n      message: 'Server error occurred. Please try again later or contact support.'\n    },\n    VALIDATION: {\n      code: 'VALIDATION_ERROR',\n      message: 'Please check your input and try again.'\n    },\n    FILE_ACCESS: {\n      code: 'FILE_ACCESS_ERROR',\n      message: 'Unable to access the specified file or directory. Please check permissions.'\n    },\n    PROCESSING: {\n      code: 'PROCESSING_ERROR',\n      message: 'Error occurred while processing your request.'\n    },\n    SOCKET: {\n      code: 'SOCKET_ERROR',\n      message: 'Real-time connection error. Updates may be delayed.'\n    },\n    UI_MISSING_ELEMENT: {\n      code: 'UI_MISSING_ELEMENT',\n      message: 'UI element not found. Some functionality may be limited.'\n    },\n    MODULE_LOADING: {\n      code: 'MODULE_LOADING_ERROR',\n      message: 'Failed to load required module. Application may not work correctly.'\n    },\n    UNKNOWN: {\n      code: 'UNKNOWN_ERROR',\n      message: 'An unexpected error occurred. Please try again.'\n    }\n  },\n  \n  // Maximum number of errors to keep in history\n  MAX_ERROR_HISTORY: 50,\n  \n  // Store error history\n  errorHistory: [],\n  \n  // Module state\n  state: errorState,\n  \n  // Configuration from centralized config (v4.0)\n  config: {\n    logToConsole: ERROR_HANDLER_CONFIG.constants.LOG_TO_CONSOLE,\n    saveToLocalStorage: ERROR_HANDLER_CONFIG.constants.SAVE_TO_LOCAL_STORAGE,\n    emitEvents: ERROR_HANDLER_CONFIG.constants.EMIT_EVENTS,\n    showNotifications: ERROR_HANDLER_CONFIG.constants.SHOW_NOTIFICATIONS,\n    detailedLogForTypes: ['NETWORK', 'SERVER', 'PROCESSING', 'BLUEPRINT'],\n    debug: false\n  },\n  \n  /**\n   * Initialize the error handler with v4.0 enhancements\n   * @param {Object} options - Configuration options\n   * @returns {Promise<boolean>} - Success state\n   */\n  async initialize(options = {}) {\n    if (this.state.initialized) {\n      this.showNotification(\"Error handler already initialized\", 'warning', 'Error Handler');\n      return true;\n    }\n    \n    try {\n      this.showNotification('Initializing Error Handler v4.0', 'info', 'Error Handler');\n      \n      // Test backend connectivity on initialization\n      const connectivityResult = await this.testBackendConnectivity();\n      if (!connectivityResult.overall) {\n        console.warn('Error Handler: Backend connectivity test failed, continuing with limited functionality');\n      }\n      \n      // Merge options with defaults\n      this.config = {\n        ...this.config,\n        ...options\n      };\n      \n      // Enable debug mode on localhost\n      if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {\n        this.config.debug = true;\n      }\n      \n      // Try to load UI module dynamically to avoid circular references\n      await this.loadUiModule();\n      \n      // Set up global error handler\n      this.setupGlobalErrorHandler();\n      \n      // Load error history from localStorage if available\n      this.loadErrorHistory();\n      \n      // Initialize error tracking\n      this.state.errorCounts = {\n        total: 0,\n        byType: {},\n        byModule: {},\n        critical: 0\n      };\n      \n      this.state.initialized = true;\n      this.showNotification('Error Handler v4.0 initialized successfully', 'success', 'Error Handler');\n      return true;\n    } catch (error) {\n      this.showNotification(`Error Handler initialization failed: ${error.message}`, 'error', 'Error Handler');\n      return false;\n    }\n  },\n  \n  /**\n   * Load UI module dynamically to avoid circular references\n   */\n  async loadUiModule() {\n    try {\n      const module = await import('./ui.js');\n      ui = module.default;\n      if (this.config.debug) {\n        console.log(\"UI module loaded in errorHandler\");\n      }\n    } catch (err) {\n      console.warn('UI module not loaded for error handler:', err);\n    }\n  },\n  \n  /**\n   * Set up global error handling\n   */\n  setupGlobalErrorHandler() {\n    // Catch unhandled promise rejections\n    window.addEventListener('unhandledrejection', event => {\n      console.error('Unhandled promise rejection:', event.reason);\n      this.handleError(event.reason, 'UNKNOWN');\n      return false;\n    });\n    \n    // Catch global errors\n    window.addEventListener('error', event => {\n      console.error('Global error:', event.error || event.message);\n      this.handleError(event.error || new Error(event.message), 'UNKNOWN');\n      return false;\n    });\n    \n    // Override fetch errors\n    const originalFetch = window.fetch;\n    window.fetch = async (...args) => {\n      try {\n        const response = await originalFetch(...args);\n        \n        // Handle HTTP error status codes\n        if (!response.ok) {\n          const error = new Error(`HTTP error: ${response.status} ${response.statusText}`);\n          error.response = response;\n          error.status = response.status;\n          \n          // Categorize error based on status code\n          let errorType = 'SERVER';\n          if (response.status === 0 || response.status === 408) {\n            errorType = 'NETWORK';\n          } else if (response.status >= 400 && response.status < 500) {\n            errorType = 'VALIDATION';\n          }\n          \n          // Log error but don't show UI notification yet (let calling code handle it)\n          this.logError(error, errorType);\n        }\n        \n        return response;\n      } catch (error) {\n        // Handle network errors\n        console.error('Fetch error:', error);\n        this.handleError(error, 'NETWORK');\n        throw error;\n      }\n    };\n    \n    // Register with event registry if available\n    setTimeout(() => this.registerWithEventRegistry(), 0);\n    \n    console.log(\"Global error handlers set up\");\n  },\n  \n  /**\n   * Register with event registry if available\n   */\n  registerWithEventRegistry() {\n    try {\n      if (typeof window.eventRegistry?.on === 'function') {\n        // Listen for module errors\n        window.eventRegistry.on('module.error', (data) => {\n          this.handleError(data.error, data.type || 'MODULE_LOADING', true, {\n            module: data.moduleName\n          });\n        });\n        \n        if (this.config.debug) {\n          console.log(\"ErrorHandler registered with eventRegistry\");\n        }\n      }\n    } catch (e) {\n      console.warn(\"Could not register with eventRegistry:\", e);\n    }\n  },\n  \n  /**\n   * Handle an error with appropriate logging and UI feedback\n   * @param {Error|string} error - The error object or message\n   * @param {string} type - Error type (from ERROR_TYPES)\n   * @param {boolean} showUI - Whether to show UI notification\n   * @param {Object} [options] - Additional options\n   * @param {string} [options.message] - Optional override message\n   * @param {string} [options.title] - Optional title for UI notification\n   * @param {Function} [options.callback] - Optional callback after error is handled\n   * @returns {Object} - Error details\n   */\n  handleError(error, type = 'UNKNOWN', showUI = true, options = {}) {\n    try {\n      // Get error object if string was provided\n      if (typeof error === 'string') {\n        error = new Error(error);\n      } else if (!error) {\n        error = new Error('Unknown error');\n      }\n      \n      // Add type to error for reference\n      error.errorType = type;\n      \n      // Log error\n      this.logError(error, type);\n      \n      // Show error in UI if requested and enabled in config\n      if (showUI && this.config.showNotifications) {\n        const errorType = this.ERROR_TYPES[type] || this.ERROR_TYPES.UNKNOWN;\n        this.showErrorNotification(error, errorType, options);\n      }\n      \n      // Call callback if provided\n      if (options.callback && typeof options.callback === 'function') {\n        try {\n          options.callback(error, type);\n        } catch (callbackError) {\n          console.error('Error in error callback:', callbackError);\n        }\n      }\n      \n      // Emit error event to any subscribers\n      if (this.config.emitEvents) {\n        this.emitErrorEvent(error, type);\n      }\n      \n      return {\n        error,\n        type,\n        timestamp: new Date().toISOString()\n      };\n    } catch (handlerError) {\n      // Last resort logging if error handler itself fails\n      console.error('Error in error handler:', handlerError);\n      console.error('Original error:', error);\n      \n      // Try to show a basic alert if everything else fails\n      try {\n        const errorMessage = error?.message || 'Unknown error';\n        alert(`An error occurred: ${errorMessage}`);\n      } catch (e) {\n        // Nothing more we can do\n      }\n      \n      return {\n        error,\n        type,\n        handlerError,\n        timestamp: new Date().toISOString()\n      };\n    }\n  },\n  \n  /**\n   * Log error to console and error history\n   * @param {Error} error - The error object\n   * @param {string} type - Error type\n   */\n  logError(error, type = 'UNKNOWN') {\n    try {\n      // Prevent logging null errors\n      if (!error) {\n        console.warn('Attempted to log null error');\n        return;\n      }\n      \n      // Log to console if enabled\n      if (this.config.logToConsole) {\n        console.error(`[${type}]`, error);\n        \n        // Log additional details for certain error types\n        if (this.config.detailedLogForTypes.includes(type)) {\n          if (error.response) {\n            console.error('Response:', error.response);\n          }\n          if (error.request) {\n            console.error('Request:', error.request);\n          }\n          if (error.config) {\n            console.error('Config:', error.config);\n          }\n        }\n      }\n      \n      // Create error item for history\n      const errorItem = {\n        message: error.message || 'Unknown error',\n        stack: error.stack || null,\n        type: type,\n        code: this.ERROR_TYPES[type]?.code || 'UNKNOWN_ERROR',\n        timestamp: new Date().toISOString(),\n        details: error.details || null,\n        status: error.status || null\n      };\n      \n      // Add to error history\n      this.errorHistory.unshift(errorItem);\n      \n      // Limit error history size\n      if (this.errorHistory.length > this.MAX_ERROR_HISTORY) {\n        this.errorHistory = this.errorHistory.slice(0, this.MAX_ERROR_HISTORY);\n      }\n      \n      // Save to localStorage if enabled\n      if (this.config.saveToLocalStorage) {\n        this.saveErrorHistory();\n      }\n    } catch (e) {\n      console.error('Error in logError:', e);\n    }\n  },\n  \n  /**\n   * Save error history to localStorage\n   */\n  saveErrorHistory() {\n    try {\n      if (typeof localStorage !== 'undefined') {\n        // Only store essential information to save space\n        const simplifiedHistory = this.errorHistory.map(err => ({\n          message: err.message,\n          type: err.type,\n          code: err.code,\n          timestamp: err.timestamp\n        }));\n        \n        localStorage.setItem('errorHistory', JSON.stringify(simplifiedHistory));\n      }\n    } catch (e) {\n      console.warn('Could not save error history to localStorage:', e);\n    }\n  },\n  \n  /**\n   * Load error history from localStorage\n   */\n  loadErrorHistory() {\n    try {\n      if (typeof localStorage !== 'undefined') {\n        const storedHistory = localStorage.getItem('errorHistory');\n        \n        if (storedHistory) {\n          const parsedHistory = JSON.parse(storedHistory);\n          \n          // Only use valid entries\n          this.errorHistory = Array.isArray(parsedHistory) ? parsedHistory : [];\n          \n          if (this.config.debug) {\n            console.log(`Loaded ${this.errorHistory.length} error history items`);\n          }\n        }\n      }\n    } catch (e) {\n      console.warn('Could not load error history from localStorage:', e);\n      this.errorHistory = [];\n    }\n  },\n  \n  /**\n   * Show error notification to the user\n   * @param {Error} error - The error object\n   * @param {Object} errorType - Error type object from ERROR_TYPES\n   * @param {Object} [options] - Additional options\n   * @param {string} [options.message] - Optional override message\n   * @param {string} [options.title] - Optional title for UI notification\n   */\n  showErrorNotification(error, errorType, options = {}) {\n    try {\n      // Determine user-friendly message\n      let userMessage = options.message || errorType.message;\n      \n      // Include specific error message if available and not too technical\n      if (error.message && \n          !options.message &&\n          !error.message.includes('undefined') && \n          !error.message.includes('null') &&\n          error.message.length < 100) {\n        userMessage = `${errorType.message} ${error.message}`;\n      }\n      \n      // Set title\n      const title = options.title || 'Error';\n      \n      // If ui module is available, use it to show toast\n      if (ui && typeof ui.showToast === 'function') {\n        ui.showToast(title, userMessage, 'error');\n      } else {\n        // Fallback to console when UI not available\n        console.error(`${title}: ${userMessage}`);\n        \n        // Try to create a simple error display\n        this.createBasicErrorDisplay(title, userMessage);\n      }\n    } catch (e) {\n      console.error('Error showing notification:', e);\n    }\n  },\n  \n  /**\n   * Create a basic error display when UI module is not available\n   * @param {string} title - Error title\n   * @param {string} message - Error message\n   */\n  createBasicErrorDisplay(title, message) {\n    try {\n      // Check if error container exists\n      let errorContainer = document.getElementById('app-loading-error');\n      \n      // Create it if needed\n      if (!errorContainer) {\n        errorContainer = document.createElement('div');\n        errorContainer.id = 'app-loading-error';\n        errorContainer.className = 'alert alert-danger m-3';\n        document.body.prepend(errorContainer);\n      }\n      \n      // Set error message\n      errorContainer.innerHTML = `<strong>${title}:</strong> ${message}`;\n      errorContainer.style.display = 'block';\n      \n      // Auto-hide after 5 seconds\n      setTimeout(() => {\n        errorContainer.style.display = 'none';\n      }, 5000);\n    } catch (e) {\n      // Last resort - nothing more we can do\n      console.error('Failed to create basic error display:', e);\n    }\n  },\n  \n  /**\n   * Emit an error event for subscribers\n   * @param {Error} error - The error object\n   * @param {string} type - Error type\n   */\n  emitErrorEvent(error, type) {\n    try {\n      // Try to use eventRegistry if available (preferred)\n      if (typeof window.eventRegistry?.emit === 'function') {\n        window.eventRegistry.emit('app.error', {\n          error: error,\n          type: type,\n          timestamp: new Date().toISOString()\n        });\n        return;\n      }\n      \n      // Fallback to custom event\n      const errorEvent = new CustomEvent('app.error', {\n        detail: {\n          error: error,\n          type: type,\n          timestamp: new Date().toISOString()\n        },\n        bubbles: true,\n        cancelable: true\n      });\n      \n      // Dispatch on document for global access\n      document.dispatchEvent(errorEvent);\n    } catch (e) {\n      console.error('Error emitting error event:', e);\n    }\n  },\n  \n  /**\n   * Show success notification to the user\n   * @param {string} title - Success title\n   * @param {string} message - Success message\n   */\n  showSuccess(title, message) {\n    try {\n      // Log success for tracking\n      console.log(`[SUCCESS] ${title}: ${message}`);\n      \n      // Show toast notification using UI module\n      if (ui && typeof ui.showToast === 'function') {\n        ui.showToast(title, message, 'success');\n      } else {\n        console.log(`${title}: ${message}`);\n      }\n    } catch (e) {\n      console.error('Error showing success:', e);\n    }\n  },\n  \n  /**\n   * Display an enhanced error message with details\n   * @param {string} title - Error title\n   * @param {Error|string} error - The error object or message\n   */\n  displayEnhancedErrorMessage(title, error) {\n    try {\n      // If error is a string, convert to Error object\n      if (typeof error === 'string') {\n        error = new Error(error);\n      }\n      \n      // Log error\n      this.logError(error, 'UNKNOWN');\n      \n      // Extract error details\n      const errorDetails = {\n        message: error.message || 'Unknown error',\n        stack: error.stack ? this.parseStackTrace(error.stack) : [],\n        timestamp: new Date().toISOString()\n      };\n      \n      // Create error message HTML\n      const errorHTML = `\n        <div class=\"alert alert-danger mb-3\">\n          <h5 class=\"alert-heading\"><i class=\"fas fa-exclamation-circle me-2\"></i>${title}</h5>\n          <p>${errorDetails.message}</p>\n          ${this.renderStackTrace(errorDetails.stack)}\n        </div>\n        <p class=\"small text-muted\">\n          <i class=\"fas fa-clock me-1\"></i> ${new Date().toLocaleTimeString()}\n        </p>\n      `;\n      \n      // Show error in UI\n      if (ui && typeof ui.showErrorAlert === 'function') {\n        ui.showErrorAlert(title, errorHTML);\n      } else {\n        console.warn(\"ui.showErrorAlert not available, falling back to basic alert\");\n        if (ui && typeof ui.showToast === 'function') {\n          ui.showToast(title, errorDetails.message, 'error');\n        } else {\n          this.createBasicErrorDisplay(title, errorDetails.message);\n        }\n      }\n    } catch (e) {\n      console.error('Error displaying enhanced message:', e);\n      // Last resort\n      alert(`${title}: ${error.message || 'Unknown error'}`);\n    }\n  },\n  \n  /**\n   * Parse a stack trace into a structured array\n   * @param {string} stackTrace - Raw stack trace string\n   * @returns {Array} - Array of stack frame objects\n   */\n  parseStackTrace(stackTrace) {\n    try {\n      if (!stackTrace) return [];\n      \n      // Split stack trace into lines\n      const lines = stackTrace.split('\\n').filter(line => line.trim());\n      \n      // Extract relevant information from each line\n      return lines.map(line => {\n        const frame = {};\n        \n        // Extract function name\n        const functionMatch = line.match(/at\\s+([^\\s]+)\\s+\\(/);\n        if (functionMatch && functionMatch[1]) {\n          frame.function = functionMatch[1];\n        }\n        \n        // Extract file path and line number\n        const fileMatch = line.match(/\\(([^:]+):(\\d+):(\\d+)\\)/);\n        if (fileMatch) {\n          frame.file = fileMatch[1];\n          frame.line = parseInt(fileMatch[2], 10);\n          frame.column = parseInt(fileMatch[3], 10);\n        } else {\n          // Alternative pattern for when there's no parentheses\n          const altMatch = line.match(/at\\s+([^:]+):(\\d+):(\\d+)/);\n          if (altMatch) {\n            frame.file = altMatch[1];\n            frame.line = parseInt(altMatch[2], 10);\n            frame.column = parseInt(altMatch[3], 10);\n          }\n        }\n        \n        // Clean up file path\n        if (frame.file) {\n          frame.file = frame.file.split('/').pop(); // Just get the filename\n        } else {\n          frame.file = 'unknown';\n        }\n        \n        // Add raw line for reference\n        frame.raw = line.trim();\n        \n        return frame;\n      });\n    } catch (e) {\n      console.error('Error parsing stack trace:', e);\n      return [];\n    }\n  },\n  \n  /**\n   * Render stack trace as HTML\n   * @param {Array} stackFrames - Array of stack frame objects\n   * @returns {string} - HTML representation of stack trace\n   */\n  renderStackTrace(stackFrames) {\n    if (!stackFrames || stackFrames.length === 0) {\n      return '';\n    }\n    \n    try {\n      // Only show first 5 frames to avoid overwhelming the user\n      const frames = stackFrames.slice(0, 5);\n      \n      // Create HTML for stack trace\n      return `\n        <div class=\"stack-trace small mt-3\">\n          <p class=\"mb-1\">Stack trace:</p>\n          <ul class=\"list-group\">\n            ${frames.map(frame => `\n              <li class=\"list-group-item list-group-item-danger py-1\">\n                ${frame.function ? `<span class=\"badge bg-secondary me-1\">${frame.function}</span>` : ''}\n                <small>${frame.file}:${frame.line}</small>\n              </li>\n            `).join('')}\n          </ul>\n        </div>\n      `;\n    } catch (e) {\n      console.error('Error rendering stack trace:', e);\n      return '';\n    }\n  },\n  \n  /**\n   * Get most recent errors\n   * @param {number} count - Number of errors to retrieve\n   * @returns {Array} - Array of error objects\n   */\n  getRecentErrors(count = 10) {\n    return this.errorHistory.slice(0, count);\n  },\n  \n  /**\n   * Clear error history\n   */\n  clearErrorHistory() {\n    this.errorHistory = [];\n    \n    if (this.config.saveToLocalStorage) {\n      try {\n        localStorage.removeItem('errorHistory');\n      } catch (e) {\n        console.warn('Could not clear error history from localStorage:', e);\n      }\n    }\n  },\n  \n  /**\n   * Get a categorized count of errors by type\n   * @returns {Object} - Object with counts by error type\n   */\n  getErrorStatsByType() {\n    const stats = {};\n    \n    // Initialize all error types with zero count\n    Object.keys(this.ERROR_TYPES).forEach(type => {\n      stats[type] = 0;\n    });\n    \n    // Count errors by type\n    this.errorHistory.forEach(error => {\n      if (error.type in stats) {\n        stats[error.type]++;\n      } else {\n        stats.UNKNOWN++;\n      }\n    });\n    \n    return stats;\n  },\n  \n  /**\n   * Create a human-readable error message\n   * @param {Error|string} error - Error object or message\n   * @param {string} type - Error type\n   * @returns {string} - Human-readable error message\n   */\n  createUserFriendlyMessage(error, type = 'UNKNOWN') {\n    // Get error type information\n    const errorType = this.ERROR_TYPES[type] || this.ERROR_TYPES.UNKNOWN;\n    \n    // Get error message\n    let errorMessage = typeof error === 'string' ? error : (error?.message || 'Unknown error');\n    \n    // Clean up error message\n    errorMessage = errorMessage\n      .replace(/^Error:?\\s*/i, '')  // Remove \"Error:\" prefix\n      .replace(/\\s+/g, ' ')         // Replace multiple spaces with single space\n      .trim();                       // Trim whitespace\n    \n    // Create user-friendly message\n    let userMessage = errorType.message;\n    \n    // Add specific error message if it's meaningful and not just technical details\n    if (errorMessage &&\n        !errorMessage.includes('undefined') &&\n        !errorMessage.includes('null') &&\n        !errorMessage.includes('object') &&\n        errorMessage.length < 100) {\n      userMessage = `${userMessage} ${errorMessage}`;\n    }\n    \n    return userMessage;\n  },\n\n  /**\n   * Enhanced notification system with 4-method delivery (v4.0)\n   * @param {string} message - Notification message\n   * @param {string} type - Notification type (info, success, warning, error)\n   * @param {string} title - Notification title\n   */\n  showNotification(message, type = 'error', title = 'Error Handler') {\n    // Method 1: Toast notifications\n    if (window.NeuroGen?.ui?.showToast) {\n      window.NeuroGen.ui.showToast(title, message, type);\n    }\n    \n    // Method 2: Console logging with styling\n    const styles = {\n      error: 'color: #dc3545; font-weight: bold;',\n      warning: 'color: #fd7e14; font-weight: bold;',\n      success: 'color: #198754; font-weight: bold;',\n      info: 'color: #0d6efd;'\n    };\n    console.log(`%c[${title}] ${message}`, styles[type] || styles.error);\n    \n    // Method 3: System notification (if available)\n    if (window.NeuroGen?.notificationHandler) {\n      window.NeuroGen.notificationHandler.show({\n        title, message, type, module: 'errorHandler'\n      });\n    }\n    \n    // Method 4: Error reporting to centralized handler (recursive prevention)\n    if (type === 'error' && window.NeuroGen?.errorHandler && window.NeuroGen.errorHandler !== this) {\n      window.NeuroGen.errorHandler.logError({\n        module: 'errorHandler', message, severity: type\n      });\n    }\n  },\n\n  /**\n   * Test backend connectivity for error handler (v4.0)\n   * @returns {Promise<Object>} Backend connectivity status\n   */\n  async testBackendConnectivity() {\n    const results = {\n      overall: false,\n      details: {},\n      timestamp: new Date().toISOString(),\n      errors: []\n    };\n\n    try {\n      // Test main health endpoint\n      const healthResponse = await fetch(ERROR_HANDLER_CONFIG.endpoints.health, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' }\n      });\n\n      results.details.health = {\n        status: healthResponse.status,\n        ok: healthResponse.ok,\n        endpoint: ERROR_HANDLER_CONFIG.endpoints.health\n      };\n\n      if (healthResponse.ok) {\n        // Test error reporting endpoint if available\n        if (ERROR_HANDLER_CONFIG.endpoints.errorReporting) {\n          try {\n            const errorResponse = await fetch(ERROR_HANDLER_CONFIG.endpoints.errorReporting, {\n              method: 'GET',\n              headers: { 'Content-Type': 'application/json' }\n            });\n            results.details.errorReporting = {\n              status: errorResponse.status,\n              ok: errorResponse.status < 500,\n              endpoint: ERROR_HANDLER_CONFIG.endpoints.errorReporting\n            };\n          } catch (error) {\n            results.details.errorReporting = {\n              error: error.message,\n              endpoint: ERROR_HANDLER_CONFIG.endpoints.errorReporting\n            };\n          }\n        }\n        \n        results.overall = true;\n        this.state.backendConnected = true;\n        this.state.lastHealthCheck = new Date().toISOString();\n        this.showNotification('Backend connectivity verified', 'success', 'Error Handler');\n      } else {\n        throw new Error(`Health endpoint returned ${healthResponse.status}`);\n      }\n\n    } catch (error) {\n      results.errors.push({\n        endpoint: ERROR_HANDLER_CONFIG.endpoints.health,\n        error: error.message\n      });\n      this.state.backendConnected = false;\n      this.showNotification(`Backend connectivity failed: ${error.message}`, 'error', 'Error Handler');\n    }\n\n    return results;\n  },\n\n  /**\n   * Get error handler health status (v4.0)\n   * @returns {Object} Health status information\n   */\n  getHealthStatus() {\n    return {\n      module: 'errorHandler',\n      version: '4.0.0',\n      status: this.state.initialized ? 'healthy' : 'initializing',\n      features: {\n        configurationDriven: true,\n        enhancedNotifications: true,\n        backendConnectivity: true,\n        blueprintErrorHandling: true,\n        stackTraceAnalysis: true,\n        errorCategorization: true\n      },\n      configuration: {\n        endpoints: ERROR_HANDLER_CONFIG.endpoints,\n        constants: ERROR_HANDLER_CONFIG.constants,\n        eventsConfigured: Object.keys(ERROR_HANDLER_CONFIG.events).length,\n        errorTypes: Object.keys(this.ERROR_TYPES).length\n      },\n      statistics: {\n        totalErrors: this.state.errorCounts.total,\n        criticalErrors: this.state.errorCounts.critical,\n        errorsByType: this.state.errorCounts.byType,\n        errorsByModule: this.state.errorCounts.byModule,\n        errorHistoryLength: this.errorHistory.length,\n        lastHealthCheck: this.state.lastHealthCheck,\n        backendConnected: this.state.backendConnected\n      }\n    };\n  },\n\n  /**\n   * Enhanced error handling for Blueprint modules (v4.0)\n   * @param {Error} error - Error object\n   * @param {string} module - Module name\n   * @param {Object} context - Blueprint context\n   */\n  handleBlueprintError(error, module, context = {}) {\n    // Increment error counts\n    this.state.errorCounts.total++;\n    this.state.errorCounts.byModule[module] = (this.state.errorCounts.byModule[module] || 0) + 1;\n    \n    // Determine error type based on Blueprint context\n    let errorType = 'UNKNOWN';\n    if (context.endpoint) {\n      errorType = 'NETWORK';\n    } else if (context.blueprint) {\n      errorType = 'BLUEPRINT';\n    } else if (context.module) {\n      errorType = 'MODULE_LOADING';\n    }\n    \n    this.state.errorCounts.byType[errorType] = (this.state.errorCounts.byType[errorType] || 0) + 1;\n    \n    // Handle error with enhanced context\n    this.handleError(error, errorType, true, {\n      ...context,\n      blueprintModule: module,\n      timestamp: new Date().toISOString(),\n      version: '4.0.0'\n    });\n    \n    // Report to systemHealth if available\n    if (window.NeuroGen?.systemHealth) {\n      window.NeuroGen.systemHealth.updateStatus('error', `${module}: ${error.message}`, {\n        module,\n        error: error.message,\n        context\n      });\n    }\n    \n    // Emit Blueprint error event\n    if (window.NeuroGen?.eventRegistry) {\n      window.NeuroGen.eventRegistry.emit(ERROR_HANDLER_CONFIG.events.error_occurred, {\n        error: error.message,\n        module,\n        context,\n        timestamp: new Date().toISOString()\n      });\n    }\n  }\n};\n\n// Export the module\nexport default errorHandler;\n\n// Named exports for the public methods only\nexport const initialize = errorHandler.initialize.bind(errorHandler);\nexport const handleError = errorHandler.handleError.bind(errorHandler);\nexport const logError = errorHandler.logError.bind(errorHandler);\nexport const showErrorNotification = errorHandler.showErrorNotification.bind(errorHandler);\nexport const createBasicErrorDisplay = errorHandler.createBasicErrorDisplay.bind(errorHandler);\nexport const emitErrorEvent = errorHandler.emitErrorEvent.bind(errorHandler);\nexport const showSuccess = errorHandler.showSuccess.bind(errorHandler);\nexport const displayEnhancedErrorMessage = errorHandler.displayEnhancedErrorMessage.bind(errorHandler);\nexport const parseStackTrace = errorHandler.parseStackTrace.bind(errorHandler);\nexport const renderStackTrace = errorHandler.renderStackTrace.bind(errorHandler);\nexport const getRecentErrors = errorHandler.getRecentErrors.bind(errorHandler);\nexport const clearErrorHistory = errorHandler.clearErrorHistory.bind(errorHandler);\nexport const getErrorStatsByType = errorHandler.getErrorStatsByType.bind(errorHandler);\nexport const createUserFriendlyMessage = errorHandler.createUserFriendlyMessage.bind(errorHandler);\n\n// v4.0 Enhanced exports\nexport const showNotification = errorHandler.showNotification.bind(errorHandler);\nexport const testBackendConnectivity = errorHandler.testBackendConnectivity.bind(errorHandler);\nexport const getHealthStatus = errorHandler.getHealthStatus.bind(errorHandler);\nexport const handleBlueprintError = errorHandler.handleBlueprintError.bind(errorHandler);\n","source":"/workspace/modules/static/js/modules/core/errorHandler.js","title":"errorHandler.js","language":"en"},{"content":"/**\n * NeuroGen Server - Event Manager Module\n * \n * Provides DOM event management functionality for the NeuroGen Server frontend.\n * Handles event delegation, registration, and common UI interactions.\n */\n\n/**\n * Event Manager module\n */\nconst eventManager = {\n  // Track registered event handlers\n  _handlers: {},\n  \n  // Track delegated events\n  _delegatedEvents: {},\n  \n  // Common element selectors\n  _selectors: {\n    buttons: 'button, .btn, [role=\"button\"]',\n    links: 'a, [role=\"link\"]',\n    forms: 'form',\n    inputs: 'input, textarea, select',\n    dropdowns: '.dropdown',\n    tooltips: '[data-tooltip]',\n    tabs: '.tab, [role=\"tab\"]',\n    modals: '.modal',\n    collapses: '.collapse, [data-collapse]'\n  },\n  \n  // Track initialization\n  initialized: false,\n  \n  /**\n   * Initialize the event manager\n   * @param {Object} options - Initialization options\n   * @returns {boolean} - Whether initialization was successful\n   */\n  initialize(options = {}) {\n    if (this.initialized) {\n      console.warn('Event manager already initialized');\n      return false;\n    }\n    \n    // Override selectors if provided\n    if (options.selectors) {\n      this._selectors = {...this._selectors, ...options.selectors};\n    }\n    \n    // Set up standard event handlers\n    if (options.setupCommonEvents || options.setupCommonEvents === undefined) {\n      this.setupDelegatedEvents();\n    }\n    \n    // Make available globally for debugging if in debug mode\n    if (window.debugMode) {\n      window.eventManager = this;\n    }\n    \n    this.initialized = true;\n    console.log('Event manager initialized');\n    \n    return true;\n  },\n  \n  /**\n   * Register events for multiple elements\n   * @param {Object} events - Map of selectors to event configurations\n   * @returns {boolean} - Whether events were registered successfully\n   */\n  registerEvents(events) {\n    if (!events || typeof events !== 'object') {\n      console.error('Events must be an object mapping selectors to event configs');\n      return false;\n    }\n    \n    // Process each selector\n    Object.entries(events).forEach(([selector, eventConfig]) => {\n      const elements = document.querySelectorAll(selector);\n      \n      if (elements.length === 0) {\n        console.warn(`No elements found for selector: ${selector}`);\n        return;\n      }\n      \n      // Process each element\n      elements.forEach(element => {\n        // Process each event for this element\n        if (typeof eventConfig === 'object') {\n          Object.entries(eventConfig).forEach(([eventType, handler]) => {\n            this._registerSingleEvent(element, eventType, handler);\n          });\n        }\n      });\n    });\n    \n    return true;\n  },\n  \n  /**\n   * Register a single event handler\n   * @private\n   * @param {HTMLElement} element - Element to attach event to\n   * @param {string} eventType - Event type (e.g., 'click')\n   * @param {Function|Object} handler - Event handler or configuration\n   */\n  _registerSingleEvent(element, eventType, handler) {\n    // Handle direct function handler\n    if (typeof handler === 'function') {\n      element.addEventListener(eventType, handler);\n      \n      // Track the handler for potential cleanup\n      this._trackHandler(element, eventType, handler);\n      return;\n    }\n    \n    // Handle configuration object\n    if (typeof handler === 'object') {\n      const handlerFn = handler.handler;\n      const options = handler.options || {};\n      \n      if (typeof handlerFn === 'function') {\n        element.addEventListener(eventType, handlerFn, options);\n        \n        // Track the handler for potential cleanup\n        this._trackHandler(element, eventType, handlerFn);\n      }\n    }\n  },\n  \n  /**\n   * Track a registered event handler\n   * @private\n   * @param {HTMLElement} element - Element with event\n   * @param {string} eventType - Event type\n   * @param {Function} handler - Event handler\n   */\n  _trackHandler(element, eventType, handler) {\n    // Create unique ID for the element if it doesn't have one\n    if (!element._eventManagerId) {\n      element._eventManagerId = `elem_${Math.random().toString(36).substr(2, 9)}`;\n    }\n    \n    const id = element._eventManagerId;\n    \n    // Initialize tracking for this element\n    if (!this._handlers[id]) {\n      this._handlers[id] = {};\n    }\n    \n    // Initialize tracking for this event type\n    if (!this._handlers[id][eventType]) {\n      this._handlers[id][eventType] = [];\n    }\n    \n    // Add handler to tracking\n    this._handlers[id][eventType].push(handler);\n  },\n  \n  /**\n   * Remove event handlers for an element\n   * @param {HTMLElement} element - Element to remove events from\n   * @param {string} eventType - Optional specific event type to remove\n   * @returns {boolean} - Whether events were removed\n   */\n  removeEvents(element, eventType = null) {\n    if (!element || !element._eventManagerId) {\n      return false;\n    }\n    \n    const id = element._eventManagerId;\n    \n    // If no handlers tracked for this element, nothing to do\n    if (!this._handlers[id]) {\n      return false;\n    }\n    \n    // If specific event type provided, only remove those handlers\n    if (eventType) {\n      if (!this._handlers[id][eventType]) {\n        return false;\n      }\n      \n      // Remove each handler\n      this._handlers[id][eventType].forEach(handler => {\n        element.removeEventListener(eventType, handler);\n      });\n      \n      // Clear tracking for this event type\n      delete this._handlers[id][eventType];\n      \n      return true;\n    }\n    \n    // Remove all handlers for all event types\n    Object.entries(this._handlers[id]).forEach(([type, handlers]) => {\n      handlers.forEach(handler => {\n        element.removeEventListener(type, handler);\n      });\n    });\n    \n    // Clear all tracking for this element\n    delete this._handlers[id];\n    \n    return true;\n  },\n  \n  /**\n   * Set up delegated events for common UI elements\n   * @param {HTMLElement} root - Root element to attach delegated events to\n   * @returns {boolean} - Whether events were set up successfully\n   */\n  setupDelegatedEvents(root = document) {\n    if (!root) {\n      console.error('Root element is required for delegation');\n      return false;\n    }\n    \n    // Remove any existing delegated events on this root\n    this.removeDelegatedEvents(root);\n    \n    // Set up click delegation for common elements\n    root.addEventListener('click', this._handleDelegatedClick.bind(this));\n    \n    // Set up form submission delegation\n    root.addEventListener('submit', this._handleDelegatedSubmit.bind(this));\n    \n    // Set up change event delegation for inputs\n    root.addEventListener('change', this._handleDelegatedChange.bind(this));\n    \n    // Set up keydown events for keyboard navigation\n    root.addEventListener('keydown', this._handleDelegatedKeydown.bind(this));\n    \n    // Track delegated events for this root\n    const rootId = root === document ? 'document' : `root_${Math.random().toString(36).substr(2, 9)}`;\n    \n    this._delegatedEvents[rootId] = {\n      root,\n      events: ['click', 'submit', 'change', 'keydown']\n    };\n    \n    return true;\n  },\n  \n  /**\n   * Remove delegated events from a root element\n   * @param {HTMLElement} root - Root element to remove events from\n   * @returns {boolean} - Whether events were removed\n   */\n  removeDelegatedEvents(root = document) {\n    // Find this root in tracked delegated events\n    const rootId = Object.keys(this._delegatedEvents).find(id => {\n      return this._delegatedEvents[id].root === root;\n    });\n    \n    if (!rootId) {\n      return false;\n    }\n    \n    // Get events for this root\n    const { events } = this._delegatedEvents[rootId];\n    \n    // Remove each event listener\n    events.forEach(eventType => {\n      switch (eventType) {\n        case 'click':\n          root.removeEventListener('click', this._handleDelegatedClick);\n          break;\n        case 'submit':\n          root.removeEventListener('submit', this._handleDelegatedSubmit);\n          break;\n        case 'change':\n          root.removeEventListener('change', this._handleDelegatedChange);\n          break;\n        case 'keydown':\n          root.removeEventListener('keydown', this._handleDelegatedKeydown);\n          break;\n      }\n    });\n    \n    // Remove tracking for this root\n    delete this._delegatedEvents[rootId];\n    \n    return true;\n  },\n  \n  /**\n   * Handle delegated click events\n   * @private\n   * @param {Event} event - Click event\n   */\n  _handleDelegatedClick(event) {\n    const target = event.target;\n    \n    // Handle buttons\n    if (target.closest(this._selectors.buttons)) {\n      const button = target.closest(this._selectors.buttons);\n      \n      // Handle data-action buttons\n      if (button.hasAttribute('data-action')) {\n        const action = button.getAttribute('data-action');\n        this._handleButtonAction(action, button, event);\n      }\n    }\n    \n    // Handle links\n    if (target.closest(this._selectors.links)) {\n      const link = target.closest(this._selectors.links);\n      \n      // Handle data-action links\n      if (link.hasAttribute('data-action')) {\n        const action = link.getAttribute('data-action');\n        this._handleLinkAction(action, link, event);\n      }\n    }\n    \n    // Handle tab activation\n    if (target.closest(this._selectors.tabs)) {\n      const tab = target.closest(this._selectors.tabs);\n      this._handleTabClick(tab, event);\n    }\n    \n    // Handle dropdowns\n    if (target.closest(this._selectors.dropdowns)) {\n      const dropdown = target.closest(this._selectors.dropdowns);\n      this._handleDropdownClick(dropdown, event);\n    }\n    \n    // Handle modals\n    if (target.closest(this._selectors.modals)) {\n      const modal = target.closest(this._selectors.modals);\n      \n      // Close button inside modal\n      if (target.closest('.modal-close')) {\n        this._handleModalClose(modal, event);\n      }\n    }\n    \n    // Handle collapses\n    if (target.closest(this._selectors.collapses)) {\n      const collapse = target.closest(this._selectors.collapses);\n      this._handleCollapseClick(collapse, event);\n    }\n    \n    // Emit event if eventRegistry is available\n    this._emitEvent('delegated:click', {\n      originalEvent: event,\n      target\n    });\n  },\n  \n  /**\n   * Handle delegated form submission\n   * @private\n   * @param {Event} event - Submit event\n   */\n  _handleDelegatedSubmit(event) {\n    const form = event.target;\n    \n    // Handle data-action forms\n    if (form.hasAttribute('data-action')) {\n      const action = form.getAttribute('data-action');\n      this._handleFormSubmit(action, form, event);\n    }\n    \n    // Emit event if eventRegistry is available\n    this._emitEvent('delegated:submit', {\n      originalEvent: event,\n      form\n    });\n  },\n  \n  /**\n   * Handle delegated change events\n   * @private\n   * @param {Event} event - Change event\n   */\n  _handleDelegatedChange(event) {\n    const target = event.target;\n    \n    // Handle input changes\n    if (target.matches(this._selectors.inputs)) {\n      // Handle data-action inputs\n      if (target.hasAttribute('data-action')) {\n        const action = target.getAttribute('data-action');\n        this._handleInputChange(action, target, event);\n      }\n    }\n    \n    // Emit event if eventRegistry is available\n    this._emitEvent('delegated:change', {\n      originalEvent: event,\n      target\n    });\n  },\n  \n  /**\n   * Handle delegated keydown events\n   * @private\n   * @param {Event} event - Keydown event\n   */\n  _handleDelegatedKeydown(event) {\n    const target = event.target;\n    \n    // Handle Escape key for modals\n    if (event.key === 'Escape' || event.keyCode === 27) {\n      const modal = document.querySelector('.modal[style*=\"display: block\"]');\n      if (modal) {\n        this._handleModalClose(modal, event);\n      }\n    }\n    \n    // Emit event if eventRegistry is available\n    this._emitEvent('delegated:keydown', {\n      originalEvent: event,\n      target,\n      key: event.key\n    });\n  },\n  \n  /**\n   * Handle button actions\n   * @private\n   * @param {string} action - Action name\n   * @param {HTMLElement} button - Button element\n   * @param {Event} event - Original event\n   */\n  _handleButtonAction(action, button, event) {\n    // Prevent default for buttons with actions\n    event.preventDefault();\n    \n    // Emit event for this action\n    this._emitEvent(`button:${action}`, {\n      button,\n      action,\n      originalEvent: event\n    });\n    \n    // Handle known actions\n    switch (action) {\n      case 'show-modal':\n        const modalId = button.getAttribute('data-target');\n        this._showModal(modalId);\n        break;\n        \n      case 'hide-modal':\n        const modal = button.closest('.modal');\n        this._handleModalClose(modal, event);\n        break;\n        \n      case 'toggle-collapse':\n        const collapseId = button.getAttribute('data-target');\n        this._toggleCollapse(collapseId);\n        break;\n        \n      case 'toggle-theme':\n        this._toggleTheme();\n        break;\n    }\n  },\n  \n  /**\n   * Handle link actions\n   * @private\n   * @param {string} action - Action name\n   * @param {HTMLElement} link - Link element\n   * @param {Event} event - Original event\n   */\n  _handleLinkAction(action, link, event) {\n    // Prevent default for links with actions\n    event.preventDefault();\n    \n    // Emit event for this action\n    this._emitEvent(`link:${action}`, {\n      link,\n      action,\n      originalEvent: event\n    });\n    \n    // Handle known actions\n    switch (action) {\n      case 'show-modal':\n        const modalId = link.getAttribute('data-target');\n        this._showModal(modalId);\n        break;\n        \n      case 'toggle-collapse':\n        const collapseId = link.getAttribute('data-target');\n        this._toggleCollapse(collapseId);\n        break;\n    }\n  },\n  \n  /**\n   * Handle form submission\n   * @private\n   * @param {string} action - Action name\n   * @param {HTMLElement} form - Form element\n   * @param {Event} event - Original event\n   */\n  _handleFormSubmit(action, form, event) {\n    // Prevent default form submission\n    event.preventDefault();\n    \n    // Emit event for this action\n    this._emitEvent(`form:${action}`, {\n      form,\n      action,\n      originalEvent: event,\n      formData: new FormData(form)\n    });\n  },\n  \n  /**\n   * Handle input changes\n   * @private\n   * @param {string} action - Action name\n   * @param {HTMLElement} input - Input element\n   * @param {Event} event - Original event\n   */\n  _handleInputChange(action, input, event) {\n    // Emit event for this action\n    this._emitEvent(`input:${action}`, {\n      input,\n      action,\n      originalEvent: event,\n      value: input.value\n    });\n  },\n  \n/**\n   * Handle tab click\n   * @private\n   * @param {HTMLElement} tab - Tab element\n   * @param {Event} event - Original event\n   */\n_handleTabClick(tab, event) {\n  event.preventDefault();\n  \n  // Get tab container\n  const tabContainer = tab.closest('.tabs');\n  if (!tabContainer) return;\n  \n  // Get all tabs in this container\n  const tabs = tabContainer.querySelectorAll(this._selectors.tabs);\n  \n  // Deactivate all tabs\n  tabs.forEach(t => {\n    t.classList.remove('active');\n    \n    // Hide associated content\n    const targetId = t.getAttribute('data-target');\n    if (targetId) {\n      const target = document.getElementById(targetId);\n      if (target) {\n        target.classList.remove('active');\n        target.style.display = 'none';\n      }\n    }\n  });\n  \n  // Activate clicked tab\n  tab.classList.add('active');\n  \n  // Show associated content\n  const targetId = tab.getAttribute('data-target');\n  if (targetId) {\n    const target = document.getElementById(targetId);\n    if (target) {\n      target.classList.add('active');\n      target.style.display = 'block';\n    }\n  }\n  \n  // Emit event\n  this._emitEvent('tab:change', {\n    tab,\n    targetId,\n    originalEvent: event\n  });\n},\n\n/**\n * Handle dropdown click\n * @private\n * @param {HTMLElement} dropdown - Dropdown element\n * @param {Event} event - Original event\n */\n_handleDropdownClick(dropdown, event) {\n  // Find dropdown toggle (the part that was clicked)\n  const toggle = dropdown.querySelector('.dropdown-toggle');\n  \n  // Only handle if toggle was clicked\n  if (!event.target.closest('.dropdown-toggle')) {\n    return;\n  }\n  \n  event.preventDefault();\n  \n  // Get dropdown menu\n  const menu = dropdown.querySelector('.dropdown-menu');\n  if (!menu) return;\n  \n  // Toggle dropdown menu\n  const isOpen = menu.classList.contains('show');\n  \n  if (isOpen) {\n    menu.classList.remove('show');\n    toggle.classList.remove('active');\n    menu.style.display = 'none';\n  } else {\n    menu.classList.add('show');\n    toggle.classList.add('active');\n    menu.style.display = 'block';\n    \n    // Position the menu\n    this._positionDropdownMenu(menu, toggle);\n  }\n  \n  // Emit event\n  this._emitEvent('dropdown:toggle', {\n    dropdown,\n    isOpen: !isOpen,\n    originalEvent: event\n  });\n  \n  // Add document click handler to close dropdown when clicking outside\n  if (!isOpen) {\n    document.addEventListener('click', this._createOutsideClickHandler(dropdown, menu), { once: true });\n  }\n},\n\n/**\n * Create a one-time handler to close dropdown when clicking outside\n * @private\n * @param {HTMLElement} dropdown - Dropdown element\n * @param {HTMLElement} menu - Dropdown menu element\n * @returns {Function} - Click handler\n */\n_createOutsideClickHandler(dropdown, menu) {\n  return function(e) {\n    if (!dropdown.contains(e.target)) {\n      menu.classList.remove('show');\n      menu.style.display = 'none';\n      \n      const toggle = dropdown.querySelector('.dropdown-toggle');\n      if (toggle) {\n        toggle.classList.remove('active');\n      }\n    }\n  };\n},\n\n/**\n * Position dropdown menu relative to its toggle\n * @private\n * @param {HTMLElement} menu - Dropdown menu element\n * @param {HTMLElement} toggle - Dropdown toggle element\n */\n_positionDropdownMenu(menu, toggle) {\n  const toggleRect = toggle.getBoundingClientRect();\n  const menuRect = menu.getBoundingClientRect();\n  \n  // Check if menu would go off bottom of screen\n  const bottomSpace = window.innerHeight - toggleRect.bottom;\n  const menuHeight = menuRect.height;\n  \n  if (bottomSpace < menuHeight && toggleRect.top > menuHeight) {\n    // Position above toggle\n    menu.style.top = `-${menuHeight}px`;\n  } else {\n    // Position below toggle\n    menu.style.top = `${toggleRect.height}px`;\n  }\n},\n\n/**\n * Handle modal close\n * @private\n * @param {HTMLElement} modal - Modal element\n * @param {Event} event - Original event\n */\n_handleModalClose(modal, event) {\n  if (!modal) return;\n  \n  event.preventDefault();\n  \n  // Hide modal\n  modal.style.display = 'none';\n  \n  // Find and remove backdrop\n  const backdrop = document.querySelector('.modal-backdrop');\n  if (backdrop) {\n    backdrop.parentNode.removeChild(backdrop);\n  }\n  \n  // Emit event\n  this._emitEvent('modal:close', {\n    modal,\n    originalEvent: event\n  });\n},\n\n/**\n * Show a modal\n * @private\n * @param {string} modalId - Modal element ID\n */\n_showModal(modalId) {\n  const modal = document.getElementById(modalId);\n  if (!modal) {\n    console.warn(`Modal not found: ${modalId}`);\n    return;\n  }\n  \n  // Add backdrop if not present\n  if (!document.querySelector('.modal-backdrop')) {\n    const backdrop = document.createElement('div');\n    backdrop.className = 'modal-backdrop';\n    backdrop.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:1040;';\n    document.body.appendChild(backdrop);\n    \n    // Click backdrop to close modal\n    backdrop.addEventListener('click', (e) => {\n      if (e.target === backdrop) {\n        this._handleModalClose(modal, e);\n      }\n    });\n  }\n  \n  // Show modal\n  modal.style.display = 'block';\n  \n  // Emit event\n  this._emitEvent('modal:open', { modal });\n},\n\n/**\n * Handle collapse click\n * @private\n * @param {HTMLElement} collapse - Collapse element\n * @param {Event} event - Original event\n */\n_handleCollapseClick(collapse, event) {\n  // Only handle if toggle was clicked\n  if (!event.target.closest('[data-collapse-toggle]')) {\n    return;\n  }\n  \n  event.preventDefault();\n  \n  // Get content element\n  const content = collapse.querySelector('.collapse-content');\n  if (!content) return;\n  \n  // Toggle collapse\n  const isOpen = content.classList.contains('show');\n  \n  this._toggleCollapse(content, !isOpen);\n  \n  // Emit event\n  this._emitEvent('collapse:toggle', {\n    collapse,\n    isOpen: !isOpen,\n    originalEvent: event\n  });\n},\n\n/**\n * Toggle collapse\n * @private\n * @param {string|HTMLElement} target - Target ID or element\n * @param {boolean} show - Whether to show or hide\n */\n_toggleCollapse(target, show = null) {\n  // Get target element\n  const content = typeof target === 'string' \n    ? document.getElementById(target)\n    : target;\n    \n  if (!content) {\n    console.warn(`Collapse target not found: ${target}`);\n    return;\n  }\n  \n  // Determine whether to show or hide\n  const isCurrentlyOpen = content.classList.contains('show');\n  const shouldShow = show !== null ? show : !isCurrentlyOpen;\n  \n  if (shouldShow) {\n    content.classList.add('show');\n    content.style.height = `${content.scrollHeight}px`;\n    \n    // After transition completes, set height to auto\n    setTimeout(() => {\n      if (content.classList.contains('show')) {\n        content.style.height = 'auto';\n      }\n    }, 350); // Match transition duration\n  } else {\n    // Set fixed height before collapsing\n    content.style.height = `${content.scrollHeight}px`;\n    \n    // Force a repaint\n    content.offsetHeight;\n    \n    // Start collapse\n    content.classList.remove('show');\n    content.style.height = '0';\n  }\n},\n\n/**\n * Toggle theme\n * @private\n */\n_toggleTheme() {\n  // Use themeManager if available\n  if (window.themeManager && typeof window.themeManager.toggleTheme === 'function') {\n    window.themeManager.toggleTheme();\n  } else {\n    // Fallback theme toggle\n    const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';\n    const newTheme = currentTheme === 'light' ? 'dark' : 'light';\n    \n    document.documentElement.setAttribute('data-theme', newTheme);\n    document.body.className = document.body.className.replace(/theme-[^\\s]+/g, '');\n    document.body.classList.add(`theme-${newTheme}`);\n    \n    // Emit event\n    this._emitEvent('theme:change', { theme: newTheme });\n  }\n},\n\n/**\n * Emit an event through eventRegistry\n * @private\n * @param {string} eventName - Event name\n * @param {Object} data - Event data\n */\n_emitEvent(eventName, data = {}) {\n  try {\n    if (window.eventRegistry && typeof window.eventRegistry.emit === 'function') {\n      window.eventRegistry.emit(eventName, data);\n    }\n  } catch (e) {\n    // Ignore errors with event registry\n  }\n}\n};\n\n// Export both default and named exports\nexport default eventManager;\nexport const registerEvents = eventManager.registerEvents.bind(eventManager);\nexport const removeEvents = eventManager.removeEvents.bind(eventManager);\nexport const setupDelegatedEvents = eventManager.setupDelegatedEvents.bind(eventManager);\nexport const removeDelegatedEvents = eventManager.removeDelegatedEvents.bind(eventManager);\nexport const initialize = eventManager.initialize.bind(eventManager);","source":"/workspace/modules/static/js/modules/core/eventManager.js","title":"eventManager.js","language":"en"},{"content":"/**\n * NeuroGen Server - Event Registry Module\n * \n * Provides a centralized event management system for publishing and subscribing to events\n * throughout the application. This module enables decoupled communication between\n * different parts of the application.\n * \n * Enhanced with:\n * - Better error handling and recovery\n * - Improved debug logging\n * - DOM-ready safety\n * - Event priority management\n * - Async/sync handling options\n * - Memory leak prevention\n * - Statistics tracking\n * - Circular reference protection\n * - Support for registerEvents with no arguments or non-array arguments\n */\n\n/**\n * Event Registry with pub/sub capabilities\n */\nconst eventRegistry = {\n  // Private event storage\n  _events: {},\n  \n  // Track module initialization\n  initialized: false,\n  \n  // Track DOM-ready state\n  _domReady: false,\n  \n  // Store events triggered before DOM ready\n  _pendingEvents: [],\n  \n  // Statistics tracking\n  _stats: {\n    totalEvents: 0,\n    emits: 0,\n    handlers: 0,\n    errors: 0\n  },\n  \n  // Default events to register\n  _defaultEvents: [\n    // System events\n    'system.ready',\n    'system.error',\n    'system.warning',\n    'system.info',\n    \n    // UI events\n    'ui.ready',\n    'ui.modal.open',\n    'ui.modal.close',\n    'ui.toast.show',\n    'ui.theme.change',\n    \n    // Application events\n    'app.initialized',\n    'app.start',\n    'app.shutdown',\n    'app.error',\n    \n    // Data events\n    'data.ready',\n    'data.changed',\n    'data.saved',\n    'data.error',\n    \n    // Session events\n    'session.login',\n    'session.logout',\n    'session.expired',\n    \n    // Socket events\n    'socket.connected',\n    'socket.disconnected',\n    'socket.error',\n    'socket.message',\n    \n    // Task events\n    'task.start',\n    'task.progress',\n    'task.complete',\n    'task.error',\n    'task.cancel'\n  ],\n  \n  /**\n   * Initialize the event registry\n   * @param {Object} options - Initialization options\n   * @returns {boolean} - Whether initialization was successful\n   */\n  initialize(options = {}) {\n    // Avoid duplicate initialization\n    if (this.initialized) {\n      console.warn('Event Registry already initialized');\n      return false;\n    }\n    \n    // Set up DOM ready handler\n    if (document.readyState === 'loading') {\n      document.addEventListener('DOMContentLoaded', () => {\n        this._domReady = true;\n        this._processPendingEvents();\n      });\n      \n      // Fallback if DOMContentLoaded already fired\n      window.addEventListener('load', () => {\n        this._domReady = true;\n        this._processPendingEvents();\n      });\n    } else {\n      // DOM already loaded\n      this._domReady = true;\n    }\n    \n    // Set up options\n    this.options = {\n      debug: window.debugMode || false,\n      defaultMaxListeners: 10,\n      warnOnMemoryLeak: true,\n      preventCircularReferences: true,\n      autoRegisterDefaultEvents: true,\n      ...options\n    };\n    \n    // Initialize events map\n    this._events = {};\n    \n    // Make available globally for debugging if in debug mode\n    if (window.debugMode) {\n      window.eventRegistry = this;\n    }\n    \n    // Auto-register default events if enabled\n    if (this.options.autoRegisterDefaultEvents) {\n      this.registerEvents(this._defaultEvents);\n    }\n    \n    this.initialized = true;\n    console.log('Event Registry initialized');\n    \n    return true;\n  },\n  \n  /**\n   * Process events that were triggered before DOM was ready\n   * @private\n   */\n  _processPendingEvents() {\n    if (this._pendingEvents.length > 0) {\n      if (this.options.debug) {\n        console.log(`Processing ${this._pendingEvents.length} pending events that were triggered before DOM ready`);\n      }\n      \n      // Process each pending event\n      this._pendingEvents.forEach(pendingEvent => {\n        this.emit(pendingEvent.eventName, pendingEvent.data);\n      });\n      \n      // Clear the pending events\n      this._pendingEvents = [];\n    }\n  },\n  \n  /**\n   * Register a new event type\n   * @param {string} eventName - Name of the event to register\n   * @param {Object} options - Options for this event type\n   * @returns {boolean} - Whether registration was successful\n   */\n  registerEvent(eventName, options = {}) {\n    if (!eventName) {\n      console.error('Event name is required');\n      return false;\n    }\n    \n    // Don't overwrite existing events unless forced\n    if (this._events[eventName] && !options.force) {\n      if (this.options.debug) {\n        console.warn(`Event '${eventName}' already registered. Use force: true to overwrite.`);\n      }\n      return false;\n    }\n    \n    // Create event with options and empty handler list\n    this._events[eventName] = {\n      handlers: [],\n      options: {\n        // Default options\n        async: false,\n        maxListeners: this.options?.defaultMaxListeners || 10,\n        logEmits: false,\n        // Override with provided options\n        ...options\n      }\n    };\n    \n    // Increment statistics\n    this._stats.totalEvents++;\n    \n    if (this.options.debug) {\n      console.log(`Event '${eventName}' registered successfully`);\n    }\n    \n    return true;\n  },\n  \n  /**\n   * Register multiple events at once\n   * @param {Array<Object>|Object|undefined} events - Array of event configurations or object with event names as keys\n   * @returns {boolean} - Whether all registrations were successful\n   */\n  registerEvents(events) {\n    // If no events provided, register default events\n    if (events === undefined || events === null) {\n      if (this.options.debug) {\n        console.log('No events provided, registering default events');\n      }\n      return this.registerEvents(this._defaultEvents);\n    }\n    \n    // Handle various input types\n    let eventArray = [];\n    \n    if (Array.isArray(events)) {\n      eventArray = events;\n    } else if (typeof events === 'object') {\n      // Convert object to array of objects\n      eventArray = Object.entries(events).map(([name, options]) => ({\n        name,\n        options: options || {}\n      }));\n    } else if (typeof events === 'string') {\n      // Single event name as string\n      eventArray = [events];\n    } else {\n      console.error('Events must be an array, object, or string');\n      return false;\n    }\n    \n    if (eventArray.length === 0) {\n      if (this.options.debug) {\n        console.log('No events to register, using default events');\n      }\n      return this.registerEvents(this._defaultEvents);\n    }\n    \n    const results = eventArray.map(event => {\n      if (typeof event === 'string') {\n        return this.registerEvent(event);\n      } else if (typeof event === 'object' && event.name) {\n        return this.registerEvent(event.name, event.options || {});\n      }\n      \n      console.warn('Invalid event format:', event);\n      return false;\n    });\n    \n    // Count successful registrations\n    const successCount = results.filter(result => result === true).length;\n    \n    if (this.options.debug) {\n      console.log(`Successfully registered ${successCount} of ${eventArray.length} events`);\n    }\n    \n    // Return true only if all registrations succeeded\n    return results.every(result => result === true);\n  },\n  \n  /**\n   * Subscribe to an event\n   * @param {string} eventName - Event to subscribe to\n   * @param {Function} handler - Callback for the event\n   * @param {Object} options - Handler-specific options\n   * @returns {Function} - Unsubscribe function\n   */\n  on(eventName, handler, options = {}) {\n    try {\n      // Validate inputs\n      if (!eventName || typeof eventName !== 'string') {\n        console.error('Event name must be a string');\n        return () => false;\n      }\n      \n      if (!handler || typeof handler !== 'function') {\n        console.error('Event handler must be a function');\n        return () => false;\n      }\n      \n      // Create event if it doesn't exist yet\n      if (!this._events[eventName]) {\n        this.registerEvent(eventName);\n      }\n      \n      const event = this._events[eventName];\n      \n      // Check max listeners\n      if (event.handlers.length >= event.options.maxListeners) {\n        if (this.options.warnOnMemoryLeak) {\n          console.warn(`Event '${eventName}' has reached maximum listeners (${event.options.maxListeners}). This may indicate a memory leak.`);\n        }\n      }\n      \n      // Create handler with options\n      const handlerObj = {\n        callback: handler,\n        options: {\n          once: false,\n          priority: 0,\n          context: null, // execution context for the handler\n          ...options\n        },\n        id: this._generateHandlerId(),\n        added: Date.now()\n      };\n      \n      // Add handler to list\n      event.handlers.push(handlerObj);\n      \n      // Sort handlers by priority\n      this._sortHandlers(eventName);\n      \n      // Update statistics\n      this._stats.handlers++;\n      \n      if (this.options.debug) {\n        console.log(`Event handler added for '${eventName}', total handlers: ${event.handlers.length}`);\n      }\n      \n      // Return unsubscribe function\n      return () => this.off(eventName, handler);\n    } catch (error) {\n      console.error(`Error in eventRegistry.on('${eventName}'):`, error);\n      this._stats.errors++;\n      return () => false;\n    }\n  },\n  \n  /**\n   * Subscribe to an event once\n   * @param {string} eventName - Event to subscribe to\n   * @param {Function} handler - Callback for the event\n   * @param {Object} options - Handler-specific options\n   * @returns {Function} - Unsubscribe function\n   */\n  once(eventName, handler, options = {}) {\n    return this.on(eventName, handler, { ...options, once: true });\n  },\n  \n  /**\n   * Unsubscribe from an event\n   * @param {string} eventName - Event to unsubscribe from\n   * @param {Function} handler - Handler to remove\n   * @returns {boolean} - Whether unsubscription was successful\n   */\n  off(eventName, handler) {\n    try {\n      // If the event doesn't exist, nothing to do\n      if (!this._events[eventName]) {\n        return false;\n      }\n      \n      const event = this._events[eventName];\n      const initialLength = event.handlers.length;\n      \n      // Filter out the specified handler\n      event.handlers = event.handlers.filter(h => h.callback !== handler);\n      \n      // Update statistics\n      this._stats.handlers -= (initialLength - event.handlers.length);\n      \n      if (this.options.debug && initialLength !== event.handlers.length) {\n        console.log(`Event handler removed for '${eventName}', remaining: ${event.handlers.length}`);\n      }\n      \n      // Return true if at least one handler was removed\n      return event.handlers.length < initialLength;\n    } catch (error) {\n      console.error(`Error in eventRegistry.off('${eventName}'):`, error);\n      this._stats.errors++;\n      return false;\n    }\n  },\n  \n  /**\n   * Unsubscribe from an event by ID\n   * @param {string} eventName - Event to unsubscribe from\n   * @param {string} handlerId - ID of the handler to remove\n   * @returns {boolean} - Whether unsubscription was successful\n   */\n  offById(eventName, handlerId) {\n    try {\n      // If the event doesn't exist, nothing to do\n      if (!this._events[eventName]) {\n        return false;\n      }\n      \n      const event = this._events[eventName];\n      const initialLength = event.handlers.length;\n      \n      // Filter out the specified handler by ID\n      event.handlers = event.handlers.filter(h => h.id !== handlerId);\n      \n      // Update statistics\n      this._stats.handlers -= (initialLength - event.handlers.length);\n      \n      if (this.options.debug && initialLength !== event.handlers.length) {\n        console.log(`Event handler removed by ID for '${eventName}', remaining: ${event.handlers.length}`);\n      }\n      \n      // Return true if at least one handler was removed\n      return event.handlers.length < initialLength;\n    } catch (error) {\n      console.error(`Error in eventRegistry.offById('${eventName}', '${handlerId}'):`, error);\n      this._stats.errors++;\n      return false;\n    }\n  },\n  \n  /**\n   * Remove all handlers for an event\n   * @param {string} eventName - Event to clear\n   * @returns {boolean} - Whether clear was successful\n   */\n  clearEvent(eventName) {\n    try {\n      if (!this._events[eventName]) {\n        return false;\n      }\n      \n      // Update statistics\n      this._stats.handlers -= this._events[eventName].handlers.length;\n      \n      // Clear handlers\n      this._events[eventName].handlers = [];\n      \n      if (this.options.debug) {\n        console.log(`Cleared all handlers for event '${eventName}'`);\n      }\n      \n      return true;\n    } catch (error) {\n      console.error(`Error in eventRegistry.clearEvent('${eventName}'):`, error);\n      this._stats.errors++;\n      return false;\n    }\n  },\n  \n  /**\n   * Remove all handlers from all events\n   * @returns {boolean} - Whether clear was successful\n   */\n  clearAllEvents() {\n    try {\n      let totalHandlersRemoved = 0;\n      \n      Object.keys(this._events).forEach(eventName => {\n        totalHandlersRemoved += this._events[eventName].handlers.length;\n        this._events[eventName].handlers = [];\n      });\n      \n      // Update statistics\n      this._stats.handlers -= totalHandlersRemoved;\n      \n      if (this.options.debug) {\n        console.log(`Cleared all handlers for all events (${totalHandlersRemoved} total)`);\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('Error in eventRegistry.clearAllEvents():', error);\n      this._stats.errors++;\n      return false;\n    }\n  },\n  \n  /**\n   * Sort handlers for an event by priority\n   * @private\n   * @param {string} eventName - Event to sort handlers for\n   */\n  _sortHandlers(eventName) {\n    if (!this._events[eventName]) return;\n    \n    // Sort handlers by priority (higher number = higher priority)\n    this._events[eventName].handlers.sort((a, b) => {\n      return b.options.priority - a.options.priority;\n    });\n  },\n  \n  /**\n   * Generate a unique handler ID\n   * @private\n   * @returns {string} - Unique ID\n   */\n  _generateHandlerId() {\n    return `handler_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  },\n  \n  /**\n   * Emit an event\n   * @param {string} eventName - Event to emit\n   * @param {*} data - Data to pass to handlers\n   * @returns {boolean} - Whether emit was successful\n   */\n  emit(eventName, data = null) {\n    try {\n      // If DOM is not ready, queue the event for later\n      if (!this._domReady && typeof document !== 'undefined') {\n        // Don't queue internal events\n        if (!eventName.startsWith('__')) {\n          this._pendingEvents.push({ eventName, data });\n          \n          if (this.options.debug) {\n            console.log(`Event '${eventName}' queued for after DOM ready`);\n          }\n          \n          return true;\n        }\n      }\n      \n      // If the event doesn't exist, auto-create it\n      if (!this._events[eventName]) {\n        // Auto-create the event if it doesn't exist\n        this.registerEvent(eventName);\n      }\n      \n      const event = this._events[eventName];\n      \n      // Log event if configured\n      if (event.options.logEmits || this.options.debug) {\n        console.log(`Event emitted: ${eventName}`, data);\n      }\n      \n      // Create handler execution list (to handle removal during iteration)\n      const handlers = [...event.handlers];\n      \n      // Skip if no handlers\n      if (handlers.length === 0) {\n        return false;\n      }\n      \n      // Track once handlers to remove\n      const handlersToRemove = [];\n      \n      // Update statistics\n      this._stats.emits++;\n      \n      // Execute handlers based on async setting\n      if (event.options.async) {\n        // Async execution\n        Promise.all(handlers.map(async (handler) => {\n          try {\n            // Apply context if provided\n            if (handler.options.context) {\n              await handler.callback.call(handler.options.context, data);\n            } else {\n              await handler.callback(data);\n            }\n            \n            // Track once handlers\n            if (handler.options.once) {\n              handlersToRemove.push(handler.callback);\n            }\n          } catch (error) {\n            this._stats.errors++;\n            console.error(`Error in async handler for event '${eventName}':`, error);\n            // Emit error event\n            if (eventName !== 'error') {\n              this.emit('error', { \n                source: 'eventHandler',\n                originalEvent: eventName,\n                error,\n                data\n              });\n            }\n          }\n        }));\n      } else {\n        // Synchronous execution\n        for (const handler of handlers) {\n          try {\n            // Apply context if provided\n            if (handler.options.context) {\n              handler.callback.call(handler.options.context, data);\n            } else {\n              handler.callback(data);\n            }\n            \n            // Track once handlers\n            if (handler.options.once) {\n              handlersToRemove.push(handler.callback);\n            }\n          } catch (error) {\n            this._stats.errors++;\n            console.error(`Error in handler for event '${eventName}':`, error);\n            // Emit error event\n            if (eventName !== 'error') {\n              this.emit('error', { \n                source: 'eventHandler',\n                originalEvent: eventName,\n                error,\n                data\n              });\n            }\n          }\n        }\n      }\n      \n      // Remove once handlers\n      handlersToRemove.forEach(handler => {\n        this.off(eventName, handler);\n      });\n      \n      return true;\n    } catch (error) {\n      this._stats.errors++;\n      console.error(`Error in eventRegistry.emit('${eventName}'):`, error);\n      return false;\n    }\n  },\n  \n  /**\n   * Emit an event and collect handler results\n   * @param {string} eventName - Event to emit\n   * @param {*} data - Data to pass to handlers\n   * @returns {Promise<Array>} - Results from all handlers\n   */\n  async emitWithResults(eventName, data = null) {\n    try {\n      // If the event doesn't exist, auto-create it\n      if (!this._events[eventName]) {\n        this.registerEvent(eventName);\n        // Return empty array if no handlers\n        return [];\n      }\n      \n      const event = this._events[eventName];\n      const handlers = [...event.handlers];\n      \n      // Skip if no handlers\n      if (handlers.length === 0) {\n        return [];\n      }\n      \n      // Log event if configured\n      if (event.options.logEmits || this.options.debug) {\n        console.log(`Event emitted with results: ${eventName}`, data);\n      }\n      \n      // Update statistics\n      this._stats.emits++;\n      \n      // Track once handlers to remove\n      const handlersToRemove = [];\n      \n      // Execute handlers and collect results\n      const results = await Promise.all(\n        handlers.map(async (handler) => {\n          try {\n            let result;\n            \n            // Apply context if provided\n            if (handler.options.context) {\n              result = await Promise.resolve(handler.callback.call(handler.options.context, data));\n            } else {\n              result = await Promise.resolve(handler.callback(data));\n            }\n            \n            // Track once handlers\n            if (handler.options.once) {\n              handlersToRemove.push(handler.callback);\n            }\n            \n            return { success: true, result };\n          } catch (error) {\n            this._stats.errors++;\n            console.error(`Error in handler for event '${eventName}':`, error);\n            \n            return { success: false, error };\n          }\n        })\n      );\n      \n      // Remove once handlers\n      handlersToRemove.forEach(handler => {\n        this.off(eventName, handler);\n      });\n      \n      return results;\n    } catch (error) {\n      this._stats.errors++;\n      console.error(`Error in eventRegistry.emitWithResults('${eventName}'):`, error);\n      return [{ success: false, error }];\n    }\n  },\n  \n  /**\n   * Get a list of all registered events\n   * @returns {Array<string>} - List of event names\n   */\n  getEvents() {\n    return Object.keys(this._events);\n  },\n  \n  /**\n   * Get the details of a specific event\n   * @param {string} eventName - Event to get information for\n   * @returns {Object|null} - Event information\n   */\n  getEventInfo(eventName) {\n    if (!this._events[eventName]) {\n      return null;\n    }\n    \n    const event = this._events[eventName];\n    \n    return {\n      name: eventName,\n      handlerCount: event.handlers.length,\n      options: { ...event.options },\n      handlers: event.handlers.map(h => ({\n        id: h.id,\n        priority: h.options.priority,\n        once: h.options.once,\n        added: h.added\n      }))\n    };\n  },\n  \n  /**\n   * Get information about all events\n   * @returns {Object} - Event information for all events\n   */\n  getAllEventInfo() {\n    const info = {};\n    \n    Object.keys(this._events).forEach(eventName => {\n      info[eventName] = this.getEventInfo(eventName);\n    });\n    \n    return info;\n  },\n  \n  /**\n   * Get a count of handlers for an event\n   * @param {string} eventName - Event to count handlers for\n   * @returns {number} - Number of handlers\n   */\n  getHandlerCount(eventName) {\n    if (!this._events[eventName]) {\n      return 0;\n    }\n    \n    return this._events[eventName].handlers.length;\n  },\n  \n  /**\n   * Check if an event has any handlers\n   * @param {string} eventName - Event to check\n   * @returns {boolean} - Whether the event has handlers\n   */\n  hasHandlers(eventName) {\n    return this.getHandlerCount(eventName) > 0;\n  },\n  \n  /**\n   * Check if an event exists\n   * @param {string} eventName - Event to check\n   * @returns {boolean} - Whether the event exists\n   */\n  eventExists(eventName) {\n    return !!this._events[eventName];\n  },\n  \n  /**\n   * Set options for an event\n   * @param {string} eventName - Event to update\n   * @param {Object} options - New options\n   * @returns {boolean} - Whether update was successful\n   */\n  setEventOptions(eventName, options) {\n    if (!this._events[eventName]) {\n      return false;\n    }\n    \n    this._events[eventName].options = {\n      ...this._events[eventName].options,\n      ...options\n    };\n    \n    return true;\n  },\n  \n  /**\n   * Get event registry statistics\n   * @returns {Object} - Statistics information\n   */\n  getStats() {\n    // Calculate active handlers\n    let activeHandlers = 0;\n    let eventWithMostHandlers = '';\n    let maxHandlers = 0;\n    \n    Object.entries(this._events).forEach(([eventName, event]) => {\n      const count = event.handlers.length;\n      activeHandlers += count;\n      \n      if (count > maxHandlers) {\n        maxHandlers = count;\n        eventWithMostHandlers = eventName;\n      }\n    });\n    \n    return {\n      ...this._stats,\n      activeEvents: Object.keys(this._events).length,\n      activeHandlers,\n      eventWithMostHandlers,\n      maxHandlers,\n      pendingEvents: this._pendingEvents.length,\n      memoryUsage: this._estimateMemoryUsage()\n    };\n  },\n  \n  /**\n   * Estimate memory usage of the event registry\n   * @private\n   * @returns {Object} - Memory usage estimate\n   */\n  _estimateMemoryUsage() {\n    let totalHandlers = 0;\n    let totalEvents = Object.keys(this._events).length;\n    \n    Object.values(this._events).forEach(event => {\n      totalHandlers += event.handlers.length;\n    });\n    \n    // Rough estimate\n    return {\n      eventsBytes: totalEvents * 200, // 200 bytes per event structure\n      handlersBytes: totalHandlers * 500, // 500 bytes per handler\n      totalBytes: totalEvents * 200 + totalHandlers * 500\n    };\n  },\n  \n  /**\n   * Reset the registry (primarily for testing)\n   */\n  reset() {\n    this._events = {};\n    this._pendingEvents = [];\n    this._stats = {\n      totalEvents: 0,\n      emits: 0,\n      handlers: 0,\n      errors: 0\n    };\n    this.initialized = false;\n    \n    if (this.options.debug) {\n      console.log('Event Registry reset');\n    }\n  }\n};\n\n// Initialize the registry at module load time\n// But wait until next tick to avoid immediate DOM access\nsetTimeout(() => {\n  try {\n    if (!eventRegistry.initialized) {\n      eventRegistry.initialize();\n    }\n  } catch (error) {\n    console.error('Error auto-initializing event registry:', error);\n  }\n}, 0);\n\n// Export both default and named exports\nexport default eventRegistry;\nexport const on = eventRegistry.on.bind(eventRegistry);\nexport const off = eventRegistry.off.bind(eventRegistry);\nexport const once = eventRegistry.once.bind(eventRegistry);\nexport const emit = eventRegistry.emit.bind(eventRegistry);\nexport const emitWithResults = eventRegistry.emitWithResults.bind(eventRegistry);\nexport const registerEvent = eventRegistry.registerEvent.bind(eventRegistry);\nexport const registerEvents = eventRegistry.registerEvents.bind(eventRegistry);\nexport const clearEvent = eventRegistry.clearEvent.bind(eventRegistry);\nexport const clearAllEvents = eventRegistry.clearAllEvents.bind(eventRegistry);\nexport const getEvents = eventRegistry.getEvents.bind(eventRegistry);\nexport const getHandlerCount = eventRegistry.getHandlerCount.bind(eventRegistry);\nexport const hasHandlers = eventRegistry.hasHandlers.bind(eventRegistry);\nexport const eventExists = eventRegistry.eventExists.bind(eventRegistry);\nexport const getEventInfo = eventRegistry.getEventInfo.bind(eventRegistry);\nexport const getAllEventInfo = eventRegistry.getAllEventInfo.bind(eventRegistry);\nexport const setEventOptions = eventRegistry.setEventOptions.bind(eventRegistry);\nexport const getStats = eventRegistry.getStats.bind(eventRegistry);\nexport const initialize = eventRegistry.initialize.bind(eventRegistry);\n","source":"/workspace/modules/static/js/modules/core/eventRegistry.js","title":"eventRegistry.js","language":"en"},{"content":"/**\n * Centralized Health Monitoring System v3.1\n * \n * Unified health check system aligned with the modular blueprint architecture\n * Integrates with backend diagnostics API for comprehensive system monitoring\n * Eliminates legacy diagnostic files and provides centralized monitoring\n * \n * @module core/healthMonitor\n */\n\n// Import dependencies with fallback for legacy compatibility\nlet MODULE_REGISTRY, loadModule;\n\n// Dynamic import function for compatibility\nasync function initializeModuleSystem() {\n  try {\n    const moduleImports = await import('./moduleImports.js');\n    MODULE_REGISTRY = moduleImports.MODULE_REGISTRY;\n    loadModule = moduleImports.loadModule;\n    return true;\n  } catch (error) {\n    console.warn('🔄 HealthMonitor: Using legacy compatibility mode (MODULE_REGISTRY not available)');\n    return false;\n  }\n}\n\n/**\n * Health Monitor Class - Centralized System v3.1\n */\nclass HealthMonitor {\n  constructor() {\n    this.state = {\n      modules: new Map(),\n      socket: null,\n      apiHealth: null,\n      lastCheck: null,\n      checkInterval: 30000, // 30 seconds\n      indicator: null,\n      isInitialized: false\n    };\n    \n    this.healthEndpoints = {\n      modules: '/api/test-modules',\n      health: '/api/health',\n      monitor: '/api/health-monitor',\n      socket: '/socket.io/'\n    };\n  }\n\n  /**\n   * Initialize the health monitor\n   */\n  async init() {\n    console.log('🏥 Initializing Health Monitor...');\n    \n    // Initialize module system (with fallback for legacy)\n    await initializeModuleSystem();\n    \n    // Create health indicator UI\n    this.createHealthIndicator();\n    \n    // Run initial health check\n    await this.runHealthCheck();\n    \n    // Set up periodic health checks\n    this.startPeriodicChecks();\n    \n    // Set up event listeners\n    this.setupEventListeners();\n    \n    this.state.isInitialized = true;\n    console.log('✅ Health Monitor initialized');\n  }\n\n  /**\n   * Create the health indicator UI element\n   */\n  createHealthIndicator() {\n    // Remove any existing indicators\n    const existing = document.querySelectorAll('.system-health-indicator');\n    existing.forEach(el => el.remove());\n    \n    // Create new indicator\n    this.state.indicator = document.createElement('div');\n    this.state.indicator.id = 'unified-health-indicator';\n    this.state.indicator.className = 'system-health-indicator';\n    this.state.indicator.style.cssText = `\n      position: fixed;\n      bottom: 10px;\n      left: 10px;\n      background: rgba(40, 167, 69, 0.9);\n      color: white;\n      padding: 8px 15px;\n      border-radius: 20px;\n      font-size: 12px;\n      z-index: 9999;\n      cursor: pointer;\n      transition: all 0.3s ease;\n      display: flex;\n      align-items: center;\n      gap: 8px;\n      box-shadow: 0 2px 10px rgba(0,0,0,0.2);\n    `;\n    \n    this.state.indicator.innerHTML = `\n      <i class=\"fas fa-heartbeat\"></i>\n      <span class=\"health-text\">System Healthy</span>\n    `;\n    \n    document.body.appendChild(this.state.indicator);\n  }\n\n  /**\n   * Run comprehensive health check\n   */\n  async runHealthCheck() {\n    const results = {\n      modules: await this.checkModules(),\n      socket: await this.checkSocket(),\n      api: await this.checkAPI(),\n      timestamp: new Date().toISOString()\n    };\n    \n    this.state.lastCheck = results;\n    this.updateHealthIndicator(results);\n    \n    return results;\n  }\n\n  /**\n   * Check module health\n   */\n  async checkModules() {\n    const moduleStatus = {\n      total: 0,\n      loaded: 0,\n      failed: [],\n      warnings: []\n    };\n    \n    // Get critical modules\n    const criticalModules = [\n      'errorHandler', 'domUtils', 'stateManager', 'eventManager',\n      'socketHandler', 'progressHandler', 'ui', 'blueprintApi'\n    ];\n    \n    // Get feature modules\n    const featureModules = [\n      'fileProcessor', 'webScraper', 'playlistDownloader', \n      'academicSearch', 'historyManager'\n    ];\n    \n    // Check each module\n    for (const moduleName of [...criticalModules, ...featureModules]) {\n      moduleStatus.total++;\n      \n      try {\n        // Check if MODULE_REGISTRY is available (compatibility with legacy loading)\n        if (typeof MODULE_REGISTRY === 'undefined') {\n          // Fallback: Check if module exists in window.NeuroGen.modules or window object\n          const module = window.NeuroGen?.modules?.[moduleName] || \n                        window.moduleInstances?.[moduleName] || \n                        window[moduleName];\n          \n          if (module) {\n            moduleStatus.loaded++;\n            this.state.modules.set(moduleName, {\n              status: 'loaded',\n              module: module\n            });\n          } else {\n            moduleStatus.warnings.push(`${moduleName} not found (legacy mode)`);\n          }\n          continue;\n        }\n        \n        // Check if module is in registry (new system)\n        if (!MODULE_REGISTRY[moduleName]) {\n          moduleStatus.warnings.push(`${moduleName} not in registry`);\n          continue;\n        }\n        \n        // Try to load module using new system\n        const module = await loadModule(moduleName);\n        if (module) {\n          moduleStatus.loaded++;\n          this.state.modules.set(moduleName, {\n            status: 'loaded',\n            module: module\n          });\n        } else {\n          throw new Error('Module loaded but is null');\n        }\n      } catch (error) {\n        moduleStatus.failed.push({\n          name: moduleName,\n          error: error.message,\n          critical: criticalModules.includes(moduleName)\n        });\n        \n        this.state.modules.set(moduleName, {\n          status: 'failed',\n          error: error.message\n        });\n      }\n    }\n    \n    // Check window.NeuroGen modules\n    if (window.NeuroGen?.modules) {\n      const loadedInstances = Object.keys(window.NeuroGen.modules);\n      moduleStatus.windowModules = loadedInstances.length;\n    }\n    \n    return moduleStatus;\n  }\n\n  /**\n   * Check Socket.IO connection\n   */\n  async checkSocket() {\n    const socketStatus = {\n      connected: false,\n      transport: null,\n      latency: null\n    };\n    \n    if (window.socket) {\n      socketStatus.connected = window.socket.connected;\n      socketStatus.transport = window.socket.io?.engine?.transport?.name;\n      \n      // Ping test\n      if (socketStatus.connected) {\n        const startTime = Date.now();\n        try {\n          await new Promise((resolve, reject) => {\n            const timeout = setTimeout(() => reject(new Error('Timeout')), 5000);\n            \n            window.socket.emit('ping', { timestamp: startTime });\n            window.socket.once('pong', () => {\n              clearTimeout(timeout);\n              socketStatus.latency = Date.now() - startTime;\n              resolve();\n            });\n          });\n        } catch (error) {\n          socketStatus.latency = -1;\n        }\n      }\n    }\n    \n    return socketStatus;\n  }\n\n  /**\n   * Check API health\n   */\n  async checkAPI() {\n    const apiStatus = {\n      healthy: false,\n      responseTime: null,\n      endpoints: {}\n    };\n    \n    try {\n      const startTime = Date.now();\n      const response = await fetch(this.healthEndpoints.health || '/api/health');\n      apiStatus.responseTime = Date.now() - startTime;\n      \n      if (response.ok) {\n        const data = await response.json();\n        apiStatus.healthy = true;\n        apiStatus.endpoints = data.endpoints || {};\n        apiStatus.version = data.version;\n      }\n    } catch (error) {\n      apiStatus.error = error.message;\n    }\n    \n    // Check specific endpoints\n    const endpointsToCheck = [\n      { name: 'file_processor', url: '/api/process' },\n      { name: 'web_scraper', url: '/api/scrape2' },\n      { name: 'playlist_downloader', url: '/api/start-playlists' }\n    ];\n    \n    for (const endpoint of endpointsToCheck) {\n      try {\n        const response = await fetch(endpoint.url, { method: 'HEAD' });\n        apiStatus.endpoints[endpoint.name] = response.ok;\n      } catch {\n        apiStatus.endpoints[endpoint.name] = false;\n      }\n    }\n    \n    return apiStatus;\n  }\n\n  /**\n   * Update health indicator based on results\n   */\n  updateHealthIndicator(results) {\n    if (!this.state.indicator) return;\n    \n    const { modules, socket, api } = results;\n    \n    // Calculate overall health\n    const moduleHealth = modules.failed.filter(m => m.critical).length === 0;\n    const socketHealth = socket.connected;\n    const apiHealth = api.healthy;\n    \n    let status = 'healthy';\n    let icon = 'fa-heartbeat';\n    let color = 'rgba(40, 167, 69, 0.9)'; // green\n    let text = 'System Healthy';\n    \n    if (!moduleHealth || !apiHealth) {\n      status = 'critical';\n      icon = 'fa-exclamation-circle';\n      color = 'rgba(220, 53, 69, 0.9)'; // red\n      text = 'System Critical';\n    } else if (!socketHealth || modules.failed.length > 0) {\n      status = 'warning';\n      icon = 'fa-exclamation-triangle';\n      color = 'rgba(255, 193, 7, 0.9)'; // yellow\n      text = 'System Warning';\n    }\n    \n    // Build status text\n    const issues = [];\n    if (modules.failed.length > 0) {\n      issues.push(`${modules.failed.length} modules failed`);\n    }\n    if (!socketHealth) {\n      issues.push('Socket disconnected');\n    }\n    if (!apiHealth) {\n      issues.push('API unhealthy');\n    }\n    \n    const statusText = issues.length > 0 ? issues.join(', ') : text;\n    \n    // Update indicator\n    this.state.indicator.style.background = color;\n    this.state.indicator.innerHTML = `\n      <i class=\"fas ${icon}\"></i>\n      <span class=\"health-text\">${statusText}</span>\n    `;\n    \n    // Add click handler for details\n    this.state.indicator.onclick = () => this.showHealthDetails();\n  }\n\n  /**\n   * Show detailed health information\n   */\n  showHealthDetails() {\n    if (!this.state.lastCheck) return;\n    \n    const modal = document.createElement('div');\n    modal.className = 'health-details-modal';\n    modal.style.cssText = `\n      position: fixed;\n      top: 50%;\n      left: 50%;\n      transform: translate(-50%, -50%);\n      background: white;\n      padding: 20px;\n      border-radius: 10px;\n      box-shadow: 0 5px 20px rgba(0,0,0,0.3);\n      z-index: 10000;\n      max-width: 600px;\n      max-height: 80vh;\n      overflow-y: auto;\n      color: #333;\n    `;\n    \n    const { modules, socket, api } = this.state.lastCheck;\n    \n    modal.innerHTML = `\n      <h3>System Health Report</h3>\n      <button onclick=\"this.parentElement.remove()\" style=\"position: absolute; top: 10px; right: 10px; border: none; background: none; font-size: 20px; cursor: pointer;\">&times;</button>\n      \n      <div style=\"margin-top: 20px;\">\n        <h4>Modules (${modules.loaded}/${modules.total})</h4>\n        ${modules.failed.length > 0 ? `\n          <div style=\"color: red;\">\n            <strong>Failed Modules:</strong>\n            <ul>\n              ${modules.failed.map(m => `<li>${m.name} ${m.critical ? '(CRITICAL)' : ''}: ${m.error}</li>`).join('')}\n            </ul>\n          </div>\n        ` : '<p style=\"color: green;\">All modules loaded successfully</p>'}\n      </div>\n      \n      <div style=\"margin-top: 20px;\">\n        <h4>Socket.IO Connection</h4>\n        <p>Status: <strong style=\"color: ${socket.connected ? 'green' : 'red'}\">${socket.connected ? 'Connected' : 'Disconnected'}</strong></p>\n        ${socket.connected ? `\n          <p>Transport: ${socket.transport}</p>\n          <p>Latency: ${socket.latency}ms</p>\n        ` : ''}\n      </div>\n      \n      <div style=\"margin-top: 20px;\">\n        <h4>API Health</h4>\n        <p>Status: <strong style=\"color: ${api.healthy ? 'green' : 'red'}\">${api.healthy ? 'Healthy' : 'Unhealthy'}</strong></p>\n        ${api.responseTime ? `<p>Response Time: ${api.responseTime}ms</p>` : ''}\n        ${api.version ? `<p>Version: ${api.version}</p>` : ''}\n        \n        <h5>Endpoints:</h5>\n        <ul>\n          ${Object.entries(api.endpoints).map(([name, status]) => \n            `<li>${name}: <strong style=\"color: ${status ? 'green' : 'red'}\">${status ? 'Available' : 'Unavailable'}</strong></li>`\n          ).join('')}\n        </ul>\n      </div>\n      \n      <div style=\"margin-top: 20px;\">\n        <p style=\"font-size: 12px; color: #666;\">Last checked: ${new Date(this.state.lastCheck.timestamp).toLocaleString()}</p>\n        <button onclick=\"window.healthMonitor.runHealthCheck().then(() => this.parentElement.remove())\" style=\"padding: 5px 15px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer;\">Refresh</button>\n      </div>\n    `;\n    \n    document.body.appendChild(modal);\n    \n    // Close on background click\n    setTimeout(() => {\n      const closeOnClick = (e) => {\n        if (e.target === modal) {\n          modal.remove();\n          document.removeEventListener('click', closeOnClick);\n        }\n      };\n      document.addEventListener('click', closeOnClick);\n    }, 100);\n  }\n\n  /**\n   * Start periodic health checks\n   */\n  startPeriodicChecks() {\n    setInterval(() => {\n      this.runHealthCheck();\n    }, this.state.checkInterval);\n  }\n\n  /**\n   * Setup event listeners\n   */\n  setupEventListeners() {\n    // Listen for module load/fail events\n    if (window.NeuroGen?.events) {\n      window.NeuroGen.events.on('module:loaded', (moduleName) => {\n        this.state.modules.set(moduleName, { status: 'loaded' });\n        this.runHealthCheck();\n      });\n      \n      window.NeuroGen.events.on('module:failed', (moduleName) => {\n        this.state.modules.set(moduleName, { status: 'failed' });\n        this.runHealthCheck();\n      });\n    }\n    \n    // Listen for socket events\n    if (window.socket) {\n      window.socket.on('connect', () => this.runHealthCheck());\n      window.socket.on('disconnect', () => this.runHealthCheck());\n    }\n  }\n\n  /**\n   * Get current health status\n   */\n  getStatus() {\n    return this.state.lastCheck;\n  }\n\n  /**\n   * Force health check\n   */\n  async forceCheck() {\n    return await this.runHealthCheck();\n  }\n}\n\n// Create singleton instance\nconst healthMonitor = new HealthMonitor();\n\n// Export for global access\nexport default healthMonitor;\n\n// Make available globally\nif (typeof window !== 'undefined') {\n  window.healthMonitor = healthMonitor;\n}\n\n// Auto-initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => healthMonitor.init());\n} else {\n  healthMonitor.init();\n}\n\nconsole.log('🏥 Health Monitor module loaded');","source":"/workspace/modules/static/js/modules/core/healthMonitor.js","title":"healthMonitor.js","language":"en"},{"content":"// Core modules index\nimport app from './app.js';\nimport errorHandler from './errorHandler.js';\nimport eventManager from './eventManager.js';\nimport eventRegistry from './eventRegistry.js';\nimport moduleLoader from './moduleLoader.js';\nimport stateManager from './stateManager.js';\nimport themeManager from './themeManager.js';\nimport uiRegistry from './uiRegistry.js';\n\n// Re-export as named exports\nexport { app, errorHandler, eventManager, eventRegistry, moduleLoader, stateManager, themeManager, uiRegistry };\n\n// Named exports from core modules\nexport * from './uiRegistry.js';\nexport * from './eventRegistry.js';\nexport * from './stateManager.js';\nexport * from './errorHandler.js';\nexport * from './eventManager.js';\nexport * from './moduleLoader.js';\nexport * from './themeManager.js';\n\n// Create index object with all exports\nconst index = {\n  app,\n  errorHandler,\n  eventManager,\n  eventRegistry,\n  moduleLoader,\n  stateManager,\n  themeManager,\n  uiRegistry\n};\n\n// Export default module\nexport default index;\n","source":"/workspace/modules/static/js/modules/core/index.js","title":"index.js","language":"en"},{"content":"/**\n * Module Bridge\n * \n * This module acts as a bridge to prevent circular dependencies between modules.\n * It provides stub implementations that can be dynamically updated after modules load.\n * \n * VERSION: 2.1.0\n * UPDATED: 2025-05-15\n */\n\n// ----------------------------------------------------------\n// Bridge Implementation with Version Tracking and Error Handling\n// ----------------------------------------------------------\nconst BRIDGE_VERSION = '2.1.0';\nconsole.log(`Module Bridge v${BRIDGE_VERSION} initializing...`);\n\n// Track bridge state\nconst bridgeState = {\n  initialized: false,\n  modules: new Map(),\n  updateHistory: new Map(),\n  dependencyGraph: new Map(),\n  eventListeners: new Map(),\n  errors: []\n};\n\n// Create empty bridges for modules that cause circular dependencies\nconst uiBridge = createBridgeObject('ui', {\n  showToast: (title, message, type = 'info') => {\n    console.log(`TOAST [${type}]: ${title} - ${message}`);\n    return null;\n  },\n  showLoadingSpinner: (message) => {\n    console.log(`LOADING: ${message}`);\n    return {\n      hide: () => console.log('Loading hidden'),\n      updateMessage: () => {},\n      updateProgress: () => {},\n      getElapsedTime: () => 0\n    };\n  },\n  hideLoading: () => console.log('Loading hidden'),\n  showModal: (title, content, options) => {\n    console.log(`MODAL: ${title}`);\n    return {\n      id: 'mock-modal',\n      hide: () => {},\n      updateContent: () => {},\n      updateTitle: () => {},\n      addButton: () => {}\n    };\n  },\n  hideModal: () => {},\n  toggleElementVisibility: (id, visible) => {},\n  getElement: (selector) => document.querySelector(selector),\n  findElement: (selector) => document.querySelector(selector),\n  findElements: (selector) => Array.from(document.querySelectorAll(selector)),\n  createElement: (tag, attrs, parent) => {\n    const el = document.createElement(tag);\n    return el;\n  },\n  confirm: (title, message, onConfirm, onCancel) => {\n    console.log(`CONFIRM: ${title} - ${message}`);\n    // Default to cancelling to avoid unintended actions\n    if (onCancel) onCancel();\n    return {\n      id: 'mock-confirm',\n      hide: () => {}\n    };\n  },\n  alert: (title, message, type, onClose) => {\n    console.log(`ALERT [${type}]: ${title} - ${message}`);\n    return {\n      id: 'mock-alert',\n      hide: () => {}\n    };\n  },\n  prompt: (title, message, onSubmit, onCancel) => {\n    console.log(`PROMPT: ${title} - ${message}`);\n    // Default to cancelling to avoid unintended actions\n    if (onCancel) onCancel();\n    return {\n      id: 'mock-prompt',\n      hide: () => {}\n    };\n  }\n});\n\nconst progressHandlerBridge = createBridgeObject('progressHandler', {\n  trackProgress: (taskId, options = {}) => {\n    console.log(`Tracking progress for task ${taskId}`);\n    return {\n      updateProgress: () => {},\n      complete: () => {},\n      error: () => {},\n      cancel: () => {},\n      getStatus: () => ({ status: 'pending' }),\n      cancelTracking: () => {}\n    };\n  },\n  updateProgressUI: () => {},\n  createProgressUI: () => {},\n  cancelTracking: () => {},\n  setupTaskProgress: (taskId, options = {}) => {\n    console.log(`Setting up progress tracking for task ${taskId}`);\n    return {\n      updateProgress: () => {},\n      complete: () => {},\n      error: () => {},\n      cancel: () => {},\n      getStatus: () => ({ status: 'pending' })\n    };\n  },\n  updateTaskProgress: () => {},\n  completeTask: () => {},\n  errorTask: () => {},\n  cancelTask: () => {},\n  formatDuration: (ms) => '0:00',\n  calculateETA: () => ({ timeRemaining: null, completionTime: null }),\n  formatBytes: (bytes) => '0 B'\n});\n\nconst socketHandlerBridge = createBridgeObject('socketHandler', {\n  startStatusPolling: () => {},\n  stopStatusPolling: () => {},\n  cancelTask: () => Promise.resolve({ success: true }),\n  isConnected: () => false,\n  registerTaskHandler: () => {},\n  emit: () => {},\n  connect: () => {},\n  disconnect: () => {},\n  on: () => {},\n  off: () => {}\n});\n\n// Helper function to create bridge objects with proper tracking\nfunction createBridgeObject(name, initialImpl) {\n  const bridge = {\n    ...initialImpl,\n    __isBridge: true,\n    __bridgeName: name,\n    __updateCount: 0,\n    __created: Date.now()\n  };\n  \n  // Track this bridge\n  bridgeState.modules.set(name, {\n    bridge,\n    initialImpl,\n    dependencies: [],\n    updateHandlers: new Map(),\n    lastUpdated: null\n  });\n  \n  return bridge;\n}\n\n// Export the bridges\nexport { uiBridge, progressHandlerBridge, socketHandlerBridge };\n\n// Also export functions to update the bridges once real modules are loaded\nexport function updateBridge(bridgeName, realImpl, options = {}) {\n  if (!bridgeName || !realImpl) {\n    console.error(`[Bridge] Invalid parameters for updateBridge: ${bridgeName}`);\n    return false;\n  }\n  \n  const moduleInfo = bridgeState.modules.get(bridgeName);\n  if (!moduleInfo) {\n    console.error(`[Bridge] Unknown bridge: ${bridgeName}`);\n    return false;\n  }\n  \n  const bridge = moduleInfo.bridge;\n  \n  try {\n    // Track update history\n    const updateCount = bridge.__updateCount + 1;\n    const timestamp = Date.now();\n    \n    // Store update history\n    if (!bridgeState.updateHistory.has(bridgeName)) {\n      bridgeState.updateHistory.set(bridgeName, []);\n    }\n    \n    bridgeState.updateHistory.get(bridgeName).push({\n      updateCount,\n      timestamp,\n      source: options.source || 'unknown'\n    });\n    \n    // Update bridge properties and methods\n    Object.keys(bridge).forEach(key => {\n      // Skip private properties and handle different types correctly\n      if (key.startsWith('__')) return;\n      \n      try {\n        if (typeof realImpl[key] === 'function') {\n          bridge[key] = realImpl[key].bind(realImpl);\n        } else if (typeof realImpl[key] !== 'undefined') {\n          bridge[key] = realImpl[key];\n        }\n      } catch (propError) {\n        console.warn(`[Bridge] Error updating property ${key} on bridge ${bridgeName}:`, propError);\n      }\n    });\n    \n    // Update bridge metadata\n    bridge.__updateCount = updateCount;\n    bridge.__lastUpdated = timestamp;\n    \n    // Call update handlers\n    const handlers = moduleInfo.updateHandlers;\n    if (handlers && handlers.size > 0) {\n      handlers.forEach((handler, id) => {\n        try {\n          handler(bridge, realImpl);\n        } catch (handlerError) {\n          console.warn(`[Bridge] Error in update handler ${id} for ${bridgeName}:`, handlerError);\n        }\n      });\n    }\n    \n    // Update module info\n    moduleInfo.lastUpdated = timestamp;\n    bridgeState.modules.set(bridgeName, moduleInfo);\n    \n    console.log(`[Bridge] Updated ${bridgeName} bridge (update #${updateCount})`);\n    return true;\n  } catch (error) {\n    console.error(`[Bridge] Error updating ${bridgeName} bridge:`, error);\n    bridgeState.errors.push({\n      bridge: bridgeName,\n      error,\n      timestamp: Date.now()\n    });\n    return false;\n  }\n}\n\n// Convenience methods for specific bridges\nexport function updateUIBridge(realUI, options = {}) {\n  return updateBridge('ui', realUI, { ...options, source: 'updateUIBridge' });\n}\n\nexport function updateProgressHandlerBridge(realProgressHandler, options = {}) {\n  return updateBridge('progressHandler', realProgressHandler, { ...options, source: 'updateProgressHandlerBridge' });\n}\n\nexport function updateSocketHandlerBridge(realSocketHandler, options = {}) {\n  return updateBridge('socketHandler', realSocketHandler, { ...options, source: 'updateSocketHandlerBridge' });\n}\n\n// Register update handlers\nexport function registerUpdateHandler(bridgeName, id, handler) {\n  if (!bridgeName || !id || typeof handler !== 'function') {\n    console.error('[Bridge] Invalid parameters for registerUpdateHandler');\n    return false;\n  }\n  \n  const moduleInfo = bridgeState.modules.get(bridgeName);\n  if (!moduleInfo) {\n    console.error(`[Bridge] Unknown bridge: ${bridgeName}`);\n    return false;\n  }\n  \n  moduleInfo.updateHandlers.set(id, handler);\n  \n  // If bridge was already updated, call handler immediately\n  if (moduleInfo.lastUpdated) {\n    try {\n      handler(moduleInfo.bridge);\n    } catch (error) {\n      console.warn(`[Bridge] Error in immediate update handler ${id} for ${bridgeName}:`, error);\n    }\n  }\n  \n  return true;\n}\n\n// Convenience methods for specific bridges\nexport function registerUIUpdateHandler(id, handler) {\n  return registerUpdateHandler('ui', id, handler);\n}\n\nexport function registerProgressHandlerUpdateHandler(id, handler) {\n  return registerUpdateHandler('progressHandler', id, handler);\n}\n\nexport function registerSocketHandlerUpdateHandler(id, handler) {\n  return registerUpdateHandler('socketHandler', id, handler);\n}\n\n// Add bridge initialization tracking\nexport function getInitializationStatus() {\n  const moduleStatuses = {};\n  \n  bridgeState.modules.forEach((info, name) => {\n    moduleStatuses[name] = {\n      initialized: info.lastUpdated !== null,\n      updateCount: info.bridge.__updateCount,\n      created: info.bridge.__created,\n      lastUpdated: info.lastUpdated\n    };\n  });\n  \n  return {\n    initialized: Array.from(bridgeState.modules.values()).every(m => m.lastUpdated !== null),\n    moduleStatuses,\n    errors: bridgeState.errors,\n    version: BRIDGE_VERSION\n  };\n}\n\n// For moduleLoader integration\nexport function reportBridgeStatus() {\n  const status = getInitializationStatus();\n  console.log(`[Bridge] Status: ${status.initialized ? 'Fully Initialized' : 'Partially Initialized'}`);\n  console.log(`[Bridge] Module Statuses:`, status.moduleStatuses);\n  return status;\n}\n\n// Initialize bridge state\nbridgeState.initialized = true;\nconsole.log(`Module Bridge v${BRIDGE_VERSION} initialized successfully`);","source":"/workspace/modules/static/js/modules/core/module-bridge.js","title":"module-bridge.js","language":"en"},{"content":"/**\n * Centralized Module Import System\n * \n * Provides consistent import handling for all NeuroGen modules\n * Handles both ES6 imports and fallbacks to window objects\n * \n * @module core/moduleImports\n */\n\n// Base path configuration\nconst BASE_PATH = '/static/js/modules';\n\n/**\n * Module registry with paths and dependencies\n */\nconst MODULE_REGISTRY = {\n  // Core modules\n  'errorHandler': { path: '/core/errorHandler.js', exports: ['showErrorNotification', 'showSuccess', 'handleError'] },\n  'domUtils': { path: '/core/domUtils.js', exports: ['getElement', 'createElement', 'addClass', 'removeClass'] },\n  'uiRegistry': { path: '/core/uiRegistry.js', exports: ['registerElement', 'getRegisteredElement'] },\n  'stateManager': { path: '/core/stateManager.js', exports: ['setState', 'getState', 'subscribe'] },\n  'eventManager': { path: '/core/eventManager.js', exports: ['registerEvents', 'emit', 'on', 'off'] },\n  'eventRegistry': { path: '/core/eventRegistry.js', exports: ['registerEvent', 'getEvents'] },\n  'themeManager': { path: '/core/themeManager.js', exports: ['setTheme', 'getTheme', 'toggleTheme'] },\n  \n  // Utils modules\n  'socketHandler': { path: '/utils/socketHandler.js', exports: ['socket', 'emit', 'on', 'off'] },\n  'progressHandler': { path: '/utils/progressHandler.js', exports: ['showProgress', 'hideProgress', 'updateProgress'] },\n  'ui': { path: '/utils/ui.js', exports: ['showLoadingSpinner', 'hideLoadingSpinner', 'showToast', 'updateUI'] },\n  'utils': { path: '/utils/utils.js', exports: ['generateId', 'formatDate', 'debounce', 'throttle'] },\n  'fileHandler': { path: '/utils/fileHandler.js', exports: ['handleFile', 'validateFile', 'getFileType'] },\n  \n  // Services\n  'blueprintApi': { path: '/services/blueprintApi.js', exports: 'default' },\n  \n  // Config modules\n  'endpoints': { path: '/config/endpoints.js', exports: ['SCRAPER_ENDPOINTS', 'ACADEMIC_ENDPOINTS', 'PDF_ENDPOINTS', 'TASK_ENDPOINTS'] },\n  'socketEvents': { path: '/config/socketEvents.js', exports: ['TASK_EVENTS', 'BLUEPRINT_EVENTS', 'SCRAPER_EVENTS', 'ACADEMIC_EVENTS'] },\n  'constants': { path: '/config/constants.js', exports: ['CONSTANTS'] },\n  \n  // Feature modules\n  'fileProcessor': { path: '/features/fileProcessor.js', exports: 'default' },\n  'webScraper': { path: '/features/webScraper.js', exports: 'default' },\n  'playlistDownloader': { path: '/features/playlistDownloader.js', exports: 'default' },\n  'academicSearch': { path: '/features/academicSearch.js', exports: 'default' },\n  'historyManager': { path: '/features/historyManager.js', exports: 'default' }\n};\n\n/**\n * Cache for loaded modules\n */\nconst moduleCache = new Map();\n\n/**\n * Load a module with consistent error handling and caching\n * @param {string} moduleName - Name of the module to load\n * @returns {Promise<any>} The loaded module or its exports\n */\nexport async function loadModule(moduleName) {\n  // Check cache first\n  if (moduleCache.has(moduleName)) {\n    return moduleCache.get(moduleName);\n  }\n  \n  const moduleConfig = MODULE_REGISTRY[moduleName];\n  if (!moduleConfig) {\n    throw new Error(`Module '${moduleName}' not found in registry`);\n  }\n  \n  try {\n    // Try ES6 import\n    const fullPath = `${BASE_PATH}${moduleConfig.path}`;\n    const module = await import(fullPath);\n    \n    // Handle different export types\n    let exports;\n    if (moduleConfig.exports === 'default') {\n      exports = module.default;\n    } else if (Array.isArray(moduleConfig.exports)) {\n      // Extract specific exports\n      exports = {};\n      for (const exportName of moduleConfig.exports) {\n        if (module[exportName] !== undefined) {\n          exports[exportName] = module[exportName];\n        }\n      }\n    } else {\n      exports = module;\n    }\n    \n    // Cache the result\n    moduleCache.set(moduleName, exports);\n    return exports;\n    \n  } catch (error) {\n    console.warn(`Failed to import ${moduleName} via ES6, checking window fallback:`, error);\n    \n    // Check window fallback\n    if (window[moduleName]) {\n      moduleCache.set(moduleName, window[moduleName]);\n      return window[moduleName];\n    }\n    \n    throw new Error(`Failed to load module '${moduleName}': ${error.message}`);\n  }\n}\n\n/**\n * Load multiple modules at once\n * @param {string[]} moduleNames - Array of module names to load\n * @returns {Promise<Object>} Object with module names as keys and loaded modules as values\n */\nexport async function loadModules(moduleNames) {\n  const results = {};\n  const promises = moduleNames.map(async (name) => {\n    try {\n      results[name] = await loadModule(name);\n    } catch (error) {\n      console.error(`Failed to load module ${name}:`, error);\n      results[name] = null;\n    }\n  });\n  \n  await Promise.all(promises);\n  return results;\n}\n\n/**\n * Import helper for feature modules\n * Provides a consistent way to import dependencies\n */\nexport class ModuleImporter {\n  constructor() {\n    this.imports = {};\n  }\n  \n  /**\n   * Import core modules\n   */\n  async importCore() {\n    const modules = await loadModules([\n      'errorHandler',\n      'domUtils',\n      'uiRegistry',\n      'stateManager',\n      'eventManager'\n    ]);\n    \n    Object.assign(this.imports, modules);\n    return modules;\n  }\n  \n  /**\n   * Import utility modules\n   */\n  async importUtils() {\n    const modules = await loadModules([\n      'socketHandler',\n      'progressHandler',\n      'ui',\n      'utils',\n      'fileHandler'\n    ]);\n    \n    Object.assign(this.imports, modules);\n    return modules;\n  }\n  \n  /**\n   * Import configuration modules\n   */\n  async importConfig() {\n    const modules = await loadModules([\n      'endpoints',\n      'socketEvents',\n      'constants'\n    ]);\n    \n    Object.assign(this.imports, modules);\n    return modules;\n  }\n  \n  /**\n   * Import service modules\n   */\n  async importServices() {\n    const modules = await loadModules(['blueprintApi']);\n    Object.assign(this.imports, modules);\n    return modules;\n  }\n  \n  /**\n   * Get all imported modules\n   */\n  getImports() {\n    return this.imports;\n  }\n}\n\n/**\n * Create a standard import set for feature modules\n */\nexport async function createStandardImports() {\n  const importer = new ModuleImporter();\n  \n  // Load all standard dependencies\n  await Promise.all([\n    importer.importCore(),\n    importer.importUtils(),\n    importer.importConfig(),\n    importer.importServices()\n  ]);\n  \n  return importer.getImports();\n}\n\n// Export for global access if needed\nif (typeof window !== 'undefined') {\n  window.ModuleImports = {\n    loadModule,\n    loadModules,\n    ModuleImporter,\n    createStandardImports,\n    MODULE_REGISTRY\n  };\n}\n\n// Export the MODULE_REGISTRY and other functions\nexport { MODULE_REGISTRY, loadModule, loadModules, ModuleImporter, createStandardImports };","source":"/workspace/modules/static/js/modules/core/moduleImports.js","title":"moduleImports.js","language":"en"},{"content":"/**\n * NeuroGen Server - Enhanced Module Loader v3.1\n * \n * Provides reliable module loading with robust error handling, dependency management,\n * and graceful fallbacks for the NeuroGen Server frontend.\n * \n * Version 3.2 Fixes:\n * - Complete solution for circular dependencies using dynamic exports\n * - Fixed module initialization sequence\n * - Enhanced lazy loading for dependent modules\n * - Improved bridge integration for circular dependency resolution\n * - Better proxy handling for module methods before availability\n */\n\n/**\n * Module Loader that handles dynamic module imports with error isolation\n */\nconst moduleLoader = {\n  // Module cache to prevent duplicate imports\n  cache: new Map(),\n  \n  // Module promises to prevent duplicate loading\n  loadingPromises: new Map(),\n  \n  // Loading modules set to detect circular dependencies\n  loadingModules: new Set(),\n  \n  // Failed modules to prevent repeated loading of failed modules\n  failedModules: new Set(),\n  \n  // Fallback modules tracking\n  fallbackModules: new Set(),\n  \n  // Track load attempts for better retry behavior\n  loadAttempts: new Map(),\n  \n  // Module initialization status\n  initialized: false,\n  \n  // Debug mode flag for enhanced logging\n  debugMode: false,\n  \n  // Verbose logging flag for granular logging\n  verboseLogging: false,\n  \n  // Default options for module loading\n  defaultOptions: {\n    maxRetries: 3,\n    timeout: 15000, // Increased from 8000ms to 15000ms for better compatibility\n    concurrencyLimit: 5,\n    ignoreErrors: false,\n    skipCache: false,\n    standardizeExports: true,\n    clearFailedModules: false\n  },\n  \n  // Map of module filenames to their locations\n  MODULE_LOCATIONS: {\n    // Core modules\n    'app.js': 'core',\n    'moduleLoader.js': 'core',\n    'uiRegistry.js': 'core',\n    'eventManager.js': 'core',\n    'eventRegistry.js': 'core',\n    'stateManager.js': 'core',\n    'errorHandler.js': 'core',\n    'themeManager.js': 'core',\n    'module-bridge.js': 'core', // Add module bridge\n    'moduleLoaderConfig.js': 'core', // Add config\n    \n    // Feature modules\n    'fileProcessor.js': 'features',\n    'pdfProcessor.js': 'features',\n    'webScraper.js': 'features',\n    'playlistDownloader.js': 'features',\n    'academicSearch.js': 'features',\n    'academicApiClient.js': 'features',\n    'academicScraper.js': 'features',\n    'historyManager.js': 'features',\n    'helpMode.js': 'features',\n    \n    // Utility modules\n    'utils.js': 'utils',\n    'ui.js': 'utils',\n    'fileHandler.js': 'utils',\n    'progressHandler.js': 'utils',\n    'socketHandler.js': 'utils',\n    'debugTools.js': 'utils',\n    'moduleDiagnostics.js': 'utils',\n    'safeFileProcessor.js': 'utils',\n    'domUtils.js': 'utils' // Ensure domUtils is included\n  },\n  \n  // Module locations map (inverse mapping for lookup by module name without extension)\n  MODULE_TYPES: {},\n  \n  // Path overrides for specific modules that might be problematic\n  PATH_OVERRIDES: {\n    './modules/features/webScraper.js': '/static/js/modules/features/webScraper.js',\n    './modules/features/academicSearch.js': '/static/js/modules/features/academicSearch.js',\n    './modules/features/fileProcessor.js': '/static/js/modules/features/fileProcessor.js',\n    './modules/utils/moduleDiagnostics.js': '/static/js/modules/utils/moduleDiagnostics.js',\n    './modules/utils/debugTools.js': '/static/js/modules/utils/debugTools.js',\n    './modules/utils/ui.js': '/static/js/modules/utils/ui.js',\n    './modules/features/historyManager.js': '/static/js/modules/features/historyManager.js',\n    './modules/utils/progressHandler.js': '/static/js/modules/utils/progressHandler.js',\n    './modules/utils/socketHandler.js': '/static/js/modules/utils/socketHandler.js',\n    './modules/utils/domUtils.js': '/static/js/modules/utils/domUtils.js', // Add domUtils path\n    'ui.js': '/static/js/modules/utils/ui.js',\n    'progressHandler.js': '/static/js/modules/utils/progressHandler.js',\n    'socketHandler.js': '/static/js/modules/utils/socketHandler.js',\n    'fileProcessor.js': '/static/js/modules/features/fileProcessor.js',\n    'webScraper.js': '/static/js/modules/features/webScraper.js',\n    'academicSearch.js': '/static/js/modules/features/academicSearch.js',\n    'historyManager.js': '/static/js/modules/features/historyManager.js',\n    'playlistDownloader.js': '/static/js/modules/features/playlistDownloader.js',\n    './modules/features/playlistDownloader.js': '/static/js/modules/features/playlistDownloader.js',\n    './playlistDownloader.js': '/static/js/modules/features/playlistDownloader.js',\n    'domUtils.js': '/static/js/modules/utils/domUtils.js'\n  },\n  \n  // OPTIMIZED INITIALIZATION ORDER - Carefully ordered to prevent circular dependencies\n  INITIALIZATION_ORDER: [\n    'module-bridge.js',    // Load module bridge first\n    'errorHandler.js',     // Load error handler second\n    'domUtils.js',         // Load domUtils early since it has no dependencies\n    'uiRegistry.js',\n    'stateManager.js',\n    'eventRegistry.js',\n    'eventManager.js',\n    'themeManager.js',\n    'socketHandler.js',    // Load before progressHandler\n    'progressHandler.js',  // Load before UI\n    'ui.js',               // Load after its dependencies\n    'fileProcessor.js',\n    'webScraper.js',\n    'academicSearch.js'\n  ],\n  \n  // Module dependencies - inform moduleLoader about dependencies\n  // FIXED DEPENDENCIES to prevent circular refs\n  MODULE_DEPENDENCIES: {\n    'module-bridge.js': [],\n    'domUtils.js': [],\n    'errorHandler.js': [],\n    'uiRegistry.js': ['errorHandler.js'],\n    'stateManager.js': ['errorHandler.js'],\n    'eventRegistry.js': ['errorHandler.js'],\n    'eventManager.js': ['errorHandler.js', 'eventRegistry.js'],\n    'themeManager.js': ['errorHandler.js', 'uiRegistry.js'],\n    'socketHandler.js': ['errorHandler.js', 'domUtils.js', 'module-bridge.js'],\n    'progressHandler.js': ['errorHandler.js', 'domUtils.js', 'module-bridge.js', 'socketHandler.js'],\n    'ui.js': ['errorHandler.js', 'domUtils.js', 'module-bridge.js', 'uiRegistry.js'],\n    'fileProcessor.js': ['domUtils.js', 'module-bridge.js', 'progressHandler.js'],\n    'webScraper.js': ['domUtils.js', 'module-bridge.js', 'progressHandler.js'],\n    'academicSearch.js': ['module-bridge.js', 'domUtils.js', 'progressHandler.js']\n  },\n  \n  // Expected method exports for common modules to auto-create missing exports\n  MODULE_EXPORTS: {\n    'ui.js': ['showToast', 'showModal', 'hideModal', 'showLoadingSpinner', 'updateProgressBar', \n              'toggleElementVisibility', 'createElement', 'getElement', 'findElement'],\n    'progressHandler.js': ['trackProgress', 'updateProgressUI', 'setupTaskProgress', 'cancelTracking', \n                          'createProgressUI', 'updateTaskProgress', 'completeTask', 'errorTask'],\n    'socketHandler.js': ['connect', 'disconnect', 'emit', 'isConnected', 'startStatusPolling', \n                        'stopStatusPolling', 'cancelTask', 'registerTaskHandler'],\n    'domUtils.js': ['getElement', 'getElements', 'getUIElements', 'createElement', \n                   'addEventListeners', 'toggleElementVisibility']\n  },\n  \n  // Methods that can safely return a Promise when called before module is loaded\n  ASYNC_SAFE_METHODS: {\n    'ui.js': ['showModal', 'showToast', 'showLoadingSpinner', 'createProgressBar'],\n    'progressHandler.js': ['setupTaskProgress', 'trackProgress', 'cancelTracking'],\n    'socketHandler.js': ['connect', 'startStatusPolling', 'stopStatusPolling', 'cancelTask']\n  },\n  \n  // CIRCULAR DEPENDENCY BREAKERS\n  // Use these proxies to break circular dependencies\n  proxyHandlers: new Map(),\n  \n  // Exported module proxies for circular dependency resolution\n  moduleProxies: new Map(),\n  \n  /**\n   * Initialize the module types map\n   */\n  init() {\n    // Initialize MODULE_TYPES based on MODULE_LOCATIONS\n    Object.entries(this.MODULE_LOCATIONS).forEach(([file, location]) => {\n      const moduleName = file.replace(/\\.js$/, '');\n      this.MODULE_TYPES[moduleName] = location;\n    });\n    \n    // Create sets for tracking module state\n    this.failedModules = new Set();\n    this.fallbackModules = new Set();\n    this.loadingModules = new Set();\n    \n    // Initialize diagnostics data structure\n    this.diagnostics = {\n      totalModules: 0,\n      failedModules: [],\n      fallbacksUsed: [],\n      retries: {},\n      timestamp: new Date().toISOString(),\n      browser: navigator.userAgent,\n      moduleCache: []\n    };\n    \n    return true;\n  },\n  \n  /**\n   * Create a proxy for a module to break circular dependencies\n   * @param {string} moduleName - Name of the module to proxy\n   * @returns {Proxy} - Proxy object that will forward to the real module when loaded\n   */\n  createModuleProxy(moduleName) {\n    // Don't create duplicate proxies\n    if (this.moduleProxies.has(moduleName)) {\n      return this.moduleProxies.get(moduleName);\n    }\n    \n    // Track method calls that happen before the real module is loaded\n    const pendingCalls = [];\n    const pendingGetters = new Map();\n    \n    // Create a handler that will forward calls to the real module when it's loaded\n    const handler = {\n      get: (target, prop) => {\n        // If the real module is loaded, forward to it\n        if (target.__realModule) {\n          // Handle function calls by binding to the real module to preserve 'this'\n          if (typeof target.__realModule[prop] === 'function') {\n            return target.__realModule[prop].bind(target.__realModule);\n          }\n          return target.__realModule[prop];\n        }\n        \n        // Otherwise, return a function that records the call for later\n        if (typeof prop === 'string' && prop !== 'then') {\n          // Check if we already created a proxy for this property\n          if (pendingGetters.has(prop)) {\n            return pendingGetters.get(prop);\n          }\n          \n          // Create a proxy function that records the call\n          const proxyFn = (...args) => {\n            console.log(`[Proxy] Call to ${moduleName}.${prop} recorded for later execution`);\n            pendingCalls.push({ method: prop, args });\n            \n            // Determine if this method should return a promise\n            const asyncSafeMethods = this.ASYNC_SAFE_METHODS[`${moduleName}.js`] || [];\n            if (asyncSafeMethods.includes(prop)) {\n              return Promise.resolve(null);\n            }\n            return undefined;\n          };\n          \n          // Store the proxy function for reuse\n          pendingGetters.set(prop, proxyFn);\n          return proxyFn;\n        }\n        \n        // Handle Promise methods to make the proxy thenable\n        if (prop === 'then') {\n          // Return a function that resolves with the proxy itself\n          return (resolve) => {\n            if (resolve) resolve(target);\n            return Promise.resolve(target);\n          };\n        }\n        \n        return undefined;\n      },\n      \n      // Handle setting properties\n      set: (target, prop, value) => {\n        // If the real module is loaded, set properties on it\n        if (target.__realModule) {\n          target.__realModule[prop] = value;\n        } else {\n          // Otherwise, store pendingSetters for later\n          target.__pendingSetters = target.__pendingSetters || [];\n          target.__pendingSetters.push({ prop, value });\n        }\n        return true;\n      }\n    };\n    \n    // Create the proxy object with metadata\n    const proxy = new Proxy({ \n      __moduleName: moduleName,\n      __pendingCalls: pendingCalls,\n      __pendingGetters: pendingGetters,\n      __realModule: null,\n      __isProxy: true\n    }, handler);\n    \n    // Store the proxy handler for updating later\n    this.proxyHandlers.set(moduleName, {\n      proxy,\n      updateRealModule: (realModule) => {\n        // Update the real module reference\n        proxy.__realModule = realModule;\n        \n        // Apply any pending setters\n        if (proxy.__pendingSetters && proxy.__pendingSetters.length > 0) {\n          proxy.__pendingSetters.forEach(({ prop, value }) => {\n            try {\n              realModule[prop] = value;\n            } catch (e) {\n              console.error(`Error applying pending setter for ${moduleName}.${prop}:`, e);\n            }\n          });\n          proxy.__pendingSetters = [];\n        }\n        \n        // Execute all pending calls now that we have the real module\n        pendingCalls.forEach(call => {\n          if (typeof realModule[call.method] === 'function') {\n            try {\n              realModule[call.method](...call.args);\n            } catch (e) {\n              console.error(`Error executing pending call to ${moduleName}.${call.method}:`, e);\n            }\n          }\n        });\n        \n        // Clear pending calls\n        pendingCalls.length = 0;\n        \n        console.log(`[Proxy] Module ${moduleName} proxy updated with real implementation`);\n      }\n    });\n    \n    // Store the proxy for future use\n    this.moduleProxies.set(moduleName, proxy);\n    \n    // Make available globally for module-bridge access if in debug mode\n    if (this.debugMode) {\n      window.__moduleProxies = this.moduleProxies;\n    }\n    \n    return proxy;\n  },\n  \n  /**\n   * Update a module proxy with the real module\n   * @param {string} moduleName - Name of the module to update\n   * @param {Object} realModule - The real module implementation\n   */\n  updateModuleProxy(moduleName, realModule) {\n    const handler = this.proxyHandlers.get(moduleName);\n    if (handler) {\n      handler.updateRealModule(realModule);\n      \n      // If this module has a bridge updater, use it\n      this.integrateWithBridge(moduleName, realModule);\n    }\n  },\n  \n  /**\n   * Integrate with module bridge to handle circular dependencies\n   * @param {string} moduleName - Module name\n   * @param {Object} moduleExport - Module export object\n   */\n  integrateWithBridge(moduleName, moduleExport) {\n    if (!moduleName || !moduleExport) return;\n    \n    try {\n      // Import the bridge module only when needed to avoid circular dependencies\n      import('./module-bridge.js').then(bridge => {\n        const cleanName = this.getModuleName(moduleName);\n        \n        // Update appropriate bridge based on module name\n        switch (cleanName) {\n          case 'ui':\n            if (typeof bridge.updateUIBridge === 'function') {\n              bridge.updateUIBridge(moduleExport, { source: 'moduleLoader' });\n              console.log(\"UI bridge updated with real implementation\");\n            }\n            break;\n          case 'progressHandler':\n            if (typeof bridge.updateProgressHandlerBridge === 'function') {\n              bridge.updateProgressHandlerBridge(moduleExport, { source: 'moduleLoader' });\n              console.log(\"ProgressHandler bridge updated with real implementation\");\n            }\n            break;\n          case 'socketHandler':\n            if (typeof bridge.updateSocketHandlerBridge === 'function') {\n              bridge.updateSocketHandlerBridge(moduleExport, { source: 'moduleLoader' });\n              console.log(\"SocketHandler bridge updated with real implementation\");\n            }\n            break;\n          default:\n            // No bridge integration needed for this module\n            break;\n        }\n      }).catch(error => {\n        console.warn(`Error integrating ${moduleName} with bridge:`, error);\n      });\n    } catch (error) {\n      console.warn(`Error importing bridge for module ${moduleName}:`, error);\n    }\n  },\n  \n  /**\n   * Initialize the module loader\n   * @param {Object} options - Initialization options\n   * @returns {boolean} - Whether initialization was successful\n   */\n  initialize(options = {}) {\n    console.log('Initializing module loader...');\n    \n    if (this.initialized) {\n      console.warn('Module loader already initialized');\n      return true;\n    }\n    \n    // Create proxies for modules that are involved in circular dependencies\n    this.createProxiesForCircularDependencies();\n    \n    // Initialize module types mapping\n    this.init();\n    \n    // Configure with options\n    this.configure(options);\n    \n    // Check browser support for ES modules\n    if (!this.supportsESModules()) {\n      console.error('Browser does not support ES modules');\n      this.showErrorMessage('Your browser does not support modern JavaScript modules. Please upgrade to a newer browser.');\n      return false;\n    }\n    \n    // Expose loader to window for debugging\n    if (this.debugMode) {\n      window.moduleLoader = this;\n    }\n    \n    // Mark as initialized\n    this.initialized = true;\n    \n    // Start collecting diagnostics\n    this.startDiagnostics();\n    \n    return true;\n  },\n  \n  /**\n   * Configure the module loader\n   * @param {Object} options - Configuration options\n   */\n  configure(options = {}) {\n    // Update debug mode\n    if (options.debugMode !== undefined) {\n      this.debugMode = !!options.debugMode;\n    }\n    \n    // Update verbose logging\n    if (options.verboseLogging !== undefined) {\n      this.verboseLogging = !!options.verboseLogging;\n    }\n    \n    // Update default options\n    if (options.defaultOptions) {\n      this.defaultOptions = {\n        ...this.defaultOptions,\n        ...options.defaultOptions\n      };\n    }\n    \n    // Update other configuration options as needed\n    // ...\n  },\n  \n  /**\n   * Create proxies for modules involved in circular dependencies\n   */\n  createProxiesForCircularDependencies() {\n    // Create proxies for modules that typically cause circular dependencies\n    this.createModuleProxy('ui');\n    this.createModuleProxy('progressHandler');\n    this.createModuleProxy('socketHandler');\n    this.createModuleProxy('uiRegistry');\n    this.createModuleProxy('fileProcessor');\n    this.createModuleProxy('webScraper');\n    this.createModuleProxy('academicSearch');\n    this.createModuleProxy('domUtils');\n    \n    console.log('Created proxies for circular dependency resolution');\n  },\n  \n  /**\n   * Start collecting diagnostics information\n   */\n  startDiagnostics() {\n    this.diagnostics = {\n      totalModules: 0,\n      failedModules: [],\n      fallbacksUsed: [],\n      retries: {},\n      timestamp: new Date().toISOString(),\n      browser: navigator.userAgent,\n      moduleCache: []\n    };\n  },\n  \n  /**\n   * Generate a diagnostic report for troubleshooting\n   * @returns {Object} - Diagnostic report\n   */\n  generateDiagnosticsReport() {\n    // Add cached modules to diagnostics\n    this.diagnostics.moduleCache = Array.from(this.cache.keys());\n    \n    // Add failed modules\n    this.diagnostics.failedModules = Array.from(this.failedModules);\n    \n    // Return the complete report\n    return {\n      ...this.diagnostics,\n      timestamp: new Date().toISOString(),\n      status: this.failedModules.size > 0 ? 'issues' : 'ok',\n      initialized: this.initialized,\n      moduleSystemHealth: this.initialized ? 'ok' : 'error',\n      totalModules: this.cache.size\n    };\n  },\n  \n  /**\n   * Create a diagnostics button for easy debugging\n   */\n  createDiagnosticsButton() {\n    // Check if button already exists\n    if (document.getElementById('module-diagnostics-btn')) {\n      return;\n    }\n    \n    // Create button\n    const button = document.createElement('button');\n    button.id = 'module-diagnostics-btn';\n    button.className = 'btn btn-info position-fixed bottom-0 start-0 m-3';\n    button.innerHTML = '<i class=\"fas fa-stethoscope me-2\"></i>Module Diagnostics';\n    button.style.zIndex = '9999';\n    button.style.borderRadius = '4px';\n    button.style.padding = '8px 16px';\n    button.style.fontSize = '14px';\n    button.style.opacity = '0.7';\n    \n    // Add hover effect\n    button.addEventListener('mouseenter', () => {\n      button.style.opacity = '1';\n    });\n    \n    button.addEventListener('mouseleave', () => {\n      button.style.opacity = '0.7';\n    });\n    \n    // Add click handler\n    button.addEventListener('click', () => {\n      this.launchDiagnostics();\n    });\n    \n    // Add to document\n    document.body.appendChild(button);\n  },\n  \n  /**\n     * Launch diagnostics tool\n     */\n  launchDiagnostics() {\n    // Generate report\n    const report = this.generateDiagnosticsReport();\n    console.log(\"Module Diagnostics Report:\", report);\n    \n    // Try to show a dialog with this information\n    if (window.ui && typeof window.ui.showModal === 'function') {\n      let reportContent = `<h5>System Health Report</h5>\n      <div class=\"mb-3\">\n        <p><strong>Status:</strong> <span class=\"badge ${report.status === 'ok' ? 'bg-success' : 'bg-warning'}\">${report.status}</span></p>\n        <p><strong>App Initialized:</strong> ${window.appInitialized ? 'Yes' : 'No'}</p>\n        <p><strong>Module System Health:</strong> ${report.moduleSystemHealth}</p>\n        <p><strong>Timestamp:</strong> ${report.timestamp}</p>\n      </div>\n      <h6>Loaded Modules (${report.moduleCache.length})</h6>\n      <div class=\"small overflow-auto\" style=\"max-height: 150px;\">\n        <ul class=\"small\">\n          ${report.moduleCache.map(m => `<li>${m}</li>`).join('')}\n        </ul>\n      </div>`;\n      \n      if (report.failedModules && report.failedModules.length > 0) {\n        reportContent += `<h6 class=\"text-danger\">Failed Modules (${report.failedModules.length})</h6>\n        <div class=\"small overflow-auto\" style=\"max-height: 100px;\">\n          <ul class=\"small text-danger\">\n            ${report.failedModules.map(m => `<li>${m}</li>`).join('')}\n          </ul>\n        </div>`;\n      }\n      \n      if (report.fallbacksUsed && report.fallbacksUsed.length > 0) {\n        reportContent += `<h6 class=\"text-warning\">Using Fallbacks (${report.fallbacksUsed.length})</h6>\n        <div class=\"small overflow-auto\" style=\"max-height: 100px;\">\n          <ul class=\"small text-warning\">\n            ${report.fallbacksUsed.map(m => `<li>${m}</li>`).join('')}\n          </ul>\n        </div>`;\n      }\n      \n      window.ui.showModal({\n        title: 'Module Diagnostics',\n        content: reportContent,\n        size: 'large',\n        buttons: [\n          {\n            text: 'Close',\n            type: 'btn-secondary'\n          },\n          {\n            text: 'Copy Report',\n            type: 'btn-primary',\n            handler: () => {\n              try {\n                navigator.clipboard.writeText(JSON.stringify(report, null, 2));\n                window.ui.showToast('Success', 'Report copied to clipboard', 'success');\n              } catch (e) {\n                console.error('Failed to copy report:', e);\n                window.ui.showToast('Error', 'Failed to copy report', 'error');\n              }\n            }\n          },\n          {\n            text: 'Fix Failed Modules',\n            type: 'btn-warning',\n            handler: () => {\n              this.fixFailedModules();\n              window.ui.showToast('Info', 'Failed modules have been reset', 'info');\n              setTimeout(() => {\n                this.launchDiagnostics();\n              }, 500);\n            }\n          }\n        ]\n      });\n    } else {\n      alert(\"Module Diagnostics Report - see console for details\");\n    }\n  },\n\n  /**\n   * Display a health report indicator in UI\n   */\n  showModuleHealth() {\n    const moduleHealthContainer = document.createElement('div');\n    moduleHealthContainer.id = 'module-health-container';\n    moduleHealthContainer.className = 'position-fixed top-0 end-0 p-3';\n    moduleHealthContainer.style.zIndex = '9999';\n    \n    const failedCount = this.failedModules.size;\n    const fallbackCount = this.fallbackModules.size;\n    \n    const statusClass = failedCount > 0 ? 'bg-danger' : \n                        fallbackCount > 0 ? 'bg-warning' : 'bg-success';\n    \n    moduleHealthContainer.innerHTML = `\n      <div class=\"module-health-indicator ${statusClass}\" style=\"padding: 8px 16px; border-radius: 4px; display: inline-block; cursor: pointer;\">\n        <i class=\"fas fa-cogs me-2\"></i>\n        <span>Modules: ${failedCount > 0 ? `${failedCount} Failed` : \n                        fallbackCount > 0 ? `${fallbackCount} Fallbacks` : 'Healthy'}</span>\n      </div>\n    `;\n    \n    // Add click handler\n    moduleHealthContainer.querySelector('.module-health-indicator').addEventListener('click', () => {\n      this.launchDiagnostics();\n    });\n    \n    document.body.appendChild(moduleHealthContainer);\n    \n    return moduleHealthContainer;\n  },\n\n  /**\n   * Apply stored theme to the document\n   */\n  applyStoredTheme() {\n    const storedTheme = localStorage.getItem('theme') || 'light';\n    document.documentElement.setAttribute('data-theme', storedTheme);\n    document.body.setAttribute('data-theme', storedTheme);\n    document.documentElement.setAttribute('data-bs-theme', storedTheme);\n\n    // Set theme toggle icon\n    const darkModeToggle = document.getElementById('darkModeToggle');\n    if (darkModeToggle) {\n      const isDark = storedTheme === 'dark';\n      darkModeToggle.innerHTML = isDark ? \n        '<i class=\"fas fa-sun fa-lg\"></i>' : \n        '<i class=\"fas fa-moon fa-lg\"></i>';\n      darkModeToggle.title = isDark ? 'Switch to light mode' : 'Switch to dark mode';\n    }\n  },\n\n  /**\n   * Set up basic tab navigation for the application\n   */\n  setupBasicTabNavigation() {\n    // If already set up, don't do it again\n    if (window._tabNavigationSetup) return;\n    \n    document.addEventListener('click', function(event) {\n      if (event.target.hasAttribute('data-bs-toggle') &&\n          event.target.getAttribute('data-bs-toggle') === 'tab') {\n        event.preventDefault();\n        const tabEl = event.target.closest('[data-bs-toggle=\"tab\"]');\n        if (!tabEl) return;\n        const target = tabEl.getAttribute('data-bs-target') || tabEl.getAttribute('href');\n        if (!target) return;\n        \n        // Deactivate all tabs\n        document.querySelectorAll('.nav-link').forEach(tab => tab.classList.remove('active'));\n        document.querySelectorAll('.tab-pane').forEach(pane => {\n          pane.classList.remove('active');\n          pane.classList.remove('show');\n        });\n        \n        // Activate selected tab\n        tabEl.classList.add('active');\n        const targetPane = document.querySelector(target);\n        if (targetPane) {\n          targetPane.classList.add('active');\n          targetPane.classList.add('show');\n        }\n      }\n    });\n    \n    window._tabNavigationSetup = true;\n  },\n\n  /**\n   * Show an error message to the user\n   * @param {string} message - The error message to display\n   */\n  showErrorMessage(message) {\n    console.error(message);\n    \n    // Try to use error handler if available\n    if (window.errorHandler && typeof window.errorHandler.showError === 'function') {\n      window.errorHandler.showError(message);\n      return;\n    }\n    \n    // Try to use UI module if available\n    const uiModule = window.ui || window.moduleInstances?.ui;\n    if (uiModule && typeof uiModule.showToast === 'function') {\n      uiModule.showToast('Error', message, 'error');\n      return;\n    }\n    \n    // Fallback to error container\n    let errorContainer = document.getElementById('app-loading-error');\n    if (!errorContainer) {\n      errorContainer = document.createElement('div');\n      errorContainer.id = 'app-loading-error';\n      errorContainer.className = 'alert alert-danger m-3';\n      document.body.appendChild(errorContainer);\n    }\n    \n    errorContainer.textContent = message;\n    errorContainer.style.display = 'block';\n  },\n\n  /**\n   * Check if browser supports ES modules\n   * @returns {boolean} - Whether the browser supports ES modules\n   */\n  supportsESModules() {\n    try {\n      new Function('import(\"\")');\n      return true;\n    } catch (err) {\n      console.error(\"Browser doesn't support ES modules\", err);\n      return false;\n    }\n  },\n\n  /**\n   * Clean module path by removing numbers at the end and normalizing\n   * @param {string} path - The module path\n   * @returns {string} - Cleaned path\n   */\n  cleanModulePath(path) {\n    if (!path) return '';\n    \n    // Remove any trailing numbers (e.g. \"ui.js 2\" becomes \"ui.js\")\n    return path.replace(/\\s+\\d+$/, '');\n  },\n\n  /**\n   * Normalize path for consistent caching\n   * @param {string} path - The path to normalize\n   * @returns {string} - Normalized path\n   */\n  getNormalizedPath(path) {\n    if (!path) return '';\n    \n    // First clean the path by removing any trailing numbers (e.g., \"ui.js 2\" -> \"ui.js\")\n    const cleanPath = this.cleanModulePath(path);\n    // Then strip query params and normalize slashes\n    return cleanPath.split('?')[0].replace(/\\/+/g, '/');\n  },\n\n  /**\n   * Enhanced path resolution with improved handling for different path formats\n   * @param {string} modulePath - The requested module path\n   * @returns {string} - The resolved path\n   */\n  resolvePath(modulePath) {\n    if (!modulePath) return '';\n    \n    // Clean the path first to remove any trailing numbers\n    const cleanPath = this.cleanModulePath(modulePath);\n    \n    // Log for debugging if in verbose mode\n    if (this.verboseLogging) {\n      console.log(\"Resolving path:\", cleanPath);\n    }\n    \n    // Handle empty or invalid paths\n    if (!cleanPath || typeof cleanPath !== 'string') {\n      return '';\n    }\n    \n    // If the path already starts with http or /, it's absolute\n    if (cleanPath.startsWith('http') || cleanPath.startsWith('/')) {\n      return cleanPath;\n    }\n    \n    // Check for direct path override\n    if (this.PATH_OVERRIDES[cleanPath]) {\n      return this.PATH_OVERRIDES[cleanPath];\n    }\n    \n    // Handle relative paths starting with ./\n    if (cleanPath.startsWith('./')) {\n      // Extract the module name from the relative path\n      const parts = cleanPath.split('/');\n      const moduleName = parts[parts.length - 1];\n      const moduleNameNoExt = moduleName.replace(/\\.js$/, '');\n      \n      // First check if this is a direct module we know\n      if (this.MODULE_LOCATIONS[moduleName]) {\n        const location = this.MODULE_LOCATIONS[moduleName];\n        return `/static/js/modules/${location}/${moduleName}`;\n      }\n      \n      // Also check without .js extension\n      if (this.MODULE_TYPES[moduleNameNoExt]) {\n        const location = this.MODULE_TYPES[moduleNameNoExt];\n        return `/static/js/modules/${location}/${moduleNameNoExt}.js`;\n      }\n      \n      // Handle module paths that include subfolders\n      if (parts.length >= 3) {\n        // For paths like ./modules/core/uiRegistry.js\n        if (parts[1] === 'modules') {\n          return `/static/js/${cleanPath.substring(2)}`; // Remove './' from start\n        }\n      }\n    }\n    \n    // Special handling for direct module names (without path)\n    if (!cleanPath.includes('/')) {\n      const moduleBase = cleanPath.endsWith('.js') ? cleanPath : `${cleanPath}.js`;\n      const location = this.MODULE_LOCATIONS[moduleBase];\n      \n      if (location) {\n        return `/static/js/modules/${location}/${moduleBase}`;\n      }\n      \n      // Try without .js extension\n      const moduleNameNoExt = cleanPath.replace(/\\.js$/, '');\n      const locationType = this.MODULE_TYPES[moduleNameNoExt];\n      \n      if (locationType) {\n        return `/static/js/modules/${locationType}/${moduleNameNoExt}.js`;\n      }\n    }\n    \n    // For relative paths within modules (../../module)\n    if (cleanPath.startsWith('../')) {\n      // Extract directory and filename\n      const parts = cleanPath.split('/');\n      const targetDir = parts[1]; // 'core', 'features', or 'utils'\n      const filename = parts[2];\n      \n      if (targetDir && filename) {\n        return `/static/js/modules/${targetDir}/${filename}`;\n      }\n    }\n    \n    // Handle paths that start with 'modules/' - convert to absolute path\n    if (cleanPath.startsWith('modules/')) {\n      return '/static/js/' + cleanPath;\n    }\n    \n    // For paths from index.js to modules, ensure they're properly resolved\n    if (cleanPath.startsWith('./modules/')) {\n      // Extract the module type and name\n      const parts = cleanPath.split('/');\n      if (parts.length >= 3) {\n        const moduleType = parts[2]; // core, features, utils\n        const moduleName = parts[parts.length - 1];\n        \n        // Handle both direct imports (./modules/core/uiRegistry.js) and modules folders imports\n        if (moduleType === 'core' || moduleType === 'features' || moduleType === 'utils') {\n          return '/static/js' + cleanPath.substring(1);\n        }\n        \n        // Check if the module name is in MODULE_LOCATIONS\n        if (moduleName && moduleName.endsWith('.js')) {\n          const location = this.MODULE_LOCATIONS[moduleName];\n          if (location) {\n            return `/static/js/modules/${location}/${moduleName}`;\n          }\n        }\n      }\n      \n      // If we can't resolve it more specifically, convert to absolute path\n      return '/static/js' + cleanPath.substring(1);\n    }\n    \n    // For core paths starting with /static/js/modules/\n    if (cleanPath.includes('/static/js/modules/')) {\n      return cleanPath;\n    }\n    \n    // Try to extract module name from the path\n    const lastSlashIndex = cleanPath.lastIndexOf('/');\n    if (lastSlashIndex !== -1) {\n      const moduleName = cleanPath.substring(lastSlashIndex + 1);\n      if (moduleName.endsWith('.js')) {\n        const location = this.MODULE_LOCATIONS[moduleName];\n        if (location) {\n          return `/static/js/modules/${location}/${moduleName}`;\n        }\n      }\n    }\n    \n    // For a simple path like 'ui.js', try to resolve it using MODULE_LOCATIONS\n    if (cleanPath.endsWith('.js')) {\n      const location = this.MODULE_LOCATIONS[cleanPath];\n      if (location) {\n        return `/static/js/modules/${location}/${cleanPath}`;\n      }\n    }\n    \n    // For module name without extension\n    const moduleNameNoExt = cleanPath.replace(/\\.js$/, '');\n    const locationType = this.MODULE_TYPES[moduleNameNoExt];\n    if (locationType) {\n      return `/static/js/modules/${locationType}/${moduleNameNoExt}.js`;\n    }\n    \n    // Default return the path unchanged\n    return cleanPath;\n  },\n\n  /**\n   * Add missing exports to a module based on expectations\n   * @param {Object} module - The loaded module\n   * @param {string} moduleName - The name of the module\n   * @returns {Object} - Module with standardized exports\n   */\n  autoCreateMissingExports(module, moduleName) {\n    if (!module || !moduleName) return module;\n    \n    // Skip if not a known module\n    if (!this.MODULE_EXPORTS[moduleName]) return module;\n    \n    const expectedExports = this.MODULE_EXPORTS[moduleName];\n    \n    // Create a new object to avoid modifying the original module\n    const result = { ...module };\n    \n    // Get the module object, either from default export or the module itself\n    const moduleObj = module.default || module;\n    \n    if (!moduleObj) {\n      if (this.verboseLogging) {\n        console.warn(`Module ${moduleName} has no default export or direct exports`);\n      }\n      return module;\n    }\n    \n    // Check for each expected export and add stub if missing\n    for (const exportName of expectedExports) {\n      // If the export already exists directly in the result, skip it\n      if (typeof result[exportName] === 'function') continue;\n      \n      // If the export exists in the module object but not directly in result, add it\n      if (typeof moduleObj[exportName] === 'function') {\n        result[exportName] = moduleObj[exportName].bind(moduleObj);\n      } else {\n        // Create a stubbed function that logs when called\n        if (this.verboseLogging) {\n          console.warn(`Adding missing export ${exportName} to module ${moduleName}`);\n        }\n        \n        result[exportName] = function(...args) {\n          console.warn(`Stub function ${moduleName}.${exportName} called with:`, args);\n          return null;\n        };\n      }\n    }\n    \n    return result;\n  },\n\n  /**\n   * Extract module name from path\n   * @param {string} path - Module path\n   * @returns {string} - Module name\n   */\n  getModuleName(path) {\n    if (!path) return '';\n    \n    try {\n      // Handle both file paths and module names\n      const parts = path.split('/');\n      const filename = parts[parts.length - 1];\n      \n      // Clean up any numbered imports (e.g. \"filename.js 2\")\n      const cleanFilename = this.cleanModulePath(filename);\n      \n      // Remove file extension if present\n      return cleanFilename.replace(/\\.js$/, '');\n    } catch (error) {\n      console.error(`Error getting module name for ${path}:`, error);\n      return path;\n    }\n  },\n\n  /**\n   * Check for duplicate function declarations in a module's code\n   * This can be used to fix the common \"redeclaration of function\" SyntaxError\n   * @param {string} modulePath - Path to the module\n   * @returns {Promise<{hasDuplicates: boolean, duplicateFunctions: Array<string>}>} Results of check\n   */\n  async checkForDuplicateFunctions(modulePath) {\n    try {\n      // Fetch the module content\n      const response = await fetch(modulePath);\n      if (!response.ok) {\n        throw new Error(`Failed to fetch module at ${modulePath}: ${response.status}`);\n      }\n      \n      const code = await response.text();\n      \n      // Find all function declarations\n      const functionDeclarations = new Map();\n      const duplicates = [];\n      \n      // First look for regular function declarations: function name() {}\n      const functionRegex = /function\\s+([a-zA-Z0-9_$]+)\\s*\\(/g;\n      let match;\n      \n      while ((match = functionRegex.exec(code)) !== null) {\n        const functionName = match[1];\n        \n        if (functionDeclarations.has(functionName)) {\n          duplicates.push({\n            name: functionName,\n            firstPosition: functionDeclarations.get(functionName),\n            secondPosition: match.index,\n            type: 'function declaration'\n          });\n        } else {\n          functionDeclarations.set(functionName, match.index);\n        }\n      }\n      \n      // Also check for class method declarations that might conflict\n      const classMethodRegex = /(?:class\\s+[a-zA-Z0-9_$]+\\s*\\{[^}]*|\\{)\\s*([a-zA-Z0-9_$]+)\\s*\\(/g;\n      functionRegex.lastIndex = 0; // Reset regex index\n      \n      while ((match = classMethodRegex.exec(code)) !== null) {\n        const methodName = match[1];\n        \n        // Skip constructor and common non-conflicting methods\n        if (methodName === 'constructor' || methodName === 'toString' || methodName === 'valueOf') {\n          continue;\n        }\n        \n        if (functionDeclarations.has(methodName)) {\n          duplicates.push({\n            name: methodName,\n            firstPosition: functionDeclarations.get(methodName),\n            secondPosition: match.index,\n            type: 'class method conflict'\n          });\n        }\n      }\n      \n      // Check for arrow functions assigned to variables that might conflict\n      const arrowFunctionRegex = /const\\s+([a-zA-Z0-9_$]+)\\s*=\\s*(?:\\([^)]*\\)|[a-zA-Z0-9_$]+)\\s*=>/g;\n      \n      while ((match = arrowFunctionRegex.exec(code)) !== null) {\n        const functionName = match[1];\n        \n        if (functionDeclarations.has(functionName)) {\n          duplicates.push({\n            name: functionName,\n            firstPosition: functionDeclarations.get(functionName),\n            secondPosition: match.index,\n            type: 'arrow function conflict'\n          });\n        }\n      }\n      \n      return {\n        hasDuplicates: duplicates.length > 0,\n        duplicateFunctions: duplicates,\n        modulePath\n      };\n    } catch (error) {\n      console.error(`Error checking for duplicate functions in ${modulePath}:`, error);\n      return {\n        hasDuplicates: false,\n        duplicateFunctions: [],\n        error: error.message,\n        modulePath\n      };\n    }\n  },\n\n  /**\n   * Create a fallback for any type of module\n   * @param {string} moduleName - The name of the module\n   * @returns {Object} - A fallback implementation\n   */\n  createFallbackModule(moduleName) {\n    if (!moduleName) {\n      console.error('Cannot create fallback for undefined module name');\n      return {\n        __isFallback: true,\n        initialize() { return Promise.resolve(true); }\n      };\n    }\n    \n    console.warn(`Creating fallback for module ${moduleName}`);\n    \n    // Record this fallback creation in diagnostics\n    this.fallbackModules.add(moduleName);\n    this.diagnostics.fallbacksUsed.push(moduleName);\n    \n    // Determine module type based on name or location\n    let moduleType = 'unknown';\n    \n    // Check using different methods to be thorough\n    if (this.MODULE_TYPES[moduleName]) {\n      moduleType = this.MODULE_TYPES[moduleName];\n    } else if (moduleName.endsWith('.js')) {\n      const fileName = moduleName;\n      if (this.MODULE_LOCATIONS[fileName]) {\n        moduleType = this.MODULE_LOCATIONS[fileName];\n      }\n    } else {\n      // Check if it's in MODULE_LOCATIONS with .js extension\n      if (this.MODULE_LOCATIONS[`${moduleName}.js`]) {\n        moduleType = this.MODULE_LOCATIONS[`${moduleName}.js`];\n      }\n    }\n    \n    // Create different types of fallbacks based on module type\n    let fallback;\n    \n    switch (moduleType) {\n      case 'core':\n        fallback = this.createCoreFallback(moduleName);\n        break;\n      \n      case 'features':\n        fallback = this.createFeatureFallback(moduleName);\n        break;\n        \n      case 'utils':\n        fallback = this.createUtilityFallback(moduleName);\n        break;\n        \n      default:\n        // Generic fallback for unknown module types\n        fallback = {\n          __isFallback: true,\n          moduleName,\n          error: 'Module type unknown, using generic fallback',\n          \n          initialize() {\n            console.warn(`Using generic fallback implementation for ${moduleName}`);\n            return Promise.resolve(true);\n          }\n        };\n    }\n    \n    // Return a proxy to handle missing methods dynamically\n    return new Proxy(fallback, this.createPromiseAwareProxyHandler(moduleName));\n  },\n\n  /**\n   * Create a proxy handler that gracefully handles promise methods\n   * @param {string} moduleName - Name of the module\n   * @returns {Object} - Proxy handler\n   */\n  createPromiseAwareProxyHandler(moduleName) {\n    return {\n      get: (target, prop) => {\n        // Return the property if it exists\n        if (prop in target) return target[prop];\n        \n        // Special handling for then/catch/finally to make it Promise-compatible\n        if (prop === 'then' || prop === 'catch' || prop === 'finally') {\n          // Return a function that returns a resolved promise to allow chaining\n          return function(...args) {\n            // If this is 'then', call the first callback with the target as \"this\"\n            if (prop === 'then' && typeof args[0] === 'function') {\n              try {\n                return Promise.resolve(args[0](target));\n              } catch (e) {\n                return Promise.reject(e);\n              }\n            }\n            return Promise.resolve(target);\n          };\n        }\n        \n        // Check if this method is in the ASYNC_SAFE_METHODS list\n        const asyncSafeMethods = this.ASYNC_SAFE_METHODS[`${moduleName}.js`] || [];\n        const isAsyncSafe = asyncSafeMethods.includes(String(prop));\n        \n        // For functions, create a fallback function\n        if (typeof prop === 'string' && !prop.startsWith('_')) {\n          return function(...args) {\n            console.warn(`[Fallback ${moduleName}] ${String(prop)} called with args:`, args);\n            \n            // Return a promise for async-safe methods\n            if (isAsyncSafe) {\n              return Promise.resolve(null);\n            }\n            \n            // Return null for regular methods\n            return null;\n          };\n        }\n        \n        return undefined;\n      }\n    };\n  },\n\n  /**\n   * Create a fallback for core modules\n   * @param {string} moduleName - The name of the module\n   * @returns {Object} - A fallback implementation\n   */\n  createCoreFallback(moduleName) {\n    // Use consistent naming without .js extension\n    const cleanName = moduleName.replace(/\\.js$/, '');\n    \n    // Basic fallback that all modules share\n    const baseFallback = {\n      __isFallback: true,\n      moduleName: cleanName,\n      initialized: false,\n      \n      initialize() {\n        console.warn(`Using fallback implementation for core module: ${cleanName}`);\n        this.initialized = true;\n        return Promise.resolve(true);\n      }\n    };\n    \n    // Add module-specific fallbacks for core modules\n    switch (cleanName) {\n      case 'errorHandler':\n        return {\n          ...baseFallback,\n          errorHistory: [],\n          \n          handleError(error) {\n            console.error('Fallback error handler:', error);\n            return true;\n          },\n          \n          showError(message) {\n            console.error('Fallback error display:', message);\n            \n            // Try to find error container\n            const errorContainer = document.getElementById('app-error-container');\n            if (errorContainer) {\n              errorContainer.innerHTML = `\n                <div class=\"alert alert-danger\">\n                  <h5>Error</h5>\n                  <p>${message}</p>\n                </div>\n              `;\n              errorContainer.style.display = 'block';\n            } else {\n              alert(message);\n            }\n            \n            return true;\n          },\n          \n          showSuccess(message) {\n            console.log('Fallback success display:', message);\n            return true;\n          },\n          \n          setupGlobalErrorHandler() {\n            // Set up window error handler\n            window.onerror = (message, source, lineno, colno, error) => {\n              this.handleError(error || message);\n              return true;\n            };\n            \n            // Set up unhandled promise rejection handler\n            window.addEventListener('unhandledrejection', (event) => {\n              this.handleError(event.reason || 'Unhandled promise rejection');\n            });\n            \n            console.log('Global error handlers set up');\n            return true;\n          }\n        };\n        \n      case 'uiRegistry':\n        return {\n          ...baseFallback,\n          elements: new Map(),\n          \n          getElement(id) {\n            console.warn(`Fallback uiRegistry.getElement called for ${id}`);\n            return document.getElementById(id);\n          },\n          \n          registerElement(id, element) {\n            this.elements.set(id, element);\n            return true;\n          },\n          \n          registerElements(elements) {\n            if (!elements || typeof elements !== 'object') return false;\n            Object.entries(elements).forEach(([id, element]) => {\n              this.registerElement(id, element);\n            });\n            return true;\n          },\n          \n          updateElement(id, content) {\n            const element = this.getElement(id);\n            if (element) {\n              if (typeof content === 'string') {\n                element.innerHTML = content;\n              } else if (content instanceof Node) {\n                element.innerHTML = '';\n                element.appendChild(content);\n              }\n              return true;\n            }\n            return false;\n          },\n          \n          setElementVisibility(id, visible) {\n            const element = this.getElement(id);\n            if (element) {\n              element.style.display = visible ? '' : 'none';\n              return true;\n            }\n            return false;\n          }\n        };\n        \n      case 'eventRegistry':\n        return {\n          ...baseFallback,\n          events: new Map(),\n          handlers: new Map(),\n          \n          on(eventName, handler) {\n            if (!this.handlers.has(eventName)) {\n              this.handlers.set(eventName, new Set());\n            }\n            this.handlers.get(eventName).add(handler);\n            return true;\n          },\n          \n          off(eventName, handler) {\n            if (this.handlers.has(eventName)) {\n              if (handler) {\n                this.handlers.get(eventName).delete(handler);\n              } else {\n                this.handlers.delete(eventName);\n              }\n              return true;\n            }\n            return false;\n          },\n          \n          emit(eventName, ...args) {\n            if (this.handlers.has(eventName)) {\n              this.handlers.get(eventName).forEach(handler => {\n                try {\n                  handler(...args);\n                } catch (error) {\n                  console.error(`Error in event handler for ${eventName}:`, error);\n                }\n              });\n              return true;\n            }\n            return false;\n          },\n          \n          reset() {\n            this.handlers.clear();\n            return true;\n          }\n        };\n        \n        case 'stateManager':\n          return {\n            ...baseFallback,\n            state: {},\n            subscribers: new Map(),\n            \n            getState(key) {\n              return key ? this.state[key] : { ...this.state };\n            },\n            \n            setState(updates) {\n              if (!updates || typeof updates !== 'object') return false;\n              \n              const changedKeys = [];\n              \n              Object.entries(updates).forEach(([key, value]) => {\n                if (this.state[key] !== value) {\n                  this.state[key] = value;\n                  changedKeys.push(key);\n                }\n              });\n              \n              // Notify subscribers\n              changedKeys.forEach(key => {\n                if (this.subscribers.has(key)) {\n                  this.subscribers.get(key).forEach(callback => {\n                    try {\n                      callback(this.state[key]);\n                    } catch (error) {\n                      console.error(`Error in state subscriber for ${key}:`, error);\n                    }\n                  });\n                }\n              });\n              \n              return true;\n            },\n            \n            subscribe(key, callback) {\n              if (!this.subscribers.has(key)) {\n                this.subscribers.set(key, new Set());\n              }\n              this.subscribers.get(key).add(callback);\n              \n              // Return unsubscribe function\n              return () => {\n                if (this.subscribers.has(key)) {\n                  this.subscribers.get(key).delete(callback);\n                }\n              };\n            }\n          };\n          \n        case 'themeManager':\n          return {\n            ...baseFallback,\n            currentTheme: 'light',\n            \n            setTheme(theme) {\n              if (theme !== 'light' && theme !== 'dark') {\n                theme = 'light';\n              }\n              \n              this.currentTheme = theme;\n              document.documentElement.setAttribute('data-theme', theme);\n              document.body.setAttribute('data-theme', theme);\n              localStorage.setItem('theme', theme);\n              \n              // Update toggle button if exists\n              const darkModeToggle = document.getElementById('darkModeToggle');\n              if (darkModeToggle) {\n                darkModeToggle.innerHTML = theme === 'dark' ? \n                  '<i class=\"fas fa-sun fa-lg\"></i>' : \n                  '<i class=\"fas fa-moon fa-lg\"></i>';\n              }\n              \n              return true;\n            },\n            \n            toggleTheme() {\n              const newTheme = this.currentTheme === 'light' ? 'dark' : 'light';\n              return this.setTheme(newTheme);\n            },\n            \n            getCurrentTheme() {\n              return this.currentTheme;\n            }\n          };\n          \n        case 'eventManager':\n          return {\n            ...baseFallback,\n            eventRegistry: null,\n            delegatedEvents: new Map(),\n            \n            setEventRegistry(registry) {\n              this.eventRegistry = registry;\n              return true;\n            },\n            \n            on(eventName, handler) {\n              if (this.eventRegistry && typeof this.eventRegistry.on === 'function') {\n                return this.eventRegistry.on(eventName, handler);\n              }\n              \n              console.warn(`Fallback eventManager.on called for ${eventName}`);\n              return false;\n            },\n            \n            off(eventName, handler) {\n              if (this.eventRegistry && typeof this.eventRegistry.off === 'function') {\n                return this.eventRegistry.off(eventName, handler);\n              }\n              \n              console.warn(`Fallback eventManager.off called for ${eventName}`);\n              return false;\n            },\n            \n            emit(eventName, ...args) {\n              if (this.eventRegistry && typeof this.eventRegistry.emit === 'function') {\n                return this.eventRegistry.emit(eventName, ...args);\n              }\n              \n              console.warn(`Fallback eventManager.emit called for ${eventName}`);\n              return false;\n            }\n          };\n        \n        case 'module-bridge':\n          return {\n            ...baseFallback,\n            \n            uiBridge: {\n              showToast: (title, message, type = 'info') => {\n                console.log(`[Bridge Fallback] Toast: ${title} - ${message} (${type})`);\n                return null;\n              },\n              showLoadingSpinner: (message = 'Loading...') => {\n                console.log(`[Bridge Fallback] Loading: ${message}`);\n                return {\n                  hide: () => {},\n                  updateMessage: () => {},\n                  updateProgress: () => {}\n                };\n              },\n              createElement: (tag, attrs = {}, parent = null) => {\n                console.log(`[Bridge Fallback] Creating element: ${tag}`);\n                return document.createElement(tag);\n              },\n              getElement: (selector) => {\n                return document.querySelector(selector);\n              }\n            },\n            \n            progressHandlerBridge: {\n              setupTaskProgress: (taskId, options = {}) => {\n                console.log(`[Bridge Fallback] Setting up progress for task: ${taskId}`);\n                return {\n                  updateProgress: () => {},\n                  complete: () => {},\n                  error: () => {}\n                };\n              },\n              trackProgress: () => {},\n              updateProgressUI: () => {},\n              createProgressUI: () => {}\n            },\n            \n            socketHandlerBridge: {\n              connect: () => Promise.resolve(false),\n              disconnect: () => Promise.resolve(true),\n              emit: () => false,\n              isConnected: () => false,\n              startStatusPolling: () => {},\n              stopStatusPolling: () => {},\n              cancelTask: () => Promise.resolve({success: false})\n            },\n            \n            updateUIBridge(realUI) {\n              console.log('[Bridge Fallback] updateUIBridge called');\n              return true;\n            },\n            \n            updateProgressHandlerBridge(realHandler) {\n              console.log('[Bridge Fallback] updateProgressHandlerBridge called');\n              return true;\n            },\n            \n            updateSocketHandlerBridge(realHandler) {\n              console.log('[Bridge Fallback] updateSocketHandlerBridge called');\n              return true;\n            }\n          };\n          \n        default:\n          return baseFallback;\n        }\n      },\n        \n  /**\n   * Create a fallback for feature modules\n         * @param {string} moduleName - The name of the module\n         * @returns {Object} - A fallback implementation\n         */\n        createFeatureFallback(moduleName) {\n          // Use consistent naming without .js extension\n          const cleanName = moduleName.replace(/\\.js$/, '');\n          \n          // Basic fallback that all modules share\n          const baseFallback = {\n            __isFallback: true,\n            moduleName: cleanName,\n            initialized: false,\n            \n            initialize() {\n              console.warn(`Using fallback implementation for feature: ${cleanName}`);\n              this.initialized = true;\n              return Promise.resolve(true);\n            }\n          };\n          \n          // Add module-specific fallbacks for features\n          switch (cleanName) {\n            case 'webScraper':\n              return {\n                ...baseFallback,\n                \n                handleStartScraping() {\n                  console.warn(\"Scraping not available (fallback module)\");\n                  return Promise.resolve(false);\n                },\n                \n                handleCancelScraping() {\n                  return Promise.resolve(false);\n                },\n                \n                showForm() {\n                  const formContainer = document.getElementById('scraper-form-container');\n                  const progressContainer = document.getElementById('scraper-progress-container');\n                  const resultsContainer = document.getElementById('scraper-results-container');\n                  \n                  if (formContainer) formContainer.style.display = 'block';\n                  if (progressContainer) progressContainer.style.display = 'none';\n                  if (resultsContainer) resultsContainer.style.display = 'none';\n                  \n                  // Add warning message\n                  if (formContainer && !formContainer.querySelector('.fallback-warning')) {\n                    const warningAlert = document.createElement('div');\n                    warningAlert.className = 'alert alert-warning mb-3 fallback-warning';\n                    warningAlert.innerHTML = `<strong>WebScraper module unavailable</strong>\n                      <p>The web scraper functionality is currently unavailable. Please try refreshing the page.</p>`;\n                    formContainer.prepend(warningAlert);\n                  }\n                  \n                  return true;\n                },\n                \n                showProgress() {\n                  const formContainer = document.getElementById('scraper-form-container');\n                  const progressContainer = document.getElementById('scraper-progress-container');\n                  const resultsContainer = document.getElementById('scraper-results-container');\n                  \n                  if (formContainer) formContainer.style.display = 'none';\n                  if (progressContainer) progressContainer.style.display = 'block';\n                  if (resultsContainer) resultsContainer.style.display = 'none';\n                  \n                  return true;\n                }\n              };\n              \n            case 'academicSearch':\n              return {\n                ...baseFallback,\n                \n                search() {\n                  console.warn(\"Academic search not available (fallback module)\");\n                  return Promise.resolve(false);\n                },\n                \n                performSearch() {\n                  return Promise.resolve(false);\n                },\n                \n                getDetails() {\n                  return Promise.resolve(null);\n                },\n                \n                downloadPaper() {\n                  return Promise.resolve(false);\n                }\n              };\n              \n            case 'fileProcessor':\n              return {\n                ...baseFallback,\n                \n                processFiles() {\n                  console.warn(\"File processing not available (fallback module)\");\n                  return Promise.resolve(false);\n                },\n                \n                handleUpload() {\n                  return false;\n                },\n                \n                cancelProcessing() {\n                  return false;\n                },\n                \n                showForm() {\n                  // Show the form container and hide progress/result/error containers\n                  const formContainer = document.getElementById('form-container');\n                  const progressContainer = document.getElementById('progress-container');\n                  const resultContainer = document.getElementById('result-container');\n                  const errorContainer = document.getElementById('error-container');\n                  \n                  if (formContainer) formContainer.style.display = 'block';\n                  if (progressContainer) progressContainer.style.display = 'none';\n                  if (resultContainer) resultContainer.style.display = 'none';\n                  if (errorContainer) errorContainer.style.display = 'none';\n                  \n                  // Add warning message\n                  if (formContainer && !formContainer.querySelector('.fallback-warning')) {\n                    const warningAlert = document.createElement('div');\n                    warningAlert.className = 'alert alert-warning mb-3 fallback-warning';\n                    warningAlert.innerHTML = `<strong>File processor module unavailable</strong>\n                      <p>The file processor functionality is currently unavailable. Please try refreshing the page.</p>`;\n                    formContainer.prepend(warningAlert);\n                  }\n                  \n                  return true;\n                },\n                \n                showProgress() {\n                  // Show the progress container and hide form/result/error containers\n                  const formContainer = document.getElementById('form-container');\n                  const progressContainer = document.getElementById('progress-container');\n                  const resultContainer = document.getElementById('result-container');\n                  const errorContainer = document.getElementById('error-container');\n                  \n                  if (formContainer) formContainer.style.display = 'none';\n                  if (progressContainer) progressContainer.style.display = 'block';\n                  if (resultContainer) resultContainer.style.display = 'none';\n                  if (errorContainer) errorContainer.style.display = 'none';\n                  \n                  return true;\n                }\n              };\n              \n            case 'playlistDownloader':\n              return this.createPlaylistDownloaderFallback();\n              \n            default:\n              return baseFallback;\n          }\n        },\n        \n        /**\n         * Create a fallback for utility modules\n         * @param {string} moduleName - The name of the module\n         * @returns {Object} - A fallback implementation\n         */\n        createUtilityFallback(moduleName) {\n          // Use consistent naming without .js extension\n          const cleanName = moduleName.replace(/\\.js$/, '');\n          \n          // Basic fallback that all modules share\n          const baseFallback = {\n            __isFallback: true,\n            moduleName: cleanName,\n            initialized: false,\n            \n            initialize() {\n              console.warn(`Using fallback implementation for utility: ${cleanName}`);\n              this.initialized = true;\n              return Promise.resolve(true);\n            }\n          };\n          \n          // Add module-specific fallbacks for utilities\n          switch (cleanName) {\n            case 'ui':\n              return {\n                ...baseFallback,\n                \n                showToast(title, message, type = 'info') {\n                  console.log(`[${type.toUpperCase()}] ${title}: ${message}`);\n                  \n                  // Try to create toast if container exists\n                  const toastContainer = document.getElementById('toast-container') || document.createElement('div');\n                  if (!toastContainer.id) {\n                    toastContainer.id = 'toast-container';\n                    toastContainer.className = 'toast-container position-fixed bottom-0 end-0 p-3';\n                    document.body.appendChild(toastContainer);\n                  }\n                  \n                  const toast = document.createElement('div');\n                  toast.className = 'toast fade show';\n                  \n                  // Choose color based on type\n                  let headerClass = 'bg-primary';\n                  if (type === 'error' || type === 'danger') headerClass = 'bg-danger';\n                  if (type === 'success') headerClass = 'bg-success';\n                  if (type === 'warning') headerClass = 'bg-warning';\n                  \n                  toast.innerHTML = `\n                    <div class=\"toast-header ${headerClass} text-white\">\n                      <strong class=\"me-auto\">${title}</strong>\n                      <button type=\"button\" class=\"btn-close btn-close-white\" data-bs-dismiss=\"toast\"></button>\n                    </div>\n                    <div class=\"toast-body\">${message}</div>\n                  `;\n                  \n                  toastContainer.appendChild(toast);\n                  \n                  // Auto-remove toast after 5 seconds\n                  setTimeout(() => {\n                    toast.classList.remove('show');\n                    setTimeout(() => toast.remove(), 150);\n                  }, 5000);\n                },\n                \n                showLoading(message = 'Loading...', options = {}) {\n                  const loadingId = 'loading-' + Date.now();\n                  \n                  // Create loading container if needed\n                  let loadingContainer = document.getElementById('loading-container');\n                  if (!loadingContainer) {\n                    loadingContainer = document.createElement('div');\n                    loadingContainer.id = 'loading-container';\n                    loadingContainer.className = 'position-fixed top-0 left-0 w-100 h-100 d-flex justify-content-center align-items-center';\n                    loadingContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';\n                    loadingContainer.style.zIndex = '9999';\n                    document.body.appendChild(loadingContainer);\n                  }\n                  \n                  // Create loading element\n                  const loadingEl = document.createElement('div');\n                  loadingEl.id = loadingId;\n                  loadingEl.className = 'bg-white p-4 rounded shadow text-center';\n                  loadingEl.innerHTML = `\n                    <div class=\"spinner-border text-primary mb-3\" role=\"status\">\n                      <span class=\"visually-hidden\">Loading...</span>\n                    </div>\n                    <div class=\"loading-message\">${message}</div>\n                  `;\n                  \n                  loadingContainer.appendChild(loadingEl);\n                  \n                  return { \n                    hide: () => {\n                      const el = document.getElementById(loadingId);\n                      if (el) el.remove();\n                      \n                      // Hide container if no more loaders\n                      if (loadingContainer.children.length === 0) {\n                        loadingContainer.style.display = 'none';\n                      }\n                    },\n                    updateMessage: (newMessage) => {\n                      const el = document.getElementById(loadingId);\n                      if (el) {\n                        const messageEl = el.querySelector('.loading-message');\n                        if (messageEl) messageEl.textContent = newMessage;\n                      }\n                    }\n                  };\n                },\n                \n                hideLoading() {\n                  const loadingContainer = document.getElementById('loading-container');\n                  if (loadingContainer) {\n                    loadingContainer.style.display = 'none';\n                    loadingContainer.innerHTML = '';\n                  }\n                  return true;\n                },\n                \n                updateProgressBar(id, progress) {\n                  const progressBar = document.getElementById(id);\n                  if (!progressBar) return;\n                  \n                  const percent = Math.round(progress);\n                  progressBar.style.width = `${percent}%`;\n                  progressBar.setAttribute('aria-valuenow', percent);\n                  progressBar.textContent = `${percent}%`;\n                },\n                \n                updateProgressStatus(id, message) {\n                  const statusElement = document.getElementById(id);\n                  if (!statusElement) return;\n                  \n                  statusElement.textContent = message;\n                },\n                \n                showModal(options) {\n                  console.log(`MODAL: ${options.title || 'Modal'}`);\n                  // Simplified fallback just showing alert\n                  alert(options.content || 'Modal content');\n                  return {\n                    id: 'fallback-modal',\n                    hide: () => {},\n                    updateContent: () => {},\n                    updateTitle: () => {},\n                    addButton: () => {}\n                  };\n                }\n              };\n              \n            case 'socketHandler':\n              return {\n                ...baseFallback,\n                \n                connect() {\n                  console.warn(\"Socket connection not available (fallback module)\");\n                  return Promise.resolve(false);\n                },\n                \n                disconnect() {\n                  return Promise.resolve(true);\n                },\n                \n                emit() {\n                  return false;\n                },\n                \n                on() {\n                  return () => {}; // Return unsubscribe function\n                },\n                \n                isConnected() {\n                  return false;\n                },\n                \n                startStatusPolling() {\n                  console.warn(\"Status polling not available (fallback module)\");\n                  return false;\n                },\n                \n                stopStatusPolling() {\n                  return true;\n                },\n                \n                cancelTask() {\n                  console.warn(\"Task cancellation not available (fallback module)\");\n                  return Promise.resolve({success: false, message: \"Module unavailable\"});\n                }\n              };\n              \n            case 'progressHandler':\n              return {\n                ...baseFallback,\n                \n                setupTaskProgress(taskId, options = {}) {\n                  console.warn(`Setting up fallback progress tracking for task ${taskId}`);\n                  \n                  return {\n                    updateProgress: (progress, message) => {\n                      console.log(`Task ${taskId} progress: ${progress}% - ${message || ''}`);\n                      \n                      // Try to update UI if elements exist\n                      const progressBar = document.getElementById(`${options.elementPrefix || ''}progress-bar`);\n                      const progressStatus = document.getElementById(`${options.elementPrefix || ''}progress-status`);\n                      \n                      if (progressBar) {\n                        progressBar.style.width = `${progress}%`;\n                        progressBar.setAttribute('aria-valuenow', progress);\n                      }\n                      \n                      if (progressStatus && message) {\n                        progressStatus.textContent = message;\n                      }\n                    },\n                    complete: (result) => {\n                      console.log(`Task ${taskId} completed with result:`, result);\n                      \n                      // Try to update UI\n                      const progressBar = document.getElementById(`${options.elementPrefix || ''}progress-bar`);\n                      \n                      if (progressBar) {\n                        progressBar.style.width = `100%`;\n                        progressBar.setAttribute('aria-valuenow', 100);\n                        progressBar.classList.add('bg-success');\n                      }\n                    },\n                    error: (error) => {\n                      console.error(`Task ${taskId} error:`, error);\n                      \n                      // Try to update UI\n                      const progressStatus = document.getElementById(`${options.elementPrefix || ''}progress-status`);\n                      \n                      if (progressStatus) {\n                        progressStatus.textContent = `Error: ${error.message || error}`;\n                        progressStatus.classList.add('text-danger');\n                      }\n                    }\n                  };\n                },\n                \n                trackProgress(taskId, options = {}) {\n                  return this.setupTaskProgress(taskId, options);\n                },\n                \n                createProgressUI(containerId, prefix = '') {\n                  console.warn(`Creating fallback progress UI in ${containerId} with prefix ${prefix}`);\n                  // This would typically create progress elements in the container\n                  return null;\n                },\n                \n                getUIElements(elementPrefix) {\n                  // Build prefix for element IDs\n                  const prefix = elementPrefix ? `${elementPrefix}-` : '';\n                  \n                  // Find elements in the DOM\n                  return {\n                    progressBar: document.getElementById(`${prefix}progress-bar`),\n                    progressStatus: document.getElementById(`${prefix}progress-status`),\n                    progressStats: document.getElementById(`${prefix}progress-stats`),\n                    progressContainer: document.getElementById(`${prefix}progress-container`),\n                    cancelButton: document.getElementById(`${prefix}cancel-btn`)\n                  };\n                }\n              };\n              \n            case 'domUtils':\n              return {\n                ...baseFallback,\n                \n                getElement(selector) {\n                  // Handle both ID-only and CSS selector cases\n                  if (selector.startsWith('#') && !selector.includes(' ')) {\n                    return document.getElementById(selector.substring(1));\n                  }\n                  return document.querySelector(selector);\n                },\n                \n                getElements(selector) {\n                  return document.querySelectorAll(selector);\n                },\n                \n                getUIElements(elementPrefix) {\n                  // Build prefix for element IDs\n                  const prefix = elementPrefix ? `${elementPrefix}-` : '';\n                  \n                  // Find elements in the DOM\n                  return {\n                    container: document.getElementById(`${prefix}container`),\n                    form: document.getElementById(`${prefix}form`),\n                    submit: document.getElementById(`${prefix}submit-btn`),\n                    cancel: document.getElementById(`${prefix}cancel-btn`),\n                    progress: document.getElementById(`${prefix}progress-bar`)\n                  };\n                },\n                \n                createElement(tag, attributes = {}) {\n                  const element = document.createElement(tag);\n                  \n                  // Set attributes\n                  for (const [key, value] of Object.entries(attributes)) {\n                    if (key === 'className' || key === 'class') {\n                      element.className = value;\n                    } else if (key === 'textContent' || key === 'text') {\n                      element.textContent = value;\n                    } else if (key === 'innerHTML' || key === 'html') {\n                      element.innerHTML = value;\n                    } else {\n                      element.setAttribute(key, value);\n                    }\n                  }\n                  \n                  return element;\n                },\n                \n                addEventListeners(element, events) {\n                  if (!element || !events) return;\n                  \n                  Object.entries(events).forEach(([event, handler]) => {\n                    if (typeof handler === 'function') {\n                      element.addEventListener(event, handler);\n                    }\n                  });\n                },\n                \n                toggleElementVisibility(element, visible) {\n                  if (typeof element === 'string') {\n                    element = this.getElement(element);\n                  }\n                  \n                  if (!element) return;\n                  \n                  element.style.display = visible ? '' : 'none';\n                }\n              };\n              \n            default:\n              return baseFallback;\n          }\n        },\n        \n        /**\n         * Create a specialized fallback for PlaylistDownloader module\n         * @returns {Object} - Fallback PlaylistDownloader module\n         */\n        createPlaylistDownloaderFallback() {\n          console.warn(\"Creating fallback for PlaylistDownloader module\");\n          \n          const fallback = {\n            __isFallback: true,\n            moduleName: 'playlistDownloader',\n            initialized: false,\n            \n            initialize() {\n              console.warn(\"Using fallback implementation for PlaylistDownloader module\");\n              this.initialized = true;\n              this.setupListeners();\n              return Promise.resolve(true);\n            },\n            \n            isInitialized() {\n              return this.initialized;\n            },\n            \n            setupListeners() {\n              // Form submit handler\n              const form = document.getElementById('playlist-form');\n              if (form) {\n                form.addEventListener('submit', (e) => {\n                  e.preventDefault();\n                  this.handlePlaylistSubmit(e);\n                });\n              }\n              \n              // Cancel button\n              const cancelButton = document.getElementById('playlist-cancel-btn');\n              if (cancelButton) {\n                cancelButton.addEventListener('click', (e) => {\n                  e.preventDefault();\n                  this.handleCancelDownload();\n                });\n              }\n              \n              // New task button\n              const newTaskButton = document.getElementById('playlist-new-task-btn');\n              if (newTaskButton) {\n                newTaskButton.addEventListener('click', (e) => {\n                  e.preventDefault();\n                  this.showForm();\n                });\n              }\n              \n              // Open output button\n              const openOutputButton = document.getElementById('playlist-open-output-btn');\n              if (openOutputButton) {\n                openOutputButton.addEventListener('click', (e) => {\n                  e.preventDefault();\n                  this.handleOpenOutput();\n                });\n              }\n            },\n            \n            handlePlaylistSubmit(e) {\n              if (e) e.preventDefault();\n              \n              // Use UI module to show a message if available\n              if (window.ui && typeof window.ui.showToast === 'function') {\n                window.ui.showToast('Warning', 'Playlist downloader functionality is not available', 'warning');\n              } else {\n                alert(\"Playlist downloader functionality is currently unavailable. Please try refreshing the page.\");\n              }\n              \n              return false;\n            },\n            \n            downloadPlaylist() {\n              console.warn(\"Playlist downloader functionality is not available (fallback module)\");\n              return Promise.resolve(false);\n            },\n            \n            cancelDownload() {\n              return false;\n            },\n            \n            handleCancelDownload() {\n              return this.cancelDownload();\n            },\n            \n            showForm() {\n              console.warn(\"Fallback playlistDownloader.showForm called\");\n              \n              // Show form container and hide others\n              const formContainer = document.getElementById('playlist-form-container');\n              const progressContainer = document.getElementById('playlist-progress-container');\n              const resultsContainer = document.getElementById('playlist-results-container');\n              \n              if (formContainer) formContainer.style.display = 'block';\n              if (formContainer) formContainer.classList.remove('d-none');\n              if (progressContainer) progressContainer.style.display = 'none';\n              if (progressContainer) progressContainer.classList.add('d-none');\n              if (resultsContainer) resultsContainer.style.display = 'none';\n              if (resultsContainer) resultsContainer.classList.add('d-none');\n              \n              // Add warning message\n              if (formContainer && !formContainer.querySelector('.playlist-warning')) {\n                const warningAlert = document.createElement('div');\n                warningAlert.className = 'alert alert-warning mb-3 playlist-warning';\n                warningAlert.innerHTML = `\n                  <i class=\"fas fa-exclamation-triangle me-2\"></i>\n                  <strong>Playlist Downloader Module Unavailable</strong>\n                  <p class=\"mb-0 mt-1\">The playlist downloader module failed to load. Some functionality may be limited. Please refresh the page and try again.</p>\n                  <button class=\"btn btn-sm btn-primary mt-2\" onclick=\"window.location.reload()\">Refresh Page</button>\n                `;\n                \n                formContainer.prepend(warningAlert);\n              }\n              \n              return true;\n            },\n            \n            showProgress() {\n              console.warn(\"Fallback playlistDownloader.showProgress called\");\n              \n              // Show progress container and hide others\n              const formContainer = document.getElementById('playlist-form-container');\n              const progressContainer = document.getElementById('playlist-progress-container');\n              const resultsContainer = document.getElementById('playlist-results-container');\n              \n              if (formContainer) formContainer.style.display = 'none';\n              if (formContainer) formContainer.classList.add('d-none');\n              if (progressContainer) progressContainer.style.display = 'block';\n              if (progressContainer) progressContainer.classList.remove('d-none');\n              if (resultsContainer) resultsContainer.style.display = 'none';\n              if (resultsContainer) resultsContainer.classList.add('d-none');\n              \n              return true;\n            },\n            \n            showResults() {\n              console.warn(\"Fallback playlistDownloader.showResults called\");\n              \n              // Show results container and hide others\n              const formContainer = document.getElementById('playlist-form-container');\n              const progressContainer = document.getElementById('playlist-progress-container');\n              const resultsContainer = document.getElementById('playlist-results-container');\n              \n              if (formContainer) formContainer.style.display = 'none';\n              if (formContainer) formContainer.classList.add('d-none');\n              if (progressContainer) progressContainer.style.display = 'none';\n              if (progressContainer) progressContainer.classList.add('d-none');\n              if (resultsContainer) resultsContainer.style.display = 'block';\n              if (resultsContainer) resultsContainer.classList.remove('d-none');\n              \n              return true;\n            },\n            \n            handlePlaylistCompletion(data) {\n              console.warn(\"Fallback handlePlaylistCompletion called with:\", data);\n              this.showResults();\n              return true;\n            },\n            \n            processStatusUpdate(data) {\n              console.warn(\"Fallback processStatusUpdate called with:\", data);\n              \n              // Update progress bar if it exists\n              const progressBar = document.getElementById('playlist-progress-bar');\n              if (progressBar && data && data.progress !== undefined) {\n                const percent = Math.round(data.progress);\n                progressBar.style.width = `${percent}%`;\n                progressBar.setAttribute('aria-valuenow', percent);\n                progressBar.textContent = `${percent}%`;\n              }\n              \n              // Update status message if it exists\n              const progressStatus = document.getElementById('playlist-progress-status');\n              if (progressStatus && data && data.message) {\n                progressStatus.textContent = data.message;\n              }\n              \n              return true;\n            },\n            \n            setupProgressTracking(taskId) {\n              console.warn(\"Fallback setupProgressTracking called with:\", taskId);\n              return null;\n            },\n            \n            handleTaskError(data) {\n              console.warn(\"Fallback handleTaskError called with:\", data);\n              \n              if (window.ui && typeof window.ui.showToast === 'function') {\n                window.ui.showToast('Error', data.error || \"An error occurred with the playlist downloader\", 'error');\n              } else {\n                alert(data.error || \"An error occurred with the playlist downloader\");\n              }\n              \n              this.showForm();\n              return true;\n            },\n            \n            handleOpenOutput() {\n              if (window.ui && typeof window.ui.showToast === 'function') {\n                window.ui.showToast('Warning', 'Cannot open output as the playlist downloader module is not fully functional', 'warning');\n              } else {\n                alert(\"Cannot open output as the playlist downloader module is not fully functional\");\n              }\n              \n              return false;\n            },\n            \n            resumeTask(taskId) {\n              console.warn(`Fallback resumeTask called with: ${taskId}`);\n              this.showProgress();\n              return true;\n            }\n          };\n          \n          // Add to fallback modules set\n          this.fallbackModules.add('playlistDownloader');\n          \n          // Add to diagnostics\n          if (!this.diagnostics.fallbacksUsed.includes('playlistDownloader')) {\n            this.diagnostics.fallbacksUsed.push('playlistDownloader');\n          }\n          \n          return fallback;\n        },\n        \n        /**\n         * Check if a module is a fallback\n         * @param {string} moduleName - Module name\n         * @returns {boolean} - Whether the module is a fallback\n         */\n        isFallbackModule(moduleName) {\n          return this.fallbackModules.has(moduleName);\n        },\n        \n        /**\n* Fix failed modules by clearing their cache entries\n*/\nfixFailedModules() {\n  if (this.failedModules.size === 0) return;\n  \n  console.log(`Fixing ${this.failedModules.size} failed modules`);\n  \n  // Clear failed modules from cache\n  this.failedModules.forEach(path => {\n    this.cache.delete(path);\n  });\n  \n  // Clear the failed modules list\n  this.failedModules.clear();\n  this.diagnostics.failedModules = [];\n  \n  // Reset load attempts counter for all modules\n  this.loadAttempts = new Map();\n  \n  console.log(\"Failed modules cache cleared\");\n },\n \n /**\n * Get modules currently using fallbacks\n * @returns {Array<string>} - List of modules using fallbacks\n */\n getModulesUsingFallbacks() {\n  return Array.from(this.fallbackModules);\n },\n \n /**\n * Generate a health report for the module loader\n * @returns {Object} - Health report\n */\n generateHealthReport() {\n  return {\n    status: this.failedModules.size > 0 ? 'issues' : 'ok',\n    moduleCount: this.cache.size,\n    failedModules: Array.from(this.failedModules),\n    fallbackModules: Array.from(this.fallbackModules)\n  };\n },\n \n /**\n * Safe import function with retry mechanism\n * @param {string} path - Path to the module\n * @param {number} attempts - Maximum number of attempts\n * @returns {Promise<Object>} - The imported module\n */\n async safeImport(path, attempts = 3) {\n  const resolvedPath = this.resolvePath(path);\n  const cacheKey = this.getNormalizedPath(resolvedPath);\n \n  // Check for circular dependencies\n  if (this.loadingModules.has(cacheKey)) {\n    console.warn(`Circular dependency detected for module: ${path}`);\n    return this.createCircularDependencyResolver(this.getModuleName(path));\n  }\n  \n  // Check if already failed\n  if (this.failedModules.has(cacheKey)) {\n    console.warn(`Module ${path} previously failed to load, using fallback`);\n    return this.createFallbackModule(this.getModuleName(path));\n  }\n  \n  // Track load attempts\n  const currentAttempts = this.loadAttempts.get(cacheKey) || 0;\n  this.loadAttempts.set(cacheKey, currentAttempts + 1);\n  \n  // Mark module as loading for circular dependency detection\n  this.loadingModules.add(cacheKey);\n  \n  try {\n    for (let i = 0; i < attempts; i++) {\n      try {\n        console.log(`Attempting to import ${resolvedPath} (attempt ${i + 1}/${attempts})`);\n        const mod = await import(resolvedPath);\n        \n        if (mod) {\n          console.log(`[Success] Imported: ${resolvedPath}`);\n          this.diagnostics.totalModules++;\n          \n          // Remove from loading modules\n          this.loadingModules.delete(cacheKey);\n          \n          return mod;\n        }\n      } catch (error) {\n        console.error(`[Attempt ${i + 1}] Failed to import ${resolvedPath}:`, error);\n        this.diagnostics.retries[resolvedPath] = (this.diagnostics.retries[resolvedPath] || 0) + 1;\n        \n        // Small pause before retrying\n        if (i < attempts - 1) {\n          await new Promise(resolve => setTimeout(resolve, 200));\n        } else {\n          // On last attempt, throw the error to be caught by outer try/catch\n          throw error;\n        }\n      }\n    }\n    \n    // Should not reach here as the last attempt should either return or throw\n    throw new Error(`Failed to import ${resolvedPath} after ${attempts} attempts`);\n  } catch (error) {\n    // Remove from loading modules\n    this.loadingModules.delete(cacheKey);\n    \n    // Mark as failed\n    this.failedModules.add(cacheKey);\n    this.diagnostics.failedModules.push(path);\n    \n    console.warn(`[Fallback] Using fallback module for: ${path}`);\n    \n    // Return fallback module\n    const moduleName = this.getModuleName(path);\n    return this.createFallbackModule(moduleName);\n  }\n },\n \n /**\n * Import a module safely with error handling and retries\n * @param {string} modulePath - Path to the module\n * @param {Object} options - Import options\n * @returns {Promise<Object>} - The imported module\n */\n async importModule(modulePath, options = {}) {\n  if (!modulePath) {\n    console.error('Invalid module path provided to importModule');\n    return null;\n  }\n  \n  const { \n    required = false, \n    fallback = null, \n    skipCache = false, \n    standardizeExports = this.defaultOptions.standardizeExports,\n    retries = this.defaultOptions.maxRetries,\n    timeout = this.defaultOptions.timeout,\n    clearFailedModules = this.defaultOptions.clearFailedModules\n  } = options;\n  \n  try {\n    // Resolve the module path\n    const resolvedPath = this.resolvePath(modulePath);\n    \n    if (!resolvedPath) {\n      throw new Error(`Could not resolve path for module: ${modulePath}`);\n    }\n    \n    const cacheKey = this.getNormalizedPath(resolvedPath);\n    \n    // Clear failed module if requested\n    if (clearFailedModules && this.failedModules.has(cacheKey)) {\n      console.log(`Clearing failed module status for ${modulePath}`);\n      this.failedModules.delete(cacheKey);\n    }\n    \n    // Check if module is already in the cache\n    if (!skipCache && this.cache.has(cacheKey)) {\n      if (this.verboseLogging) {\n        console.log(`[Cache] Module loaded from cache: ${modulePath}`);\n      }\n      return this.cache.get(cacheKey);\n    }\n    \n    // Check if module is currently being loaded\n    if (this.loadingPromises.has(cacheKey)) {\n      if (this.verboseLogging) {\n        console.log(`Module ${modulePath} is already being loaded, reusing promise`);\n      }\n      return this.loadingPromises.get(cacheKey);\n    }\n    \n    // Check if module failed to load previously\n    if (this.failedModules.has(cacheKey)) {\n      console.warn(`Module ${modulePath} previously failed to load, using fallback`);\n      return fallback || this.createFallbackModule(this.getModuleName(modulePath));\n    }\n    \n    // Check for circular dependencies\n    if (this.loadingModules.has(cacheKey)) {\n      console.warn(`Circular dependency detected for module: ${modulePath}`);\n      // Get module name for proxy creation\n      const moduleName = this.getModuleName(modulePath);\n      \n      // Create or retrieve proxy to break circular dependency\n      if (this.moduleProxies.has(moduleName)) {\n        return this.moduleProxies.get(moduleName);\n      } else {\n        return this.createModuleProxy(moduleName);\n      }\n    }\n    \n    // Mark module as loading to detect circular dependencies\n    this.loadingModules.add(cacheKey);\n    \n    // Create a loading promise with proper error handling\n    const loadPromise = (async () => {\n      try {\n        // Create timeout promise\n        const timeoutPromise = new Promise((_, reject) => {\n          setTimeout(() => reject(new Error(`Module import timed out: ${modulePath}`)), timeout);\n        });\n        \n        // Attempt to import the module with timeout\n        const modulePromise = import(resolvedPath);\n        const module = await Promise.race([modulePromise, timeoutPromise]);\n        \n        // Get module name for auto-export creation\n        const moduleNameWithExt = this.getModuleName(modulePath) + '.js';\n        \n        // Enhance module with missing exports if needed\n        let enhancedModule = module;\n        if (standardizeExports) {\n          enhancedModule = this.autoCreateMissingExports(module, moduleNameWithExt);\n        }\n        \n        // Get the default export or the module itself\n        const moduleExport = enhancedModule.default || enhancedModule;\n        \n        // Add to cache\n        this.cache.set(cacheKey, moduleExport);\n        \n        // Add to diagnostics cache list\n        if (!this.diagnostics.moduleCache.includes(cacheKey)) {\n          this.diagnostics.moduleCache.push(cacheKey);\n        }\n        \n        // Remove from loading set and promises\n        this.loadingModules.delete(cacheKey);\n        this.loadingPromises.delete(cacheKey);\n        \n        // If this module has a proxy, update it with the real module\n        const moduleName = this.getModuleName(modulePath);\n        if (this.moduleProxies.has(moduleName)) {\n          this.updateModuleProxy(moduleName, moduleExport);\n        }\n        \n        console.log(`Module ${resolvedPath} loaded successfully`);\n        \n        return moduleExport;\n      } catch (error) {\n        // Remove from loading set and promises\n        this.loadingModules.delete(cacheKey);\n        this.loadingPromises.delete(cacheKey);\n        \n        // Add to failed modules set\n        this.failedModules.add(cacheKey);\n        this.diagnostics.failedModules.push(cacheKey);\n        \n        console.error(`Module ${resolvedPath} failed to load:`, error);\n        \n        // Rethrow for outer catch\n        throw error;\n      }\n    })();\n    \n    // Store promise for reuse\n    this.loadingPromises.set(cacheKey, loadPromise);\n    \n    // Return the loading promise\n    return loadPromise;\n  } catch (error) {\n    // Try retries if specified\n    if (retries > 1) {\n      console.warn(`Retrying to load ${modulePath}, ${retries-1} attempts remaining`);\n      return this.importModule(modulePath, {...options, retries: retries - 1});\n    }\n    \n    const resolvedPath = this.resolvePath(modulePath);\n    if (!resolvedPath) {\n      console.error(`Failed to resolve path for module: ${modulePath}`);\n      return fallback || this.createFallbackModule(this.getModuleName(modulePath), error);\n    }\n    \n    const cacheKey = this.getNormalizedPath(resolvedPath);\n    \n    // Add to failed modules set\n    this.failedModules.add(cacheKey);\n    \n    // Log the error\n    console.error(`Failed to import module ${modulePath}:`, error);\n    \n    // Handle required modules\n    if (required) {\n      this.showErrorMessage(`Failed to load required module: ${modulePath}. ${error.message}`);\n    }\n    \n    // Create and return fallback\n    return fallback || this.createFallbackModule(this.getModuleName(modulePath), error);\n  }\n },\n \n /**\n * Load multiple modules in parallel with proper error handling\n * @param {Array<string>} modulePaths - Array of module paths\n * @param {boolean} allRequired - Whether all modules are required\n * @param {Object} options - Additional options\n * @returns {Promise<Object>} - Object with modules mapped by name\n */\n async importModules(modulePaths, allRequired = false, options = {}) {\n  if (!modulePaths || !Array.isArray(modulePaths) || modulePaths.length === 0) {\n    console.warn('No modules to import');\n    return {};\n  }\n  \n  // Filter out empty paths and duplicates\n  const uniquePaths = [...new Set(modulePaths.filter(path => path))];\n  \n  // Merge with default options\n  const importOptions = {\n    ...this.defaultOptions,\n    ...options\n  };\n  \n  // Group modules for ordered loading\n  const coreModules = uniquePaths.filter(path => {\n    const name = this.getModuleName(path) + '.js';\n    return this.INITIALIZATION_ORDER.includes(name);\n  }).sort((a, b) => {\n    const nameA = this.getModuleName(a) + '.js';\n    const nameB = this.getModuleName(b) + '.js';\n    return this.INITIALIZATION_ORDER.indexOf(nameA) - this.INITIALIZATION_ORDER.indexOf(nameB);\n  });\n  \n  const otherModules = uniquePaths.filter(path => {\n    const name = this.getModuleName(path) + '.js';\n    return !this.INITIALIZATION_ORDER.includes(name);\n  });\n  \n  // First load core modules in order\n  const modules = {};\n  \n  for (const path of coreModules) {\n    const moduleName = this.getModuleName(path);\n    try {\n      const module = await this.importModule(path, { \n        required: allRequired,\n        skipCache: importOptions.skipCache,\n        standardizeExports: importOptions.standardizeExports,\n        retries: importOptions.retries + 1, // Extra retry for core modules\n        timeout: importOptions.timeout + 3000 // Extra time for core modules\n      });\n      \n      if (module) {\n        modules[moduleName] = module;\n        \n        // Initialize core modules immediately if they have an initialize method\n        if (module.initialize && typeof module.initialize === 'function' && !module.initialized) {\n          try {\n            const result = await Promise.race([\n              module.initialize(),\n              new Promise((_, reject) => setTimeout(() => \n                reject(new Error(`${moduleName} initialization timed out`)), 5000))\n            ]);\n            \n            if (result !== false) {\n              module.initialized = true;\n              if (this.verboseLogging) {\n                console.log(`Initialized core module: ${moduleName}`);\n              }\n            } else {\n              console.warn(`Module ${moduleName} initialization returned false`);\n            }\n          } catch (initError) {\n            console.error(`Error initializing module ${moduleName}:`, initError);\n          }\n        }\n      } else {\n        modules[moduleName] = null;\n        console.warn(`Module ${path} failed to load`);\n      }\n    } catch (error) {\n      modules[moduleName] = null;\n      console.error(`Error importing core module ${path}:`, error);\n      \n      // Create fallback for core modules when required\n      if (allRequired) {\n        modules[moduleName] = this.createFallbackModule(moduleName, error);\n      }\n    }\n  }\n  \n  // Then load other modules in parallel with concurrency limit\n  const concurrencyLimit = importOptions.concurrencyLimit;\n  const chunks = [];\n  \n  // Split into chunks for controlled concurrency\n  for (let i = 0; i < otherModules.length; i += concurrencyLimit) {\n    chunks.push(otherModules.slice(i, i + concurrencyLimit));\n  }\n  \n  // Process each chunk in sequence\n  for (const chunk of chunks) {\n    const modulePromises = chunk.map(path => {\n      return this.importModule(path, { \n        required: allRequired,\n        skipCache: importOptions.skipCache,\n        standardizeExports: importOptions.standardizeExports,\n        retries: importOptions.retries,\n        timeout: importOptions.timeout\n      })\n      .then(module => {\n        console.log(`Successfully loaded module ${this.getModuleName(path)} from ${path}`);\n        return { path, module };\n      })\n      .catch(error => {\n        // Handle errors per module's requirements\n        if (importOptions.ignoreErrors || !allRequired) {\n          console.warn(`Module ${path} failed to load:`, error);\n          return { \n            path, \n            error, \n            module: this.createFallbackModule(this.getModuleName(path), error) \n          };\n        }\n        throw error; // Rethrow for required modules if not ignoring errors\n      });\n    });\n    \n    try {\n      const results = await Promise.all(modulePromises);\n      \n      // Process results and add to modules object\n      results.forEach(result => {\n        const moduleName = this.getModuleName(result.path);\n        \n        if (result.module) {\n          modules[moduleName] = result.module;\n        } else {\n          modules[moduleName] = null;\n          console.warn(`Module ${result.path} failed to load:`, result.error);\n        }\n      });\n    } catch (error) {\n      console.error(\"Error loading module chunk:\", error);\n      // Continue with next chunk even if one fails\n    }\n  }\n  \n  return modules;\n },\n \n /**\n * Load a module with its dependencies\n * @param {string} modulePath - Path to the module\n * @param {Object} options - Options\n * @returns {Promise<Object>} - Module and its dependencies\n */\n async loadModule(modulePath, options = {}) {\n  const moduleName = this.getModuleName(modulePath);\n  \n  // Get dependencies for this module\n  const dependencies = this.MODULE_DEPENDENCIES[moduleName + '.js'] || \n                       this.MODULE_DEPENDENCIES[moduleName] || [];\n  \n  // Load dependencies first\n  const deps = {};\n  if (dependencies.length > 0) {\n    console.log(`Loading dependencies for ${moduleName}.js: ${dependencies.join(', ')}`);\n    for (const dep of dependencies) {\n      try {\n        const depName = dep.replace('.js', '');\n        const depModule = await this.ensureModule(depName, {\n          required: false,\n          retries: options.retries || this.defaultOptions.maxRetries,\n          timeout: options.timeout || this.defaultOptions.timeout,\n          standardizeExports: true\n        });\n        \n        if (depModule) {\n          deps[depName] = depModule;\n        }\n      } catch (depError) {\n        console.warn(`Failed to load dependency ${dep} for ${moduleName}:`, depError);\n      }\n    }\n  }\n  \n  // Load the main module\n  try {\n    const module = await this.importModule(modulePath, options);\n    \n    return {\n      module,\n      dependencies: deps\n    };\n  } catch (error) {\n    console.error(`Error loading module ${moduleName} with dependencies:`, error);\n    \n    // Create fallback if required\n    if (options.required) {\n      return {\n        module: this.createFallbackModule(moduleName, error),\n        dependencies: deps\n      };\n    }\n    \n    throw error;\n  }\n },\n \n /**\n * Ensure a module is loaded\n * @param {string} moduleName - Name of the module\n * @param {Object} options - Import options\n * @returns {Promise<Object>} - Loaded module\n */\n async ensureModule(moduleName, options = {}) {\n  if (!moduleName) return null;\n  \n  try {\n    // Handle both with and without .js extension\n    const moduleFileName = moduleName.endsWith('.js') ? moduleName : `${moduleName}.js`;\n    const moduleBase = moduleName.replace(/\\.js$/, '');\n    \n    // Get module location\n    const moduleType = this.MODULE_TYPES[moduleBase] || this.MODULE_LOCATIONS[moduleFileName];\n    \n    if (!moduleType) {\n      console.warn(`Module type not found for ${moduleName}`);\n    }\n    \n    // Try to find the module path\n    let modulePath;\n    \n    if (moduleType) {\n      modulePath = `/static/js/modules/${moduleType}/${moduleFileName}`;\n    } else {\n      // Try to handle both direct and relative paths\n      if (moduleName.includes('/')) {\n        // Likely a direct path\n        modulePath = moduleName;\n      } else {\n        // Try to resolve it as a direct module name\n        modulePath = moduleFileName;\n      }\n    }\n    \n    if (!modulePath) {\n      throw new Error(`Could not resolve path for module: ${moduleName}`);\n    }\n    \n    // Load the module\n    return await this.importModule(modulePath, options);\n  } catch (error) {\n    console.error(`Error ensuring module ${moduleName}:`, error);\n    \n    if (options.required) {\n      throw error;\n    }\n    \n    return this.createFallbackModule(moduleName);\n  }\n },\n \n /**\n * Get a cached module by name\n * @param {string} moduleName - Module name\n * @returns {Object|null} - Cached module or null if not found\n */\n getModule(moduleName) {\n  if (!moduleName) return null;\n  \n  // Try to find by module name\n  const moduleBase = moduleName.replace(/\\.js$/, '');\n  const moduleType = this.MODULE_TYPES[moduleBase];\n  \n  if (moduleType) {\n    const path = `/static/js/modules/${moduleType}/${moduleBase}.js`;\n    const cacheKey = this.getNormalizedPath(path);\n    \n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey);\n    }\n  }\n  \n  // Try to find by directly looking at the cache\n  for (const [cacheKey, module] of this.cache.entries()) {\n    if (cacheKey.includes(moduleBase)) {\n      return module;\n    }\n  }\n  \n  return null;\n },\n \n /**\n * Check module health\n * @returns {Object} - Health check result\n */\n checkModuleHealth() {\n  const result = {\n    healthStatus: 'ok',\n    failedModules: Array.from(this.failedModules),\n    moduleIsFallback: false,\n    systemOperational: true,\n    criticalModulesStatus: {}\n  };\n  \n  // Check critical core modules\n  const criticalModules = ['errorHandler', 'eventRegistry', 'stateManager', 'uiRegistry'];\n  \n  for (const moduleName of criticalModules) {\n    const module = this.getModule(moduleName);\n    \n    if (!module) {\n      result.criticalModulesStatus[moduleName] = 'missing';\n      result.healthStatus = 'critical';\n      result.systemOperational = false;\n    } else if (module.__isFallback) {\n      result.criticalModulesStatus[moduleName] = 'fallback';\n      result.moduleIsFallback = true;\n      result.healthStatus = 'warning';\n    } else {\n      result.criticalModulesStatus[moduleName] = 'ok';\n    }\n  }\n  \n  // Add failed modules count\n  result.failedModulesCount = this.failedModules.size;\n  result.fallbackModulesCount = this.fallbackModules.size;\n  \n  return result;\n },\n \n /**\n * Activate recovery mode in case of critical module failures\n * @returns {Promise<boolean>} - Whether recovery mode was activated\n */\n async activateRecoveryMode() {\n  console.log(\"Activating recovery mode for module loader\");\n  \n  // Set recovery mode flag\n  this._inRecoveryMode = true;\n  \n  try {\n    // Fix any failed modules\n    this.fixFailedModules();\n    \n    // Attempt to reload critical modules with fallbacks\n    const coreModules = ['errorHandler', 'uiRegistry', 'stateManager', 'eventRegistry', 'eventManager', 'themeManager'];\n    const utilityModules = ['ui', 'progressHandler', 'socketHandler'];\n    \n    console.log(\"Attempting to recover core modules...\");\n    for (const moduleName of coreModules) {\n      // Skip modules that are already loaded\n      if (window[moduleName] && !window[moduleName].__isFallback) {\n        continue;\n      }\n      \n      try {\n        const module = await this.ensureModule(moduleName, {\n          retries: 1,\n          timeout: 5000,\n          required: true\n        });\n        \n        if (module) {\n          // Create global reference\n          window[moduleName] = module;\n          window.moduleInstances = window.moduleInstances || {};\n          window.moduleInstances[moduleName] = module;\n          \n          // Initialize if not already initialized\n          if (typeof module.initialize === 'function' && !module.initialized) {\n            try {\n              await module.initialize();\n              console.log(`Recovered and initialized core module: ${moduleName}`);\n            } catch (initError) {\n              console.warn(`Error initializing recovered module ${moduleName}:`, initError);\n            }\n          }\n        }\n      } catch (error) {\n        console.warn(`Failed to recover core module ${moduleName}:`, error);\n        \n        // Create fallback as last resort\n        const fallback = this.createCoreFallback(moduleName);\n        window[moduleName] = fallback;\n        window.moduleInstances = window.moduleInstances || {};\n        window.moduleInstances[moduleName] = fallback;\n        \n        // Initialize fallback\n        if (typeof fallback.initialize === 'function') {\n          await fallback.initialize();\n        }\n      }\n    }\n    \n    console.log(\"Attempting to recover utility modules...\");\n    for (const moduleName of utilityModules) {\n      // Skip modules that are already loaded\n      if (window[moduleName] && !window[moduleName].__isFallback) {\n        continue;\n      }\n      \n      try {\n        const module = await this.ensureModule(moduleName, {\n          retries: 1,\n          timeout: 5000,\n          required: false\n        });\n        \n        if (module) {\n          // Create global reference\n          window[moduleName] = module;\n          window.moduleInstances = window.moduleInstances || {};\n          window.moduleInstances[moduleName] = module;\n          \n          // Initialize if not already initialized\n          if (typeof module.initialize === 'function' && !module.initialized) {\n            try {\n              await module.initialize();\n              console.log(`Recovered and initialized utility module: ${moduleName}`);\n            } catch (initError) {\n              console.warn(`Error initializing recovered utility module ${moduleName}:`, initError);\n            }\n          }\n        }\n      } catch (error) {\n        console.warn(`Failed to recover utility module ${moduleName}:`, error);\n        \n        // Create fallback as last resort\n        const fallback = this.createUtilityFallback(moduleName);\n        window[moduleName] = fallback;\n        window.moduleInstances = window.moduleInstances || {};\n        window.moduleInstances[moduleName] = fallback;\n        \n        // Initialize fallback\n        if (typeof fallback.initialize === 'function') {\n          await fallback.initialize();\n        }\n      }\n    }\n    \n    // Create recovery UI with diagnostic information\n    this.createRecoveryUI();\n    \n    return true;\n  } catch (error) {\n    console.error(\"Error activating recovery mode:\", error);\n    return false;\n  }\n },\n \n /**\n * Create recovery UI for troubleshooting\n */\n createRecoveryUI() {\n  // Try to find or create recovery container\n  let recoveryContainer = document.getElementById('recovery-container');\n  if (recoveryContainer) {\n    recoveryContainer.style.display = 'block';\n    return;\n  }\n  \n  // Create container\n  recoveryContainer = document.createElement('div');\n  recoveryContainer.id = 'recovery-container';\n  recoveryContainer.className = 'container mt-4 p-4 border rounded bg-light';\n  \n  // Create content with helpful options\n  recoveryContainer.innerHTML = `\n    <div class=\"alert alert-warning mb-4\">\n      <h4><i class=\"fas fa-exclamation-triangle me-2\"></i>Limited Functionality Mode</h4>\n      <p>Some modules failed to load correctly. The application is running with reduced functionality.</p>\n    </div>\n    \n    <div class=\"row\">\n      <div class=\"col-md-6\">\n        <div class=\"card mb-3\">\n          <div class=\"card-header bg-primary text-white\">\n            Recovery Options\n          </div>\n          <div class=\"card-body\">\n            <button id=\"refresh-page-btn\" class=\"btn btn-primary mb-2 w-100\">\n              <i class=\"fas fa-sync-alt me-2\"></i>Refresh Page\n            </button>\n            <button id=\"clear-cache-btn\" class=\"btn btn-secondary mb-2 w-100\">\n              <i class=\"fas fa-broom me-2\"></i>Clear Cache & Reload\n            </button>\n            <button id=\"diagnostics-btn\" class=\"btn btn-info mb-2 w-100\">\n              <i class=\"fas fa-stethoscope me-2\"></i>Run Diagnostics\n            </button>\n          </div>\n        </div>\n      </div>\n      \n      <div class=\"col-md-6\">\n        <div class=\"card\">\n          <div class=\"card-header bg-info text-white\">\n            Technical Information\n          </div>\n          <div class=\"card-body\">\n            <p><strong>Failed Modules:</strong> <span id=\"failed-modules-count\">...</span></p>\n            <p><strong>Using Fallbacks:</strong> <span id=\"fallback-modules-count\">...</span></p>\n            <p><strong>Browser:</strong> ${navigator.userAgent}</p>\n            <p><strong>Time:</strong> ${new Date().toLocaleString()}</p>\n          </div>\n        </div>\n      </div>\n    </div>\n    \n    <div id=\"failed-modules-details\" class=\"mt-3 d-none\">\n      <h5>Failed Module Details</h5>\n      <div class=\"table-responsive\">\n        <table class=\"table table-sm table-striped\">\n          <thead>\n            <tr>\n              <th>Module</th>\n              <th>Path</th>\n              <th>Error</th>\n              <th>Attempts</th>\n            </tr>\n          </thead>\n          <tbody id=\"failed-modules-table\">\n          </tbody>\n        </table>\n      </div>\n    </div>\n  `;\n  \n  // Add to document\n  document.body.appendChild(recoveryContainer);\n  \n  // Update failed modules count and fallbacks count\n  const failedModulesCount = document.getElementById('failed-modules-count');\n  const fallbackModulesCount = document.getElementById('fallback-modules-count');\n  const failedModulesTable = document.getElementById('failed-modules-table');\n  const failedModulesDetails = document.getElementById('failed-modules-details');\n  \n  // Get the failed modules information\n  let failedModules = [];\n  if (this.failedModules) {\n    failedModules = Array.from(this.failedModules);\n    \n    if (failedModulesCount) {\n      failedModulesCount.textContent = failedModules.length;\n    }\n    \n    // If we have detailed information about failed modules, show it\n    if (failedModulesTable && failedModules.length > 0) {\n      // Show the details section\n      if (failedModulesDetails) {\n        failedModulesDetails.classList.remove('d-none');\n      }\n      \n      // Populate the table\n      failedModulesTable.innerHTML = failedModules.map(modulePath => {\n        const moduleName = this.getModuleName ? \n                        this.getModuleName(modulePath) : \n                        modulePath.split('/').pop();\n        \n        const attempts = this.loadAttempts && this.loadAttempts.get ? \n                      this.loadAttempts.get(modulePath) || 0 : \n                      'Unknown';\n                      \n        return `\n          <tr>\n            <td>${moduleName}</td>\n            <td><small>${modulePath}</small></td>\n            <td>Failed to load</td>\n            <td>${attempts}</td>\n          </tr>\n        `;\n      }).join('');\n    }\n  } else if (failedModulesCount) {\n    failedModulesCount.textContent = \"Unknown\";\n  }\n  \n  // Get the fallback modules information\n let fallbackModules = [];\n if (this.fallbackModules) {\n   fallbackModules = Array.from(this.fallbackModules);\n   \n   if (fallbackModulesCount) {\n     fallbackModulesCount.textContent = fallbackModules.length;\n   }\n } else if (fallbackModulesCount) {\n   fallbackModulesCount.textContent = \"Unknown\";\n }\n \n // Add button event handlers\n const refreshBtn = document.getElementById('refresh-page-btn');\n if (refreshBtn) {\n   refreshBtn.addEventListener('click', () => {\n     window.location.reload();\n   });\n }\n \n const clearCacheBtn = document.getElementById('clear-cache-btn');\n if (clearCacheBtn) {\n   clearCacheBtn.addEventListener('click', () => {\n     try {\n       // Clear localStorage cache flags\n       localStorage.removeItem('moduleCache');\n       \n       // Clear failed modules state\n       localStorage.removeItem('failedModules');\n       \n       // Clear module loader cache\n       if (typeof this.clearCache === 'function') {\n         this.clearCache(true);\n       }\n       \n       // Reload page\n       window.location.reload();\n     } catch (error) {\n       console.error(\"Error clearing cache:\", error);\n       window.location.reload();\n     }\n   });\n }\n \n const diagnosticsBtn = document.getElementById('diagnostics-btn');\n if (diagnosticsBtn) {\n   diagnosticsBtn.addEventListener('click', () => {\n     if (typeof this.launchDiagnostics === 'function') {\n       this.launchDiagnostics();\n     } else {\n       alert(\"Diagnostics not available\");\n     }\n   });\n }\n},\n\n/**\n* Initialize module diagnostics\n*/\ninitializeModuleDiagnostics() {\n if (this.diagnosticsInitialized) {\n   return;\n }\n \n // Add diagnostics button\n this.createDiagnosticsButton();\n \n // Create diagnostics module if not already created\n window.launchDiagnostics = () => {\n   this.launchDiagnostics();\n };\n \n this.diagnosticsInitialized = true;\n},\n\n/**\n* Create a circular dependency resolver that uses module-bridge\n* @param {string} moduleName - Name of the module\n* @returns {Object} - Object with methods to help resolve circular dependencies\n*/\ncreateCircularDependencyResolver(moduleName) {\n // If there's a proxy for this module, use it\n if (this.moduleProxies.has(moduleName)) {\n   return this.moduleProxies.get(moduleName);\n }\n \n // Create a new proxy to handle circular dependencies\n return this.createModuleProxy(moduleName);\n},\n\n/**\n* Clear the module cache\n* @param {boolean} clearFailed - Whether to clear failed modules too\n*/\nclearCache(clearFailed = false) {\n console.log(\"Clearing module cache\");\n \n // Clear the module cache\n this.cache.clear();\n this.loadingPromises.clear();\n \n // Clear failed modules if requested\n if (clearFailed) {\n   this.fixFailedModules();\n }\n \n // Clear load attempts\n this.loadAttempts.clear();\n \n console.log(\"Module cache cleared\");\n}\n};\n\n// Initialize the module loader to set up the module types\nmoduleLoader.init();\n\n// Export the module loader\nexport default moduleLoader;\n\n// Core functionality exports\nexport const initialize = moduleLoader.initialize.bind(moduleLoader);\nexport const configure = moduleLoader.configure.bind(moduleLoader);\nexport const init = moduleLoader.init.bind(moduleLoader);\nexport const createProxiesForCircularDependencies = moduleLoader.createProxiesForCircularDependencies.bind(moduleLoader);\nexport const startDiagnostics = moduleLoader.startDiagnostics.bind(moduleLoader);\nexport const generateDiagnosticsReport = moduleLoader.generateDiagnosticsReport.bind(moduleLoader);\nexport const clearCache = moduleLoader.clearCache.bind(moduleLoader);\nexport const fixFailedModules = moduleLoader.fixFailedModules.bind(moduleLoader);\n\n// Module loading exports\nexport const importModule = moduleLoader.importModule.bind(moduleLoader);\nexport const importModules = moduleLoader.importModules.bind(moduleLoader);\nexport const loadModule = moduleLoader.loadModule.bind(moduleLoader);\nexport const ensureModule = moduleLoader.ensureModule.bind(moduleLoader);\nexport const getModule = moduleLoader.getModule.bind(moduleLoader);\nexport const safeImport = moduleLoader.safeImport.bind(moduleLoader);\n\n// Path resolution exports\nexport const resolvePath = moduleLoader.resolvePath.bind(moduleLoader);\nexport const getNormalizedPath = moduleLoader.getNormalizedPath.bind(moduleLoader);\nexport const cleanModulePath = moduleLoader.cleanModulePath.bind(moduleLoader);\nexport const getModuleName = moduleLoader.getModuleName.bind(moduleLoader);\n\n// Proxy management exports\nexport const createModuleProxy = moduleLoader.createModuleProxy.bind(moduleLoader);\nexport const updateModuleProxy = moduleLoader.updateModuleProxy.bind(moduleLoader);\nexport const integrateWithBridge = moduleLoader.integrateWithBridge.bind(moduleLoader);\nexport const createCircularDependencyResolver = moduleLoader.createCircularDependencyResolver.bind(moduleLoader);\nexport const createPromiseAwareProxyHandler = moduleLoader.createPromiseAwareProxyHandler.bind(moduleLoader);\n\n// Fallback management exports\nexport const createFallbackModule = moduleLoader.createFallbackModule.bind(moduleLoader);\nexport const createCoreFallback = moduleLoader.createCoreFallback.bind(moduleLoader);\nexport const createFeatureFallback = moduleLoader.createFeatureFallback.bind(moduleLoader);\nexport const createUtilityFallback = moduleLoader.createUtilityFallback.bind(moduleLoader);\nexport const createPlaylistDownloaderFallback = moduleLoader.createPlaylistDownloaderFallback.bind(moduleLoader);\nexport const isFallbackModule = moduleLoader.isFallbackModule.bind(moduleLoader);\nexport const getModulesUsingFallbacks = moduleLoader.getModulesUsingFallbacks.bind(moduleLoader);\n\n// Diagnostic & health checking exports\nexport const checkModuleHealth = moduleLoader.checkModuleHealth.bind(moduleLoader);\nexport const generateHealthReport = moduleLoader.generateHealthReport.bind(moduleLoader);\nexport const createDiagnosticsButton = moduleLoader.createDiagnosticsButton.bind(moduleLoader);\nexport const launchDiagnostics = moduleLoader.launchDiagnostics.bind(moduleLoader);\nexport const showModuleHealth = moduleLoader.showModuleHealth.bind(moduleLoader);\nexport const initializeModuleDiagnostics = moduleLoader.initializeModuleDiagnostics.bind(moduleLoader);\nexport const activateRecoveryMode = moduleLoader.activateRecoveryMode.bind(moduleLoader);\nexport const createRecoveryUI = moduleLoader.createRecoveryUI.bind(moduleLoader);\n\n// UI & DOM utilities exports\nexport const applyStoredTheme = moduleLoader.applyStoredTheme.bind(moduleLoader);\nexport const setupBasicTabNavigation = moduleLoader.setupBasicTabNavigation.bind(moduleLoader);\nexport const showErrorMessage = moduleLoader.showErrorMessage.bind(moduleLoader);\nexport const supportsESModules = moduleLoader.supportsESModules.bind(moduleLoader);\n\n// Utility function exports\nexport const autoCreateMissingExports = moduleLoader.autoCreateMissingExports.bind(moduleLoader);\nexport const checkForDuplicateFunctions = moduleLoader.checkForDuplicateFunctions.bind(moduleLoader);","source":"/workspace/modules/static/js/modules/core/moduleLoader.js","title":"moduleLoader.js","language":"en"},{"content":"/**\n * NeuroGen Server - State Manager Module\n * \n * Provides a centralized state management system for the application.\n * Implements a simplified Redux-like pattern with state, actions, and subscriptions.\n * Enhanced with persistence, detailed history tracking, path-based subscriptions,\n * and error recovery mechanisms.\n */\n\n/**\n * State Manager for application-wide state\n */\nconst stateManager = {\n  // Private state storage\n  _state: {\n    // Application-level state\n    app: {\n      initialized: false,\n      theme: 'light',\n      error: null,\n      version: '1.0.0',\n      lastUpdated: new Date().toISOString(),\n      debugMode: false,\n      systemInfo: {\n        platform: typeof navigator !== 'undefined' ? navigator.platform : 'unknown',\n        userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'unknown',\n        language: typeof navigator !== 'undefined' ? navigator.language : 'unknown'\n      }\n    },\n    \n    // Feature-specific state\n    fileProcessor: {\n      files: [],\n      processing: false,\n      task: null,\n      progress: 0,\n      error: null,\n      results: null,\n      options: {\n        extractText: true,\n        extractTables: true,\n        parseStructure: true,\n        useOcr: true\n      }\n    },\n    \n    webScraper: {\n      urls: [],\n      processing: false,\n      task: null,\n      progress: 0,\n      results: null,\n      error: null,\n      options: {\n        downloadPdfs: true,\n        processPdfs: true,\n        maxDepth: 1,\n        followLinks: false\n      },\n      pdfDownloads: []\n    },\n    \n    playlistDownloader: {\n      playlists: [],\n      processing: false,\n      task: null,\n      progress: 0,\n      results: null,\n      error: null,\n      options: {\n        audioOnly: true,\n        highQuality: false,\n        createPlaylist: true,\n        extractMetadata: true\n      }\n    },\n    \n    academicSearch: {\n      results: [],\n      searching: false,\n      query: '',\n      source: 'all',\n      filters: {\n        yearStart: null,\n        yearEnd: null,\n        openAccess: false,\n        sortBy: 'relevance'\n      },\n      selectedItems: []\n    },\n    \n    // UI state\n    ui: {\n      activeTab: 'file-processor',\n      modals: {},\n      loading: false,\n      notifications: [],\n      tour: {\n        completed: false,\n        currentStep: 0\n      },\n      panels: {\n        leftSidebar: {\n          visible: true,\n          width: 250\n        },\n        rightSidebar: {\n          visible: false, \n          width: 300\n        }\n      },\n      lastInteraction: new Date().toISOString()\n    },\n    \n    // User settings/preferences\n    settings: {\n      outputPath: '',\n      darkMode: false,\n      autoDownload: true,\n      debug: false,\n      advanced: {\n        maxThreads: 4,\n        cacheResults: true,\n        socketTimeout: 30000,\n        autoSave: true\n      },\n      accessibility: {\n        highContrast: false,\n        fontSize: 'normal',\n        reduceMotion: false\n      }\n    },\n    \n    // Processing history\n    history: {\n      tasks: [],\n      recentFiles: [],\n      recentSearches: [],\n      lastTask: null\n    }\n  },\n  \n  // Subscriber callbacks\n  _subscribers: [],\n  \n  // Path-based subscribers\n  _pathSubscribers: {},\n  \n  // History of state changes\n  _history: [],\n  \n  // Maximum history size\n  _maxHistorySize: 50,\n  \n  // Root paths for persistence\n  _persistentPaths: ['settings', 'history.recentFiles', 'history.recentSearches'],\n  \n  // Storage key for persistence\n  _storageKey: 'neurogenserver_state',\n  \n  // Flag to prevent circular updates with persistence\n  _updatingFromStorage: false,\n  \n  // Debug mode flag\n  _debugMode: false,\n  \n  // Track initialization status\n  initialized: false,\n  \n  /**\n   * Initialize the state manager\n   * @param {Object} initialState - Optional initial state override\n   * @param {Object} options - Optional configuration\n   * @returns {boolean} - Whether initialization was successful\n   */\n  initialize(initialState = {}, options = {}) {\n    if (this.initialized) {\n      console.warn('State manager already initialized');\n      return false;\n    }\n    \n    try {\n      // Set options\n      if (options.debugMode !== undefined) {\n        this._debugMode = options.debugMode;\n      }\n      \n      if (options.storageKey) {\n        this._storageKey = options.storageKey;\n      }\n      \n      if (options.maxHistorySize !== undefined) {\n        this._maxHistorySize = options.maxHistorySize;\n      }\n      \n      if (options.persistentPaths) {\n        this._persistentPaths = options.persistentPaths;\n      }\n      \n      // Load persisted state from storage\n      this._loadPersistedState();\n      \n      // Merge initialState with default state if provided\n      if (initialState && typeof initialState === 'object') {\n        this._state = this._deepMerge(this._state, initialState);\n      }\n      \n      // Set debug mode in state\n      this._state.app.debugMode = this._debugMode;\n      \n      // Initialize state change monitoring for state persistence\n      this._initStateChangeMonitoring();\n      \n      // Mark as initialized\n      this.initialized = true;\n      this._state.app.initialized = true;\n      this._state.app.lastUpdated = new Date().toISOString();\n      \n      // Make available globally for debugging if in debug mode\n      if (this._debugMode || window.debugMode) {\n        window.stateManager = this;\n      }\n      \n      // Add event listener for storage events to sync state across tabs if needed\n      if (options.syncAcrossTabs) {\n        this._setupStorageListener();\n      }\n      \n      console.log('State manager initialized');\n      return true;\n    } catch (error) {\n      console.error('Error initializing state manager:', error);\n      return false;\n    }\n  },\n  \n  /**\n   * Get current state or a specific part of it\n   * @param {string} path - Optional dot notation path (e.g., 'app.theme')\n   * @returns {*} - The requested state or full state object\n   */\n  getState(path = null) {\n    try {\n      // Return full state if no path provided\n      if (!path) {\n        return this._deepClone(this._state);\n      }\n      \n      // Parse the path\n      const parts = path.split('.');\n      let currentObj = this._state;\n      \n      // Traverse the path\n      for (const part of parts) {\n        if (currentObj === undefined || currentObj === null) {\n          return undefined;\n        }\n        \n        currentObj = currentObj[part];\n      }\n      \n      // Return a deep clone to prevent direct state modification\n      return this._deepClone(currentObj);\n    } catch (error) {\n      console.error('Error getting state:', error);\n      return undefined;\n    }\n  },\n  \n  /**\n   * Update the state\n   * @param {string|Object} pathOrState - Path to update or state object\n   * @param {*} value - Value to set (if path is provided)\n   * @param {Object} options - Additional options for the update\n   * @returns {boolean} - Whether the update was successful\n   */\n  setState(pathOrState, value, options = {}) {\n    try {\n      // Default options\n      const defaultOptions = {\n        addToHistory: true,\n        notifySubscribers: true,\n        persist: true\n      };\n      \n      const updateOptions = { ...defaultOptions, ...options };\n      \n      // Save previous state for history\n      const previousState = this._deepClone(this._state);\n      \n      // Handle object update\n      if (typeof pathOrState === 'object') {\n        // Merge in the new state\n        this._state = this._deepMerge(this._state, pathOrState);\n      }\n      // Handle path update\n      else if (typeof pathOrState === 'string') {\n        const path = pathOrState;\n        \n        // Parse the path\n        const parts = path.split('.');\n        let currentObj = this._state;\n        \n        // Traverse the path to the parent object\n        for (let i = 0; i < parts.length - 1; i++) {\n          const part = parts[i];\n          \n          // Create missing objects along the path\n          if (currentObj[part] === undefined || currentObj[part] === null) {\n            currentObj[part] = {};\n          }\n          \n          currentObj = currentObj[part];\n        }\n        \n        // Set the value at the leaf\n        const lastPart = parts[parts.length - 1];\n        currentObj[lastPart] = value;\n      }\n      else {\n        console.error('Invalid argument for setState: must be object or string path');\n        return false;\n      }\n      \n      // Update last updated timestamp\n      this._state.app.lastUpdated = new Date().toISOString();\n      \n      // Add to history if enabled\n      if (updateOptions.addToHistory) {\n        this._addToHistory(previousState, this._state);\n      }\n      \n      // Persist state if enabled and not triggered by storage event\n      if (updateOptions.persist && !this._updatingFromStorage) {\n        this._persistState();\n      }\n      \n      // Notify subscribers if enabled\n      if (updateOptions.notifySubscribers) {\n        this._notifySubscribers(previousState);\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('Error setting state:', error);\n      return false;\n    }\n  },\n  \n  /**\n   * Batch multiple state updates in a single operation\n   * @param {Array<{path: string, value: any}>|Object} updates - Array of updates or object with paths as keys\n   * @param {Object} options - Additional options for the batch update\n   * @returns {boolean} - Whether all updates were successful\n   */\n  batchUpdate(updates, options = {}) {\n    try {\n      // Save previous state for history\n      const previousState = this._deepClone(this._state);\n      \n      // Apply all updates without notifications\n      let success = true;\n      \n      // Handle array of updates\n      if (Array.isArray(updates)) {\n        for (const update of updates) {\n          if (!update.path) {\n            console.error('Invalid update: missing path', update);\n            success = false;\n            continue;\n          }\n          \n          // Apply update without history or notifications\n          const updateResult = this.setState(\n            update.path, \n            update.value, \n            { addToHistory: false, notifySubscribers: false, persist: false }\n          );\n          \n          if (!updateResult) {\n            success = false;\n          }\n        }\n      }\n      // Handle object with paths as keys\n      else if (typeof updates === 'object') {\n        for (const [path, value] of Object.entries(updates)) {\n          // Apply update without history or notifications\n          const updateResult = this.setState(\n            path, \n            value, \n            { addToHistory: false, notifySubscribers: false, persist: false }\n          );\n          \n          if (!updateResult) {\n            success = false;\n          }\n        }\n      }\n      else {\n        console.error('Invalid argument for batchUpdate: must be array or object');\n        return false;\n      }\n      \n      // Update timestamp\n      this._state.app.lastUpdated = new Date().toISOString();\n      \n      // Now add to history, persist, and notify subscribers just once\n      if (options.addToHistory !== false) {\n        this._addToHistory(previousState, this._state);\n      }\n      \n      if (options.persist !== false && !this._updatingFromStorage) {\n        this._persistState();\n      }\n      \n      if (options.notifySubscribers !== false) {\n        this._notifySubscribers(previousState);\n      }\n      \n      return success;\n    } catch (error) {\n      console.error('Error performing batch update:', error);\n      return false;\n    }\n  },\n  \n  /**\n   * Load persisted state from storage\n   * @private\n   */\n  _loadPersistedState() {\n    try {\n      this._updatingFromStorage = true;\n      \n      // Try to get persisted state from localStorage\n      const persistedStateJson = localStorage.getItem(this._storageKey);\n      if (!persistedStateJson) {\n        this._updatingFromStorage = false;\n        return;\n      }\n      \n      const persistedState = JSON.parse(persistedStateJson);\n      if (!persistedState || typeof persistedState !== 'object') {\n        this._updatingFromStorage = false;\n        return;\n      }\n      \n      // Apply persisted state for each persistent path\n      for (const path of this._persistentPaths) {\n        const value = this._getValueByPath(persistedState, path);\n        if (value !== undefined) {\n          this._setValueByPath(this._state, path, value);\n        }\n      }\n      \n      this._updatingFromStorage = false;\n      console.log('Loaded persisted state');\n    } catch (error) {\n      this._updatingFromStorage = false;\n      console.warn('Error loading persisted state:', error);\n    }\n  },\n  \n  /**\n   * Persist state to storage\n   * @private\n   */\n  _persistState() {\n    try {\n      // Create a new object with only persistent paths\n      const persistObj = {};\n      \n      for (const path of this._persistentPaths) {\n        const value = this._getValueByPath(this._state, path);\n        if (value !== undefined) {\n          this._setValueByPath(persistObj, path, value);\n        }\n      }\n      \n      // Add metadata\n      persistObj.meta = {\n        timestamp: new Date().toISOString(),\n        version: this._state.app.version\n      };\n      \n      // Store in localStorage\n      localStorage.setItem(this._storageKey, JSON.stringify(persistObj));\n      \n      if (this._debugMode) {\n        console.log('State persisted to storage');\n      }\n    } catch (error) {\n      console.warn('Error persisting state:', error);\n    }\n  },\n  \n  /**\n   * Set up storage event listener for cross-tab syncing\n   * @private\n   */\n  _setupStorageListener() {\n    try {\n      window.addEventListener('storage', (event) => {\n        if (event.key === this._storageKey && event.newValue) {\n          try {\n            this._updatingFromStorage = true;\n            \n            const persistedState = JSON.parse(event.newValue);\n            if (!persistedState || typeof persistedState !== 'object') {\n              this._updatingFromStorage = false;\n              return;\n            }\n            \n            // Save previous state for notifications\n            const previousState = this._deepClone(this._state);\n            \n            // Apply persisted state for each persistent path\n            for (const path of this._persistentPaths) {\n              const value = this._getValueByPath(persistedState, path);\n              if (value !== undefined) {\n                this._setValueByPath(this._state, path, value);\n              }\n            }\n            \n            // Update timestamp\n            this._state.app.lastUpdated = new Date().toISOString();\n            \n            // Notify subscribers\n            this._notifySubscribers(previousState);\n            \n            this._updatingFromStorage = false;\n            \n            if (this._debugMode) {\n              console.log('State synchronized from another tab');\n            }\n          } catch (error) {\n            this._updatingFromStorage = false;\n            console.warn('Error processing storage event:', error);\n          }\n        }\n      });\n      \n      console.log('Cross-tab state synchronization enabled');\n    } catch (error) {\n      console.warn('Error setting up storage listener:', error);\n    }\n  },\n  \n  /**\n   * Get a value from an object by dot notation path\n   * @private\n   * @param {Object} obj - Object to get value from\n   * @param {string} path - Dot notation path\n   * @returns {*} - Value at path or undefined\n   */\n  _getValueByPath(obj, path) {\n    try {\n      const parts = path.split('.');\n      let current = obj;\n      \n      for (const part of parts) {\n        if (current === undefined || current === null) {\n          return undefined;\n        }\n        current = current[part];\n      }\n      \n      return current;\n    } catch (error) {\n      console.warn(`Error getting value by path ${path}:`, error);\n      return undefined;\n    }\n  },\n  \n  /**\n   * Set a value in an object by dot notation path\n   * @private\n   * @param {Object} obj - Object to set value in\n   * @param {string} path - Dot notation path\n   * @param {*} value - Value to set\n   */\n  _setValueByPath(obj, path, value) {\n    try {\n      const parts = path.split('.');\n      let current = obj;\n      \n      // Navigate to the parent of the target\n      for (let i = 0; i < parts.length - 1; i++) {\n        const part = parts[i];\n        if (current[part] === undefined || current[part] === null) {\n          current[part] = {};\n        }\n        current = current[part];\n      }\n      \n      // Set the value on the target property\n      const lastPart = parts[parts.length - 1];\n      current[lastPart] = value;\n    } catch (error) {\n      console.warn(`Error setting value by path ${path}:`, error);\n    }\n  },\n  \n  /**\n   * Initialize state change monitoring for persistence\n   * @private\n   */\n  _initStateChangeMonitoring() {\n    // Subscribe to state changes for persistence\n    this.subscribe((newState, oldState) => {\n      // Check if any persistent paths changed\n      let persistentPathChanged = false;\n      \n      for (const path of this._persistentPaths) {\n        const newValue = this._getValueByPath(newState, path);\n        const oldValue = this._getValueByPath(oldState, path);\n        \n        // Compare as JSON strings for deep equality\n        if (JSON.stringify(newValue) !== JSON.stringify(oldValue)) {\n          persistentPathChanged = true;\n          break;\n        }\n      }\n      \n      // Persist if changed and not already updating from storage\n      if (persistentPathChanged && !this._updatingFromStorage) {\n        this._persistState();\n      }\n    });\n  },\n  \n  /**\n     * Add a state change to history\n     * @private\n     * @param {Object} previousState - State before change\n     * @param {Object} newState - State after change\n     */\n  _addToHistory(previousState, newState) {\n    try {\n      // Create history entry with timestamp\n      const historyEntry = {\n        timestamp: new Date().toISOString(),\n        previousState,\n        newState,\n        changes: this._getChanges(previousState, newState)\n      };\n      \n      // Add to history\n      this._history.push(historyEntry);\n      \n      // Trim history if needed\n      if (this._history.length > this._maxHistorySize) {\n        this._history.shift();\n      }\n    } catch (error) {\n      console.warn('Error adding to history:', error);\n    }\n  },\n\n  /**\n   * Get the changes between two states\n   * @private\n   * @param {Object} prevState - Previous state\n   * @param {Object} newState - New state\n   * @returns {Object} - Changed paths and values\n   */\n  _getChanges(prevState, newState) {\n    try {\n      const changes = {};\n      \n      // Helper to find changes recursively\n      const findChanges = (prev, next, path = '') => {\n        // If types differ, consider it changed\n        if (typeof prev !== typeof next) {\n          changes[path] = { from: prev, to: next };\n          return;\n        }\n        \n        // Handle null\n        if (prev === null || next === null) {\n          if (prev !== next) {\n            changes[path] = { from: prev, to: next };\n          }\n          return;\n        }\n        \n        // Handle non-objects\n        if (typeof prev !== 'object') {\n          if (prev !== next) {\n            changes[path] = { from: prev, to: next };\n          }\n          return;\n        }\n        \n        // Handle arrays\n        if (Array.isArray(prev) && Array.isArray(next)) {\n          if (JSON.stringify(prev) !== JSON.stringify(next)) {\n            changes[path] = { from: prev, to: next };\n          }\n          return;\n        }\n        \n        // Handle Dates\n        if (prev instanceof Date && next instanceof Date) {\n          if (prev.getTime() !== next.getTime()) {\n            changes[path] = { from: prev.toISOString(), to: next.toISOString() };\n          }\n          return;\n        }\n        \n        // Handle objects\n        const allKeys = new Set([...Object.keys(prev), ...Object.keys(next)]);\n        \n        for (const key of allKeys) {\n          const keyPath = path ? `${path}.${key}` : key;\n          \n          // If key exists in both objects, recurse\n          if (key in prev && key in next) {\n            findChanges(prev[key], next[key], keyPath);\n          }\n          // Key only in prev\n          else if (key in prev) {\n            changes[keyPath] = { from: prev[key], to: undefined };\n          }\n          // Key only in next\n          else {\n            changes[keyPath] = { from: undefined, to: next[key] };\n          }\n        }\n      };\n      \n      findChanges(prevState, newState);\n      return changes;\n    } catch (error) {\n      console.warn('Error calculating state changes:', error);\n      return {};\n    }\n  },\n\n  /**\n   * Notify all subscribers of state change\n   * @private\n   * @param {Object} previousState - State before change\n   */\n  _notifySubscribers(previousState) {\n    try {\n      const newState = this._deepClone(this._state);\n      \n      // Prepare changes for path-based subscriptions\n      const changes = this._getChanges(previousState, newState);\n      const changedPaths = Object.keys(changes);\n      \n      // Call each global subscriber with new state and previous state\n      for (const subscriber of this._subscribers) {\n        try {\n          subscriber(newState, previousState);\n        } catch (error) {\n          console.error('Error in state subscriber callback:', error);\n        }\n      }\n      \n      // Call path-based subscribers if their paths changed\n      for (const [path, subscribers] of Object.entries(this._pathSubscribers)) {\n        // Check if this path or any child path was changed\n        const pathChanged = changedPaths.some(changedPath => \n          changedPath === path || // Exact match\n          changedPath.startsWith(`${path}.`) || // Child property\n          path.startsWith(`${changedPath}.`) // Parent property\n        );\n        \n        if (pathChanged) {\n          const pathValue = this._getValueByPath(newState, path);\n          const previousPathValue = this._getValueByPath(previousState, path);\n          \n          for (const subscriber of subscribers) {\n            try {\n              subscriber(pathValue, previousPathValue, newState, previousState);\n            } catch (error) {\n              console.error(`Error in path subscriber callback for ${path}:`, error);\n            }\n          }\n        }\n      }\n      \n      // Try to dispatch event if eventRegistry is available\n      try {\n        if (window.eventRegistry && typeof window.eventRegistry.emit === 'function') {\n          window.eventRegistry.emit('state:change', {\n            state: newState,\n            previousState,\n            changes\n          });\n        }\n      } catch (e) {\n        // Ignore errors with event registry\n        if (this._debugMode) {\n          console.debug('Error emitting state:change event:', e);\n        }\n      }\n    } catch (error) {\n      console.error('Error notifying subscribers:', error);\n    }\n  },\n\n  /**\n   * Subscribe to state changes\n   * @param {Function} callback - Function to call on state change\n   * @returns {Function} - Unsubscribe function\n   */\n  subscribe(callback) {\n    if (typeof callback !== 'function') {\n      console.error('Subscriber must be a function');\n      return () => {};\n    }\n    \n    try {\n      // Add subscriber\n      this._subscribers.push(callback);\n      \n      // Return unsubscribe function\n      return () => {\n        const index = this._subscribers.indexOf(callback);\n        if (index !== -1) {\n          this._subscribers.splice(index, 1);\n          return true;\n        }\n        return false;\n      };\n    } catch (error) {\n      console.error('Error subscribing to state changes:', error);\n      return () => {};\n    }\n  },\n\n  /**\n   * Subscribe to changes at a specific state path\n   * @param {string} path - Dot notation path to subscribe to\n   * @param {Function} callback - Function to call when this path changes\n   * @returns {Function} - Unsubscribe function\n   */\n  subscribePath(path, callback) {\n    if (typeof path !== 'string') {\n      console.error('Path must be a string');\n      return () => {};\n    }\n    \n    if (typeof callback !== 'function') {\n      console.error('Subscriber must be a function');\n      return () => {};\n    }\n    \n    try {\n      // Create subscribers array for this path if it doesn't exist\n      if (!this._pathSubscribers[path]) {\n        this._pathSubscribers[path] = [];\n      }\n      \n      // Add the callback\n      this._pathSubscribers[path].push(callback);\n      \n      // Return unsubscribe function\n      return () => {\n        if (!this._pathSubscribers[path]) return false;\n        \n        const index = this._pathSubscribers[path].indexOf(callback);\n        if (index !== -1) {\n          this._pathSubscribers[path].splice(index, 1);\n          \n          // Clean up empty arrays\n          if (this._pathSubscribers[path].length === 0) {\n            delete this._pathSubscribers[path];\n          }\n          \n          return true;\n        }\n        return false;\n      };\n    } catch (error) {\n      console.error(`Error subscribing to path ${path}:`, error);\n      return () => {};\n    }\n  },\n\n  /**\n   * Reset state to initial values\n   * @param {string} section - Optional section to reset\n   * @returns {boolean} - Whether reset was successful\n   */\n  resetState(section = null) {\n    try {\n      // Save previous state\n      const previousState = this._deepClone(this._state);\n      \n      if (section) {\n        // Reset only the specified section by creating a fresh state\n        const initialState = {\n          app: {\n            initialized: true,\n            theme: this._state.app.theme,\n            version: this._state.app.version,\n            lastUpdated: new Date().toISOString(),\n            debugMode: this._debugMode,\n            systemInfo: this._state.app.systemInfo,\n            error: null\n          },\n          fileProcessor: {\n            files: [],\n            processing: false,\n            task: null,\n            progress: 0,\n            error: null,\n            results: null,\n            options: {\n              extractText: true,\n              extractTables: true,\n              parseStructure: true,\n              useOcr: true\n            }\n          },\n          webScraper: {\n            urls: [],\n            processing: false,\n            task: null,\n            progress: 0,\n            results: null,\n            error: null,\n            options: {\n              downloadPdfs: true,\n              processPdfs: true,\n              maxDepth: 1,\n              followLinks: false\n            },\n            pdfDownloads: []\n          },\n          playlistDownloader: {\n            playlists: [],\n            processing: false,\n            task: null,\n            progress: 0,\n            results: null,\n            error: null,\n            options: {\n              audioOnly: true,\n              highQuality: false,\n              createPlaylist: true,\n              extractMetadata: true\n            }\n          },\n          academicSearch: {\n            results: [],\n            searching: false,\n            query: '',\n            source: 'all',\n            filters: {\n              yearStart: null,\n              yearEnd: null,\n              openAccess: false,\n              sortBy: 'relevance'\n            },\n            selectedItems: []\n          },\n          ui: {\n            activeTab: 'file-processor',\n            modals: {},\n            loading: false,\n            notifications: [],\n            tour: {\n              completed: false,\n              currentStep: 0\n            },\n            panels: {\n              leftSidebar: {\n                visible: true,\n                width: 250\n              },\n              rightSidebar: {\n                visible: false, \n                width: 300\n              }\n            },\n            lastInteraction: new Date().toISOString()\n          },\n          settings: this._state.settings, // Preserve settings\n          history: this._state.history // Preserve history\n        };\n        \n        if (initialState[section]) {\n          this._state[section] = this._deepClone(initialState[section]);\n          \n          // For processing modules, ensure they're not in a broken state\n          if (['fileProcessor', 'webScraper', 'playlistDownloader', 'academicSearch'].includes(section)) {\n            this._state[section].processing = false;\n            this._state[section].progress = 0;\n            this._state[section].error = null;\n          }\n        } else {\n          console.error(`Invalid state section: ${section}`);\n          return false;\n        }\n      } else {\n        // Reset entire state by recreating it\n        // But preserve settings and process history\n        const settings = this._deepClone(this._state.settings);\n        const history = this._deepClone(this._state.history);\n        \n        // Reset with initial state\n        this._state = this._deepClone(this._getInitialState());\n        \n        // Restore settings and history\n        this._state.settings = settings;\n        this._state.history = history;\n        \n        // Ensure app is marked as initialized\n        this._state.app.initialized = true;\n        this._state.app.lastUpdated = new Date().toISOString();\n        this._state.app.debugMode = this._debugMode;\n      }\n      \n      // Add to history\n      this._addToHistory(previousState, this._state);\n      \n      // Persist state changes\n      this._persistState();\n      \n      // Notify subscribers\n      this._notifySubscribers(previousState);\n      \n      console.log(`State ${section ? `section ${section}` : 'fully'} reset`);\n      return true;\n    } catch (error) {\n      console.error('Error resetting state:', error);\n      return false;\n    }\n  },\n\n  /**\n   * Get a fresh initial state object\n   * @private\n   * @returns {Object} - Initial state object\n   */\n  _getInitialState() {\n    return {\n      app: {\n        initialized: false,\n        theme: 'light',\n        error: null,\n        version: '1.0.0',\n        lastUpdated: new Date().toISOString(),\n        debugMode: this._debugMode,\n        systemInfo: {\n          platform: typeof navigator !== 'undefined' ? navigator.platform : 'unknown',\n          userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'unknown',\n          language: typeof navigator !== 'undefined' ? navigator.language : 'unknown'\n        }\n      },\n      fileProcessor: {\n        files: [],\n        processing: false,\n        task: null,\n        progress: 0,\n        error: null,\n        results: null,\n        options: {\n          extractText: true,\n          extractTables: true,\n          parseStructure: true,\n          useOcr: true\n        }\n      },\n      webScraper: {\n        urls: [],\n        processing: false,\n        task: null,\n        progress: 0,\n        results: null,\n        error: null,\n        options: {\n          downloadPdfs: true,\n          processPdfs: true,\n          maxDepth: 1,\n          followLinks: false\n        },\n        pdfDownloads: []\n      },\n      playlistDownloader: {\n        playlists: [],\n        processing: false,\n        task: null,\n        progress: 0,\n        results: null,\n        error: null,\n        options: {\n          audioOnly: true,\n          highQuality: false,\n          createPlaylist: true,\n          extractMetadata: true\n        }\n      },\n      academicSearch: {\n        results: [],\n        searching: false,\n        query: '',\n        source: 'all',\n        filters: {\n          yearStart: null,\n          yearEnd: null,\n          openAccess: false,\n          sortBy: 'relevance'\n        },\n        selectedItems: []\n      },\n      ui: {\n        activeTab: 'file-processor',\n        modals: {},\n        loading: false,\n        notifications: [],\n        tour: {\n          completed: false,\n          currentStep: 0\n        },\n        panels: {\n          leftSidebar: {\n            visible: true,\n            width: 250\n          },\n          rightSidebar: {\n            visible: false, \n            width: 300\n          }\n        },\n        lastInteraction: new Date().toISOString()\n      },\n      settings: {\n        outputPath: '',\n        darkMode: false,\n        autoDownload: true,\n        debug: false,\n        advanced: {\n          maxThreads: 4,\n          cacheResults: true,\n          socketTimeout: 30000,\n          autoSave: true\n        },\n        accessibility: {\n          highContrast: false,\n          fontSize: 'normal',\n          reduceMotion: false\n        }\n      },\n      history: {\n        tasks: [],\n        recentFiles: [],\n        recentSearches: [],\n        lastTask: null\n      }\n    };\n  },\n\n  /**\n   * Get state history\n   * @param {number} limit - Max number of history entries to return\n   * @returns {Array} - State history\n   */\n  getHistory(limit = null) {\n    try {\n      if (limit) {\n        return this._deepClone(this._history.slice(-limit));\n      }\n      \n      return this._deepClone(this._history);\n    } catch (error) {\n      console.error('Error getting state history:', error);\n      return [];\n    }\n  },\n\n  /**\n   * Clear state history\n   * @returns {boolean} - Whether history was cleared\n   */\n  clearHistory() {\n    try {\n      this._history = [];\n      return true;\n    } catch (error) {\n      console.error('Error clearing state history:', error);\n      return false;\n    }\n  },\n\n  /**\n   * Add an item to a state array\n   * @param {string} path - Path to the array\n   * @param {*} item - Item to add\n   * @param {Object} options - Additional options\n   * @returns {boolean} - Whether item was added\n   */\n  addArrayItem(path, item, options = {}) {\n    try {\n      const array = this._getValueByPath(this._state, path);\n      \n      if (!Array.isArray(array)) {\n        console.error(`Path ${path} is not an array`);\n        return false;\n      }\n      \n      // Clone the array\n      const newArray = [...array];\n      \n      // Add the item\n      if (options.prepend) {\n        newArray.unshift(item);\n      } else {\n        newArray.push(item);\n      }\n      \n      // Limit the array size if specified\n      if (options.maxLength && newArray.length > options.maxLength) {\n        if (options.prepend) {\n          // Remove from the end\n          newArray.splice(options.maxLength);\n        } else {\n          // Remove from the beginning\n          newArray.splice(0, newArray.length - options.maxLength);\n        }\n      }\n      \n      // Update the state\n      return this.setState(path, newArray, options);\n    } catch (error) {\n      console.error(`Error adding item to array at ${path}:`, error);\n      return false;\n    }\n  },\n\n  /**\n   * Remove an item from a state array\n   * @param {string} path - Path to the array\n   * @param {*} itemOrPredicate - Item to remove or predicate function\n   * @param {Object} options - Additional options\n   * @returns {boolean} - Whether item was removed\n   */\n  removeArrayItem(path, itemOrPredicate, options = {}) {\n    try {\n      const array = this._getValueByPath(this._state, path);\n      \n      if (!Array.isArray(array)) {\n        console.error(`Path ${path} is not an array`);\n        return false;\n      }\n      \n      // Clone the array\n      let newArray = [...array];\n      \n      // Remove the item(s)\n      if (typeof itemOrPredicate === 'function') {\n        // Use predicate function to filter items\n        newArray = newArray.filter(item => !itemOrPredicate(item));\n      } else {\n        // Remove by equality\n        if (options.strict) {\n          // Use strict equality\n          newArray = newArray.filter(item => item !== itemOrPredicate);\n        } else {\n          // Use deep equality\n          const stringifiedItem = JSON.stringify(itemOrPredicate);\n          newArray = newArray.filter(item => JSON.stringify(item) !== stringifiedItem);\n        }\n      }\n      \n      // Check if anything was removed\n      if (newArray.length === array.length) {\n        return false;\n      }\n      \n      // Update the state\n      return this.setState(path, newArray, options);\n    } catch (error) {\n      console.error(`Error removing item from array at ${path}:`, error);\n      return false;\n    }\n  },\n\n  /**\n   * Update an item in a state array\n   * @param {string} path - Path to the array\n   * @param {*} itemOrPredicate - Item to update or predicate function\n   * @param {*} updatedItem - Updated item or update function\n   * @param {Object} options - Additional options\n   * @returns {boolean} - Whether item was updated\n   */\n  updateArrayItem(path, itemOrPredicate, updatedItem, options = {}) {\n    try {\n      const array = this._getValueByPath(this._state, path);\n      \n      if (!Array.isArray(array)) {\n        console.error(`Path ${path} is not an array`);\n        return false;\n      }\n      \n      // Clone the array\n      const newArray = [...array];\n      let updated = false;\n      \n      // Find and update the item(s)\n      if (typeof itemOrPredicate === 'function') {\n        // Use predicate function to find items\n        for (let i = 0; i < newArray.length; i++) {\n          if (itemOrPredicate(newArray[i], i, newArray)) {\n            if (typeof updatedItem === 'function') {\n              newArray[i] = updatedItem(newArray[i], i, newArray);\n            } else {\n              newArray[i] = updatedItem;\n            }\n            updated = true;\n            if (options.onlyFirst) break;\n          }\n        }\n      } else {\n        // Update by equality\n        const stringifiedItem = JSON.stringify(itemOrPredicate);\n        \n        for (let i = 0; i < newArray.length; i++) {\n          if (JSON.stringify(newArray[i]) === stringifiedItem) {\n            if (typeof updatedItem === 'function') {\n              newArray[i] = updatedItem(newArray[i], i, newArray);\n            } else {\n              newArray[i] = updatedItem;\n            }\n            updated = true;\n            if (options.onlyFirst) break;\n          }\n        }\n      }\n      \n      if (!updated) {\n        return false;\n      }\n      \n      // Update the state\n      return this.setState(path, newArray, options);\n    } catch (error) {\n      console.error(`Error updating item in array at ${path}:`, error);\n      return false;\n    }\n  },\n\n  /**\n   * Get a list of subscribers\n   * @returns {Object} - Subscriber information\n   */\n  getSubscriberInfo() {\n    try {\n      return {\n        globalSubscribers: this._subscribers.length,\n        pathSubscribers: Object.entries(this._pathSubscribers).map(([path, subscribers]) => ({\n          path,\n          subscriberCount: subscribers.length\n        }))\n      };\n    } catch (error) {\n      console.error('Error getting subscriber info:', error);\n      return { globalSubscribers: 0, pathSubscribers: [] };\n    }\n  },\n\n  /**\n   * Set or toggle debug mode\n   * @param {boolean} [enable] - Whether to enable debug mode (or toggle if not provided)\n   * @returns {boolean} - Current debug mode state\n   */\n  setDebugMode(enable) {\n    try {\n      if (typeof enable === 'undefined') {\n        // Toggle debug mode\n        this._debugMode = !this._debugMode;\n      } else {\n        // Set debug mode\n        this._debugMode = Boolean(enable);\n      }\n      \n      // Update app state\n      this.setState('app.debugMode', this._debugMode, { addToHistory: false });\n      \n      // Make available globally if debug mode is enabled\n      if (this._debugMode) {\n        window.stateManager = this;\n      } else if (window.stateManager === this) {\n        delete window.stateManager;\n      }\n      \n      console.log(`Debug mode ${this._debugMode ? 'enabled' : 'disabled'}`);\n      return this._debugMode;\n    } catch (error) {\n      console.error('Error setting debug mode:', error);\n      return this._debugMode;\n    }\n  },\n\n  /**\n   * Set what paths to persist in storage\n   * @param {Array<string>} paths - Paths to persist\n   * @returns {boolean} - Whether paths were set successfully\n   */\n  setPersistentPaths(paths) {\n    try {\n      if (!Array.isArray(paths)) {\n        console.error('Persistent paths must be an array');\n        return false;\n      }\n      \n      this._persistentPaths = [...paths];\n      \n      // Immediately persist state with new paths\n      this._persistState();\n      \n      console.log('Updated persistent paths:', this._persistentPaths);\n      return true;\n    } catch (error) {\n      console.error('Error setting persistent paths:', error);\n      return false;\n    }\n  },\n\n  /**\n   * Deep clone an object\n   * @private\n   * @param {*} obj - Object to clone\n   * @returns {*} - Cloned object\n   */\n  _deepClone(obj) {\n    try {\n      if (obj === null || typeof obj !== 'object') {\n        return obj;\n      }\n      \n      // Handle Date\n      if (obj instanceof Date) {\n        return new Date(obj);\n      }\n      \n      // Handle Array\n      if (Array.isArray(obj)) {\n        return obj.map(item => this._deepClone(item));\n      }\n      \n      // Handle Object\n      const copy = {};\n      for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          copy[key] = this._deepClone(obj[key]);\n        }\n      }\n      \n      return copy;\n    } catch (error) {\n      console.error('Error performing deep clone:', error);\n      // Return a simple copy as fallback\n      return Array.isArray(obj) ? [...obj] : { ...obj };\n    }\n  },\n\n  /**\n   * Deep merge objects\n   * @private\n   * @param {Object} target - Target object\n   * @param {Object} source - Source object\n   * @returns {Object} - Merged object\n   */\n  _deepMerge(target, source) {\n    try {\n      const output = {...target};\n      \n      if (typeof target === 'object' && typeof source === 'object') {\n        Object.keys(source).forEach(key => {\n          if (typeof source[key] === 'object' && source[key] !== null) {\n            if (!(key in target)) {\n              output[key] = source[key];\n            } else if (typeof target[key] === 'object' && target[key] !== null) {\n              output[key] = this._deepMerge(target[key], source[key]);\n            } else {\n              output[key] = source[key];\n            }\n          } else {\n            output[key] = source[key];\n          }\n        });\n      }\n      \n      return output;\n    } catch (error) {\n      console.error('Error performing deep merge:', error);\n      // Return a simple merge as fallback\n      return { ...target, ...source };\n    }\n  },\n\n  /**\n   * Export state to JSON\n   * @param {boolean} includeHistory - Whether to include state history\n   * @returns {string} - JSON string of state\n   */\n  exportState(includeHistory = false) {\n    try {\n      const exportData = {\n        state: this._deepClone(this._state),\n        exportDate: new Date().toISOString(),\n        version: this._state.app.version\n      };\n      \n      if (includeHistory) {\n        exportData.history = this._deepClone(this._history);\n      }\n      \n      return JSON.stringify(exportData, null, 2);\n    } catch (error) {\n      console.error('Error exporting state:', error);\n      return null;\n    }\n  },\n\n  /**\n   * Import state from JSON\n   * @param {string} json - JSON string of state\n   * @param {Object} options - Import options\n   * @returns {boolean} - Whether import was successful\n   */\n  importState(json, options = {}) {\n    try {\n      const importData = JSON.parse(json);\n      \n      if (!importData.state || typeof importData.state !== 'object') {\n        console.error('Invalid state import: missing state object');\n        return false;\n      }\n      \n      // Save previous state for history\n      const previousState = this._deepClone(this._state);\n      \n      // Apply imported state\n      if (options.merge) {\n        // Merge with current state\n        this._state = this._deepMerge(this._state, importData.state);\n      } else {\n        // Replace current state\n        this._state = this._deepClone(importData.state);\n      }\n      \n      // Update app metadata\n      this._state.app.lastUpdated = new Date().toISOString();\n      \n      // Import history if included and requested\n      if (importData.history && options.importHistory) {\n        this._history = this._deepClone(importData.history);\n      }\n      \n      // Add import as a history entry\n      this._addToHistory(previousState, this._state);\n      \n      // Persist state\n      this._persistState();\n      \n      // Notify subscribers\n      this._notifySubscribers(previousState);\n      \n      console.log('State import successful');\n      return true;\n    } catch (error) {\n      console.error('Error importing state:', error);\n      return false;\n    }\n  },\n\n  /**\n   * Set error state\n   * @param {string} section - State section to set error on\n   * @param {string|Object} error - Error message or object\n   * @returns {boolean} - Whether error was set\n   */\n  setError(section, error) {\n    try {\n      const errorObj = typeof error === 'string' ? { message: error } : error;\n      \n      // Enhance error with timestamp\n      errorObj.timestamp = new Date().toISOString();\n      \n      // Set error at the specific section\n      if (section === 'app') {\n        return this.setState('app.error', errorObj);\n      } else if (['fileProcessor', 'webScraper', 'playlistDownloader', 'academicSearch'].includes(section)) {\n        return this.setState(`${section}.error`, errorObj);\n      } else {\n        console.error(`Invalid section for error: ${section}`);\n        return false;\n      }\n    } catch (e) {\n      console.error('Error setting error state:', e);\n      return false;\n    }\n  },\n\n  /**\n   * Clear error state\n   * @param {string} section - State section to clear error from\n   * @returns {boolean} - Whether error was cleared\n   */\n  clearError(section) {\n    try {\n      // Clear error at the specific section\n      if (section === 'app') {\n        return this.setState('app.error', null);\n      } else if (['fileProcessor', 'webScraper', 'playlistDownloader', 'academicSearch'].includes(section)) {\n        return this.setState(`${section}.error`, null);\n      } else {\n        console.error(`Invalid section for error: ${section}`);\n        return false;\n      }\n    } catch (e) {\n      console.error('Error clearing error state:', e);\n      return false;\n    }\n  }\n  };\n\n// Export both default and named exports\nexport default stateManager;\nexport const getState = stateManager.getState.bind(stateManager);\nexport const setState = stateManager.setState.bind(stateManager);\nexport const subscribe = stateManager.subscribe.bind(stateManager);\nexport const subscribePath = stateManager.subscribePath.bind(stateManager);\nexport const resetState = stateManager.resetState.bind(stateManager);\nexport const getHistory = stateManager.getHistory.bind(stateManager);\nexport const initialize = stateManager.initialize.bind(stateManager);\nexport const batchUpdate = stateManager.batchUpdate.bind(stateManager);\nexport const clearHistory = stateManager.clearHistory.bind(stateManager);\nexport const addArrayItem = stateManager.addArrayItem.bind(stateManager);\nexport const removeArrayItem = stateManager.removeArrayItem.bind(stateManager);\nexport const updateArrayItem = stateManager.updateArrayItem.bind(stateManager);\nexport const getSubscriberInfo = stateManager.getSubscriberInfo.bind(stateManager);\nexport const setDebugMode = stateManager.setDebugMode.bind(stateManager);\nexport const setPersistentPaths = stateManager.setPersistentPaths.bind(stateManager);\nexport const exportState = stateManager.exportState.bind(stateManager);\nexport const importState = stateManager.importState.bind(stateManager);\nexport const setError = stateManager.setError.bind(stateManager);\nexport const clearError = stateManager.clearError.bind(stateManager);","source":"/workspace/modules/static/js/modules/core/stateManager.js","title":"stateManager.js","language":"en"},{"content":"/**\n * NeuroGen Server - Theme Manager Module\n * \n * Provides theming capabilities for the NeuroGen Server frontend.\n * Manages theme changes, persistence, and system preference tracking.\n * \n * Features:\n * - Multiple theme support (light, dark, system)\n * - System preference detection\n * - CSS variable-based theming\n * - Theme persistence\n * - Bootstrap integration\n * - Support for custom themes\n * - Event emission on theme changes\n */\n\n/**\n * Theme Manager for application appearance\n */\nconst themeManager = {\n  // Available themes\n  _themes: ['light', 'dark', 'system'],\n  \n  // Current active theme - default to dark for consistency\n  _currentTheme: 'dark',\n  \n  // Theme variables\n  _themeVariables: {\n    light: {\n      // Base colors\n      '--bg-color': '#ffffff',\n      '--text-color': '#333333',\n      '--primary-color': '#3498db',\n      '--secondary-color': '#2ecc71',\n      '--accent-color': '#e74c3c',\n      '--border-color': '#dddddd',\n      \n      // Component backgrounds\n      '--card-bg': '#f8f9fa',\n      '--header-bg': '#f0f0f0',\n      '--footer-bg': '#f0f0f0',\n      '--form-control-bg': '#ffffff',\n      '--dropdown-bg': '#ffffff',\n      '--modal-bg': '#ffffff',\n      '--toast-bg': '#ffffff',\n      \n      // Status colors\n      '--success-color': '#28a745',\n      '--warning-color': '#ffc107',\n      '--error-color': '#dc3545',\n      '--info-color': '#17a2b8',\n      \n      // Interactive elements\n      '--link-color': '#0066cc',\n      '--link-hover-color': '#005299',\n      '--btn-text-color': '#ffffff',\n      '--btn-primary-bg': '#3498db',\n      '--btn-secondary-bg': '#6c757d',\n      '--btn-success-bg': '#28a745',\n      '--btn-warning-bg': '#ffc107',\n      '--btn-danger-bg': '#dc3545',\n      '--btn-info-bg': '#17a2b8',\n      \n      // Input and form elements\n      '--input-border-color': '#ced4da',\n      '--input-focus-border-color': '#86b7fe',\n      '--input-focus-shadow': 'rgba(13, 110, 253, 0.25)',\n      '--input-disabled-bg': '#e9ecef',\n      \n      // Tables\n      '--table-border-color': '#dee2e6',\n      '--table-header-bg': '#e9ecef',\n      '--table-row-hover-bg': '#f5f5f5',\n      \n      // Shadows\n      '--shadow-sm': '0 .125rem .25rem rgba(0, 0, 0, .075)',\n      '--shadow-md': '0 .5rem 1rem rgba(0, 0, 0, .15)',\n      '--shadow-lg': '0 1rem 3rem rgba(0, 0, 0, .175)'\n    },\n    dark: {\n      // Base colors\n      '--bg-color': '#222222',\n      '--text-color': '#f0f0f0',\n      '--primary-color': '#3498db',\n      '--secondary-color': '#2ecc71',\n      '--accent-color': '#e74c3c',\n      '--border-color': '#444444',\n      \n      // Component backgrounds\n      '--card-bg': '#333333',\n      '--header-bg': '#1a1a1a',\n      '--footer-bg': '#1a1a1a',\n      '--form-control-bg': '#333333',\n      '--dropdown-bg': '#333333',\n      '--modal-bg': '#333333',\n      '--toast-bg': '#333333',\n      \n      // Status colors\n      '--success-color': '#28a745',\n      '--warning-color': '#ffc107',\n      '--error-color': '#dc3545',\n      '--info-color': '#17a2b8',\n      \n      // Interactive elements\n      '--link-color': '#4dadff',\n      '--link-hover-color': '#69b9ff',\n      '--btn-text-color': '#ffffff',\n      '--btn-primary-bg': '#3498db',\n      '--btn-secondary-bg': '#6c757d',\n      '--btn-success-bg': '#28a745',\n      '--btn-warning-bg': '#ffc107',\n      '--btn-danger-bg': '#dc3545',\n      '--btn-info-bg': '#17a2b8',\n      \n      // Input and form elements\n      '--input-border-color': '#495057',\n      '--input-focus-border-color': '#86b7fe',\n      '--input-focus-shadow': 'rgba(13, 110, 253, 0.25)',\n      '--input-disabled-bg': '#343a40',\n      \n      // Tables\n      '--table-border-color': '#495057',\n      '--table-header-bg': '#343a40',\n      '--table-row-hover-bg': '#2d3339',\n      \n      // Shadows\n      '--shadow-sm': '0 .125rem .25rem rgba(0, 0, 0, .2)',\n      '--shadow-md': '0 .5rem 1rem rgba(0, 0, 0, .4)',\n      '--shadow-lg': '0 1rem 3rem rgba(0, 0, 0, .5)'\n    }\n  },\n  \n  // Track initialization\n  initialized: false,\n  \n  // System preference media query\n  _systemPreference: null,\n  \n  // Storage key for theme preference - ALWAYS use 'theme' for consistency\n  _storageKey: 'theme',\n  \n  // Bootstrap data-bs-theme integration\n  _bootstrapIntegration: true,\n  \n  // Local event handlers\n  _eventHandlers: {},\n  \n  /**\n   * Initialize the theme manager\n   * @param {Object} options - Initialization options\n   * @returns {boolean} - Whether initialization was successful\n   */\n  initialize(options = {}) {\n    if (this.initialized) {\n      console.warn('Theme manager already initialized');\n      return false;\n    }\n    \n    try {\n      console.log(\"Initializing theme manager...\");\n      \n      // For theme persistence, we ALWAYS use 'theme' as the storage key\n      // to avoid conflicts with other components\n      this._storageKey = 'theme';\n      \n      // Set up bootstrap integration option\n      if (options.bootstrapIntegration !== undefined) {\n        this._bootstrapIntegration = options.bootstrapIntegration;\n      }\n      \n      // Set up system preference tracking\n      this._setupSystemPreference();\n      \n      // Load saved theme preference\n      this._loadThemePreference();\n      \n      // Set initial theme - prioritize options.theme if provided\n      if (options.theme && this._themes.includes(options.theme)) {\n        this.setTheme(options.theme);\n      } else {\n        this.applyCurrentTheme();\n      }\n      \n      // Add theme toggle button event listener if it exists\n      this._setupThemeToggleButton();\n      \n      // Register keyboard shortcut for theme toggle (Shift+Alt+T)\n      this._setupKeyboardShortcut();\n      \n      // Make available globally for debugging and access\n      window.themeManager = this;\n      \n      // Indicate initialized state\n      this.initialized = true;\n      console.log(`Theme manager initialized with theme: ${this._currentTheme} (effective: ${this.getEffectiveTheme()})`);\n      \n      return true;\n    } catch (error) {\n      console.error('Error initializing theme manager:', error);\n      return false;\n    }\n  },\n  \n  /**\n   * Set up system preference tracking\n   * @private\n   */\n  _setupSystemPreference() {\n    try {\n      this._systemPreference = window.matchMedia('(prefers-color-scheme: dark)');\n      \n      // Listen for system preference changes\n      if (this._systemPreference.addEventListener) {\n        this._systemPreference.addEventListener('change', this._handleSystemPreferenceChange.bind(this));\n      } else if (this._systemPreference.addListener) {\n        // Older browsers\n        this._systemPreference.addListener(this._handleSystemPreferenceChange.bind(this));\n      }\n    } catch (error) {\n      console.warn('Error setting up system preference tracking:', error);\n    }\n  },\n  \n  /**\n   * Handle system preference changes\n   * @private\n   * @param {MediaQueryListEvent} event - Media query change event\n   */\n  _handleSystemPreferenceChange(event) {\n    // Only update if current theme is 'system'\n    if (this._currentTheme === 'system') {\n      this.applyCurrentTheme();\n    }\n    \n    // Emit event if eventRegistry is available\n    try {\n      if (window.eventRegistry && typeof window.eventRegistry.emit === 'function') {\n        window.eventRegistry.emit('theme:system-preference-change', {\n          prefersDarkMode: event.matches,\n          effectiveTheme: this.getEffectiveTheme()\n        });\n      }\n    } catch (e) {\n      // Ignore errors with event registry\n      console.debug('Error emitting theme:system-preference-change event:', e);\n    }\n    \n    // Trigger local event handlers\n    this._triggerEvent('system-preference-change', {\n      prefersDarkMode: event.matches,\n      effectiveTheme: this.getEffectiveTheme()\n    });\n  },\n  \n  /**\n   * Load saved theme preference with improved reliability\n   * @private\n   */\n  _loadThemePreference() {\n    try {\n      console.log(\"Loading theme preference from storage...\");\n      \n      // Always use 'theme' as the storage key for consistency\n      this._storageKey = 'theme';\n      \n      // Try localStorage with our storage key\n      const savedTheme = localStorage.getItem(this._storageKey);\n      \n      if (savedTheme && this._themes.includes(savedTheme)) {\n        this._currentTheme = savedTheme;\n        console.log(`Loaded saved theme preference: ${savedTheme}`);\n        \n        // Apply immediately for better UI consistency\n        const effectiveTheme = this.getEffectiveTheme();\n        document.documentElement.setAttribute('data-theme', effectiveTheme);\n        document.documentElement.setAttribute('data-bs-theme', effectiveTheme);\n        document.body.setAttribute('data-theme', effectiveTheme);\n        \n        return;\n      }\n      \n      // No saved preference found, default to 'dark' for consistency\n      // This is a change from the original behavior that defaulted to 'system'\n      console.log(\"No saved theme preference found, defaulting to dark mode\");\n      this._currentTheme = 'dark';\n      \n      // Save this preference for future visits\n      this._saveThemePreference('dark');\n    } catch (e) {\n      console.warn('Error loading theme preference from localStorage:', e);\n      \n      // Default to dark theme if there's an error\n      this._currentTheme = 'dark';\n      \n      // Try to save the default\n      try {\n        localStorage.setItem(this._storageKey, this._currentTheme);\n      } catch (error) {\n        console.error('Error saving default theme preference:', error);\n      }\n    }\n  },\n  \n  /**\n   * Save theme preference with improved reliability\n   * @private\n   * @param {string} theme - Theme to save\n   */\n  _saveThemePreference(theme) {\n    try {\n      // Save to standard 'theme' key\n      localStorage.setItem('theme', theme);\n      console.log(`Saved theme preference: ${theme}`);\n    } catch (e) {\n      console.warn('Error saving theme preference to localStorage:', e);\n    }\n  },\n  \n  /**\n   * Set up theme toggle button if it exists in the DOM\n   * @private\n   */\n  _setupThemeToggleButton() {\n    try {\n      const darkModeToggle = document.getElementById('darkModeToggle');\n      if (darkModeToggle) {\n        // First update the button to match the current theme\n        this._updateThemeToggleButton();\n        \n        // Add click event listener\n        darkModeToggle.addEventListener('click', () => {\n          this.toggleTheme();\n        });\n        \n        console.log('Theme toggle button initialized');\n      }\n    } catch (error) {\n      console.warn('Error setting up theme toggle button:', error);\n    }\n  },\n  \n  /**\n   * Update theme toggle button to reflect current theme\n   * @private\n   */\n  _updateThemeToggleButton() {\n    try {\n      const darkModeToggle = document.getElementById('darkModeToggle');\n      if (!darkModeToggle) return;\n      \n      const isDark = this.getEffectiveTheme() === 'dark';\n      const iconElement = darkModeToggle.querySelector('i');\n      \n      if (iconElement) {\n        // Update icon class\n        iconElement.className = isDark ? 'fas fa-sun fa-lg' : 'fas fa-moon fa-lg';\n      } else {\n        // If no icon element, recreate button content\n        darkModeToggle.innerHTML = isDark ? \n          '<i class=\"fas fa-sun fa-lg\"></i>' : \n          '<i class=\"fas fa-moon fa-lg\"></i>';\n      }\n      \n      // Update button title/tooltip\n      darkModeToggle.title = isDark ? 'Switch to light mode' : 'Switch to dark mode';\n      \n      // Add/remove active class\n      if (isDark) {\n        darkModeToggle.classList.add('active');\n      } else {\n        darkModeToggle.classList.remove('active');\n      }\n    } catch (error) {\n      console.warn('Error updating theme toggle button:', error);\n    }\n  },\n  \n  /**\n   * Set up keyboard shortcut for theme toggle (Shift+Alt+T)\n   * @private\n   */\n  _setupKeyboardShortcut() {\n    try {\n      document.addEventListener('keydown', (event) => {\n        // Shift+Alt+T for theme toggle\n        if (event.shiftKey && event.altKey && event.key === 'T') {\n          this.toggleTheme();\n          event.preventDefault();\n        }\n      });\n    } catch (error) {\n      console.warn('Error setting up keyboard shortcut:', error);\n    }\n  },\n  \n  /**\n   * Set the active theme and ensure it persists\n   * @param {string} theme - Theme name ('light', 'dark', 'system')\n   * @returns {boolean} - Whether theme was set successfully\n   */\n  setTheme(theme) {\n    if (!this._themes.includes(theme)) {\n      console.error(`Invalid theme: ${theme}. Available themes: ${this._themes.join(', ')}`);\n      return false;\n    }\n    \n    try {\n      console.log(`Setting theme to: ${theme}`);\n      \n      // Save current theme\n      this._currentTheme = theme;\n      \n      // Save preference BEFORE applying the theme to ensure persistence\n      this._saveThemePreference(theme);\n      \n      // Apply the theme\n      this.applyCurrentTheme();\n      \n      // Update theme toggle button\n      this._updateThemeToggleButton();\n      \n      // Emit event if eventRegistry is available\n      try {\n        if (window.eventRegistry && typeof window.eventRegistry.emit === 'function') {\n          window.eventRegistry.emit('theme:change', {\n            theme: theme,\n            effectiveTheme: this.getEffectiveTheme()\n          });\n        }\n      } catch (e) {\n        // Ignore errors with event registry\n        console.debug('Error emitting theme:change event:', e);\n      }\n      \n      // Trigger local event handlers\n      this._triggerEvent('theme-change', {\n        theme: theme,\n        effectiveTheme: this.getEffectiveTheme()\n      });\n      \n      return true;\n    } catch (error) {\n      console.error('Error setting theme:', error);\n      return false;\n    }\n  },\n  \n  /**\n   * Get the current theme\n   * @returns {string} - Current theme name\n   */\n  getTheme() {\n    return this._currentTheme;\n  },\n  \n  /**\n   * Get the effective theme (resolves 'system' to actual theme)\n   * @returns {string} - Effective theme ('light' or 'dark')\n   */\n  getEffectiveTheme() {\n    if (this._currentTheme === 'system') {\n      return this._getSystemTheme();\n    }\n    \n    return this._currentTheme;\n  },\n  \n  /**\n   * Get the system theme preference\n   * @private\n   * @returns {string} - System theme ('light' or 'dark')\n   */\n  _getSystemTheme() {\n    try {\n      if (this._systemPreference && this._systemPreference.matches) {\n        return 'dark';\n      }\n    } catch (error) {\n      console.warn('Error getting system theme preference:', error);\n    }\n    \n    return 'light';\n  },\n  \n  /**\n   * Apply the current theme to the document consistently\n   * @returns {boolean} - Whether theme was applied successfully\n   */\n  applyCurrentTheme() {\n    try {\n      const effectiveTheme = this.getEffectiveTheme();\n      \n      // Set CSS variables\n      this._applyCssVariables(effectiveTheme);\n      \n      // Set theme attribute on document for CSS selectors\n      document.documentElement.setAttribute('data-theme', effectiveTheme);\n      document.body.setAttribute('data-theme', effectiveTheme);\n      \n      // Always update Bootstrap 5 data-bs-theme for better framework compatibility\n      document.documentElement.setAttribute('data-bs-theme', effectiveTheme);\n      \n      // Set class name on body\n      document.body.className = document.body.className.replace(/theme-[^\\s]+/g, '');\n      document.body.classList.add(`theme-${effectiveTheme}`);\n      \n      // Update theme-specific elements in the DOM\n      this._updateThemeElements(effectiveTheme);\n      \n      console.log(`Applied theme: ${effectiveTheme}`);\n      return true;\n    } catch (error) {\n      console.error('Error applying theme:', error);\n      return false;\n    }\n  },\n  \n  /**\n   * Apply CSS variables for the theme\n   * @private\n   * @param {string} theme - Theme to apply\n   */\n  _applyCssVariables(theme) {\n    try {\n      const variables = this._themeVariables[theme];\n      if (!variables) {\n        console.warn(`No variables defined for theme: ${theme}`);\n        return;\n      }\n      \n      // Apply to :root\n      const root = document.documentElement;\n      \n      for (const [variable, value] of Object.entries(variables)) {\n        root.style.setProperty(variable, value);\n      }\n    } catch (error) {\n      console.error('Error applying CSS variables:', error);\n    }\n  },\n  \n  /**\n   * Update theme-specific elements in the DOM\n   * @private\n   * @param {string} theme - Theme to apply ('light' or 'dark')\n   */\n  _updateThemeElements(theme) {\n    try {\n      // Update favicon if it exists\n      this._updateFavicon(theme);\n      \n      // Update theme toggle button\n      this._updateThemeToggleButton();\n      \n      // Update logo if it has a theme-specific version\n      const logoImage = document.querySelector('.header-container img');\n      if (logoImage) {\n        const currentSrc = logoImage.getAttribute('src');\n        if (currentSrc) {\n          // If logo path contains '_light' or '_dark', swap it\n          if (theme === 'dark' && currentSrc.includes('_light')) {\n            logoImage.setAttribute('src', currentSrc.replace('_light', '_dark'));\n          } else if (theme === 'light' && currentSrc.includes('_dark')) {\n            logoImage.setAttribute('src', currentSrc.replace('_dark', '_light'));\n          }\n        }\n      }\n      \n      // Update charts if any charting libraries are detected\n      this._updateCharts(theme);\n    } catch (error) {\n      console.warn('Error updating theme-specific elements:', error);\n    }\n  },\n  \n  /**\n   * Update favicon for theme\n   * @private\n   * @param {string} theme - Current theme\n   */\n  _updateFavicon(theme) {\n    try {\n      const favicon = document.querySelector('link[rel=\"icon\"]');\n      if (!favicon) return;\n      \n      const currentHref = favicon.getAttribute('href');\n      if (!currentHref) return;\n      \n      // If favicon path contains '_light' or '_dark', swap it\n      if (theme === 'dark' && currentHref.includes('_light')) {\n        favicon.setAttribute('href', currentHref.replace('_light', '_dark'));\n      } else if (theme === 'light' && currentHref.includes('_dark')) {\n        favicon.setAttribute('href', currentHref.replace('_dark', '_light'));\n      }\n    } catch (error) {\n      console.warn('Error updating favicon:', error);\n    }\n  },\n  \n  /**\n   * Update charts if any charting libraries are detected\n   * @private\n   * @param {string} theme - Current theme\n   */\n  _updateCharts(theme) {\n    try {\n      // Check if Chart.js is available\n      if (typeof Chart !== 'undefined' && Chart.defaults) {\n        // Update Chart.js defaults for the theme\n        const isLightTheme = theme === 'light';\n        \n        Chart.defaults.color = isLightTheme ? '#666666' : '#dddddd';\n        Chart.defaults.borderColor = isLightTheme ? 'rgba(0, 0, 0, 0.1)' : 'rgba(255, 255, 255, 0.1)';\n        \n        // Set default grid line colors\n        Chart.defaults.scale.grid.color = isLightTheme ? 'rgba(0, 0, 0, 0.05)' : 'rgba(255, 255, 255, 0.05)';\n        \n        // Refresh all charts\n        if (Chart.instances) {\n          Object.values(Chart.instances).forEach(chart => {\n            chart.update();\n          });\n        }\n      }\n      \n      // Check if Recharts is available (React-based charts)\n      if (window.document.querySelectorAll('.recharts-wrapper').length > 0) {\n        // Emit an event that React components can listen for\n        if (window.eventRegistry && typeof window.eventRegistry.emit === 'function') {\n          window.eventRegistry.emit('theme:charts-update', {\n            theme: theme\n          });\n        }\n      }\n    } catch (error) {\n      console.warn('Error updating charts:', error);\n    }\n  },\n  \n  /**\n   * Toggle between light and dark themes and ensure persistence\n   * @returns {string} - New theme name\n   */\n  toggleTheme() {\n    const currentTheme = this.getTheme();\n    let newTheme;\n    \n    if (currentTheme === 'system') {\n      // If system, toggle based on the effective theme\n      newTheme = this.getEffectiveTheme() === 'dark' ? 'light' : 'dark';\n    } else {\n      // Otherwise toggle directly\n      newTheme = currentTheme === 'light' ? 'dark' : 'light';\n    }\n    \n    console.log(`Toggling theme from ${currentTheme} to ${newTheme}`);\n    this.setTheme(newTheme);\n    return newTheme;\n  },\n  \n  /**\n   * Check if dark mode is active\n   * @returns {boolean} - Whether dark mode is active\n   */\n  isDarkMode() {\n    return this.getEffectiveTheme() === 'dark';\n  },\n  \n  /**\n   * Add a custom theme\n   * @param {string} name - Theme name\n   * @param {Object} variables - Theme CSS variables\n   * @returns {boolean} - Whether theme was added successfully\n   */\n  addTheme(name, variables) {\n    if (this._themes.includes(name)) {\n      console.warn(`Theme ${name} already exists. Use updateTheme to modify.`);\n      return false;\n    }\n    \n    try {\n      // Add theme to available themes\n      this._themes.push(name);\n      \n      // Add theme variables\n      this._themeVariables[name] = variables;\n      \n      console.log(`Added custom theme: ${name}`);\n      return true;\n    } catch (error) {\n      console.error('Error adding custom theme:', error);\n      return false;\n    }\n  },\n  \n  /**\n   * Update a theme's variables\n   * @param {string} name - Theme name\n   * @param {Object} variables - Theme CSS variables\n   * @returns {boolean} - Whether theme was updated successfully\n   */\n  updateTheme(name, variables) {\n    if (!this._themes.includes(name)) {\n      console.error(`Theme ${name} does not exist.`);\n      return false;\n    }\n    \n    try {\n      // Update theme variables\n      this._themeVariables[name] = {\n        ...this._themeVariables[name] || {},\n        ...variables\n      };\n      \n      // Re-apply if this is the current theme\n      if (this.getEffectiveTheme() === name) {\n        this.applyCurrentTheme();\n      }\n      \n      console.log(`Updated theme: ${name}`);\n      return true;\n    } catch (error) {\n      console.error('Error updating theme:', error);\n      return false;\n    }\n  },\n  \n  /**\n   * Get available themes\n   * @returns {Array<string>} - List of available themes\n   */\n  getAvailableThemes() {\n    return [...this._themes];\n  },\n  \n  /**\n   * Get theme variables for a theme\n   * @param {string} theme - Theme name\n   * @returns {Object} - Theme variables\n   */\n  getThemeVariables(theme) {\n    const effectiveTheme = theme || this.getEffectiveTheme();\n    return { ...this._themeVariables[effectiveTheme] };\n  },\n  \n  /**\n   * Reset to default theme\n   * @returns {boolean} - Whether reset was successful\n   */\n  resetToDefault() {\n    try {\n      // Reset to dark theme (changed from system for better consistency)\n      this._currentTheme = 'dark';\n      this._saveThemePreference(this._currentTheme);\n      this.applyCurrentTheme();\n      \n      console.log('Reset to default theme (dark)');\n      return true;\n    } catch (error) {\n      console.error('Error resetting to default theme:', error);\n      return false;\n    }\n  },\n  \n  /**\n   * Add an event listener for theme changes\n   * @param {string} event - Event name\n   * @param {Function} callback - Event callback\n   * @returns {Function} - Function to remove the listener\n   */\n  addEventListener(event, callback) {\n    if (typeof callback !== 'function') {\n      console.error('Event callback must be a function');\n      return () => {};\n    }\n    \n    if (!this._eventHandlers[event]) {\n      this._eventHandlers[event] = [];\n    }\n    \n    this._eventHandlers[event].push(callback);\n    \n    // Return a function to remove the listener\n    return () => {\n      this.removeEventListener(event, callback);\n    };\n  },\n  \n  /**\n   * Remove an event listener\n   * @param {string} event - Event name\n   * @param {Function} callback - Event callback to remove\n   * @returns {boolean} - Whether removal was successful\n   */\n  removeEventListener(event, callback) {\n    if (!this._eventHandlers[event]) {\n      return false;\n    }\n    \n    const index = this._eventHandlers[event].indexOf(callback);\n    if (index !== -1) {\n      this._eventHandlers[event].splice(index, 1);\n      return true;\n    }\n    \n    return false;\n  },\n  \n  /**\n   * Trigger event handlers for a specific event\n   * @private\n   * @param {string} event - Event name\n   * @param {Object} data - Event data\n   */\n  _triggerEvent(event, data) {\n    if (!this._eventHandlers[event]) {\n      return;\n    }\n    \n    for (const callback of this._eventHandlers[event]) {\n      try {\n        callback(data);\n      } catch (error) {\n        console.error(`Error in theme manager event listener (${event}):`, error);\n      }\n    }\n  },\n  \n  /**\n   * Set whether to integrate with Bootstrap's theme system\n   * @param {boolean} enable - Whether to enable integration\n   */\n  setBootstrapIntegration(enable) {\n    this._bootstrapIntegration = enable;\n    this.applyCurrentTheme(); // Re-apply theme to update integration\n  },\n  \n  /**\n   * Apply high contrast mode for accessibility\n   * @param {boolean} enable - Whether to enable high contrast\n   * @returns {boolean} - Whether the operation was successful\n   */\n  setHighContrastMode(enable) {\n    try {\n      if (enable) {\n        // Apply high contrast overrides to current theme\n        const baseTheme = this.getEffectiveTheme();\n        const highContrastOverrides = {\n          // Enhanced contrast variables\n          '--text-color': baseTheme === 'dark' ? '#ffffff' : '#000000',\n          '--bg-color': baseTheme === 'dark' ? '#000000' : '#ffffff',\n          '--link-color': baseTheme === 'dark' ? '#ffff00' : '#0000ff',\n          '--link-hover-color': baseTheme === 'dark' ? '#ffdd00' : '#000099',\n          '--border-color': baseTheme === 'dark' ? '#ffffff' : '#000000',\n          '--shadow-sm': 'none',\n          '--shadow-md': 'none',\n          '--shadow-lg': 'none',\n          // Add focus indicators\n          '--input-focus-border-color': baseTheme === 'dark' ? '#ffff00' : '#0000ff',\n          '--input-focus-shadow': baseTheme === 'dark' ? 'rgba(255, 255, 0, 0.5)' : 'rgba(0, 0, 255, 0.5)'\n        };\n        \n        // Apply overrides to root element\n        const root = document.documentElement;\n        for (const [variable, value] of Object.entries(highContrastOverrides)) {\n          root.style.setProperty(variable, value);\n        }\n        \n        // Add high contrast class to body\n        document.body.classList.add('high-contrast-mode');\n      } else {\n        // Remove high contrast class\n        document.body.classList.remove('high-contrast-mode');\n        \n        // Re-apply the current theme to reset variables\n        this.applyCurrentTheme();\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('Error setting high contrast mode:', error);\n      return false;\n    }\n  },\n\n  /**\n   * Check if high contrast mode is enabled\n   * @returns {boolean} - Whether high contrast mode is enabled\n   */\n  isHighContrastMode() {\n    return document.body.classList.contains('high-contrast-mode');\n  },\n\n  /**\n     * Set font size scale for accessibility\n     * @param {string} scale - Font size scale ('normal', 'large', 'x-large')\n     * @returns {boolean} - Whether the operation was successful\n     */\n  setFontSizeScale(scale) {\n    try {\n      // First remove any existing font scale classes\n      document.body.classList.remove('font-size-normal', 'font-size-large', 'font-size-x-large');\n      \n      // Add the new font scale class\n      if (scale === 'large' || scale === 'x-large') {\n        document.body.classList.add(`font-size-${scale}`);\n      } else {\n        // Default to normal\n        document.body.classList.add('font-size-normal');\n      }\n      \n      // Store the preference\n      try {\n        localStorage.setItem('font_size_scale', scale);\n      } catch (e) {\n        console.warn('Error saving font size preference:', e);\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('Error setting font size scale:', error);\n      return false;\n    }\n  },\n\n  /**\n   * Load an external theme file\n   * @param {string} url - URL to theme file\n   * @returns {Promise<boolean>} - Whether the theme was loaded\n   */\n  async loadExternalTheme(url) {\n    try {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`Failed to load theme: ${response.status} ${response.statusText}`);\n      }\n      \n      const themeData = await response.json();\n      \n      // Validate theme data\n      if (!themeData.name || !themeData.variables) {\n        throw new Error('Invalid theme format: missing name or variables');\n      }\n      \n      // Add theme\n      this.addTheme(themeData.name, themeData.variables);\n      \n      // Apply theme if specified\n      if (themeData.apply) {\n        this.setTheme(themeData.name);\n      }\n      \n      console.log(`Loaded external theme: ${themeData.name}`);\n      return true;\n    } catch (error) {\n      console.error('Error loading external theme:', error);\n      return false;\n    }\n  },\n\n  /**\n   * Export current theme as JSON\n   * @param {string} [themeName] - Optional theme name to export (defaults to current theme)\n   * @returns {Object} - Theme data object\n   */\n  exportTheme(themeName) {\n    const theme = themeName || this.getEffectiveTheme();\n    if (!this._themeVariables[theme]) {\n      console.error(`Theme ${theme} does not exist`);\n      return null;\n    }\n    \n    return {\n      name: theme,\n      variables: { ...this._themeVariables[theme] },\n      exportDate: new Date().toISOString(),\n      version: '1.0'\n    };\n  },\n\n  /**\n   * Update theme toggle icon based on OS preference\n   * @param {string} iconFamily - Icon family name ('fas', 'far', etc.)\n   * @returns {boolean} - Whether update was successful\n   */\n  useCustomThemeIcons(iconFamily) {\n    try {\n      const darkModeToggle = document.getElementById('darkModeToggle');\n      if (!darkModeToggle) return false;\n      \n      const iconElement = darkModeToggle.querySelector('i');\n      if (!iconElement) return false;\n      \n      // Get current icon classes\n      const classNames = iconElement.className.split(' ');\n      \n      // Find current icon family (fas, far, etc.)\n      const currentFamily = classNames.find(cls => cls.startsWith('fa') && cls !== 'fa-lg' && cls !== 'fa-sun' && cls !== 'fa-moon');\n      \n      // Replace icon family if it's different\n      if (currentFamily && currentFamily !== iconFamily) {\n        iconElement.classList.remove(currentFamily);\n        iconElement.classList.add(iconFamily);\n        \n        console.log(`Updated theme icon family to: ${iconFamily}`);\n        return true;\n      }\n      \n      return false;\n    } catch (error) {\n      console.error('Error updating theme icons:', error);\n      return false;\n    }\n  },\n\n  /**\n   * Apply a theme transition effect\n   * @param {number} [duration=300] - Transition duration in milliseconds\n   * @returns {boolean} - Whether transition was applied\n   */\n  applyThemeTransition(duration = 300) {\n    try {\n      // Create a style element for transitions\n      const style = document.createElement('style');\n      style.innerHTML = `\n        body, body * {\n          transition: background-color ${duration}ms ease, color ${duration}ms ease, \n                    border-color ${duration}ms ease, box-shadow ${duration}ms ease !important;\n        }\n      `;\n      document.head.appendChild(style);\n      \n      // Remove the style after transition completes\n      setTimeout(() => {\n        document.head.removeChild(style);\n      }, duration + 50);\n      \n      return true;\n    } catch (error) {\n      console.error('Error applying theme transition:', error);\n      return false;\n    }\n  },\n\n  /**\n   * Check if theme is supported by the browser\n   * @returns {boolean} - Whether theme features are supported\n   */\n  isThemeSupported() {\n    try {\n      // Check for CSS custom properties support\n      const isCSSVarsSupported = window.CSS && window.CSS.supports && window.CSS.supports('--a', '0');\n      \n      // Check for localStorage support\n      const isLocalStorageSupported = (() => {\n        try {\n          localStorage.setItem('test', 'test');\n          localStorage.removeItem('test');\n          return true;\n        } catch (e) {\n          return false;\n        }\n      })();\n      \n      // Check for media query support\n      const isMediaQuerySupported = typeof window.matchMedia === 'function';\n      \n      return isCSSVarsSupported && isLocalStorageSupported && isMediaQuerySupported;\n    } catch (error) {\n      console.error('Error checking theme support:', error);\n      return false;\n    }\n  },\n\n  /**\n   * Reset all custom theme preferences\n   * @returns {boolean} - Whether reset was successful\n   */\n  resetAllPreferences() {\n    try {\n      // Reset to dark theme (changed from system)\n      this._currentTheme = 'dark';\n      \n      // Remove high contrast mode\n      document.body.classList.remove('high-contrast-mode');\n      \n      // Reset font size\n      this.setFontSizeScale('normal');\n      \n      // Clear localStorage preferences\n      localStorage.removeItem(this._storageKey);\n      localStorage.removeItem('font_size_scale');\n      \n      // Save the dark theme preference\n      this._saveThemePreference('dark');\n      \n      // Apply default theme\n      this.applyCurrentTheme();\n      \n      // Emit event\n      if (window.eventRegistry && typeof window.eventRegistry.emit === 'function') {\n        window.eventRegistry.emit('theme:reset', {\n          timestamp: new Date().toISOString()\n        });\n      }\n      \n      // Trigger local event handlers\n      this._triggerEvent('preferences-reset', {\n        timestamp: new Date().toISOString()\n      });\n      \n      console.log('All theme preferences reset to defaults');\n      return true;\n    } catch (error) {\n      console.error('Error resetting theme preferences:', error);\n      return false;\n    }\n  }\n  };\n\n\n  \n// Export both default and named exports\nexport default themeManager;\nexport const setTheme = themeManager.setTheme.bind(themeManager);\nexport const getTheme = themeManager.getTheme.bind(themeManager);\nexport const getEffectiveTheme = themeManager.getEffectiveTheme.bind(themeManager);\nexport const toggleTheme = themeManager.toggleTheme.bind(themeManager);\nexport const isDarkMode = themeManager.isDarkMode.bind(themeManager);\nexport const addTheme = themeManager.addTheme.bind(themeManager);\nexport const updateTheme = themeManager.updateTheme.bind(themeManager);\nexport const getAvailableThemes = themeManager.getAvailableThemes.bind(themeManager);\nexport const applyCurrentTheme = themeManager.applyCurrentTheme.bind(themeManager);\nexport const initialize = themeManager.initialize.bind(themeManager);\nexport const setHighContrastMode = themeManager.setHighContrastMode.bind(themeManager);\nexport const isHighContrastMode = themeManager.isHighContrastMode.bind(themeManager);\nexport const setFontSizeScale = themeManager.setFontSizeScale.bind(themeManager);\nexport const getThemeVariables = themeManager.getThemeVariables.bind(themeManager);\nexport const resetToDefault = themeManager.resetToDefault.bind(themeManager);\nexport const addEventListener = themeManager.addEventListener.bind(themeManager);\nexport const removeEventListener = themeManager.removeEventListener.bind(themeManager);\nexport const setBootstrapIntegration = themeManager.setBootstrapIntegration.bind(themeManager);\nexport const loadExternalTheme = themeManager.loadExternalTheme.bind(themeManager);\nexport const exportTheme = themeManager.exportTheme.bind(themeManager);\nexport const isThemeSupported = themeManager.isThemeSupported.bind(themeManager);\nexport const resetAllPreferences = themeManager.resetAllPreferences.bind(themeManager);","source":"/workspace/modules/static/js/modules/core/themeManager.js","title":"themeManager.js","language":"en"},{"content":"/**\n * NeuroGen Server - Enhanced Core UI Module v4.0\n * \n * Advanced UI functionality optimized for the new Blueprint architecture.\n * Provides comprehensive UI operations with centralized configuration\n * and integrated health monitoring.\n * \n * NEW v4.0 Features:\n * - Configuration-driven architecture using centralized constants\n * - Enhanced 4-method notification system (Toast + Console + System + Error)\n * - Backend connectivity testing with health checks\n * - ES6 module imports with centralized configuration\n * - Blueprint-aware UI components and context\n * \n * @module core/ui\n * @version 4.0.0 - Blueprint Architecture Optimization\n */\n\n// Import dependencies from centralized config\nimport { API_ENDPOINTS, BLUEPRINT_ROUTES } from '../config/endpoints.js';\nimport { CONSTANTS, API_CONFIG, UI_CONFIG } from '../config/constants.js';\nimport { SOCKET_EVENTS, TASK_EVENTS } from '../config/socketEvents.js';\nimport { getElement, getElements, getUIElements, createElement, addEventListeners } from './domUtils.js';\nimport { updateUIBridge } from '../core/module-bridge.js';\n\n// Global configuration for core UI module\nconst CORE_UI_CONFIG = {\n  endpoints: {\n    health: API_ENDPOINTS.SYSTEM?.HEALTH || '/api/health',\n    ...API_ENDPOINTS\n  },\n  api: API_CONFIG,\n  constants: UI_CONFIG || {\n    ANIMATIONS_ENABLED: true,\n    TOAST_POSITION: 'bottom-end',\n    TOAST_DURATION: 5000,\n    MODAL_BACKDROP_CLOSE: true,\n    DEFAULT_THEME: 'light'\n  },\n  events: {\n    ...TASK_EVENTS,\n    ui_ready: 'core_ui_ready',\n    theme_changed: 'core_theme_changed'\n  }\n};\n\n// UI state management - centralized state for all UI components\nconst uiState = {\n  activePanel: null,\n  isLoading: false,\n  notifications: [],\n  modalStack: [],\n  toastContainer: null,\n  modalInstances: new Map(),\n  progressBars: new Map(),\n  spinners: new Map(),\n  activeTabSets: new Map(),\n  eventHandlers: new Map(),\n  configOptions: {\n    animationsEnabled: true,\n    toastPosition: 'bottom-end', // top-start, top-end, bottom-start, bottom-end\n    toastDuration: 5000,\n    modalBackdropClose: true,\n    defaultTheme: 'light'\n  }\n};\n\n/**\n * Initialize the UI module\n * @param {Object} options - Configuration options\n * @returns {Object} UI API\n */\nfunction initUI(options = {}) {\n  // Apply configuration options\n  Object.assign(uiState.configOptions, options);\n  \n  // Set theme on initialization\n  setTheme(uiState.configOptions.defaultTheme);\n  \n  // Create toast container if it doesn't exist\n  ensureToastContainer();\n  \n  console.log(\"UI module initialized successfully\");\n  \n  // Return the public API\n  return {\n    // Core UI functions\n    showPanel,\n    hidePanel,\n    togglePanel,\n    showModal,\n    closeModal,\n    showNotification,\n    clearNotifications,\n    showLoading,\n    hideLoading,\n    updateProgressBar,\n    createTabs,\n    toggleElementVisibility,\n    toggleClass,\n    setTheme,\n    \n    // Dialog utilities\n    confirm,\n    alert,\n    prompt,\n    \n    // DOM utilities (re-exported from domUtils)\n    getElement,\n    getElements,\n    getUIElements,\n    createElement,\n    addEventListeners,\n    \n    // State and configuration\n    getConfig: () => ({ ...uiState.configOptions }),\n    updateConfig: (newOptions) => Object.assign(uiState.configOptions, newOptions)\n  };\n}\n\n/**\n * Ensure the toast container exists in the DOM\n * @returns {HTMLElement} Toast container element\n */\nfunction ensureToastContainer() {\n  if (uiState.toastContainer) return uiState.toastContainer;\n  \n  // Get position classes based on configuration\n  const posClasses = getPositionClasses(uiState.configOptions.toastPosition);\n  \n  // Create container if it doesn't exist\n  const container = getElement('toast-container');\n  if (container) {\n    uiState.toastContainer = container;\n    // Update classes in case position changed\n    container.className = `toast-container position-fixed ${posClasses} p-3`;\n    return container;\n  }\n  \n  // Create new container\n  const newContainer = createElement('div', {\n    id: 'toast-container',\n    className: `toast-container position-fixed ${posClasses} p-3`,\n    style: 'z-index: 1100;'\n  });\n  \n  document.body.appendChild(newContainer);\n  uiState.toastContainer = newContainer;\n  return newContainer;\n}\n\n/**\n * Get position classes for toast container\n * @param {string} position - Toast position\n * @returns {string} Position classes\n */\nfunction getPositionClasses(position) {\n  switch (position) {\n    case 'top-start': return 'top-0 start-0';\n    case 'top-end': return 'top-0 end-0';\n    case 'bottom-start': return 'bottom-0 start-0';\n    case 'bottom-end': \n    default: return 'bottom-0 end-0';\n  }\n}\n\n/**\n * Show a notification toast\n * @param {Object} options - Notification options\n * @returns {HTMLElement} Notification element\n */\nfunction showNotification(options = {}) {\n  try {\n    const container = ensureToastContainer();\n    \n    const defaults = {\n      title: 'Notification',\n      message: '',\n      type: 'info', // success, error, warning, info\n      duration: uiState.configOptions.toastDuration,\n      dismissible: true,\n      icon: true\n    };\n    \n    const config = { ...defaults, ...options };\n    \n    // Generate unique ID for this toast\n    const toastId = 'toast-' + Date.now() + '-' + Math.floor(Math.random() * 1000);\n    \n    // Determine appropriate icon and class\n    let iconHTML = '';\n    let headerClass = '';\n    \n    if (config.icon) {\n      switch (config.type) {\n        case 'success':\n          iconHTML = '<i class=\"fas fa-check-circle me-2\"></i>';\n          headerClass = 'bg-success text-white';\n          break;\n        case 'error':\n          iconHTML = '<i class=\"fas fa-exclamation-circle me-2\"></i>';\n          headerClass = 'bg-danger text-white';\n          break;\n        case 'warning':\n          iconHTML = '<i class=\"fas fa-exclamation-triangle me-2\"></i>';\n          headerClass = 'bg-warning text-dark';\n          break;\n        default: // info\n          iconHTML = '<i class=\"fas fa-info-circle me-2\"></i>';\n          headerClass = 'bg-info text-white';\n      }\n    }\n    \n    // Create toast element\n    const toast = createElement('div', {\n      id: toastId,\n      className: 'toast',\n      role: 'alert',\n      'aria-live': 'assertive',\n      'aria-atomic': 'true'\n    });\n    \n    // Create toast header\n    const toastHeader = createElement('div', {\n      className: `toast-header ${headerClass}`\n    });\n    \n    // Create header content\n    toastHeader.innerHTML = `\n      ${iconHTML}\n      <strong class=\"me-auto\">${config.title}</strong>\n      ${config.dismissible ? \n        '<button type=\"button\" class=\"btn-close btn-close-white\" data-bs-dismiss=\"toast\" aria-label=\"Close\"></button>' : \n        ''}\n    `;\n    \n    // Create toast body\n    const toastBody = createElement('div', {\n      className: 'toast-body'\n    }, config.message);\n    \n    // Assemble toast\n    toast.appendChild(toastHeader);\n    toast.appendChild(toastBody);\n    \n    // Add to container\n    container.appendChild(toast);\n    \n    // Add to state\n    uiState.notifications.push(toast);\n    \n    // Initialize Bootstrap Toast if available\n    if (window.bootstrap && window.bootstrap.Toast) {\n      const bsToast = new window.bootstrap.Toast(toast, {\n        autohide: config.duration > 0,\n        delay: config.duration\n      });\n      bsToast.show();\n    } else {\n      // Fallback if Bootstrap is not available\n      toast.classList.add('show');\n      \n      // Add close button handler\n      if (config.dismissible) {\n        const closeButton = toast.querySelector('.btn-close');\n        if (closeButton) {\n          addEventListeners(closeButton, 'click', () => {\n            removeNotification(toast);\n          });\n        }\n      }\n      \n      // Auto-dismiss after duration\n      if (config.duration > 0) {\n        setTimeout(() => {\n          removeNotification(toast);\n        }, config.duration);\n      }\n    }\n    \n    return toast;\n  } catch (error) {\n    console.error(\"Error showing notification:\", error);\n    return null;\n  }\n}\n\n/**\n * Remove a notification\n * @param {HTMLElement} notification - Notification to remove\n */\nfunction removeNotification(notification) {\n  if (!notification) return;\n  \n  notification.classList.remove('show');\n  \n  // Remove from state\n  const index = uiState.notifications.indexOf(notification);\n  if (index > -1) {\n    uiState.notifications.splice(index, 1);\n  }\n  \n  // Remove element after animation completes\n  setTimeout(() => {\n    if (notification.parentNode) {\n      notification.remove();\n    }\n  }, 300);\n}\n\n/**\n * Clear all notifications\n */\nfunction clearNotifications() {\n  const notifications = [...uiState.notifications];\n  notifications.forEach(notification => {\n    removeNotification(notification);\n  });\n}\n\n/**\n * Show a specific panel\n * @param {string|HTMLElement} panel - Panel to show\n * @param {Object} options - Display options\n */\nfunction showPanel(panel, options = {}) {\n  const panelElement = getElement(panel);\n  if (!panelElement) return;\n  \n  // Hide current active panel if exclusive option is true\n  if (options.exclusive && uiState.activePanel && uiState.activePanel !== panelElement) {\n    hidePanel(uiState.activePanel);\n  }\n  \n  // Apply display mode\n  panelElement.style.display = options.display || 'block';\n  panelElement.setAttribute('aria-hidden', 'false');\n  \n  // Apply animation if enabled\n  if (options.animate && uiState.configOptions.animationsEnabled) {\n    panelElement.classList.add('panel-animate-in');\n    setTimeout(() => panelElement.classList.remove('panel-animate-in'), 300);\n  }\n  \n  // Update active panel\n  uiState.activePanel = panelElement;\n  \n  // Trigger custom event\n  const event = new CustomEvent('panel:shown', { \n    detail: { \n      panelId: panelElement.id, \n      options \n    } \n  });\n  panelElement.dispatchEvent(event);\n}\n\n/**\n * Hide a specific panel\n * @param {string|HTMLElement} panel - Panel to hide\n * @param {Object} options - Display options\n */\nfunction hidePanel(panel, options = {}) {\n  const panelElement = getElement(panel);\n  if (!panelElement) return;\n  \n  if (options.animate && uiState.configOptions.animationsEnabled) {\n    panelElement.classList.add('panel-animate-out');\n    setTimeout(() => {\n      panelElement.style.display = 'none';\n      panelElement.classList.remove('panel-animate-out');\n      panelElement.setAttribute('aria-hidden', 'true');\n    }, 300);\n  } else {\n    panelElement.style.display = 'none';\n    panelElement.setAttribute('aria-hidden', 'true');\n  }\n  \n  // Update active panel\n  if (uiState.activePanel === panelElement) {\n    uiState.activePanel = null;\n  }\n  \n  // Trigger custom event\n  const event = new CustomEvent('panel:hidden', { \n    detail: { \n      panelId: panelElement.id, \n      options \n    } \n  });\n  panelElement.dispatchEvent(event);\n}\n\n/**\n * Toggle a panel's visibility\n * @param {string|HTMLElement} panel - Panel to toggle\n * @param {Object} options - Display options\n */\nfunction togglePanel(panel, options = {}) {\n  const panelElement = getElement(panel);\n  if (!panelElement) return;\n  \n  if (panelElement.style.display === 'none' || panelElement.getAttribute('aria-hidden') === 'true') {\n    showPanel(panelElement, options);\n  } else {\n    hidePanel(panelElement, options);\n  }\n}\n\n/**\n * Show a modal dialog\n * @param {Object} options - Modal options\n * @returns {Object} Modal control object\n */\nfunction showModal(options = {}) {\n  try {\n    // Default options\n    const defaults = {\n      title: 'Modal Dialog',\n      content: '',\n      size: 'default', // small, default, large, xl\n      dismissible: true,\n      buttons: [],\n      onClose: null,\n      onOpen: null,\n      centered: false,\n      scrollable: true,\n      backdrop: true,\n      keyboard: true,\n      fullscreen: false\n    };\n    \n    const config = { ...defaults, ...options };\n    \n    // Generate unique ID\n    const modalId = 'modal-' + Date.now() + '-' + Math.floor(Math.random() * 1000);\n    \n    // Get modal container or create it\n    let modalContainer = getElement('modal-container');\n    if (!modalContainer) {\n      modalContainer = createElement('div', { id: 'modal-container' });\n      document.body.appendChild(modalContainer);\n    }\n    \n    // Determine size class\n    let sizeClass = '';\n    switch (config.size) {\n      case 'small': sizeClass = 'modal-sm'; break;\n      case 'large': sizeClass = 'modal-lg'; break;\n      case 'xl': sizeClass = 'modal-xl'; break;\n    }\n    \n    // Determine fullscreen class\n    let fullscreenClass = '';\n    if (config.fullscreen === true) {\n      fullscreenClass = 'modal-fullscreen';\n    } else if (typeof config.fullscreen === 'string') {\n      fullscreenClass = `modal-fullscreen-${config.fullscreen}-down`;\n    }\n    \n    // Create modal element\n    const modal = createElement('div', {\n      id: modalId,\n      className: 'modal fade',\n      tabindex: '-1',\n      role: 'dialog',\n      'aria-labelledby': `${modalId}-title`,\n      'aria-hidden': 'true',\n      'data-bs-backdrop': config.backdrop ? 'true' : 'static',\n      'data-bs-keyboard': config.keyboard ? 'true' : 'false'\n    });\n    \n    // Create dialog element\n    const dialogClasses = [\n      'modal-dialog', \n      sizeClass, \n      config.centered ? 'modal-dialog-centered' : '',\n      config.scrollable ? 'modal-dialog-scrollable' : '',\n      fullscreenClass\n    ].filter(Boolean).join(' ');\n    \n    const dialog = createElement('div', {\n      className: dialogClasses\n    });\n    \n    // Create content element\n    const content = createElement('div', {\n      className: 'modal-content'\n    });\n    \n    // Create header\n    const header = createElement('div', {\n      className: 'modal-header'\n    });\n    \n    // Add title\n    const title = createElement('h5', {\n      className: 'modal-title',\n      id: `${modalId}-title`\n    }, config.title);\n    \n    header.appendChild(title);\n    \n    // Add close button if dismissible\n    if (config.dismissible) {\n      const closeButton = createElement('button', {\n        type: 'button',\n        className: 'btn-close',\n        'data-bs-dismiss': 'modal',\n        'aria-label': 'Close'\n      });\n      \n      header.appendChild(closeButton);\n    }\n    \n    // Create body\n    const body = createElement('div', {\n      className: 'modal-body'\n    });\n    \n    // Add content\n    if (typeof config.content === 'string') {\n      body.innerHTML = config.content;\n    } else if (config.content instanceof HTMLElement) {\n      body.appendChild(config.content);\n    }\n    \n    // Create footer if buttons provided\n    let footer = null;\n    if (Array.isArray(config.buttons) && config.buttons.length > 0) {\n      footer = createElement('div', {\n        className: 'modal-footer'\n      });\n      \n      // Add buttons\n      config.buttons.forEach(btn => {\n        const buttonType = btn.type || (btn.primary ? 'primary' : 'secondary');\n        const buttonClass = `btn btn-${buttonType} ${btn.className || ''}`.trim();\n        \n        const button = createElement('button', {\n          type: 'button',\n          className: buttonClass,\n          'data-action': btn.action || ''\n        }, btn.text || 'Button');\n        \n        if (btn.dismiss !== false) {\n          button.setAttribute('data-bs-dismiss', 'modal');\n        }\n        \n        if (btn.onClick && typeof btn.onClick === 'function') {\n          addEventListeners(button, 'click', () => btn.onClick(modalId, modal));\n        }\n        \n        footer.appendChild(button);\n      });\n    }\n    \n    // Assemble modal\n    content.appendChild(header);\n    content.appendChild(body);\n    if (footer) content.appendChild(footer);\n    dialog.appendChild(content);\n    modal.appendChild(dialog);\n    modalContainer.appendChild(modal);\n    \n    // Add to modal stack\n    uiState.modalStack.push(modal);\n    \n    // Initialize Bootstrap Modal if available\n    let bootstrapModal = null;\n    if (window.bootstrap && window.bootstrap.Modal) {\n      bootstrapModal = new window.bootstrap.Modal(modal, {\n        backdrop: config.backdrop ? true : 'static',\n        keyboard: config.keyboard,\n        focus: true\n      });\n      \n      bootstrapModal.show();\n    } else {\n      // Fallback if Bootstrap is not available\n      setTimeout(() => {\n        document.body.classList.add('modal-open');\n        modal.style.display = 'block';\n        modal.classList.add('show');\n        \n        // Create backdrop if not already exists\n        if (!document.querySelector('.modal-backdrop') && config.backdrop) {\n          const backdrop = createElement('div', {\n            className: 'modal-backdrop fade show'\n          });\n          document.body.appendChild(backdrop);\n        }\n      }, 10);\n      \n      // Add close button handler\n      if (config.dismissible) {\n        const closeButtons = modal.querySelectorAll('[data-bs-dismiss=\"modal\"]');\n        closeButtons.forEach(button => {\n          addEventListeners(button, 'click', () => closeModal(modalId));\n        });\n      }\n    }\n    \n    // Register modal instance\n    uiState.modalInstances.set(modalId, {\n      element: modal,\n      bootstrapInstance: bootstrapModal,\n      config,\n      dispose: () => {\n        // Remove from modal stack\n        const index = uiState.modalStack.indexOf(modal);\n        if (index > -1) {\n          uiState.modalStack.splice(index, 1);\n        }\n        \n        // Remove from instances\n        uiState.modalInstances.delete(modalId);\n        \n        // Remove event listeners\n        modal.querySelectorAll('button').forEach(button => {\n          button.removeEventListener('click', button.clickHandler);\n        });\n        \n        // Call onClose callback\n        if (config.onClose && typeof config.onClose === 'function') {\n          config.onClose(modalId, modal);\n        }\n        \n        // Remove element\n        if (modal.parentNode) {\n          modal.remove();\n        }\n        \n        // Remove backdrop if no more modals\n        if (uiState.modalStack.length === 0) {\n          document.body.classList.remove('modal-open');\n          const backdrop = document.querySelector('.modal-backdrop');\n          if (backdrop) backdrop.remove();\n        }\n      }\n    });\n    \n    // Add hidden event handler\n    addEventListeners(modal, 'hidden.bs.modal', () => {\n      const instance = uiState.modalInstances.get(modalId);\n      if (instance) instance.dispose();\n    });\n    \n    // Add custom hidden event for non-bootstrap\n    if (!window.bootstrap) {\n      addEventListeners(modal, 'click', (event) => {\n        // Close on backdrop click if enabled\n        if (config.backdrop && event.target === modal) {\n          closeModal(modalId);\n        }\n      });\n      \n      // Add keyboard support\n      if (config.keyboard) {\n        addEventListeners(document, 'keydown', (event) => {\n          if (event.key === 'Escape' && uiState.modalStack[uiState.modalStack.length - 1] === modal) {\n            closeModal(modalId);\n          }\n        });\n      }\n    }\n    \n    // Call onOpen callback\n    if (config.onOpen && typeof config.onOpen === 'function') {\n      setTimeout(() => config.onOpen(modalId, modal), 300);\n    }\n    \n    // Return control object\n    return {\n      id: modalId,\n      element: modal,\n      close: () => closeModal(modalId),\n      getBody: () => body,\n      getFooter: () => footer,\n      setTitle: (newTitle) => {\n        title.textContent = newTitle;\n      },\n      setContent: (newContent) => {\n        if (typeof newContent === 'string') {\n          body.innerHTML = newContent;\n        } else if (newContent instanceof HTMLElement) {\n          body.innerHTML = '';\n          body.appendChild(newContent);\n        }\n      }\n    };\n  } catch (error) {\n    console.error(\"Error showing modal:\", error);\n    return {\n      id: null,\n      element: null,\n      close: () => {},\n      getBody: () => null,\n      getFooter: () => null,\n      setTitle: () => {},\n      setContent: () => {}\n    };\n  }\n}\n\n/**\n * Close a modal dialog\n * @param {string} modalId - Modal ID\n */\nfunction closeModal(modalId) {\n  try {\n    const instance = uiState.modalInstances.get(modalId);\n    if (!instance) return;\n    \n    if (instance.bootstrapInstance) {\n      instance.bootstrapInstance.hide();\n    } else {\n      // Fallback if Bootstrap is not available\n      instance.element.classList.remove('show');\n      instance.element.style.display = 'none';\n      \n      // Call dispose\n      instance.dispose();\n    }\n  } catch (error) {\n    console.error(\"Error closing modal:\", error);\n  }\n}\n\n/**\n * Show loading indicator\n * @param {Object} options - Loading options\n * @returns {Object} Loading control object\n */\nfunction showLoading(options = {}) {\n  try {\n    const defaults = {\n      fullscreen: false,\n      message: 'Loading...',\n      target: null,\n      showSpinner: true,\n      overlay: true,\n      spinnerSize: 'md', // sm, md, lg\n      spinnerColor: 'primary' // primary, secondary, success, danger, warning, info\n    };\n    \n    const config = { ...defaults, ...options };\n    \n    // Generate unique ID\n    const loaderId = 'loader-' + Date.now() + '-' + Math.floor(Math.random() * 1000);\n    \n    // Create container class\n    let containerClass = 'loading-indicator';\n    if (config.fullscreen) {\n      containerClass += ' position-fixed top-0 start-0 w-100 h-100';\n      if (config.overlay) containerClass += ' bg-dark bg-opacity-50';\n    } else {\n      containerClass += ' position-relative';\n    }\n    \n    // Create spinner class\n    let spinnerClass = `spinner-border text-${config.spinnerColor}`;\n    if (config.spinnerSize === 'sm') spinnerClass += ' spinner-border-sm';\n    if (config.spinnerSize === 'lg') spinnerClass += ' spinner-border-lg';\n    \n    // Create loader element\n    const loader = createElement('div', {\n      id: loaderId,\n      className: containerClass,\n      style: 'z-index: 1050; display: flex; align-items: center; justify-content: center;'\n    });\n    \n    // Create container for content\n    const inner = createElement('div', {\n      className: 'bg-white p-3 rounded shadow-sm d-flex align-items-center'\n    });\n    \n    // Add spinner if enabled\n    if (config.showSpinner) {\n      const spinner = createElement('div', {\n        className: spinnerClass,\n        role: 'status'\n      });\n      \n      const srOnly = createElement('span', {\n        className: 'visually-hidden'\n      }, 'Loading...');\n      \n      spinner.appendChild(srOnly);\n      inner.appendChild(spinner);\n    }\n    \n    // Add message element\n    const message = createElement('div', {\n      id: `${loaderId}-message`,\n      className: config.showSpinner ? 'ms-3' : ''\n    }, config.message);\n    \n    inner.appendChild(message);\n    loader.appendChild(inner);\n    \n    // Add to DOM\n    if (config.fullscreen) {\n      document.body.appendChild(loader);\n    } else if (config.target) {\n      const targetElement = getElement(config.target);\n      if (targetElement) {\n        if (config.overlay) {\n          // Position the loader appropriately\n          const targetPosition = window.getComputedStyle(targetElement).position;\n          if (targetPosition === 'static') {\n            targetElement.style.position = 'relative';\n          }\n        }\n        targetElement.appendChild(loader);\n      } else {\n        document.body.appendChild(loader);\n      }\n    } else {\n      document.body.appendChild(loader);\n    }\n    \n    // Add show class after a short delay for animation\n    setTimeout(() => loader.classList.add('show'), 10);\n    \n    // Update state\n    uiState.isLoading = true;\n    uiState.spinners.set(loaderId, {\n      element: loader,\n      config\n    });\n    \n    // Return control object\n    return {\n      id: loaderId,\n      element: loader,\n      hide: () => hideLoading(loaderId),\n      updateMessage: (newMessage) => {\n        const messageElement = document.getElementById(`${loaderId}-message`);\n        if (messageElement) {\n          messageElement.textContent = newMessage;\n        }\n      }\n    };\n  } catch (error) {\n    console.error(\"Error showing loading indicator:\", error);\n    return {\n      id: null,\n      element: null,\n      hide: () => {},\n      updateMessage: () => {}\n    };\n  }\n}\n// At the end of ui.js - After all exports\n\n// Create ui object with all exports\nconst ui = {\n  initUI,\n  showPanel,\n  hidePanel,\n  togglePanel,\n  showModal,\n  closeModal,\n  showNotification,\n  clearNotifications,\n  showLoading,\n  hideLoading,\n  updateProgressBar,\n  confirm,\n  alert,\n  prompt,\n  toggleElementVisibility,\n  toggleClass,\n  createTabs,\n  setTheme\n};\n\n// Update the bridge with the real UI module\nupdateUIBridge(ui);\n\nconsole.log(\"UI module initialized and bridge updated\");\n/**\n * Hide loading indicator\n * @param {string} [loaderId] - ID of specific loader to hide, or all if not specified\n */\nfunction hideLoading(loaderId) {\n  try {\n    if (loaderId) {\n      // Hide specific loader\n      const loaderInfo = uiState.spinners.get(loaderId);\n      if (!loaderInfo) return;\n      \n      const loader = loaderInfo.element;\n      loader.classList.remove('show');\n      \n      // Remove after animation\n      setTimeout(() => {\n        if (loader.parentNode) {\n          // Reset target position if overlay was used\n          if (loaderInfo.config.overlay && !loaderInfo.config.fullscreen) {\n            const target = loader.parentNode;\n            // Only reset if no other overlays are present\n            const hasOtherOverlays = Array.from(target.children).some(child => \n              child !== loader && \n              child.classList.contains('loading-indicator') && \n              loaderInfo.config.overlay\n            );\n            \n            if (!hasOtherOverlays) {\n              target.style.position = '';\n            }\n          }\n          \n          loader.remove();\n        }\n        \n        // Remove from state\n        uiState.spinners.delete(loaderId);\n        \n        // Update loading state if no more spinners\n        if (uiState.spinners.size === 0) {\n          uiState.isLoading = false;\n        }\n      }, 300);\n    } else {\n      // Hide all loaders\n      const loaderIds = Array.from(uiState.spinners.keys());\n      loaderIds.forEach(id => hideLoading(id));\n    }\n  } catch (error) {\n    console.error(\"Error hiding loading indicator:\", error);\n  }\n}\n\n/**\n * Update a progress bar\n * @param {string} elementId - Progress bar element ID\n * @param {number} value - Progress value (0-100)\n * @param {Object} options - Update options\n * @returns {boolean} Success status\n */\nfunction updateProgressBar(elementId, value, options = {}) {\n  try {\n    const progressBar = getElement(elementId);\n    if (!progressBar) return false;\n    \n    // Default options\n    const defaults = {\n      text: null,\n      textInside: false,\n      animated: true,\n      contextual: true\n    };\n    \n    const config = { ...defaults, ...options };\n    \n    // Ensure value is in valid range\n    const percent = Math.min(100, Math.max(0, value));\n    \n    // Find the actual progress bar element (could be a child)\n    const innerBar = progressBar.classList.contains('progress') ? \n      progressBar.querySelector('.progress-bar') : \n      progressBar;\n    \n    if (!innerBar) return false;\n    \n    // Update progress\n    innerBar.style.width = `${percent}%`;\n    innerBar.setAttribute('aria-valuenow', percent);\n    \n    // Update animation class\n    if (config.animated) {\n      innerBar.classList.add('progress-bar-animated', 'progress-bar-striped');\n    } else {\n      innerBar.classList.remove('progress-bar-animated', 'progress-bar-striped');\n    }\n    \n    // Update contextual class if enabled\n    if (config.contextual) {\n      // Remove existing contextual classes\n      ['bg-danger', 'bg-warning', 'bg-info', 'bg-success'].forEach(cls => {\n        innerBar.classList.remove(cls);\n      });\n      \n      // Add appropriate class based on progress\n      if (percent < 25) {\n        innerBar.classList.add('bg-danger');\n      } else if (percent < 50) {\n        innerBar.classList.add('bg-warning');\n      } else if (percent < 75) {\n        innerBar.classList.add('bg-info');\n      } else {\n        innerBar.classList.add('bg-success');\n      }\n    }\n    \n    // Update text if provided\n    if (config.text !== null) {\n      // Determine where to show text\n      if (config.textInside) {\n        innerBar.textContent = config.text;\n      } else {\n        // Find or create text element\n        let textEl = progressBar.querySelector('.progress-text');\n        if (!textEl) {\n          textEl = createElement('div', { className: 'progress-text mt-1' });\n          progressBar.parentNode.insertBefore(textEl, progressBar.nextSibling);\n        }\n        textEl.textContent = config.text;\n      }\n    }\n    \n    // Save in state\n    uiState.progressBars.set(elementId, {\n      element: progressBar,\n      value: percent\n    });\n    \n    return true;\n  } catch (error) {\n    console.error(\"Error updating progress bar:\", error);\n    return false;\n  }\n}\n\n/**\n * Create a confirmation dialog\n * @param {string} title - Dialog title\n * @param {string|HTMLElement} message - Dialog message\n * @param {Function} onConfirm - Confirm callback\n * @param {Function} onCancel - Cancel callback\n * @param {Object} options - Dialog options\n * @returns {Object} Modal control object\n */\nfunction confirm(title, message, onConfirm, onCancel = null, options = {}) {\n  // Default options\n  const defaults = {\n    confirmText: 'Confirm',\n    cancelText: 'Cancel',\n    confirmType: 'primary',\n    cancelType: 'secondary',\n    size: 'small',\n    centered: true\n  };\n  \n  const config = { ...defaults, ...options };\n  \n  // Create content element\n  let content;\n  if (typeof message === 'string') {\n    content = createElement('div', {}, message);\n  } else if (message instanceof HTMLElement) {\n    content = message;\n  } else {\n    content = createElement('div', {}, 'Are you sure?');\n  }\n  \n  // Create buttons\n  const buttons = [\n    {\n      text: config.cancelText,\n      type: config.cancelType,\n      onClick: onCancel || (() => {})\n    },\n    {\n      text: config.confirmText,\n      type: config.confirmType,\n      primary: true,\n      onClick: onConfirm\n    }\n  ];\n  \n  // Show modal\n  return showModal({\n    title,\n    content,\n    size: config.size,\n    centered: config.centered,\n    buttons\n  });\n}\n\n/**\n * Show an alert dialog\n * @param {string} title - Alert title\n * @param {string|HTMLElement} message - Alert message\n * @param {Object} options - Alert options\n * @returns {Object} Modal control object\n */\nfunction alert(title, message, options = {}) {\n  // Default options\n  const defaults = {\n    buttonText: 'OK',\n    buttonType: 'primary',\n    size: 'small',\n    centered: true,\n    icon: null // success, error, warning, info\n  };\n  \n  const config = { ...defaults, ...options };\n  \n  // Create content with icon if specified\n  let content;\n  if (config.icon) {\n    let iconHTML = '';\n    let iconClass = '';\n    \n    switch (config.icon) {\n      case 'success':\n        iconHTML = '<i class=\"fas fa-check-circle text-success fa-3x mb-3\"></i>';\n        break;\n      case 'error':\n        iconHTML = '<i class=\"fas fa-exclamation-circle text-danger fa-3x mb-3\"></i>';\n        break;\n      case 'warning':\n        iconHTML = '<i class=\"fas fa-exclamation-triangle text-warning fa-3x mb-3\"></i>';\n        break;\n      case 'info':\n        iconHTML = '<i class=\"fas fa-info-circle text-info fa-3x mb-3\"></i>';\n        break;\n    }\n    \n    const container = createElement('div', {\n      className: 'text-center'\n    });\n    \n    if (iconHTML) {\n      container.innerHTML = iconHTML;\n    }\n    \n    // Add message\n    const messageEl = createElement('div', {\n      className: 'mt-2'\n    });\n    \n    if (typeof message === 'string') {\n      messageEl.textContent = message;\n    } else if (message instanceof HTMLElement) {\n      messageEl.appendChild(message);\n    }\n    \n    container.appendChild(messageEl);\n    content = container;\n  } else {\n    // No icon, just use message\n    if (typeof message === 'string') {\n      content = createElement('div', {}, message);\n    } else if (message instanceof HTMLElement) {\n      content = message;\n    }\n  }\n  \n  // Show modal\n  return showModal({\n    title,\n    content,\n    size: config.size,\n    centered: config.centered,\n    buttons: [\n      {\n        text: config.buttonText,\n        type: config.buttonType,\n        primary: true,\n        onClick: config.onClose || (() => {})\n      }\n    ]\n  });\n}\n\n/**\n * Show a prompt dialog\n * @param {string} title - Prompt title\n * @param {string} message - Prompt message\n * @param {Function} onSubmit - Submit callback\n * @param {Function} onCancel - Cancel callback\n * @param {Object} options - Prompt options\n * @returns {Object} Modal control object\n */\nfunction prompt(title, message, onSubmit, onCancel = null, options = {}) {\n  // Default options\n  const defaults = {\n    defaultValue: '',\n    placeholder: '',\n    submitText: 'Submit',\n    cancelText: 'Cancel',\n    inputType: 'text',\n    size: 'small',\n    centered: true,\n    required: false,\n    validator: null\n  };\n  \n  const config = { ...defaults, ...options };\n  \n  // Create input ID\n  const inputId = 'prompt-input-' + Date.now();\n  \n  // Create content\n  const content = createElement('div', {});\n  \n  // Add message\n  if (message) {\n    const messageEl = createElement('p', {\n      className: 'mb-3'\n    }, message);\n    content.appendChild(messageEl);\n  }\n  \n  // Create form group\n  const formGroup = createElement('div', {\n    className: 'mb-3'\n  });\n  \n  // Create input\n  const input = createElement('input', {\n    type: config.inputType,\n    className: 'form-control',\n    id: inputId,\n    placeholder: config.placeholder,\n    value: config.defaultValue,\n    required: config.required\n  });\n  \n  formGroup.appendChild(input);\n  content.appendChild(formGroup);\n  \n  // Add validator if provided\n  let isValid = true;\n  let validatorTimeout = null;\n  \n  if (config.validator && typeof config.validator === 'function') {\n    // Create feedback element\n    const feedback = createElement('div', {\n      className: 'invalid-feedback'\n    });\n    formGroup.appendChild(feedback);\n    \n    // Add input event listener\n    input.addEventListener('input', () => {\n      // Clear previous timeout\n      if (validatorTimeout) {\n        clearTimeout(validatorTimeout);\n      }\n      \n      // Set new timeout to avoid too many validations\n      validatorTimeout = setTimeout(() => {\n        const result = config.validator(input.value);\n        if (result === true) {\n          input.classList.remove('is-invalid');\n          input.classList.add('is-valid');\n          isValid = true;\n        } else {\n          input.classList.remove('is-valid');\n          input.classList.add('is-invalid');\n          feedback.textContent = typeof result === 'string' ? result : 'Invalid input';\n          isValid = false;\n        }\n      }, 300);\n    });\n  }\n  \n  // Create buttons\n  const buttons = [\n    {\n      text: config.cancelText,\n      type: 'secondary',\n      onClick: onCancel || (() => {})\n    },\n    {\n      text: config.submitText,\n      type: 'primary',\n      primary: true,\n      onClick: () => {\n        // Check if valid\n        if (config.validator && !isValid) {\n          return false; // Prevent modal from closing\n        }\n        \n        // Check required\n        if (config.required && !input.value.trim()) {\n          input.classList.add('is-invalid');\n          return false; // Prevent modal from closing\n        }\n        \n        // Call submit handler\n        onSubmit(input.value);\n      },\n      dismiss: !config.validator // Allow validation to control closing\n    }\n  ];\n  \n  // Show modal\n  const modal = showModal({\n    title,\n    content,\n    size: config.size,\n    centered: config.centered,\n    buttons\n  });\n  \n  // Focus input after modal is shown\n  setTimeout(() => {\n    input.focus();\n    \n    // Select text if default value is provided\n    if (config.defaultValue) {\n      input.select();\n    }\n  }, 300);\n  \n  // Add enter key support\n  input.addEventListener('keydown', (event) => {\n    if (event.key === 'Enter') {\n      event.preventDefault();\n      \n      // Check if valid\n      if (config.validator && !isValid) {\n        return;\n      }\n      \n      // Check required\n      if (config.required && !input.value.trim()) {\n        input.classList.add('is-invalid');\n        return;\n      }\n      \n      // Call submit handler and close\n      onSubmit(input.value);\n      modal.close();\n    }\n  });\n  \n  return modal;\n}\n\n/**\n * Toggle element visibility\n * @param {string|HTMLElement} element - Element to toggle\n * @param {boolean} visible - Whether to show or hide\n * @param {string} displayMode - Display value when showing\n * @returns {boolean} Success status\n */\nfunction toggleElementVisibility(element, visible, displayMode = 'block') {\n  try {\n    const el = getElement(element);\n    if (!el) return false;\n    \n    el.style.display = visible ? displayMode : 'none';\n    \n    // If animation enabled, add classes\n    if (uiState.configOptions.animationsEnabled) {\n      if (visible) {\n        el.classList.add('element-animate-in');\n        setTimeout(() => el.classList.remove('element-animate-in'), 300);\n      } else {\n        el.classList.add('element-animate-out');\n      }\n    }\n    \n    return true;\n  } catch (error) {\n    console.error(\"Error toggling element visibility:\", error);\n    return false;\n  }\n}\n\n/**\n * Toggle element class\n * @param {string|HTMLElement} element - Element to modify\n * @param {string} className - Class to toggle\n * @param {boolean} [add] - Whether to add or remove (if undefined, toggles)\n * @returns {boolean} Success status\n */\nfunction toggleClass(element, className, add) {\n  try {\n    const el = getElement(element);\n    if (!el) return false;\n    \n    if (typeof add === 'undefined') {\n      el.classList.toggle(className);\n    } else if (add) {\n      el.classList.add(className);\n    } else {\n      el.classList.remove(className);\n    }\n    \n    return true;\n  } catch (error) {\n    console.error(\"Error toggling class:\", error);\n    return false;\n  }\n}\n\n/**\n * Create tabs interface\n * @param {string|HTMLElement} container - Container element\n * @param {Array<Object>} tabs - Tab definitions\n * @param {Object} options - Tab options\n * @returns {Object} Tabs control object\n */\nfunction createTabs(container, tabs, options = {}) {\n  try {\n    const containerEl = getElement(container);\n    if (!containerEl) return null;\n    \n    // Default options\n    const defaults = {\n      id: 'tabs-' + Date.now(),\n      activeIndex: 0,\n      type: 'tabs', // tabs, pills, underline\n      vertical: false,\n      justified: false,\n      fade: true,\n      onTabChange: null\n    };\n    \n    const config = { ...defaults, ...options };\n    \n    // Generate unique ID if container doesn't have one\n    const containerId = containerEl.id || config.id;\n    containerEl.id = containerId;\n    \n    // Build the tab structure\n    const navId = `${containerId}-nav`;\n    const contentId = `${containerId}-content`;\n    \n    // Determine nav classes\n    let navClasses = 'nav';\n    switch (config.type) {\n      case 'pills':\n        navClasses += ' nav-pills';\n        break;\n      case 'underline':\n        navClasses += ' nav-underline';\n        break;\n      default:\n        navClasses += ' nav-tabs';\n    }\n    \n    if (config.vertical) {\n      navClasses += ' flex-column';\n    }\n    \n    if (config.justified) {\n      navClasses += ' nav-justified';\n    }\n    \n    // Create nav\n    const nav = createElement('ul', {\n      id: navId,\n      className: navClasses,\n      role: 'tablist'\n    });\n    \n    // Create content container\n    const content = createElement('div', {\n      id: contentId,\n      className: 'tab-content mt-2'\n    });\n    \n    // Build tabs\n    tabs.forEach((tab, index) => {\n      const isActive = index === config.activeIndex;\n      const tabId = tab.id || `${containerId}-tab-${index}`;\n      const paneId = `${tabId}-pane`;\n      \n      // Create nav item\n      const navItem = createElement('li', {\n        className: 'nav-item',\n        role: 'presentation'\n      });\n      \n      // Create nav link\n      const navLink = createElement('button', {\n        className: `nav-link ${isActive ? 'active' : ''}`,\n        id: tabId,\n        'data-bs-toggle': 'tab',\n        'data-bs-target': `#${paneId}`,\n        type: 'button',\n        role: 'tab',\n        'aria-controls': paneId,\n        'aria-selected': isActive ? 'true' : 'false'\n      }, tab.title);\n      \n      // Add icon if provided\n      if (tab.icon) {\n        const icon = createElement('i', {\n          className: `${tab.icon} ${tab.title ? 'me-2' : ''}`\n        });\n        navLink.insertBefore(icon, navLink.firstChild);\n      }\n      \n      navItem.appendChild(navLink);\n      nav.appendChild(navItem);\n      \n      // Create tab pane\n      const pane = createElement('div', {\n        className: `tab-pane ${config.fade ? 'fade' : ''} ${isActive ? 'show active' : ''}`,\n        id: paneId,\n        role: 'tabpanel',\n        'aria-labelledby': tabId\n      });\n      \n      // Add content\n      if (typeof tab.content === 'string') {\n        pane.innerHTML = tab.content;\n      } else if (tab.content instanceof HTMLElement) {\n        pane.appendChild(tab.content);\n      }\n      \n      content.appendChild(pane);\n    });\n    \n    // Clear container and add tabs\n    containerEl.innerHTML = '';\n    containerEl.appendChild(nav);\n    containerEl.appendChild(content);\n    \n    // Add event listeners\n    const navLinks = nav.querySelectorAll('.nav-link');\n    navLinks.forEach((link, index) => {\n      link.addEventListener('click', (event) => {\n        // Prevent default if we're handling manually\n        if (!window.bootstrap) {\n          event.preventDefault();\n        }\n        \n        // Update active state\n        navLinks.forEach(l => {\n          l.classList.remove('active');\n          l.setAttribute('aria-selected', 'false');\n        });\n        \n        link.classList.add('active');\n        link.setAttribute('aria-selected', 'true');\n        \n        // Update panes\n        const panes = content.querySelectorAll('.tab-pane');\n        panes.forEach(p => {\n          p.classList.remove('active');\n          if (config.fade) p.classList.remove('show');\n        });\n        \n        const targetId = link.getAttribute('data-bs-target') || link.getAttribute('href');\n        const targetPane = document.querySelector(targetId);\n        \n        if (targetPane) {\n          targetPane.classList.add('active');\n          \n          if (config.fade) {\n            setTimeout(() => targetPane.classList.add('show'), 10);\n          }\n        }\n        \n        // Call change handler\n        if (config.onTabChange && typeof config.onTabChange === 'function') {\n          config.onTabChange(index, tabs[index]);\n        }\n      });\n    });\n    \n    // Store in state\n    uiState.activeTabSets.set(containerId, {\n      element: containerEl,\n      config,\n      tabs\n    });\n    \n    // Return control object\n    return {\n      id: containerId,\n      element: containerEl,\n      setActiveTab: (index) => {\n        if (index >= 0 && index < navLinks.length) {\n          navLinks[index].click();\n          return true;\n        }\n        return false;\n      },\n      getActiveIndex: () => {\n        let activeIndex = 0;\n        navLinks.forEach((link, i) => {\n          if (link.classList.contains('active')) {\n            activeIndex = i;\n          }\n        });\n        return activeIndex;\n      },\n      updateTabContent: (index, newContent) => {\n        if (index >= 0 && index < tabs.length) {\n          const paneId = `${containerId}-tab-${index}-pane`;\n          const pane = document.getElementById(paneId);\n          \n          if (pane) {\n            if (typeof newContent === 'string') {\n              pane.innerHTML = newContent;\n            } else if (newContent instanceof HTMLElement) {\n              pane.innerHTML = '';\n              pane.appendChild(newContent);\n            }\n            return true;\n          }\n        }\n        return false;\n      }\n    };\n  } catch (error) {\n    console.error(\"Error creating tabs:\", error);\n    return null;\n  }\n}\n\n/**\n * Set application theme\n * @param {string} theme - Theme name ('light', 'dark', or custom)\n */\nfunction setTheme(theme) {\n  document.documentElement.setAttribute('data-theme', theme);\n  if (typeof localStorage !== 'undefined') {\n    localStorage.setItem('app-theme', theme);\n  }\n  \n  // Update configuration\n  uiState.configOptions.defaultTheme = theme;\n  \n  // Add appropriate class to body\n  if (theme === 'dark') {\n    document.body.classList.add('dark-mode');\n    document.body.classList.remove('light-mode');\n  } else {\n    document.body.classList.add('light-mode');\n    document.body.classList.remove('dark-mode');\n  }\n}\n\n// Export the module\nexport default initUI;\n\n// Named exports for convenience\nexport {\n  showPanel,\n  hidePanel,\n  togglePanel,\n  showModal,\n  closeModal,\n  showNotification,\n  clearNotifications,\n  showLoading,\n  hideLoading,\n  updateProgressBar,\n  confirm,\n  alert,\n  prompt,\n  toggleElementVisibility,\n  toggleClass,\n  createTabs,\n  setTheme\n};","source":"/workspace/modules/static/js/modules/core/ui.js","title":"ui.js","language":"en"},{"content":"/**\n * UI Registry Module\n * \n * Provides a centralized registry for UI elements with enhanced error handling.\n * Efficiently manages DOM elements, provides safe access, and validates against\n * common errors like null references.\n * \n * Features:\n * - Categorized element registration\n * - Default values for missing elements\n * - Error boundary for DOM operations\n * - Lazy loading of UI elements\n * - Common element registration shortcuts\n */\n\n// Import handleError safely - avoid syntax errors with dynamic imports\nlet handleErrorFunc = console.error;\ntry {\n  // Static import would be preferable, but we'll use this approach to avoid import errors\n  console.log(\"Setting up error handler for uiRegistry\");\n} catch (e) {\n  console.warn('Could not import errorHandler, using fallback', e);\n}\n\n/**\n * UI Registry for managing DOM elements\n */\nconst uiRegistry = {\n  // Map of all registered UI elements\n  elements: new Map(),\n\n  // Default categories for organization\n  categories: {\n    // Document-wide elements\n    global: {},\n    \n    // Tab-specific elements\n    fileTab: {},\n    scraper: {},\n    playlist: {},\n    academic: {},\n    \n    // Feature-specific elements\n    history: {},\n    settings: {},\n    \n    // Component-specific elements\n    modal: {},\n    sidebar: {}\n  },\n\n  // Configuration\n  config: {\n    debug: false,\n    warnOnMissing: false, // Set to false to reduce console noise during initialization\n    autoRegisterIds: true,\n    validateOnStartup: true,\n    lazyInitialization: true // Added to help with elements not yet in DOM\n  },\n\n  /**\n   * Initialize the UI Registry\n   * @param {Object} options - Configuration options\n   * @returns {boolean} - Success state\n   */\n  initialize(options = {}) {\n    console.log('Initializing UI Registry...');\n    \n    // Apply configuration options\n    Object.assign(this.config, options);\n    \n    try {\n      // Validate categories\n      Object.keys(this.categories).forEach(category => {\n        if (typeof this.categories[category] !== 'object') {\n          this.categories[category] = {};\n        }\n      });\n      \n      // Auto-register elements with IDs if configured\n      if (this.config.autoRegisterIds) {\n        this.autoRegisterElementsWithIds();\n      }\n      \n      // Only register common elements if not using lazy initialization\n      if (!this.config.lazyInitialization) {\n        this.registerCommonElements();\n      } else {\n        // Schedule registration for when DOM is likely to be ready\n        setTimeout(() => {\n          this.registerCommonElements();\n        }, 100);\n      }\n      \n      console.log('UI Registry initialized successfully');\n      return true;\n    } catch (error) {\n      console.error('Error initializing UI Registry:', error);\n      if (typeof handleErrorFunc === 'function') {\n        handleErrorFunc(error, 'UI_REGISTRY_INITIALIZATION', false);\n      }\n      return false;\n    }\n  },\n\n  /**\n   * Auto-register all elements with IDs\n   */\n  autoRegisterElementsWithIds() {\n    try {\n      const elementsWithIds = document.querySelectorAll('[id]');\n      \n      if (this.config.debug) {\n        console.log(`Auto-registering ${elementsWithIds.length} elements with IDs`);\n      }\n      \n      elementsWithIds.forEach(element => {\n        const id = element.id;\n        \n        if (id) {\n          // Register as global elements for backward compatibility\n          this.elements.set(id, element);\n          \n          if (this.config.debug) {\n            console.log(`Auto-registered element with ID: ${id}`);\n          }\n        }\n      });\n    } catch (error) {\n      console.error('Error auto-registering elements with IDs:', error);\n    }\n  },\n\n  /**\n   * Register common UI elements\n   */\n  registerCommonElements() {\n    console.log('Registering common UI elements...');\n    \n    try {\n      // Register global elements - with less noisy warnings\n      const origWarnSetting = this.config.warnOnMissing;\n      this.config.warnOnMissing = false;\n      \n      // Register global elements\n      this.registerElements('global', {\n        mainContainer: '#main-container',\n        navTabs: '.nav-tabs',\n        tabContents: '.tab-content',\n        darkModeToggle: '#darkModeToggle'\n      });\n      \n      // Register file tab elements - only attempt if the container exists\n      if (document.querySelector('#file-tab')) {\n        this.registerElements('fileTab', {\n          container: '#file-tab',\n          form: '#process-form',\n          inputDir: '#input-dir',\n          outputFile: '#output-file'\n        });\n      }\n      \n      // Register scraper tab elements - only attempt if the container exists\n      if (document.querySelector('#scraper-tab')) {\n        this.registerElements('scraper', {\n          container: '#scraper-tab',\n          form: '#scraper-form'\n        });\n      }\n      \n      // Only try to register history elements if the container exists\n      if (document.querySelector('#history-container')) {\n        this.registerElements('history', {\n          container: '#history-container'\n        });\n      }\n      \n      // Reset warning setting\n      this.config.warnOnMissing = origWarnSetting;\n      \n      console.log('UI elements registered successfully');\n    } catch (error) {\n      console.error('Error registering common UI elements:', error);\n      if (typeof handleErrorFunc === 'function') {\n        handleErrorFunc(error, 'UI_REGISTRY_COMMON_ELEMENTS', false);\n      }\n    }\n  },\n\n  /**\n   * Register multiple UI elements for a category\n   * @param {string} category - The category name\n   * @param {Object} elementsObj - Object mapping element IDs to selectors\n   * @returns {boolean} - Success state\n   */\n  registerElements(category, elementsObj) {\n    if (!category || typeof elementsObj !== 'object') {\n      console.error(`Invalid parameters for registering elements: ${category}`);\n      return false;\n    }\n    \n    try {\n      // Create category if it doesn't exist\n      if (!this.categories[category]) {\n        this.categories[category] = {};\n      }\n      \n      // Register each element\n      Object.entries(elementsObj).forEach(([id, selector]) => {\n        this.registerElement(id, selector, category);\n      });\n      \n      return true;\n    } catch (error) {\n      console.error(`Error registering elements for category ${category}:`, error);\n      return false;\n    }\n  },\n\n  /**\n   * Register a single UI element\n   * @param {string} id - The element ID \n   * @param {string|HTMLElement} selector - CSS selector or element\n   * @param {string} [category='global'] - Optional category\n   * @returns {HTMLElement|null} - The registered element or null if not found\n   */\n  registerElement(id, selector, category = 'global') {\n    if (!id) {\n      console.error('Invalid ID for registering element');\n      return null;\n    }\n    \n    try {\n      // Create category if it doesn't exist\n      if (!this.categories[category]) {\n        this.categories[category] = {};\n      }\n      \n      // Allow direct element references\n      if (selector instanceof HTMLElement) {\n        this.categories[category][id] = selector;\n        this.elements.set(`${category}.${id}`, selector);\n        // Also register by simple ID for backward compatibility\n        this.elements.set(id, selector);\n        return selector;\n      }\n      \n      // Handle string selectors\n      if (typeof selector === 'string') {\n        const element = document.querySelector(selector);\n        \n        if (!element) {\n          if (this.config.warnOnMissing) {\n            console.warn(`Element not found for selector: ${selector} (${category}.${id})`);\n          }\n          // Store the selector for lazy loading\n          this.categories[category][id] = selector;\n          this.elements.set(`${category}.${id}`, selector);\n          \n          // Also store by simple ID for backward compatibility\n          this.elements.set(id, selector);\n          return null;\n        }\n        \n        // Store the actual element\n        this.categories[category][id] = element;\n        this.elements.set(`${category}.${id}`, element);\n        \n        // Also store by simple ID for backward compatibility\n        this.elements.set(id, element);\n        \n        if (this.config.debug) {\n          console.log(`Registered element ${category}.${id} with selector \"${selector}\"`);\n        }\n        \n        return element;\n      }\n      \n      console.warn(`Invalid selector for ${category}.${id}:`, selector);\n      return null;\n    } catch (error) {\n      console.error(`Error registering element ${id}:`, error);\n      return null;\n    }\n  },\n\n  /**\n   * Get a UI element by ID and optionally category\n   * @param {string} id - Element ID or path in format \"category.id\"\n   * @returns {HTMLElement|null} - The requested element or null if not found\n   */\n  getElement(id) {\n    if (!id) {\n      if (this.config.warnOnMissing) {\n        console.warn('Missing element ID in getElement()');\n      }\n      return null;\n    }\n    \n    try {\n      // Check if id includes category (contains a dot)\n      if (id.includes('.')) {\n        const [category, elementId] = id.split('.');\n        \n        // Validate format\n        if (!category || !elementId) {\n          if (this.config.warnOnMissing) {\n            console.warn(`Invalid element path: ${id}. Expected format: 'category.elementId'`);\n          }\n          return null;\n        }\n        \n        // Check if category exists\n        if (!this.categories[category]) {\n          if (this.config.warnOnMissing) {\n            console.warn(`Category not found: ${category}`);\n          }\n          return null;\n        }\n        \n        // Get the element or its selector\n        const elementOrSelector = this.categories[category][elementId];\n        \n        if (!elementOrSelector) {\n          if (this.config.warnOnMissing) {\n            console.warn(`Element not found: ${category}.${elementId}`);\n          }\n          return null;\n        }\n        \n        // If it's already an element, return it\n        if (elementOrSelector instanceof HTMLElement) {\n          return elementOrSelector;\n        }\n        \n        // Otherwise, it's a selector - find the element\n        const element = document.querySelector(elementOrSelector);\n        \n        if (element) {\n          // Cache the element for future use\n          this.categories[category][elementId] = element;\n          this.elements.set(`${category}.${elementId}`, element);\n          return element;\n        } else {\n          if (this.config.warnOnMissing) {\n            console.warn(`Element not found with selector \"${elementOrSelector}\" for ${category}.${elementId}`);\n          }\n          return null;\n        }\n      } else {\n        // No category - check if it's registered by simple ID\n        const elementOrSelector = this.elements.get(id);\n        \n        if (!elementOrSelector) {\n          // Try direct DOM lookup\n          const element = document.getElementById(id);\n          if (element) {\n            // Cache for future use\n            this.elements.set(id, element);\n            return element;\n          }\n          \n          if (this.config.warnOnMissing) {\n            console.warn(`Element not found with ID: ${id}`);\n          }\n          return null;\n        }\n        \n        // If it's already an element, return it\n        if (elementOrSelector instanceof HTMLElement) {\n          return elementOrSelector;\n        }\n        \n        // Otherwise, it's a selector - find the element\n        const element = document.querySelector(elementOrSelector);\n        \n        if (element) {\n          // Cache the element for future use\n          this.elements.set(id, element);\n          return element;\n        } else {\n          if (this.config.warnOnMissing) {\n            console.warn(`Element not found with selector \"${elementOrSelector}\" for ID ${id}`);\n          }\n          return null;\n        }\n      }\n    } catch (error) {\n      console.error(`Error getting element ${id}:`, error);\n      return null;\n    }\n  },\n\n  /**\n   * Set visibility of an element\n   * @param {string} id - Element identifier\n   * @param {boolean} visible - Whether the element should be visible\n   * @returns {boolean} - Success status\n   */\n  setElementVisibility(id, visible) {\n    const element = this.getElement(id);\n    if (!element) {\n      return false;\n    }\n    \n    try {\n      element.style.display = visible ? '' : 'none';\n      return true;\n    } catch (error) {\n      console.error(`Error setting visibility for element ${id}:`, error);\n      return false;\n    }\n  },\n\n  /**\n   * Update a registered element with a new reference\n   * @param {string} id - Element identifier\n   * @param {HTMLElement} element - New element reference\n   * @returns {boolean} - Success status\n   */\n  updateElement(id, element) {\n    if (!id || !element) {\n      return false;\n    }\n    \n    try {\n      // Check if the ID contains a category\n      if (id.includes('.')) {\n        const [category, elementId] = id.split('.');\n        \n        if (!this.categories[category]) {\n          this.categories[category] = {};\n        }\n        \n        this.categories[category][elementId] = element;\n        this.elements.set(id, element);\n      } else {\n        // Simple ID\n        this.elements.set(id, element);\n        \n        // Also try to update in categories if it exists\n        for (const category in this.categories) {\n          if (id in this.categories[category]) {\n            this.categories[category][id] = element;\n          }\n        }\n      }\n      \n      return true;\n    } catch (error) {\n      console.error(`Error updating element ${id}:`, error);\n      return false;\n    }\n  },\n\n  /**\n   * Reset the registry and clear all elements\n   * @returns {boolean} - Success status\n   */\n  reset() {\n    try {\n      this.elements.clear();\n      // Reset all categories\n      Object.keys(this.categories).forEach(category => {\n        this.categories[category] = {};\n      });\n      return true;\n    } catch (error) {\n      console.error('Error resetting UI registry:', error);\n      return false;\n    }\n  },\n\n  /**\n   * Get UI element registry info\n   * @returns {Object} - Info about the registry\n   */\n  getRegistryInfo() {\n    const totalElements = this.elements.size;\n    const categoryCounts = {};\n    \n    Object.keys(this.categories).forEach(category => {\n      categoryCounts[category] = Object.keys(this.categories[category]).length;\n    });\n    \n    return {\n      totalElements,\n      categories: categoryCounts,\n      config: this.config\n    };\n  },\n\n  /**\n   * Get the UI elements to initialize the registry\n   * @deprecated Use registerCommonElements() instead\n   */\n  getUIElements() {\n    console.warn('getUIElements() is deprecated, use registerCommonElements() instead');\n    this.registerCommonElements();\n    return this.elements;\n  },\n  \n  /**\n   * Get the categories for debugging\n   * @returns {Object} Copy of the categories\n   */\n  getCategories() {\n    return {...this.categories};\n  }\n};\n\n// Export both default and named exports for compatibility\nexport default uiRegistry;\nexport const getElement = uiRegistry.getElement.bind(uiRegistry);\nexport const registerElement = uiRegistry.registerElement.bind(uiRegistry);\nexport const registerElements = uiRegistry.registerElements.bind(uiRegistry);\nexport const setElementVisibility = uiRegistry.setElementVisibility.bind(uiRegistry);\nexport const updateElement = uiRegistry.updateElement.bind(uiRegistry);\nexport const reset = uiRegistry.reset.bind(uiRegistry);\n\n// Additional exports to fix the \"missing named exports\" error in the logs\nexport const initialize = uiRegistry.initialize.bind(uiRegistry);\nexport const autoRegisterElementsWithIds = uiRegistry.autoRegisterElementsWithIds.bind(uiRegistry);\nexport const registerCommonElements = uiRegistry.registerCommonElements.bind(uiRegistry);\nexport const getRegistryInfo = uiRegistry.getRegistryInfo.bind(uiRegistry);\nexport const getUIElements = uiRegistry.getUIElements.bind(uiRegistry);\nexport const getCategories = uiRegistry.getCategories.bind(uiRegistry);","source":"/workspace/modules/static/js/modules/core/uiRegistry.js","title":"uiRegistry.js","language":"en"},{"content":"/**\n * academicApiClient.js\n * Specialized client for interfacing with academic paper APIs\n * Handles fetching papers, citations, and recommendations\n */\n\nimport { showError } from '../core/errorHandler.js';\nimport { getState, setState } from '../core/stateManager.js';\n\nclass AcademicApiClient {\n    constructor() {\n        this.apiEndpoints = {\n            search: '/api/academic/search',\n            multiSource: '/api/academic/multi-source',\n            details: '/api/academic/details',\n            citations: '/api/academic/citations',\n            recommendations: '/api/academic/recommendations',\n            download: '/api/academic/download',\n            extract: '/api/academic/extract',\n            analyze: '/api/academic/analyze',\n            bulk: '/api/academic/bulk/download',\n            health: '/api/academic/health'\n        };\n        \n        this.defaultSource = 'arxiv';\n        this.rateLimitDelay = 1000; // Milliseconds between requests\n        this.lastRequestTime = 0;\n        this.requestQueue = [];\n        this.processingQueue = false;\n        \n        // Cache for paper details\n        this.paperCache = new Map();\n        this.loadCacheFromStorage();\n    }\n\n    /**\n     * Search for academic papers\n     * @param {string} query - Search query\n     * @param {string} source - Source to search (arxiv, semantic, etc.)\n     * @param {number} limit - Maximum number of results\n     * @returns {Promise<Object>} Search results\n     */\n    async searchPapers(query, source = this.defaultSource, limit = 10) {\n        if (!query) {\n            throw new Error('Search query is required');\n        }\n        \n        const url = `${this.apiEndpoints.search}?query=${encodeURIComponent(query)}&source=${source}&limit=${limit}`;\n        return this.makeRequest(url);\n    }\n\n    /**\n     * Search multiple sources simultaneously\n     * @param {string} query - Search query\n     * @param {string[]} sources - List of sources to search\n     * @param {number} limit - Maximum results per source\n     * @returns {Promise<Object>} Combined search results\n     */\n    async searchMultipleSources(query, sources = ['arxiv', 'semantic'], limit = 5) {\n        if (!query) {\n            throw new Error('Search query is required');\n        }\n        \n        const sourcesParam = sources.join(',');\n        const url = `${this.apiEndpoints.multiSource}?query=${encodeURIComponent(query)}&sources=${sourcesParam}&limit=${limit}`;\n        return this.makeRequest(url);\n    }\n\n    /**\n     * Get detailed information about a paper\n     * @param {string} paperId - Unique identifier for the paper\n     * @param {string} source - Source platform (arxiv, semantic, etc.)\n     * @returns {Promise<Object>} Paper details\n     */\n    async getPaperDetails(paperId, source = this.defaultSource) {\n        if (!paperId) {\n            throw new Error('Paper ID is required');\n        }\n        \n        // Check cache first\n        const cacheKey = `${source}:${paperId}`;\n        if (this.paperCache.has(cacheKey)) {\n            return this.paperCache.get(cacheKey);\n        }\n        \n        const url = `${this.apiEndpoints.details}/${paperId}?source=${source}`;\n        const details = await this.makeRequest(url);\n        \n        // Cache the result\n        if (details && !details.error) {\n            this.paperCache.set(cacheKey, details);\n            this.saveCacheToStorage();\n        }\n        \n        return details;\n    }\n\n    /**\n     * Get citation data for a paper\n     * @param {string} paperId - Unique identifier for the paper\n     * @param {string} source - Source platform\n     * @param {number} depth - Depth of citation analysis\n     * @returns {Promise<Object>} Citation analysis\n     */\n    async getPaperCitations(paperId, source = this.defaultSource, depth = 1) {\n        if (!paperId) {\n            throw new Error('Paper ID is required');\n        }\n        \n        const url = `${this.apiEndpoints.citations}/${paperId}?source=${source}&depth=${depth}`;\n        return this.makeRequest(url);\n    }\n\n    /**\n     * Get recommended papers related to a paper\n     * @param {string} paperId - Unique identifier for the paper\n     * @param {string} source - Source platform\n     * @param {number} limit - Maximum number of recommendations\n     * @returns {Promise<Object>} Paper recommendations\n     */\n    async getRecommendations(paperId, source = this.defaultSource, limit = 5) {\n        if (!paperId) {\n            throw new Error('Paper ID is required');\n        }\n        \n        const url = `${this.apiEndpoints.recommendations}/${paperId}?source=${source}&limit=${limit}`;\n        return this.makeRequest(url);\n    }\n\n    /**\n     * Download a paper\n     * @param {string} paperId - Unique identifier for the paper\n     * @param {string} source - Source platform\n     * @param {string} filename - Custom filename (optional)\n     * @returns {Promise<Object>} Download result\n     */\n    async downloadPaper(paperId, source = this.defaultSource, filename = '') {\n        if (!paperId) {\n            throw new Error('Paper ID is required');\n        }\n        \n        const url = `${this.apiEndpoints.download}/${paperId}?source=${source}${filename ? `&filename=${encodeURIComponent(filename)}` : ''}`;\n        return this.makeRequest(url);\n    }\n\n    /**\n     * Download multiple papers in bulk\n     * @param {string[]} paperIds - List of paper IDs\n     * @param {string} source - Source platform\n     * @returns {Promise<Object>} Bulk download result\n     */\n    async downloadMultiplePapers(paperIds, source = this.defaultSource) {\n        if (!paperIds || !paperIds.length) {\n            throw new Error('At least one paper ID is required');\n        }\n        \n        return this.makeRequest(this.apiEndpoints.bulk, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                paper_ids: paperIds,\n                source: source\n            })\n        });\n    }\n\n    /**\n     * Extract papers from a URL\n     * @param {string} url - URL to extract papers from\n     * @param {boolean} download - Whether to download extracted papers\n     * @param {string} outputFolder - Folder to save downloads\n     * @returns {Promise<Object>} Extraction results\n     */\n    async extractPapersFromUrl(url, download = false, outputFolder = '') {\n        if (!url) {\n            throw new Error('URL is required');\n        }\n        \n        const endpoint = `${this.apiEndpoints.extract}?url=${encodeURIComponent(url)}&download=${download}${outputFolder ? `&output_folder=${encodeURIComponent(outputFolder)}` : ''}`;\n        return this.makeRequest(endpoint);\n    }\n\n    /**\n     * Analyze a paper (comprehensive analysis)\n     * @param {string} paperId - Unique identifier for the paper\n     * @param {string} source - Source platform\n     * @returns {Promise<Object>} Comprehensive analysis\n     */\n    async analyzePaper(paperId, source = this.defaultSource) {\n        if (!paperId) {\n            throw new Error('Paper ID is required');\n        }\n        \n        const url = `${this.apiEndpoints.analyze}/${paperId}?source=${source}`;\n        return this.makeRequest(url);\n    }\n\n    /**\n     * Check API health status\n     * @returns {Promise<Object>} Health status\n     */\n    async checkHealth() {\n        return this.makeRequest(this.apiEndpoints.health);\n    }\n\n    /**\n     * Convert a DOI to a paper ID for a specific platform\n     * @param {string} doi - DOI (Digital Object Identifier)\n     * @param {string} targetPlatform - Target platform (arxiv, semantic, etc.)\n     * @returns {Promise<string|null>} Platform-specific ID or null if not found\n     */\n    async convertDoi(doi, targetPlatform = this.defaultSource) {\n        if (!doi) {\n            throw new Error('DOI is required');\n        }\n        \n        // Search for the paper by DOI\n        const results = await this.searchPapers(`doi:${doi}`, targetPlatform);\n        \n        if (results && results.results && results.results.length > 0) {\n            return results.results[0].id;\n        }\n        \n        return null;\n    }\n\n    /**\n     * Make a rate-limited API request\n     * @param {string} url - API endpoint\n     * @param {Object} options - Fetch options\n     * @returns {Promise<Object>} API response\n     */\n    async makeRequest(url, options = {}) {\n        // Add request to queue\n        return new Promise((resolve, reject) => {\n            this.requestQueue.push({\n                url,\n                options,\n                resolve,\n                reject\n            });\n            \n            // Start processing the queue if not already processing\n            if (!this.processingQueue) {\n                this.processQueue();\n            }\n        });\n    }\n\n    /**\n     * Process the request queue with rate limiting\n     */\n    async processQueue() {\n        if (this.requestQueue.length === 0) {\n            this.processingQueue = false;\n            return;\n        }\n        \n        this.processingQueue = true;\n        \n        // Get the next request\n        const request = this.requestQueue.shift();\n        \n        // Apply rate limiting\n        const now = Date.now();\n        const timeToWait = Math.max(0, this.lastRequestTime + this.rateLimitDelay - now);\n        \n        if (timeToWait > 0) {\n            await new Promise(resolve => setTimeout(resolve, timeToWait));\n        }\n        \n        try {\n            // Make the request\n            const response = await fetch(request.url, request.options);\n            \n            if (!response.ok) {\n                // Try to get error details\n                try {\n                    const errorData = await response.json();\n                    throw new Error(errorData.error?.message || `HTTP error ${response.status}: ${response.statusText}`);\n                } catch (jsonError) {\n                    throw new Error(`HTTP error ${response.status}: ${response.statusText}`);\n                }\n            }\n            \n            const data = await response.json();\n            request.resolve(data);\n        } catch (error) {\n            request.reject(error);\n        }\n        \n        // Update last request time\n        this.lastRequestTime = Date.now();\n        \n        // Process next request\n        setTimeout(() => this.processQueue(), 50);\n    }\n\n    /**\n     * Load paper cache from localStorage\n     */\n    loadCacheFromStorage() {\n        try {\n            const cachedData = localStorage.getItem('academicPaperCache');\n            if (cachedData) {\n                const parsed = JSON.parse(cachedData);\n                this.paperCache = new Map(parsed);\n            }\n        } catch (error) {\n            console.error('Failed to load paper cache from storage:', error);\n            this.paperCache = new Map();\n        }\n    }\n\n    /**\n     * Save paper cache to localStorage\n     */\n    saveCacheToStorage() {\n        try {\n            const cacheData = JSON.stringify([...this.paperCache]);\n            localStorage.setItem('academicPaperCache', cacheData);\n        } catch (error) {\n            console.error('Failed to save paper cache to storage:', error);\n        }\n    }\n\n    /**\n     * Clear the paper cache\n     */\n    clearCache() {\n        this.paperCache.clear();\n        localStorage.removeItem('academicPaperCache');\n    }\n}\n\nconst academicApiClient = new AcademicApiClient();\n\nexport default academicApiClient;","source":"/workspace/modules/static/js/modules/features/academicApiClient.js","title":"academicApiClient.js","language":"en"},{"content":"/**\n * Academic Scraper Module\n * \n * Handles academic search, paper discovery, and PDF downloads.\n * Integrates with the Web Scraper for comprehensive document collection.\n * \n * @module academicScraper\n */\n\nimport { showToast, showLoadingSpinner } from '../utils/ui.js';\nimport { on, emit } from '../utils/socketHandler.js';\nimport { getState, setState } from '../core/stateManager.js';\nimport { handleError } from '../core/errorHandler.js';\nimport { getElement, registerElement } from '../core/uiRegistry.js';\nimport { formatBytes, formatDuration } from '../utils/utils.js';\nimport { initialize as initWebScraper } from '../features/webScraper.js';\n\n// Module internal state\nconst state = {\n  initialized: false,\n  searchResults: [],\n  selectedPapers: [],\n  currentQuery: '',\n  currentSource: 'all',\n  isSearching: false\n};\n\n/**\n * Academic Scraper module for paper discovery and PDF downloads\n */\nconst academicScraper = {\n  /**\n   * Initialize the academic scraper module\n   * @returns {boolean} Success status\n   */\n  initialize() {\n    try {\n      console.log(\"Initializing Academic Scraper module...\");\n      \n      if (state.initialized) {\n        console.log(\"Academic Scraper module already initialized\");\n        return true;\n      }\n      \n      // Register UI elements\n      this.registerUIElements();\n      \n      // Set up event listeners\n      this.registerEvents();\n      \n      // Mark as initialized\n      state.initialized = true;\n      console.log(\"Academic Scraper module initialized successfully\");\n      \n      return true;\n    } catch (error) {\n      this.handleError(error, \"Error initializing Academic Scraper module\");\n      return false;\n    }\n  },\n\n  /**\n   * Register UI elements with the uiRegistry\n   */\n  registerUIElements() {\n    try {\n      // Academic search elements\n      registerElement('academic.searchInput', document.getElementById('academic-search-input'));\n      registerElement('academic.sources', document.getElementById('academic-sources'));\n      registerElement('academic.searchBtn', document.getElementById('academic-search-btn'));\n      registerElement('academic.results', document.getElementById('academic-results'));\n      registerElement('academic.resultsContainer', document.getElementById('academic-results-container'));\n      registerElement('academic.addSelectedBtn', document.getElementById('add-selected-papers'));\n      \n      // Scraper elements that we need to interface with\n      registerElement('scraper.urlsContainer', document.getElementById('scraper-urls-container'));\n      registerElement('scraper.pdfInfoSection', document.getElementById('pdf-info-section'));\n    } catch (error) {\n      this.handleError(error, \"Error registering UI elements for Academic Scraper\");\n    }\n  },\n\n  /**\n   * Register event listeners\n   */\n  registerEvents() {\n    try {\n      // Search button\n      const searchBtn = getElement('academic.searchBtn');\n      if (searchBtn) {\n        searchBtn.addEventListener('click', this.performSearch.bind(this));\n      }\n      \n      // Search input (for enter key)\n      const searchInput = getElement('academic.searchInput');\n      if (searchInput) {\n        searchInput.addEventListener('keypress', event => {\n          if (event.key === 'Enter') {\n            event.preventDefault();\n            this.performSearch();\n          }\n        });\n      }\n      \n      // Add selected papers button\n      const addSelectedBtn = getElement('academic.addSelectedBtn');\n      if (addSelectedBtn) {\n        addSelectedBtn.addEventListener('click', this.addSelectedPapers.bind(this));\n      }\n    } catch (error) {\n      this.handleError(error, \"Error registering events for Academic Scraper\");\n    }\n  },\n\n  /**\n   * Perform academic search\n   */\n  performSearch() {\n    try {\n      const searchInput = getElement('academic.searchInput');\n      const sourcesSelect = getElement('academic.sources');\n      const resultsContainer = getElement('academic.resultsContainer');\n      const resultsArea = getElement('academic.results');\n      \n      if (!searchInput || !sourcesSelect || !resultsContainer) {\n        throw new Error(\"Required UI elements not found\");\n      }\n      \n      const query = searchInput.value.trim();\n      const source = sourcesSelect.value;\n      \n      if (!query) {\n        showToast('Error', 'Please enter a search query', 'error');\n        return;\n      }\n      \n      // Update state\n      state.currentQuery = query;\n      state.currentSource = source;\n      state.isSearching = true;\n      \n      // Show loading indicator\n      resultsArea.classList.remove('d-none');\n      resultsContainer.innerHTML = `\n        <div class=\"text-center py-4\">\n          <div class=\"spinner-border text-primary\" role=\"status\">\n            <span class=\"visually-hidden\">Loading...</span>\n          </div>\n          <p class=\"mt-2\">Searching academic sources...</p>\n        </div>\n      `;\n      \n      // Determine API endpoint\n      let apiEndpoint;\n      let queryParams;\n      \n      if (source === 'all') {\n        apiEndpoint = '/api/academic/multi-source';\n        queryParams = new URLSearchParams({\n          query: query,\n          sources: 'arxiv,semantic,openalex',\n          limit: 10\n        });\n      } else {\n        apiEndpoint = '/api/academic/search';\n        queryParams = new URLSearchParams({\n          query: query,\n          source: source,\n          limit: 10\n        });\n      }\n      \n      // Make the API call\n      fetch(`${apiEndpoint}?${queryParams.toString()}`)\n        .then(response => {\n          if (!response.ok) {\n            throw new Error(`Server error: ${response.status}`);\n          }\n          return response.json();\n        })\n        .then(data => {\n          // Update state\n          state.searchResults = data.results || [];\n          state.isSearching = false;\n          \n          // Display results\n          this.displaySearchResults(data.results || []);\n        })\n        .catch(error => {\n          state.isSearching = false;\n          this.handleError(error, \"Error performing academic search\");\n          \n          // Show error in results area\n          resultsContainer.innerHTML = `\n            <div class=\"alert alert-danger\">\n              <i class=\"fas fa-exclamation-triangle me-2\"></i>\n              Error: ${error.message}\n            </div>\n          `;\n          \n          showToast('Error', `Search failed: ${error.message}`, 'error');\n        });\n    } catch (error) {\n      state.isSearching = false;\n      this.handleError(error, \"Error performing academic search\");\n      showToast('Error', `Search failed: ${error.message}`, 'error');\n    }\n  },\n\n/**\n   * Display academic search results\n   * @param {Array} results Search results\n   */\ndisplaySearchResults(results) {\n  try {\n    const resultsContainer = getElement('academic.resultsContainer');\n    if (!resultsContainer) return;\n    \n    if (results.length === 0) {\n      resultsContainer.innerHTML = `\n        <div class=\"alert alert-warning\">\n          <i class=\"fas fa-exclamation-triangle me-2\"></i>\n          No results found. Try a different search term or source.\n        </div>\n      `;\n      return;\n    }\n    \n    // Clear previous results\n    resultsContainer.innerHTML = '';\n    \n    // Add each result to the container\n    results.forEach((paper, index) => {\n      // Create new result item\n      const resultItem = document.createElement('div');\n      resultItem.className = 'paper-result-item list-group-item list-group-item-action';\n      resultItem.dataset.paperId = paper.id;\n      resultItem.dataset.paperUrl = paper.pdf_url || paper.url || '';\n      resultItem.dataset.paperTitle = paper.title || '';\n      \n      // Determine source badge\n      let sourceBadge = '';\n      if (paper.source === 'arxiv') {\n        sourceBadge = '<span class=\"academic-source-badge academic-source-arxiv me-2\">arXiv</span>';\n      } else if (paper.source === 'semantic') {\n        sourceBadge = '<span class=\"academic-source-badge academic-source-semantic me-2\">Semantic Scholar</span>';\n      } else if (paper.source === 'openalex') {\n        sourceBadge = '<span class=\"academic-source-badge academic-source-openalex me-2\">OpenAlex</span>';\n      }\n      \n      // Format authors list\n      const authors = Array.isArray(paper.authors) ? paper.authors.join(', ') : (paper.authors || 'Unknown authors');\n      \n      // Build HTML content\n      resultItem.innerHTML = `\n        <div class=\"d-flex align-items-start\">\n          <div class=\"form-check mt-1 me-2\">\n            <input class=\"form-check-input paper-select\" type=\"checkbox\" id=\"paper-${index}\">\n          </div>\n          <div class=\"flex-grow-1\">\n            <div class=\"d-flex justify-content-between\">\n              <h6 class=\"mb-1\">${paper.title || 'Untitled Paper'}</h6>\n            </div>\n            <div class=\"mb-1\">\n              ${sourceBadge}\n              <small class=\"text-muted\">${authors}</small>\n            </div>\n            <p class=\"mb-1 small\">${paper.abstract || 'No abstract available'}</p>\n            <div class=\"mt-2\">\n              ${paper.pdf_url ? \n                `<span class=\"badge bg-light text-dark me-2\">\n                  <i class=\"fas fa-file-pdf me-1 text-danger\"></i> PDF Available\n                </span>` : ''}\n              <span class=\"badge bg-light text-dark\">\n                <i class=\"fas fa-calendar-alt me-1\"></i> ${paper.publication_date || paper.date || 'N/A'}\n              </span>\n            </div>\n          </div>\n        </div>\n      `;\n      \n      // Add click handler to toggle selection\n      resultItem.addEventListener('click', function(e) {\n        // Don't toggle if clicking on the checkbox directly\n        if (e.target.type !== 'checkbox') {\n          const checkbox = this.querySelector('.paper-select');\n          checkbox.checked = !checkbox.checked;\n        }\n        \n        // Toggle selected class\n        this.classList.toggle('selected', this.querySelector('.paper-select').checked);\n      });\n      \n      // Add to container\n      resultsContainer.appendChild(resultItem);\n    });\n  } catch (error) {\n    this.handleError(error, \"Error displaying search results\");\n  }\n},\n\n/**\n * Add selected papers to the URL list\n */\naddSelectedPapers() {\n  try {\n    const resultsContainer = getElement('academic.resultsContainer');\n    const urlsContainer = getElement('scraper.urlsContainer');\n    const pdfInfoSection = getElement('scraper.pdfInfoSection');\n    \n    if (!resultsContainer || !urlsContainer) {\n      throw new Error(\"Required UI elements not found\");\n    }\n    \n    // Get selected papers\n    const selectedCheckboxes = resultsContainer.querySelectorAll('.paper-select:checked');\n    \n    if (selectedCheckboxes.length === 0) {\n      showToast('Warning', 'Please select at least one paper', 'warning');\n      return;\n    }\n    \n    // Add each selected paper as a URL entry\n    selectedCheckboxes.forEach(checkbox => {\n      const paperItem = checkbox.closest('.paper-result-item');\n      const paperUrl = paperItem.dataset.paperUrl;\n      const paperTitle = paperItem.dataset.paperTitle;\n      \n      if (paperUrl) {\n        // Add the URL to the scraper with PDF setting\n        this.addScraperUrlWithData(paperUrl, 'pdf', paperTitle);\n      }\n    });\n    \n    // Show confirmation\n    showToast('Success', `Added ${selectedCheckboxes.length} papers to scraping list`, 'success');\n    \n    // Show PDF info section\n    if (pdfInfoSection) {\n      pdfInfoSection.classList.remove('d-none');\n    }\n  } catch (error) {\n    this.handleError(error, \"Error adding selected papers\");\n    showToast('Error', `Failed to add papers: ${error.message}`, 'error');\n  }\n},\n\n/**\n * Add a URL to the scraper with specific settings\n * @param {string} url URL to add\n * @param {string} setting Setting to use ('pdf', 'full', etc.)\n * @param {string} title Optional title for tooltip\n */\naddScraperUrlWithData(url, setting, title = '') {\n  try {\n    const urlsContainer = getElement('scraper.urlsContainer');\n    if (!urlsContainer) return;\n    \n    // Create container\n    const container = document.createElement('div');\n    container.classList.add('input-group', 'mb-2');\n    \n    // Build HTML\n    container.innerHTML = `\n      <input type=\"url\" class=\"form-control scraper-url\" placeholder=\"Enter Website URL\" value=\"${url}\" required />\n      <select class=\"form-select scraper-settings\" style=\"max-width: 160px;\">\n        <option value=\"full\">Full Text</option>\n        <option value=\"metadata\">Metadata Only</option>\n        <option value=\"title\">Title Only</option>\n        <option value=\"keyword\">Keyword Search</option>\n        <option value=\"pdf\">PDF Download</option>\n      </select>\n      <input type=\"text\" class=\"form-control scraper-keyword\" placeholder=\"Keyword (optional)\" style=\"display:none;\" />\n      <button type=\"button\" class=\"btn btn-outline-danger remove-url\">\n        <i class=\"fas fa-trash\"></i>\n      </button>\n    `;\n    \n    // Set the settings dropdown to the specified value\n    const settingsSelect = container.querySelector('.scraper-settings');\n    settingsSelect.value = setting;\n    \n    // Add tooltip with paper title if provided\n    if (title) {\n      const urlInput = container.querySelector('.scraper-url');\n      urlInput.setAttribute('title', title);\n    }\n    \n    // Add event listeners\n    const removeBtn = container.querySelector('.remove-url');\n    removeBtn.addEventListener('click', () => {\n      urlsContainer.removeChild(container);\n      this.updatePdfInfoSection();\n    });\n    \n    const settings = container.querySelector('.scraper-settings');\n    settings.addEventListener('change', this.handleScraperSettingsChange.bind(this));\n    \n    // Add to container\n    urlsContainer.appendChild(container);\n    \n    // Update PDF info section visibility\n    this.updatePdfInfoSection();\n  } catch (error) {\n    this.handleError(error, \"Error adding URL to scraper\");\n  }\n},\n\n/**\n * Handle scraper settings change\n * @param {Event} event Change event\n */\nhandleScraperSettingsChange(event) {\n  try {\n    if (!event.target.classList.contains('scraper-settings')) return;\n    \n    const parentGroup = event.target.closest('.input-group');\n    const keywordInput = parentGroup.querySelector('.scraper-keyword');\n    \n    if (event.target.value === 'keyword') {\n      keywordInput.style.display = '';\n    } else {\n      keywordInput.style.display = 'none';\n      keywordInput.value = '';\n    }\n    \n    // Update PDF info section visibility\n    this.updatePdfInfoSection();\n  } catch (error) {\n    this.handleError(error, \"Error handling settings change\");\n  }\n},\n\n/**\n * Update PDF info section visibility\n */\nupdatePdfInfoSection() {\n  try {\n    const pdfInfoSection = getElement('scraper.pdfInfoSection');\n    if (!pdfInfoSection) return;\n    \n    // Get all settings dropdowns\n    const scraperSettings = document.querySelectorAll('.scraper-settings');\n    \n    // Check if any are set to 'pdf'\n    const hasPdfSelected = Array.from(scraperSettings).some(select => select.value === 'pdf');\n    \n    // Show/hide the section\n    if (hasPdfSelected) {\n      pdfInfoSection.classList.remove('d-none');\n    } else {\n      pdfInfoSection.classList.add('d-none');\n    }\n  } catch (error) {\n    this.handleError(error, \"Error updating PDF info section\");\n  }\n},\n\n/**\n * Handle error consistently\n * @param {Error} error Error object\n * @param {string} context Error context\n */\nhandleError(error, context = 'Academic Scraper Error') {\n  console.error(`[Academic Scraper] ${context}:`, error);\n  \n  // Use error handler if available\n  if (typeof handleError === 'function') {\n    handleError(error, 'ACADEMIC_SCRAPER', false, { context });\n  }\n  \n  // Show error message in UI\n  showToast('Error', error.message || 'An unknown error occurred', 'error');\n}\n};\n\n// Export the module with both default and named exports\nexport default academicScraper;\n\n// Named exports (bound to the academicScraper object)\nexport const initialize = academicScraper.initialize.bind(academicScraper);\nexport const performSearch = academicScraper.performSearch.bind(academicScraper);\nexport const displaySearchResults = academicScraper.displaySearchResults.bind(academicScraper);\nexport const addSelectedPapers = academicScraper.addSelectedPapers.bind(academicScraper);\nexport const addScraperUrlWithData = academicScraper.addScraperUrlWithData.bind(academicScraper);\nexport const handleScraperSettingsChange = academicScraper.handleScraperSettingsChange.bind(academicScraper);\nexport const updatePdfInfoSection = academicScraper.updatePdfInfoSection.bind(academicScraper);","source":"/workspace/modules/static/js/modules/features/academicScraper.js","title":"academicScraper.js","language":"en"},{"content":"/**\n * Drag and Drop Handler Module\n * \n * Handles drag and drop file operations\n * Extracted from index.html to prevent conflicts with the modular system\n */\n\nimport { formatBytes } from '../utils/utils.js';\nimport { showToast } from '../utils/ui.js';\nimport { getElement } from '../utils/domUtils.js';\n\nclass DragDropHandler {\n  constructor() {\n    this.dropZones = new Map();\n    this.initialized = false;\n    this.activeDropZone = null;\n  }\n\n  /**\n   * Initialize drag and drop handlers\n   */\n  initialize() {\n    if (this.initialized) {\n      console.warn('Drag and drop handler already initialized');\n      return;\n    }\n\n    this.setupDefaultDropZones();\n    this.initialized = true;\n    console.log('Drag and drop handler initialized');\n  }\n\n  /**\n   * Setup default drop zones\n   */\n  setupDefaultDropZones() {\n    // Main file drop zone\n    const mainDropZone = getElement('drop-zone');\n    if (mainDropZone) {\n      this.registerDropZone('main', mainDropZone, {\n        accept: '*/*',\n        multiple: true,\n        onDrop: (files) => this.handleMainDropZone(files)\n      });\n    }\n\n    // Register other drop zones as needed\n    this.findAndRegisterDropZones();\n  }\n\n  /**\n   * Find and register all elements with drop-zone class\n   */\n  findAndRegisterDropZones() {\n    const dropZones = document.querySelectorAll('.drop-zone[data-drop-target]');\n    dropZones.forEach(zone => {\n      const target = zone.getAttribute('data-drop-target');\n      if (target && !this.dropZones.has(target)) {\n        this.registerDropZone(target, zone);\n      }\n    });\n  }\n\n  /**\n   * Register a drop zone\n   * @param {string} id - Unique identifier for the drop zone\n   * @param {HTMLElement} element - The drop zone element\n   * @param {Object} options - Configuration options\n   */\n  registerDropZone(id, element, options = {}) {\n    if (!element) return;\n\n    const config = {\n      accept: options.accept || '*/*',\n      multiple: options.multiple !== false,\n      maxSize: options.maxSize || 100 * 1024 * 1024, // 100MB default\n      onDrop: options.onDrop || null,\n      onError: options.onError || null,\n      validateFile: options.validateFile || null\n    };\n\n    // Prevent default drag behaviors\n    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {\n      element.addEventListener(eventName, this.preventDefaults, false);\n    });\n\n    // Highlight drop zone when item is dragged over it\n    ['dragenter', 'dragover'].forEach(eventName => {\n      element.addEventListener(eventName, (e) => this.handleDragEnter(e, id), false);\n    });\n\n    ['dragleave', 'drop'].forEach(eventName => {\n      element.addEventListener(eventName, (e) => this.handleDragLeave(e, id), false);\n    });\n\n    // Handle dropped files\n    element.addEventListener('drop', (e) => this.handleDrop(e, id), false);\n\n    // Store configuration\n    this.dropZones.set(id, {\n      element,\n      config,\n      isActive: false\n    });\n\n    console.log(`Drop zone registered: ${id}`);\n  }\n\n  /**\n   * Prevent default drag and drop behavior\n   * @param {Event} e - The event\n   */\n  preventDefaults(e) {\n    e.preventDefault();\n    e.stopPropagation();\n  }\n\n  /**\n   * Handle drag enter\n   * @param {DragEvent} e - The drag event\n   * @param {string} zoneId - The drop zone ID\n   */\n  handleDragEnter(e, zoneId) {\n    const zone = this.dropZones.get(zoneId);\n    if (!zone) return;\n\n    zone.isActive = true;\n    zone.element.classList.add('drag-highlight', 'drag-over');\n    this.activeDropZone = zoneId;\n\n    // Add visual feedback\n    const icon = zone.element.querySelector('.drop-zone-icon');\n    if (icon) {\n      icon.classList.add('pulse');\n    }\n  }\n\n  /**\n   * Handle drag leave\n   * @param {DragEvent} e - The drag event\n   * @param {string} zoneId - The drop zone ID\n   */\n  handleDragLeave(e, zoneId) {\n    const zone = this.dropZones.get(zoneId);\n    if (!zone) return;\n\n    // Check if we're still within the drop zone\n    if (e.target === zone.element || zone.element.contains(e.target)) {\n      const rect = zone.element.getBoundingClientRect();\n      if (e.clientX >= rect.left && e.clientX <= rect.right &&\n          e.clientY >= rect.top && e.clientY <= rect.bottom) {\n        return; // Still within bounds\n      }\n    }\n\n    zone.isActive = false;\n    zone.element.classList.remove('drag-highlight', 'drag-over');\n    \n    const icon = zone.element.querySelector('.drop-zone-icon');\n    if (icon) {\n      icon.classList.remove('pulse');\n    }\n\n    if (this.activeDropZone === zoneId) {\n      this.activeDropZone = null;\n    }\n  }\n\n  /**\n   * Handle file drop\n   * @param {DragEvent} e - The drag event\n   * @param {string} zoneId - The drop zone ID\n   */\n  async handleDrop(e, zoneId) {\n    const zone = this.dropZones.get(zoneId);\n    if (!zone) return;\n\n    // Clean up visual state\n    zone.isActive = false;\n    zone.element.classList.remove('drag-highlight', 'drag-over');\n    \n    const icon = zone.element.querySelector('.drop-zone-icon');\n    if (icon) {\n      icon.classList.remove('pulse');\n    }\n\n    // Get dropped files\n    const dt = e.dataTransfer;\n    const files = Array.from(dt.files);\n\n    if (files.length === 0) {\n      showToast('No Files', 'No files were dropped', 'warning');\n      return;\n    }\n\n    // Validate files\n    const validFiles = [];\n    const errors = [];\n\n    for (const file of files) {\n      const validation = this.validateFile(file, zone.config);\n      if (validation.valid) {\n        validFiles.push(file);\n      } else {\n        errors.push(`${file.name}: ${validation.error}`);\n      }\n    }\n\n    // Show errors if any\n    if (errors.length > 0) {\n      showToast('File Validation Errors', errors.join('<br>'), 'error', 5000);\n    }\n\n    // Process valid files\n    if (validFiles.length > 0) {\n      if (zone.config.onDrop) {\n        try {\n          await zone.config.onDrop(validFiles, e);\n        } catch (error) {\n          console.error('Error in drop handler:', error);\n          if (zone.config.onError) {\n            zone.config.onError(error);\n          } else {\n            showToast('Error', 'Failed to process dropped files', 'error');\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Validate a file\n   * @param {File} file - The file to validate\n   * @param {Object} config - The drop zone configuration\n   * @returns {Object} - Validation result\n   */\n  validateFile(file, config) {\n    // Check file size\n    if (config.maxSize && file.size > config.maxSize) {\n      return {\n        valid: false,\n        error: `File too large (max ${formatBytes(config.maxSize)})`\n      };\n    }\n\n    // Check file type\n    if (config.accept && config.accept !== '*/*') {\n      const acceptedTypes = config.accept.split(',').map(t => t.trim());\n      const fileType = file.type || '';\n      const fileExt = '.' + file.name.split('.').pop().toLowerCase();\n      \n      const isAccepted = acceptedTypes.some(accepted => {\n        if (accepted.endsWith('/*')) {\n          // Check MIME type category (e.g., image/*)\n          const category = accepted.split('/')[0];\n          return fileType.startsWith(category + '/');\n        } else if (accepted.startsWith('.')) {\n          // Check file extension\n          return accepted === fileExt;\n        } else {\n          // Check exact MIME type\n          return accepted === fileType;\n        }\n      });\n\n      if (!isAccepted) {\n        return {\n          valid: false,\n          error: `File type not accepted (accepted: ${config.accept})`\n        };\n      }\n    }\n\n    // Custom validation\n    if (config.validateFile) {\n      const customResult = config.validateFile(file);\n      if (customResult !== true) {\n        return {\n          valid: false,\n          error: customResult || 'File validation failed'\n        };\n      }\n    }\n\n    return { valid: true };\n  }\n\n  /**\n   * Handle main drop zone files\n   * @param {File[]} files - The dropped files\n   */\n  handleMainDropZone(files) {\n    const fileInput = getElement('folder-input');\n    const inputDirField = getElement('input-dir');\n    const selectedFilesInfo = getElement('selected-files-info');\n\n    if (!fileInput) {\n      console.error('File input not found');\n      return;\n    }\n\n    // Try to find a common directory path\n    if (inputDirField && files.length > 0) {\n      const paths = files.map(file => file.name);\n      const folderName = this.findCommonDirectory(paths) || 'Selected Files';\n      inputDirField.value = folderName;\n    }\n\n    // Show selected files info\n    if (selectedFilesInfo) {\n      const totalSize = files.reduce((sum, file) => sum + file.size, 0);\n      const filesByType = this.groupFilesByType(files);\n      \n      let infoHtml = `\n        <div class=\"alert alert-info mt-3\">\n          <div class=\"d-flex justify-content-between align-items-center mb-2\">\n            <strong>${files.length} file${files.length > 1 ? 's' : ''} selected</strong>\n            <span class=\"badge bg-primary\">${formatBytes(totalSize)}</span>\n          </div>\n      `;\n\n      if (Object.keys(filesByType).length > 1) {\n        infoHtml += '<div class=\"small mt-2\">File types: ';\n        Object.entries(filesByType).forEach(([type, count]) => {\n          infoHtml += `<span class=\"badge bg-secondary me-1\">${type} (${count})</span>`;\n        });\n        infoHtml += '</div>';\n      }\n\n      infoHtml += '</div>';\n      selectedFilesInfo.innerHTML = infoHtml;\n    }\n\n    // Trigger file input change event\n    if (fileInput.files !== files) {\n      // Create a new FileList-like object\n      const dt = new DataTransfer();\n      files.forEach(file => dt.items.add(file));\n      fileInput.files = dt.files;\n      \n      // Trigger change event\n      fileInput.dispatchEvent(new Event('change', { bubbles: true }));\n    }\n\n    showToast('Files Dropped', `${files.length} file${files.length > 1 ? 's' : ''} ready to process`, 'success');\n  }\n\n  /**\n   * Find common directory from file paths\n   * @param {string[]} paths - Array of file paths\n   * @returns {string} - Common directory or null\n   */\n  findCommonDirectory(paths) {\n    if (paths.length === 0) return null;\n    if (paths.length === 1) {\n      const parts = paths[0].split('/');\n      return parts.length > 1 ? parts[0] : null;\n    }\n\n    // Find common prefix\n    const splitPaths = paths.map(p => p.split('/'));\n    const minLength = Math.min(...splitPaths.map(p => p.length));\n    \n    let commonParts = [];\n    for (let i = 0; i < minLength; i++) {\n      const part = splitPaths[0][i];\n      if (splitPaths.every(p => p[i] === part)) {\n        commonParts.push(part);\n      } else {\n        break;\n      }\n    }\n\n    return commonParts.length > 0 ? commonParts.join('/') : null;\n  }\n\n  /**\n   * Group files by type\n   * @param {File[]} files - Array of files\n   * @returns {Object} - Files grouped by type\n   */\n  groupFilesByType(files) {\n    const groups = {};\n    \n    files.forEach(file => {\n      const ext = file.name.split('.').pop().toLowerCase();\n      groups[ext] = (groups[ext] || 0) + 1;\n    });\n\n    return groups;\n  }\n\n  /**\n   * Get drop zone by ID\n   * @param {string} id - Drop zone ID\n   * @returns {Object} - Drop zone configuration\n   */\n  getDropZone(id) {\n    return this.dropZones.get(id);\n  }\n\n  /**\n   * Remove drop zone\n   * @param {string} id - Drop zone ID\n   */\n  removeDropZone(id) {\n    const zone = this.dropZones.get(id);\n    if (zone) {\n      // Remove event listeners\n      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {\n        zone.element.removeEventListener(eventName, this.preventDefaults);\n      });\n      \n      this.dropZones.delete(id);\n      console.log(`Drop zone removed: ${id}`);\n    }\n  }\n}\n\n// Create and export singleton instance\nconst dragDropHandler = new DragDropHandler();\nexport default dragDropHandler;\n\n// Auto-initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => dragDropHandler.initialize());\n} else {\n  dragDropHandler.initialize();\n}","source":"/workspace/modules/static/js/modules/features/dragDropHandler.js","title":"dragDropHandler.js","language":"en"},{"content":"/**\n * Academic Search Module - Optimized Blueprint Implementation v4.0\n * \n * Advanced academic paper search, retrieval, and citation analysis module\n * optimized for the new Blueprint architecture. Features configuration-driven\n * architecture, enhanced error handling, and comprehensive integration.\n * \n * NEW v4.0 Features:\n * - Configuration-driven architecture using centralized endpoints\n * - Enhanced 4-method notification system (Toast + Console + System + Error)\n * - Backend connectivity testing with health checks\n * - ES6 module imports with centralized configuration\n * - Optimized for Blueprint architecture integration\n * - Enhanced progressHandler v4.0 integration\n * - Advanced error handling and recovery mechanisms\n * \n * Legacy Features (Enhanced):\n * - Search across multiple academic sources (arXiv, Semantic Scholar, etc.)\n * - Paper details and metadata retrieval\n * - PDF download and management\n * - Citation network visualization\n * - Related paper recommendations\n * \n * @module features/academicSearch\n * @version 4.0.0 - Blueprint Architecture Optimization\n */\n\n// Import dependencies from centralized config\nimport { API_ENDPOINTS, BLUEPRINT_ROUTES } from '../config/endpoints.js';\nimport { CONSTANTS, API_CONFIG, SOCKET_CONFIG } from '../config/constants.js';\nimport { SOCKET_EVENTS, TASK_EVENTS } from '../config/socketEvents.js';\n\n// Import from core modules with proper destructuring\nimport { registerEvents } from '../core/eventManager.js';\nimport { registerElement } from '../core/uiRegistry.js';\nimport { showErrorNotification, showSuccess } from '../core/errorHandler.js';\nimport { setState } from '../core/stateManager.js';\n\n// Import DOM utilities from domUtils - correctly pull these in from a single source\nimport { getElement } from '../utils/domUtils.js';\n\n// Import from utility modules - remove unused imports\nimport { showLoadingSpinner, showToast } from '../utils/ui.js';\nimport { generateId } from '../utils/utils.js';\n\n// Import progress handler utilities - only include what we actually use\nimport { trackProgress } from '../utils/progressHandler.js';\n\n// Configuration shorthand\nconst ACADEMIC_SEARCH_CONFIG = {\n  endpoints: API_ENDPOINTS.ACADEMIC_SEARCH,\n  blueprint: BLUEPRINT_ROUTES.academic_search,\n  constants: CONSTANTS.ACADEMIC_SEARCH || {},\n  api: API_CONFIG,\n  socket: SOCKET_CONFIG\n};\n\n/**\n * Academic Search class for handling academic search and paper management\n */\nclass AcademicSearch {\n    /**\n     * Create a new AcademicSearch instance\n     */\n    constructor() {\n        // Initialize state\n        this.searchResults = [];\n        this.currentPaperDetails = null;\n        this.downloadQueue = new Map();\n        \n        // Track active operations\n        this.activeSearches = new Map();\n        this.activePaperRequests = new Map();\n        \n        // Internal state for the module\n        this.state = {\n            initialized: false,\n            lastSearch: null,\n            now: () => Date.now(),\n            currentSpinner: null, // Track current loading spinner\n            from: (timestamp) => new Date(timestamp),\n            backendConnected: false,\n            lastHealthCheck: null\n        };\n        \n        // Initialize the module\n        this.initialize();\n    }\n    \n    /**\n     * Enhanced notification system with 4-method delivery\n     * @param {string} message - Notification message\n     * @param {string} type - Type of notification (info, success, warning, error)\n     * @param {string} title - Notification title\n     */\n    showNotification(message, type = 'info', title = 'Academic Search') {\n        // Method 1: Toast notifications\n        if (window.NeuroGen?.ui?.showToast) {\n            window.NeuroGen.ui.showToast(title, message, type);\n        }\n        \n        // Method 2: Console logging with styling\n        const styles = {\n            error: 'color: #dc3545; font-weight: bold;',\n            warning: 'color: #fd7e14; font-weight: bold;',\n            success: 'color: #198754; font-weight: bold;',\n            info: 'color: #0d6efd;'\n        };\n        console.log(`%c[${title}] ${message}`, styles[type] || styles.info);\n        \n        // Method 3: System notification (if available)\n        if (window.NeuroGen?.notificationHandler) {\n            window.NeuroGen.notificationHandler.show({\n                title, message, type, module: 'academicSearch'\n            });\n        }\n        \n        // Method 4: Error reporting to centralized handler\n        if (type === 'error' && window.NeuroGen?.errorHandler) {\n            window.NeuroGen.errorHandler.logError({\n                module: 'academicSearch', message, severity: type\n            });\n        }\n    }\n\n    /**\n     * Test backend connectivity for academic search\n     * @returns {Promise<Object>} Backend connectivity status\n     */\n    async testBackendConnectivity() {\n        const results = {\n            overall: false,\n            details: {},\n            timestamp: new Date().toISOString(),\n            errors: []\n        };\n\n        try {\n            // Test academic search health endpoint\n            const healthResponse = await fetch(ACADEMIC_SEARCH_CONFIG.endpoints?.HEALTH || '/api/academic/health', {\n                method: 'GET',\n                headers: { 'Content-Type': 'application/json' }\n            });\n\n            results.details.health = {\n                status: healthResponse.status,\n                ok: healthResponse.ok,\n                endpoint: ACADEMIC_SEARCH_CONFIG.endpoints?.HEALTH || '/api/academic/health'\n            };\n\n            if (healthResponse.ok) {\n                // Test academic search endpoint with a simple query\n                const testResponse = await fetch(`${ACADEMIC_SEARCH_CONFIG.endpoints?.SEARCH || '/api/academic/search'}?query=test`, {\n                    method: 'GET',\n                    headers: { 'Content-Type': 'application/json' }\n                });\n\n                results.details.search = {\n                    status: testResponse.status,\n                    ok: testResponse.ok,\n                    endpoint: ACADEMIC_SEARCH_CONFIG.endpoints?.SEARCH || '/api/academic/search'\n                };\n\n                if (testResponse.ok || testResponse.status === 400) { // 400 might be expected for empty query\n                    results.overall = true;\n                    this.state.backendConnected = true;\n                    this.state.lastHealthCheck = new Date();\n                    this.showNotification('Backend connectivity verified', 'success', 'Academic Search');\n                }\n            }\n\n            if (!results.overall) {\n                throw new Error(`Health endpoint returned ${healthResponse.status}`);\n            }\n\n        } catch (error) {\n            results.errors.push({\n                endpoint: ACADEMIC_SEARCH_CONFIG.endpoints?.HEALTH || '/api/academic/health',\n                error: error.message\n            });\n            this.state.backendConnected = false;\n            this.showNotification(`Backend connectivity failed: ${error.message}`, 'error', 'Academic Search');\n        }\n\n        return results;\n    }\n\n    /**\n     * Get academic search health status\n     * @returns {Object} Health status information\n     */\n    getHealthStatus() {\n        return {\n            module: 'academicSearch',\n            version: '4.0.0',\n            status: this.state.initialized ? 'healthy' : 'initializing',\n            features: {\n                configurationDriven: true,\n                enhancedNotifications: true,\n                backendConnectivity: true,\n                paperSearch: true,\n                pdfDownloading: true,\n                citationAnalysis: true\n            },\n            configuration: {\n                endpoints: ACADEMIC_SEARCH_CONFIG.endpoints,\n                searchSources: ACADEMIC_SEARCH_CONFIG.constants.SEARCH_SOURCES?.length || 0,\n                maxResults: ACADEMIC_SEARCH_CONFIG.constants.MAX_RESULTS || 50\n            },\n            state: {\n                initialized: this.state.initialized,\n                searchResults: this.searchResults.length,\n                downloadQueue: this.downloadQueue.size,\n                activeSearches: this.activeSearches.size,\n                backendConnected: this.state.backendConnected,\n                lastHealthCheck: this.state.lastHealthCheck\n            }\n        };\n    }\n    \n    /**\n     * Show loading spinner (internal helper)\n     * @param {string} message - Loading message\n     */\n    showLoading(message) {\n        // Hide any existing spinner first\n        this.hideLoading();\n        // Create new spinner and store reference\n        this.state.currentSpinner = showLoadingSpinner(message);\n    }\n    \n    /**\n     * Hide current loading spinner (internal helper)\n     */\n    hideLoading() {\n        if (this.state.currentSpinner && this.state.currentSpinner.hide) {\n            this.state.currentSpinner.hide();\n            this.state.currentSpinner = null;\n        }\n    }\n\n    /**\n     * Initialize the academic search module with enhanced Blueprint architecture integration\n     * @returns {Promise<boolean>} Success status\n     */\n    async initialize() {\n        try {\n            this.showNotification('Initializing Academic Search v4.0', 'info', 'Academic Search');\n            \n            // Test backend connectivity on initialization\n            await this.testBackendConnectivity();\n            \n            this.registerUIElements();\n            this.setupEventListeners();\n            \n            // Load previous state if available\n            this.loadSavedState();\n            \n            this.state.initialized = true;\n            this.showNotification('Academic Search v4.0 initialized successfully', 'success', 'Academic Search');\n            return true;\n            \n        } catch (error) {\n            this.showNotification(`Academic Search initialization failed: ${error.message}`, 'error', 'Academic Search');\n            return false;\n        }\n    }\n\n    /**\n     * Register UI elements used by this module\n     */\n    registerUIElements() {\n        // Register only if elements exist in the DOM\n        if (document.querySelector('#academic-search-form')) {\n            registerElement('academicSearchForm', '#academic-search-form');\n        }\n        \n        if (document.querySelector('#academic-query-input')) {\n            registerElement('academicQueryInput', '#academic-query-input');\n        }\n        \n        if (document.querySelector('#academic-source-select')) {\n            registerElement('academicSourceSelect', '#academic-source-select');\n        }\n        \n        if (document.querySelector('#academic-search-btn')) {\n            registerElement('academicSearchBtn', '#academic-search-btn');\n        }\n        \n        if (document.querySelector('#academic-results-container')) {\n            registerElement('academicResultsContainer', '#academic-results-container');\n        }\n        \n        if (document.querySelector('#academic-paper-details')) {\n            registerElement('academicPaperDetailsContainer', '#academic-paper-details');\n        }\n        \n        if (document.querySelector('#academic-citations-container')) {\n            registerElement('academicCitationsContainer', '#academic-citations-container');\n        }\n        \n        if (document.querySelector('#academic-download-queue')) {\n            registerElement('academicDownloadQueue', '#academic-download-queue');\n        }\n    }\n\n    /**\n     * Set up event listeners for academic search functionality\n     */\n    setupEventListeners() {\n        try {\n            // Get form elements if they exist\n            const searchForm = getElement('academicSearchForm');\n            const searchBtn = getElement('academicSearchBtn');\n            \n            // Use event registry if elements exist\n            if (searchForm) {\n                registerEvents({\n                    'submit:academicSearchForm': (e) => this.handleSearchSubmit(e)\n                });\n            }\n            \n            if (searchBtn) {\n                registerEvents({\n                    'click:academicSearchBtn': () => this.performSearch()\n                });\n            }\n            \n            // Use event delegation for results and actions\n            document.addEventListener('click', (e) => {\n                // View paper details\n                if (e.target.closest('.view-paper-details')) {\n                    const button = e.target.closest('.view-paper-details');\n                    this.loadPaperDetails(button.dataset.id, button.dataset.source);\n                    e.preventDefault();\n                }\n                \n                // Download paper\n                if (e.target.closest('.download-paper')) {\n                    const button = e.target.closest('.download-paper');\n                    this.downloadPaper(button.dataset.id, button.dataset.source, button.dataset.pdfUrl);\n                    e.preventDefault();\n                }\n                \n                // View citations\n                if (e.target.closest('.view-citations')) {\n                    const button = e.target.closest('.view-citations');\n                    this.loadPaperCitations(button.dataset.id, button.dataset.source);\n                    e.preventDefault();\n                }\n                \n                // View recommendations\n                if (e.target.closest('.view-recommendations')) {\n                    const button = e.target.closest('.view-recommendations');\n                    this.loadRecommendations(button.dataset.id, button.dataset.source);\n                    e.preventDefault();\n                }\n                \n                // Extract papers from URL\n                if (e.target.closest('.extract-papers')) {\n                    const button = e.target.closest('.extract-papers');\n                    this.extractPapersFromUrl(button.dataset.url);\n                    e.preventDefault();\n                }\n            });\n            \n            console.log(\"Academic search event listeners set up\");\n        } catch (error) {\n            console.error(\"Error setting up academic search event listeners:\", error);\n        }\n    }\n\n    /**\n     * Load saved state from localStorage\n     */\n    loadSavedState() {\n        try {\n            const savedState = localStorage.getItem('academicSearchState');\n            if (savedState) {\n                const state = JSON.parse(savedState);\n                \n                // Restore last search if available\n                if (state.lastSearch) {\n                    const queryInput = getElement('academicQueryInput');\n                    const sourceSelect = getElement('academicSourceSelect');\n                    \n                    if (queryInput && state.lastSearch.query) {\n                        queryInput.value = state.lastSearch.query;\n                    }\n                    \n                    if (sourceSelect && state.lastSearch.source) {\n                        sourceSelect.value = state.lastSearch.source;\n                    }\n                    \n                    this.state.lastSearch = state.lastSearch;\n                }\n                \n                // Restore download queue if available\n                if (state.downloadQueue && Array.isArray(state.downloadQueue)) {\n                    state.downloadQueue.forEach(item => {\n                        if (item.id && item.status) {\n                            this.downloadQueue.set(item.id, item);\n                        }\n                    });\n                    \n                    // Update queue display\n                    this.updateDownloadQueue();\n                }\n            }\n        } catch (error) {\n            console.error(\"Error loading saved academic search state:\", error);\n        }\n    }\n\n    /**\n     * Save current state to localStorage\n     */\n    saveState() {\n        try {\n            const state = {\n                lastSearch: this.state.lastSearch || {\n                    query: getElement('academicQueryInput')?.value || '',\n                    source: getElement('academicSourceSelect')?.value || 'arxiv',\n                    timestamp: Date.now()\n                },\n                downloadQueue: Array.from(this.downloadQueue.values())\n            };\n            \n            localStorage.setItem('academicSearchState', JSON.stringify(state));\n        } catch (error) {\n            console.error(\"Error saving academic search state:\", error);\n        }\n    }\n\n    /**\n     * Handle search form submission\n     * @param {Event} event - Form submission event\n     */\n    handleSearchSubmit(event) {\n        if (event) {\n            event.preventDefault();\n        }\n        this.performSearch();\n    }\n\n    /**\n     * Perform an academic search\n     * @returns {Promise<Object>} - Search results\n     */\n    async performSearch() {\n        try {\n            // Get search parameters\n            const queryInput = getElement('academicQueryInput');\n            const sourceSelect = getElement('academicSourceSelect');\n            \n            if (!queryInput) {\n                throw new Error('Search form elements not found');\n            }\n            \n            const query = queryInput.value.trim();\n            const source = sourceSelect ? sourceSelect.value : 'arxiv';\n\n            if (!query) {\n                showErrorNotification(new Error('Please enter a search query'), { message: 'Please enter a search query' });\n                return;\n            }\n\n            // Show loading indicator\n            this.showLoading('Searching for papers...');\n\n            // Save current search in state\n            this.state.lastSearch = {\n                query,\n                source,\n                timestamp: Date.now()\n            };\n            \n            // Save to localStorage\n            this.saveState();\n            \n            // Generate a unique search ID\n            const searchId = generateId();\n            this.activeSearches.set(searchId, { query, source, timestamp: Date.now() });\n\n            // Make the API request\n            const response = await fetch(`/api/academic/search?query=${encodeURIComponent(query)}&source=${source}`);\n\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.error?.message || 'Search failed');\n            }\n\n            const data = await response.json();\n            this.searchResults = data.results || [];\n            \n            // Update state with results\n            setState('academicSearchResults', this.searchResults);\n            \n            // Remove from active searches\n            this.activeSearches.delete(searchId);\n            \n            // Hide loading indicator\n            this.hideLoading();\n            \n            // Display results\n            this.displaySearchResults(this.searchResults);\n            \n            // Return results\n            return {\n                query,\n                source,\n                results: this.searchResults,\n                total: this.searchResults.length\n            };\n        } catch (error) {\n            // Hide loading indicator\n            this.hideLoading();\n            \n            // Show error\n            showErrorNotification(error, { message: 'Academic search failed' });\n            \n            // Log error\n            console.error('Search error:', error);\n            \n            return {\n                error: error.message,\n                results: []\n            };\n        }\n    }\n\n    /**\n     * Display search results in the UI\n     * @param {Array} results - Search results to display\n     */\n    displaySearchResults(results) {\n        const container = getElement('academicResultsContainer');\n        if (!container) return;\n\n        if (!results || results.length === 0) {\n            container.innerHTML = '<div class=\"alert alert-info\">No results found. Try modifying your search query.</div>';\n            return;\n        }\n\n        let html = `\n            <h3>Search Results (${results.length})</h3>\n            <div class=\"papers-list\">\n        `;\n\n        results.forEach(paper => {\n            html += `\n                <div class=\"paper-item\">\n                    <h4>${paper.title || 'Untitled Paper'}</h4>\n                    <p class=\"paper-authors\">${this.formatAuthors(paper.authors)}</p>\n                    <p class=\"paper-abstract\">${paper.abstract || 'No abstract available'}</p>\n                    <div class=\"paper-actions\">\n                        <button class=\"btn btn-sm btn-primary view-paper-details\" \n                            data-id=\"${paper.id}\" \n                            data-source=\"${paper.source}\">Details</button>\n                        <button class=\"btn btn-sm btn-success download-paper\" \n                            data-id=\"${paper.id}\" \n                            data-source=\"${paper.source}\"\n                            data-pdf-url=\"${paper.pdf_url || ''}\">Download PDF</button>\n                        <button class=\"btn btn-sm btn-outline-secondary view-citations\"\n                            data-id=\"${paper.id}\" \n                            data-source=\"${paper.source}\">Citations</button>\n                    </div>\n                </div>\n            `;\n        });\n\n        html += '</div>';\n        container.innerHTML = html;\n        \n        // Scroll to top of results\n        container.scrollIntoView({ behavior: 'smooth' });\n    }\n\n    /**\n     * Format an array of authors for display\n     * @param {Array} authors - Author names\n     * @returns {string} - Formatted author list\n     */\n    formatAuthors(authors) {\n        if (!authors || !Array.isArray(authors) || authors.length === 0) {\n            return 'Unknown Authors';\n        }\n        \n        if (authors.length === 1) {\n            return authors[0];\n        }\n        \n        if (authors.length === 2) {\n            return `${authors[0]} and ${authors[1]}`;\n        }\n        \n        return `${authors[0]}, ${authors[1]}, et al.`;\n    }\n\n    /**\n     * Load detailed information about a paper\n     * @param {string} paperId - Paper identifier\n     * @param {string} source - Source database\n     * @returns {Promise<Object>} - Paper details\n     */\n    async loadPaperDetails(paperId, source) {\n        if (!paperId) return;\n        \n        try {\n            this.showLoading('Loading paper details...');\n            \n            // Generate request ID\n            const requestId = generateId();\n            this.activePaperRequests.set(requestId, { paperId, source, type: 'details', timestamp: Date.now() });\n            \n            // Make API request\n            const response = await fetch(`/api/academic/details/${paperId}?source=${source || 'arxiv'}`);\n            \n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.error?.message || 'Failed to load paper details');\n            }\n            \n            const paperDetails = await response.json();\n            this.currentPaperDetails = paperDetails;\n            \n            // Remove from active requests\n            this.activePaperRequests.delete(requestId);\n            \n            // Update state\n            setState('currentPaperDetails', paperDetails);\n            \n            this.hideLoading();\n            this.displayPaperDetails(paperDetails);\n            \n            return paperDetails;\n        } catch (error) {\n            this.hideLoading();\n            showErrorNotification(error, { message: 'Failed to load paper details' });\n            console.error('Error loading paper details:', error);\n            \n            return { error: error.message };\n        }\n    }\n\n    /**\n     * Display paper details in the UI\n     * @param {Object} paper - Paper details to display\n     */\n    displayPaperDetails(paper) {\n        const container = getElement('academicPaperDetailsContainer');\n        if (!container) return;\n        \n        let html = `\n            <div class=\"paper-details\">\n                <h3>${paper.title || 'Untitled Paper'}</h3>\n                <p class=\"paper-authors\"><strong>Authors:</strong> ${this.formatAuthors(paper.authors)}</p>\n                <p class=\"paper-date\"><strong>Publication Date:</strong> ${paper.publication_date || 'Unknown'}</p>\n                <div class=\"paper-abstract\">\n                    <h4>Abstract</h4>\n                    <p>${paper.abstract || 'No abstract available'}</p>\n                </div>\n        `;\n        \n        if (paper.metadata && Object.keys(paper.metadata).length > 0) {\n            html += '<div class=\"paper-metadata\"><h4>Metadata</h4><ul>';\n            \n            for (const [key, value] of Object.entries(paper.metadata)) {\n                if (Array.isArray(value)) {\n                    html += `<li><strong>${key}:</strong> ${value.join(', ')}</li>`;\n                } else {\n                    html += `<li><strong>${key}:</strong> ${value}</li>`;\n                }\n            }\n            \n            html += '</ul></div>';\n        }\n        \n        html += `\n                <div class=\"paper-actions\">\n                    ${paper.pdf_url ? `\n                        <button class=\"btn btn-primary download-paper\" \n                            data-id=\"${paper.id}\" \n                            data-source=\"${paper.source}\"\n                            data-pdf-url=\"${paper.pdf_url}\">Download PDF</button>\n                    ` : ''}\n                    <button class=\"btn btn-outline-secondary view-citations\"\n                        data-id=\"${paper.id}\" \n                        data-source=\"${paper.source}\">View Citations</button>\n                    <button class=\"btn btn-outline-secondary view-recommendations\"\n                        data-id=\"${paper.id}\" \n                        data-source=\"${paper.source}\">Similar Papers</button>\n                </div>\n            </div>\n        `;\n        \n        container.innerHTML = html;\n        \n        // Scroll to paper details\n        container.scrollIntoView({ behavior: 'smooth' });\n    }\n\n    /**\n     * Download a paper PDF\n     * @param {string} paperId - Paper identifier\n     * @param {string} source - Paper source\n     * @param {string} pdfUrl - Optional direct PDF URL\n     * @returns {Promise<Object>} - Download result\n     */\n    async downloadPaper(paperId, source, pdfUrl) {\n        let downloadId;\n        \n        try {\n            this.showLoading('Downloading paper...');\n            \n            const downloadUrl = pdfUrl || (this.currentPaperDetails?.pdf_url);\n            \n            if (!downloadUrl && !paperId) {\n                throw new Error('No PDF URL or paper ID available');\n            }\n            \n            // Create a download record\n            downloadId = generateId();\n            this.downloadQueue.set(downloadId, {\n                id: downloadId,\n                paperId,\n                source,\n                status: 'downloading',\n                timestamp: Date.now()\n            });\n            \n            // Update the download queue display\n            this.updateDownloadQueue();\n            \n            // Save state\n            this.saveState();\n            \n            // Start download tracking\n            const progressTracker = trackProgress(downloadId, {\n                elementPrefix: 'pdf-download',\n                taskType: 'pdfDownload',\n                saveToSessionStorage: false\n            });\n            \n            // Use either direct PDF URL (if available) or academic download endpoint\n            let response;\n            if (downloadUrl && (downloadUrl.includes('.pdf') || downloadUrl.includes('arxiv.org'))) {\n                response = await fetch('/api/download-pdf', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        url: downloadUrl,\n                        processFile: true\n                    })\n                });\n            } else {\n                response = await fetch(`/api/academic/download/${paperId}?source=${source || 'arxiv'}`);\n            }\n            \n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.error?.message || 'Download failed');\n            }\n            \n            const data = await response.json();\n            \n            // Update download status\n            const download = this.downloadQueue.get(downloadId);\n            if (download) {\n                download.status = 'completed';\n                download.filePath = data.file_path;\n                download.fileName = data.file_name;\n                download.fileSize = data.file_size;\n                this.downloadQueue.set(downloadId, download);\n            }\n            \n            // Update the progress tracker\n            progressTracker.updateProgress(100, 'Download completed');\n            progressTracker.complete(data);\n            \n            // Update queue display\n            this.updateDownloadQueue();\n            \n            // Save state\n            this.saveState();\n            \n            this.hideLoading();\n            showSuccess('Paper downloaded successfully');\n            \n            return {\n                downloadId,\n                status: 'completed',\n                filePath: data.file_path,\n                fileName: data.file_name\n            };\n        } catch (error) {\n            this.hideLoading();\n            \n            // Update download status to failed\n            if (downloadId) {\n                const download = this.downloadQueue.get(downloadId);\n                if (download) {\n                    download.status = 'failed';\n                    download.error = error.message;\n                    this.downloadQueue.set(downloadId, download);\n                    this.updateDownloadQueue();\n                    \n                    // Save state\n                    this.saveState();\n                }\n            }\n            \n            showErrorNotification(error, { message: 'Paper download failed' });\n            console.error('Download error:', error);\n            \n            return {\n                error: error.message,\n                status: 'failed'\n            };\n        }\n    }\n\n    /**\n     * Update the download queue UI\n     */\n    updateDownloadQueue() {\n        const container = getElement('academicDownloadQueue');\n        if (!container) return;\n        \n        if (this.downloadQueue.size === 0) {\n            container.innerHTML = '';\n            return;\n        }\n        \n        let html = `\n            <h4>Download Queue</h4>\n            <div class=\"download-queue-list\">\n        `;\n        \n        for (const [id, download] of this.downloadQueue.entries()) {\n            const statusClass = download.status === 'completed' ? 'text-success' : \n                              (download.status === 'failed' ? 'text-danger' : 'text-info');\n            \n            html += `\n                <div class=\"download-item\">\n                    <div class=\"download-info\">\n                        <span class=\"download-id\">${download.paperId || id}</span>\n                        <span class=\"download-status ${statusClass}\">${download.status}</span>\n                    </div>\n                    ${download.status === 'completed' ? `\n                        <div class=\"download-actions\">\n                            <button class=\"btn btn-sm btn-outline-primary view-file\" data-path=\"${download.filePath}\">View</button>\n                        </div>\n                    ` : ''}\n                    ${download.status === 'failed' ? `\n                        <div class=\"download-error\">Error: ${download.error}</div>\n                    ` : ''}\n                </div>\n            `;\n        }\n        \n        html += '</div>';\n        container.innerHTML = html;\n        \n        // Add event listeners to view buttons\n        const viewButtons = container.querySelectorAll('.view-file');\n        viewButtons.forEach(button => {\n            button.addEventListener('click', () => {\n                this.viewFile(button.dataset.path);\n            });\n        });\n    }\n\n    /**\n     * Load citation data for a paper\n     * @param {string} paperId - Paper identifier\n     * @param {string} source - Paper source\n     * @returns {Promise<Object>} - Citation data\n     */\n    async loadPaperCitations(paperId, source) {\n        if (!paperId) return;\n        \n        try {\n            this.showLoading('Loading citation data...');\n            \n            // Generate request ID\n            const requestId = generateId();\n            this.activePaperRequests.set(requestId, { paperId, source, type: 'citations', timestamp: Date.now() });\n            \n            const response = await fetch(`/api/academic/citations/${paperId}?source=${source || 'arxiv'}`);\n            \n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.error?.message || 'Failed to load citations');\n            }\n            \n            const citationData = await response.json();\n            \n            // Remove from active requests\n            this.activePaperRequests.delete(requestId);\n            \n            this.hideLoading();\n            this.displayCitationData(citationData);\n            \n            return citationData;\n        } catch (error) {\n            this.hideLoading();\n            showErrorNotification(error, { message: 'Failed to load citations' });\n            console.error('Error loading citations:', error);\n            \n            return { error: error.message };\n        }\n    }\n\n    /**\n     * Display citation data in the UI\n     * @param {Object} data - Citation data to display\n     */\n    displayCitationData(data) {\n        const container = getElement('academicCitationsContainer');\n        if (!container) return;\n        \n        if (!data || data.error) {\n            container.innerHTML = `<div class=\"alert alert-warning\">Could not load citation data: ${data.error || 'Unknown error'}</div>`;\n            return;\n        }\n        \n        let html = `\n            <div class=\"citations-data\">\n                <h3>Citation Analysis for \"${data.paper_title || 'Paper'}\"</h3>\n                <div class=\"citation-stats\">\n                    <p><strong>Total Citations:</strong> ${data.total_citations || 0}</p>\n                </div>\n        `;\n        \n        // If we have citation by year data\n        if (data.citation_by_year && Object.keys(data.citation_by_year).length > 0) {\n            html += '<div class=\"citation-years\"><h4>Citations by Year</h4><ul>';\n            \n            const years = Object.keys(data.citation_by_year).sort();\n            for (const year of years) {\n                html += `<li><strong>${year}:</strong> ${data.citation_by_year[year]}</li>`;\n            }\n            \n            html += '</ul></div>';\n        }\n        \n        // If we have top citing authors\n        if (data.top_citing_authors && data.top_citing_authors.length > 0) {\n            html += '<div class=\"top-authors\"><h4>Top Citing Authors</h4><ol>';\n            \n            for (const author of data.top_citing_authors) {\n                html += `<li>${author.name || ''} (${author.count || 0} citations)</li>`;\n            }\n            \n            html += '</ol></div>';\n        }\n        \n        // If we have citation network data\n        if (data.citation_network && data.citation_network.nodes && data.citation_network.nodes.length > 0) {\n            html += `\n                <div class=\"citation-network\">\n                    <h4>Citation Network</h4>\n                    <p>Network with ${data.citation_network.nodes.length} nodes and ${data.citation_network.links?.length || 0} connections</p>\n                    <div id=\"network-visualization\" class=\"network-vis-container\"></div>\n                </div>\n            `;\n        }\n        \n        html += '</div>';\n        container.innerHTML = html;\n        \n        // If we have network data and container exists, try to visualize it\n        if (data.citation_network && document.getElementById('network-visualization')) {\n            this.visualizeNetwork(data.citation_network, 'network-visualization');\n        }\n        \n        // Scroll to citations container\n        container.scrollIntoView({ behavior: 'smooth' });\n    }\n\n    /**\n     * Visualize a citation network (placeholder for actual visualization)\n     * @param {Object} network - Network data with nodes and links\n     * @param {string} containerId - ID of the container element\n     */\n    visualizeNetwork(network, containerId) {\n        const container = document.getElementById(containerId);\n        if (!container) return;\n        \n        // In a real implementation, we would integrate a visualization library\n        // such as D3.js to render the network\n        \n        // For now, just show a placeholder message\n        container.innerHTML = `\n            <div class=\"alert alert-info\">\n                <p>Network visualization would go here.</p>\n                <p>Network has ${network.nodes.length} nodes and ${network.links?.length || 0} links.</p>\n            </div>\n        `;\n    }\n\n    /**\n     * Load paper recommendations\n     * @param {string} paperId - Paper identifier\n     * @param {string} source - Paper source\n     * @returns {Promise<Object>} - Recommendation data\n     */\n    async loadRecommendations(paperId, source) {\n        if (!paperId) return;\n        \n        try {\n            showLoading('Loading recommendations...');\n            \n            // Generate request ID\n            const requestId = generateId();\n            this.activePaperRequests.set(requestId, { paperId, source, type: 'recommendations', timestamp: Date.now() });\n            \n            const response = await fetch(`/api/academic/recommendations/${paperId}?source=${source || 'arxiv'}`);\n            \n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.error?.message || 'Failed to load recommendations');\n            }\n            \n            const data = await response.json();\n            \n            // Remove from active requests\n            this.activePaperRequests.delete(requestId);\n            \n            this.hideLoading();\n            this.displayRecommendations(data);\n            \n            return data;\n        } catch (error) {\n            this.hideLoading();\n            showErrorNotification(error, { message: 'Failed to load recommendations' });\n            console.error('Error loading recommendations:', error);\n            \n            return { error: error.message };\n        }\n    }\n\n    /**\n     * Display paper recommendations in the UI\n     * @param {Object} data - Recommendation data to display\n     */\n    displayRecommendations(data) {\n        const container = getElement('academicResultsContainer');\n        if (!container) return;\n        \n        if (!data || !data.recommendations || data.recommendations.length === 0) {\n            container.innerHTML = '<div class=\"alert alert-info\">No related papers found.</div>';\n            return;\n        }\n        \n        let html = `\n            <h3>Related Papers for \"${data.paper_id || 'Paper'}\"</h3>\n            <div class=\"papers-list related-papers\">\n        `;\n        \n        data.recommendations.forEach(paper => {\n            html += `\n                <div class=\"paper-item\">\n                    <h4>${paper.title || 'Untitled Paper'}</h4>\n                    <p class=\"paper-authors\">${this.formatAuthors(paper.authors)}</p>\n                    <p class=\"paper-abstract\">${paper.abstract || 'No abstract available'}</p>\n                    <p class=\"similarity-score\">Similarity: ${(paper.similarity_score * 100).toFixed(1)}%</p>\n                    <div class=\"paper-actions\">\n                        <button class=\"btn btn-sm btn-primary view-paper-details\" \n                            data-id=\"${paper.id}\" \n                            data-source=\"${paper.source}\">Details</button>\n                        <button class=\"btn btn-sm btn-success download-paper\" \n                            data-id=\"${paper.id}\" \n                            data-source=\"${paper.source}\"\n                            data-pdf-url=\"${paper.pdf_url || ''}\">Download PDF</button>\n                    </div>\n                </div>\n            `;\n        });\n        \n        html += '</div>';\n        container.innerHTML = html;\n        \n        // Scroll to results container\n        container.scrollIntoView({ behavior: 'smooth' });\n    }\n\n    /**\n     * Extract papers from a URL\n     * @param {string} url - URL to extract papers from\n     * @returns {Promise<Object>} - Extraction results\n     */\n    async extractPapersFromUrl(url) {\n        if (!url) return;\n        \n        try {\n            showLoading('Extracting papers from URL...');\n            \n            const response = await fetch(`/api/academic/extract?url=${encodeURIComponent(url)}`);\n            \n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.error?.message || 'Extraction failed');\n            }\n            \n            const data = await response.json();\n            \n            this.hideLoading();\n            this.displayExtractedPapers(data);\n            \n            return data;\n        } catch (error) {\n            this.hideLoading();\n            showErrorNotification(error, { message: 'Failed to extract papers' });\n            console.error('Extraction error:', error);\n            \n            return { error: error.message };\n        }\n    }\n\n    /**\n     * Display extracted papers in the UI\n     * @param {Object} data - Extraction data to display\n     */\n    displayExtractedPapers(data) {\n        const container = getElement('academicResultsContainer');\n        if (!container) return;\n        \n        if (!data.pdfs || data.pdfs.length === 0) {\n            container.innerHTML = `<div class=\"alert alert-info\">No PDFs found at URL: ${data.url}</div>`;\n            return;\n        }\n        \n        let html = `\n            <h3>Extracted Papers (${data.pdfs_found || data.pdfs.length})</h3>\n            <p>Source: ${data.url}</p>\n            <div class=\"papers-list extracted-papers\">\n        `;\n        \n        data.pdfs.forEach(pdf => {\n            html += `\n                <div class=\"paper-item\">\n                    <h4>${pdf.title || 'Untitled Paper'}</h4>\n                    <div class=\"paper-actions\">\n                        <button class=\"btn btn-sm btn-success download-paper\" \n                            data-pdf-url=\"${pdf.url}\">Download PDF</button>\n                    </div>\n                    ${pdf.downloaded ? `\n                        <div class=\"download-info\">\n                            <span class=\"text-success\">Already downloaded</span>\n                            <button class=\"btn btn-sm btn-outline-primary view-file\" data-path=\"${pdf.file_path}\">View</button>\n                        </div>\n                    ` : ''}\n                </div>\n            `;\n        });\n        \n        html += '</div>';\n        container.innerHTML = html;\n        \n        // Add event listeners\n        const downloadButtons = container.querySelectorAll('.download-paper');\n        downloadButtons.forEach(button => {\n            button.addEventListener('click', () => {\n                this.downloadPaper(null, null, button.dataset.pdfUrl);\n            });\n        });\n        \n        const viewButtons = container.querySelectorAll('.view-file');\n        viewButtons.forEach(button => {\n            button.addEventListener('click', () => {\n                this.viewFile(button.dataset.path);\n            });\n        });\n        \n        // Scroll to results container\n        container.scrollIntoView({ behavior: 'smooth' });\n    }\n\n    /**\n     * View a file in the browser\n     * @param {string} filePath - Path to the file\n     */\n    viewFile(filePath) {\n        if (!filePath) return;\n        \n        if (filePath.toLowerCase().endsWith('.pdf')) {\n            window.open(`/download-pdf/${filePath}`, '_blank');\n        } else {\n            window.open(`/download-file/${filePath}`, '_blank');\n        }\n    }\n\n    /**\n     * Perform a multi-source search across multiple academic databases\n     * @param {string} query - Search query\n     * @param {Array} sources - Array of sources to search\n     * @returns {Promise<Object>} - Combined search results\n     */\n    async performMultiSourceSearch(query, sources = ['arxiv', 'semantic', 'openalex']) {\n        if (!query || !sources || !Array.isArray(sources) || sources.length === 0) {\n            return { error: 'Invalid search parameters' };\n        }\n        \n        try {\n            showLoading('Searching multiple academic sources...');\n            \n            // Generate a unique search ID\n            const searchId = generateId();\n            this.activeSearches.set(searchId, { \n                query, \n                sources, \n                multi: true, \n                timestamp: Date.now() \n            });\n            \n            // Construct query parameters\n            const sourceParam = sources.join(',');\n            const url = `/api/academic/multi-source?query=${encodeURIComponent(query)}&sources=${sourceParam}`;\n            \n            const response = await fetch(url);\n            \n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.error?.message || 'Multi-source search failed');\n            }\n            \n            const data = await response.json();\n            \n            // Store results\n            this.searchResults = data.results || [];\n            \n            // Update state\n            setState('academicSearchResults', this.searchResults);\n            setState('academicSearch', {\n                query,\n                sources,\n                multi: true,\n                timestamp: Date.now()\n            });\n            \n            // Remove from active searches\n            this.activeSearches.delete(searchId);\n            \n            // Hide loading indicator\n            this.hideLoading();\n            \n            // Display results with source distribution information\n            this.displayMultiSourceResults(data);\n            \n            return data;\n        } catch (error) {\n            this.hideLoading();\n            showErrorNotification(error, { message: 'Multi-source search failed' });\n            console.error('Multi-source search error:', error);\n            \n            return { error: error.message };\n        }\n    }\n\n    /**\n     * Display multi-source search results\n     * @param {Object} data - Results with source distribution information\n     */\n    displayMultiSourceResults(data) {\n        const container = getElement('academicResultsContainer');\n        if (!container) return;\n        \n        if (!data.results || data.results.length === 0) {\n            container.innerHTML = '<div class=\"alert alert-info\">No results found across selected sources.</div>';\n            return;\n        }\n        \n        let html = `\n            <h3>Search Results (${data.results.length})</h3>\n        `;\n        \n        // Display source distribution if available\n        if (data.source_distribution) {\n            html += `<div class=\"source-distribution\"><p>Results by source: `;\n            \n            const sources = Object.entries(data.source_distribution);\n            sources.forEach(([source, count], index) => {\n                html += `<span class=\"badge bg-primary\">${source}: ${count}</span>`;\n                if (index < sources.length - 1) {\n                    html += ' ';\n                }\n            });\n            \n            html += `</p></div>`;\n        }\n        \n        html += `<div class=\"papers-list\">`;\n        \n        data.results.forEach(paper => {\n            html += `\n                <div class=\"paper-item\">\n                    <div class=\"paper-source-badge\">\n                        <span class=\"badge bg-secondary\">${paper.source}</span>\n                    </div>\n                    <h4>${paper.title || 'Untitled Paper'}</h4>\n                    <p class=\"paper-authors\">${this.formatAuthors(paper.authors)}</p>\n                    <p class=\"paper-abstract\">${paper.abstract || 'No abstract available'}</p>\n                    <div class=\"paper-actions\">\n                        <button class=\"btn btn-sm btn-primary view-paper-details\" \n                            data-id=\"${paper.id}\" \n                            data-source=\"${paper.source}\">Details</button>\n                        <button class=\"btn btn-sm btn-success download-paper\" \n                            data-id=\"${paper.id}\" \n                            data-source=\"${paper.source}\"\n                            data-pdf-url=\"${paper.pdf_url || ''}\">Download PDF</button>\n                        <button class=\"btn btn-sm btn-outline-secondary view-citations\"\n                            data-id=\"${paper.id}\" \n                            data-source=\"${paper.source}\">Citations</button>\n                    </div>\n                </div>\n            `;\n        });\n        \n        html += '</div>';\n        container.innerHTML = html;\n        \n        // Scroll to results container\n        container.scrollIntoView({ behavior: 'smooth' });\n    }\n\n    /**\n     * Analyze a paper using the academic API\n     * @param {string} paperId - Paper identifier\n     * @param {string} source - Paper source\n     * @returns {Promise<Object>} - Comprehensive analysis data\n     */\n    async analyzePaper(paperId, source) {\n        if (!paperId) return;\n        \n        try {\n            showLoading('Analyzing paper...');\n            \n            // Generate a unique analysis ID\n            const analysisId = generateId();\n            this.activePaperRequests.set(analysisId, { \n                paperId, \n                source, \n                type: 'analysis', \n                timestamp: Date.now() \n            });\n            \n            const response = await fetch(`/api/academic/analyze/${paperId}?source=${source || 'arxiv'}`);\n            \n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.error?.message || 'Analysis failed');\n            }\n            \n            const analysisData = await response.json();\n            \n            // Remove from active requests\n            this.activePaperRequests.delete(analysisId);\n            \n            this.hideLoading();\n            \n            // Display analysis results\n            this.displayAnalysisResults(analysisData);\n            \n            return analysisData;\n        } catch (error) {\n            this.hideLoading();\n            showErrorNotification(error, { message: 'Paper analysis failed' });\n            console.error('Analysis error:', error);\n            \n            return { error: error.message };\n        }\n    }\n\n    /**\n     * Display paper analysis results\n     * @param {Object} data - Analysis data to display\n     */\n    displayAnalysisResults(data) {\n        // This would be implemented to show a comprehensive view\n        // of the paper including details, citations, and recommendations\n        showToast('Paper analysis complete', 'Analysis results are available', 'info');\n        \n        // Log the analysis data for debugging (remove in production)\n        console.log('Paper analysis results:', data);\n        \n        // In a real implementation, this would update a specific UI container\n        // to show the comprehensive analysis results\n    }\n\n    /**\n     * Cancel active operations\n     * @param {string} [operationType] - Optional type of operations to cancel ('search' or 'paper')\n     */\n    cancelActiveOperations(operationType) {\n        if (!operationType || operationType === 'search') {\n            // Clear active searches\n            this.activeSearches.clear();\n        }\n        \n        if (!operationType || operationType === 'paper') {\n            // Clear active paper requests\n            this.activePaperRequests.clear();\n        }\n        \n        // Hide loading indicator\n        hideLoading();\n        \n        showToast('Operations cancelled', '', 'warning');\n    }\n\n    /**\n     * Get active operations status\n     * @returns {Object} - Status of active operations\n     */\n    getActiveOperationsStatus() {\n        return {\n            searches: Array.from(this.activeSearches.entries()).map(([id, data]) => ({\n                id,\n                ...data,\n                elapsedTime: Date.now() - data.timestamp\n            })),\n            paperRequests: Array.from(this.activePaperRequests.entries()).map(([id, data]) => ({\n                id,\n                ...data,\n                elapsedTime: Date.now() - data.timestamp\n            })),\n            downloadQueue: Array.from(this.downloadQueue.entries()).map(([id, data]) => ({\n                id,\n                ...data,\n                elapsedTime: Date.now() - data.timestamp\n            }))\n        };\n    }\n}\n\n// Create an instance of AcademicSearch\nconst academicSearch = new AcademicSearch();\n\n// Export both the instance and the class\nexport default academicSearch;\nexport { AcademicSearch };\n\n// Export utility functions from the class instance for external use\nexport const now = academicSearch.state.now.bind(academicSearch.state);\nexport const from = academicSearch.state.from.bind(academicSearch.state);","source":"/workspace/modules/static/js/modules/features/academicSearch.js","title":"academicSearch.js","language":"en"},{"content":"/**\n * File Processor Module - Optimized Blueprint Implementation v4.0\n * \n * Advanced file processing module optimized for the new Blueprint architecture.\n * Features configuration-driven architecture, enhanced error handling, and\n * comprehensive integration with the centralized progress tracking system.\n * \n * NEW v4.0 Features:\n * - Configuration-driven architecture using centralized endpoints\n * - Enhanced 4-method notification system (Toast + Console + System + Error)\n * - Backend connectivity testing with health checks\n * - ES6 module imports with centralized configuration\n * - Optimized for Blueprint architecture integration\n * - Enhanced progressHandler v4.0 integration\n * - Advanced error handling and recovery mechanisms\n * \n * @module features/fileProcessor\n * @version 4.0.0 - Blueprint Architecture Optimization\n */\n\n// Import dependencies with fallbacks for robustness\nlet API_ENDPOINTS, BLUEPRINT_ROUTES, CONSTANTS, API_CONFIG, SOCKET_CONFIG, SOCKET_EVENTS, TASK_EVENTS, blueprintApi;\n\n// Initialize imports with fallbacks\nasync function initializeImports() {\n  try {\n    const endpointsModule = await import('../config/endpoints.js');\n    API_ENDPOINTS = endpointsModule.API_ENDPOINTS;\n    BLUEPRINT_ROUTES = endpointsModule.BLUEPRINT_ROUTES;\n  } catch (error) {\n    console.warn('Failed to import endpoints config, using fallbacks');\n    API_ENDPOINTS = {\n      FILE_PROCESSOR: {\n        PROCESS: '/api/process',\n        HEALTH: '/api/health',\n        CANCEL: '/api/cancel/:taskId'\n      }\n    };\n    BLUEPRINT_ROUTES = { file_processor: '/api' };\n  }\n\n  try {\n    const constantsModule = await import('../config/constants.js');\n    CONSTANTS = constantsModule.CONSTANTS;\n    API_CONFIG = constantsModule.API_CONFIG;\n    SOCKET_CONFIG = constantsModule.SOCKET_CONFIG;\n  } catch (error) {\n    console.warn('Failed to import constants config, using fallbacks');\n    CONSTANTS = {\n      MAX_FILENAME_LENGTH: 255,\n      WINDOWS_INVALID_CHARS: /[<>:\"|?*]/,\n      WINDOWS_RESERVED_NAMES: ['CON', 'PRN', 'AUX', 'NUL']\n    };\n    API_CONFIG = { API_TIMEOUT: 30000 };\n    SOCKET_CONFIG = {};\n  }\n\n  try {\n    const socketModule = await import('../config/socketEvents.js');\n    SOCKET_EVENTS = socketModule.SOCKET_EVENTS;\n    TASK_EVENTS = socketModule.TASK_EVENTS;\n  } catch (error) {\n    console.warn('Failed to import socket events config, using fallbacks');\n    TASK_EVENTS = {\n      STARTED: 'task_started',\n      PROGRESS: 'progress_update',\n      COMPLETED: 'task_completed',\n      ERROR: 'task_error'\n    };\n    SOCKET_EVENTS = {};\n  }\n\n  try {\n    const apiModule = await import('../services/blueprintApi.js');\n    blueprintApi = apiModule.default;\n  } catch (error) {\n    console.warn('Failed to import blueprint API, using fallback');\n    blueprintApi = {\n      processFiles: async (inputDir, outputFile, options) => {\n        const response = await fetch('/api/process', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({\n            input_dir: inputDir,\n            output_file: outputFile,\n            ...options\n          })\n        });\n        if (!response.ok) throw new Error(`HTTP ${response.status}`);\n        return response.json();\n      },\n      cancelTask: async (taskId) => {\n        const response = await fetch(`/api/cancel/${taskId}`, { method: 'POST' });\n        return response.ok;\n      },\n      verifyPath: async (path) => ({ valid: true })\n    };\n  }\n}\n\n// Configuration shorthand (will be initialized after imports)\nlet FILE_PROCESSOR_CONFIG = {\n  constants: {},\n  endpoints: {},\n  blueprint: '',\n  api: {},\n  socket: {}\n};\n\n/**\n * File Processor Class - Clean Blueprint Implementation\n */\nclass FileProcessor {\n  constructor() {\n    this.state = {\n      isInitialized: false,\n      currentTask: null,\n      processingState: 'idle', // 'idle', 'processing', 'completed', 'error'\n      elements: new Map(),\n      eventListeners: new Set(),\n      socketListeners: new Set(),\n      backendConnected: false,\n      lastHealthCheck: null,\n      // Enhanced completion tracking\n      completionState: {\n        completed: false,\n        completionTime: null,\n        error: false,\n        cancelled: false\n      },\n      // Progress tracking for stuck task detection\n      lastProgressTimestamp: null,\n      lastReportedProgress: 0,\n      progressUpdateCount: 0,\n      progressRates: [],\n      processingStartTime: null,\n      // Completion monitoring\n      completionMonitoring: {\n        enabled: true,\n        timeoutIds: new Set(),\n        checkIntervalMs: 5000, // Check every 5 seconds\n        maxStuckDurationMs: 30000 // Consider stuck after 30 seconds with no updates\n      },\n      // Progress tracker instance\n      progressTracker: null\n    };\n    \n    // Initialize config with safe defaults - will be properly set in init()\n    this.config = {\n      supportedFormats: ['.txt', '.md', '.json', '.xml', '.html', '.csv'],\n      maxFileSize: 50 * 1024 * 1024, // 50MB default\n      maxBatchSize: 100,\n      chunkSize: 1024 * 1024 // 1MB chunks\n    };\n  }\n\n  /**\n   * Enhanced notification system with fallbacks\n   * @param {string} message - Notification message\n   * @param {string} type - Type of notification (info, success, warning, error)\n   * @param {string} title - Notification title\n   */\n  showNotification(message, type = 'info', title = 'File Processor') {\n    // Method 1: Console logging with styling (always works)\n    const styles = {\n      error: 'color: #dc3545; font-weight: bold;',\n      warning: 'color: #fd7e14; font-weight: bold;',\n      success: 'color: #198754; font-weight: bold;',\n      info: 'color: #0d6efd;'\n    };\n    console.log(`%c[${title}] ${message}`, styles[type] || styles.info);\n    \n    // Method 2: Try various toast systems\n    if (window.NeuroGen?.ui?.showToast) {\n      window.NeuroGen.ui.showToast(title, message, type);\n    } else if (window.showToast) {\n      window.showToast(title, message, type);\n    } else if (window.ui?.showToast) {\n      window.ui.showToast(title, message, type);\n    }\n    \n    // Method 3: System notification (if available)\n    if (window.NeuroGen?.notificationHandler) {\n      window.NeuroGen.notificationHandler.show({\n        title, message, type, module: 'fileProcessor'\n      });\n    }\n    \n    // Method 4: Error reporting to centralized handler\n    if (type === 'error' && window.NeuroGen?.errorHandler) {\n      window.NeuroGen.errorHandler.logError({\n        module: 'fileProcessor', message, severity: type\n      });\n    }\n    \n    // Method 5: Fallback for critical errors\n    if (type === 'error' && !window.NeuroGen?.ui?.showToast && !window.showToast) {\n      alert(`${title}: ${message}`);\n    }\n  }\n\n  /**\n   * Test backend connectivity for file processor\n   * @returns {Promise<Object>} Backend connectivity status\n   */\n  async testBackendConnectivity() {\n    const results = {\n      overall: false,\n      details: {},\n      timestamp: new Date().toISOString(),\n      errors: []\n    };\n\n    try {\n      // Test file processor health endpoint\n      const healthResponse = await fetch(FILE_PROCESSOR_CONFIG.endpoints?.HEALTH || '/api/health', {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' }\n      });\n\n      results.details.health = {\n        status: healthResponse.status,\n        ok: healthResponse.ok,\n        endpoint: FILE_PROCESSOR_CONFIG.endpoints?.HEALTH || '/api/health'\n      };\n\n      if (healthResponse.ok) {\n        // Test file processor endpoint\n        const testResponse = await fetch(FILE_PROCESSOR_CONFIG.endpoints?.PROCESS || '/api/process', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({\n            input_dir: '/tmp/connectivity_test',\n            output_file: 'connectivity_test.json',\n            action: 'validate'\n          })\n        });\n\n        results.details.process = {\n          status: testResponse.status,\n          ok: testResponse.ok,\n          endpoint: FILE_PROCESSOR_CONFIG.endpoints?.PROCESS || '/api/process'\n        };\n\n        if (testResponse.ok || testResponse.status === 400) { // 400 is expected for invalid path\n          results.overall = true;\n          this.state.backendConnected = true;\n          this.state.lastHealthCheck = new Date();\n          this.showNotification('Backend connectivity verified', 'success', 'File Processor');\n        }\n      }\n\n      if (!results.overall) {\n        throw new Error(`Health endpoint returned ${healthResponse.status}`);\n      }\n\n    } catch (error) {\n      results.errors.push({\n        endpoint: FILE_PROCESSOR_CONFIG.endpoints?.HEALTH || '/api/health',\n        error: error.message\n      });\n      this.state.backendConnected = false;\n      this.showNotification(`Backend connectivity failed: ${error.message}`, 'error', 'File Processor');\n    }\n\n    return results;\n  }\n\n  /**\n   * Get file processor health status\n   * @returns {Object} Health status information\n   */\n  getHealthStatus() {\n    return {\n      module: 'fileProcessor',\n      version: '4.0.0',\n      status: this.state.isInitialized ? 'healthy' : 'initializing',\n      features: {\n        configurationDriven: true,\n        enhancedNotifications: true,\n        backendConnectivity: true,\n        fileProcessing: true,\n        progressTracking: true\n      },\n      configuration: {\n        endpoints: FILE_PROCESSOR_CONFIG.endpoints,\n        supportedFormats: this.config.supportedFormats?.length || 0,\n        maxFileSize: this.config.maxFileSize,\n        maxBatchSize: this.config.maxBatchSize\n      },\n      state: {\n        initialized: this.state.isInitialized,\n        currentTask: this.state.currentTask,\n        processingState: this.state.processingState,\n        backendConnected: this.state.backendConnected,\n        lastHealthCheck: this.state.lastHealthCheck\n      }\n    };\n  }\n\n  /**\n   * Initialize the File Processor module with enhanced Blueprint architecture integration\n   */\n  async init() {\n    if (this.state.isInitialized) return;\n    \n    try {\n      console.log('📁 Initializing File Processor v4.0...');\n      \n      // Initialize imports with fallbacks first\n      await initializeImports();\n      \n      // Initialize configuration after imports\n      FILE_PROCESSOR_CONFIG = {\n        endpoints: API_ENDPOINTS?.FILE_PROCESSING || {\n          PROCESS: '/api/process',\n          HEALTH: '/api/health',\n          CANCEL: '/api/cancel/:taskId'\n        },\n        blueprint: BLUEPRINT_ROUTES?.file_processor || '/api',\n        constants: CONSTANTS?.FILE_PROCESSOR || CONSTANTS || {},\n        api: API_CONFIG || { API_TIMEOUT: 30000 },\n        socket: SOCKET_CONFIG || {}\n      };\n      \n      // Update config with actual values after imports\n      this.config = {\n        supportedFormats: FILE_PROCESSOR_CONFIG.constants.ALLOWED_EXTENSIONS || CONSTANTS?.ALLOWED_EXTENSIONS || this.config.supportedFormats,\n        maxFileSize: FILE_PROCESSOR_CONFIG.constants.MAX_FILE_SIZE || CONSTANTS?.MAX_FILE_SIZE || this.config.maxFileSize,\n        maxBatchSize: FILE_PROCESSOR_CONFIG.constants.MAX_BATCH_SIZE || CONSTANTS?.MAX_BATCH_SIZE || this.config.maxBatchSize,\n        chunkSize: FILE_PROCESSOR_CONFIG.constants.CHUNK_SIZE || CONSTANTS?.CHUNK_SIZE || this.config.chunkSize\n      };\n      \n      this.showNotification('Initializing File Processor v4.0', 'info', 'File Processor');\n      \n      // Cache DOM elements first\n      this.cacheElements();\n      \n      // Setup event handlers (most critical for preventing page refresh)\n      this.setupEventHandlers();\n      \n      // Setup other components\n      this.setupSocketHandlers();\n      this.setupFormValidation();\n      \n      // Test backend connectivity last (non-critical)\n      try {\n        await this.testBackendConnectivity();\n      } catch (error) {\n        console.warn('Backend connectivity test failed, but continuing:', error);\n      }\n      \n      this.state.isInitialized = true;\n      this.showNotification('File Processor v4.0 initialized successfully', 'success', 'File Processor');\n      console.log('✅ File Processor v4.0 initialized successfully');\n      \n    } catch (error) {\n      console.error('❌ File Processor initialization failed:', error);\n      this.showNotification(`File Processor initialization failed: ${error.message}`, 'error', 'File Processor');\n      // Don't throw - allow graceful degradation\n    }\n  }\n\n  /**\n   * Cache DOM elements for efficient access\n   */\n  cacheElements() {\n    const elementIds = [\n      'process-form',\n      'form-container',\n      'input-dir',\n      'output-file', \n      'submit-btn',\n      'progress-container',\n      'progress-bar',\n      'progress-status',\n      'progress-stats',\n      'result-container',\n      'result-stats',\n      'open-btn',\n      'new-task-btn',\n      'error-container',\n      'error-message', \n      'error-details',\n      'retry-btn',\n      'cancel-btn'\n    ];\n\n    elementIds.forEach(id => {\n      const element = document.getElementById(id);\n      if (element) {\n        this.state.elements.set(id, element);\n        console.log(`✅ [FileProcessor] Cached element: ${id}`);\n      } else {\n        console.warn(`⚠️ [FileProcessor] Element not found: ${id}`);\n      }\n    });\n  }\n\n  /**\n   * Setup event handlers for UI interactions\n   */\n  setupEventHandlers() {\n    console.log('📁 Setting up File Processor event handlers...');\n    \n    // Form submission (CRITICAL - prevents page refresh)\n    const form = this.state.elements.get('process-form');\n    if (form) {\n      const submitHandler = (e) => {\n        console.log('📁 Form submit intercepted by File Processor');\n        e.preventDefault();\n        e.stopPropagation();\n        this.handleFormSubmit();\n        return false;\n      };\n      \n      form.addEventListener('submit', submitHandler, true); // Use capture phase\n      this.state.eventListeners.add(() => form.removeEventListener('submit', submitHandler, true));\n      console.log('✅ Form submission handler attached');\n    } else {\n      console.error('❌ Form element not found - form submission will cause page refresh!');\n    }\n\n    // Start button (backup handler)\n    const startBtn = this.state.elements.get('submit-btn');\n    if (startBtn) {\n      const clickHandler = (e) => {\n        console.log('📁 Submit button clicked by File Processor');\n        e.preventDefault();\n        e.stopPropagation();\n        this.startProcessing();\n        return false;\n      };\n      startBtn.addEventListener('click', clickHandler, true);\n      this.state.eventListeners.add(() => startBtn.removeEventListener('click', clickHandler, true));\n      console.log('✅ Submit button handler attached');\n    } else {\n      console.error('❌ Submit button not found - button clicks may not work!');\n    }\n\n    // Cancel button\n    const cancelBtn = this.state.elements.get('cancel-btn');\n    if (cancelBtn) {\n      const clickHandler = (e) => {\n        e.preventDefault();\n        this.cancelProcessing();\n      };\n      cancelBtn.addEventListener('click', clickHandler);\n      this.state.eventListeners.add(() => cancelBtn.removeEventListener('click', clickHandler));\n      console.log('✅ Cancel button handler attached');\n    }\n\n    // Input validation\n    this.setupInputValidation();\n    \n    console.log('📁 File Processor event handlers setup complete');\n  }\n\n  /**\n   * Setup Socket.IO event handlers using Blueprint events\n   */\n  setupSocketHandlers() {\n    if (!window.socket) return;\n\n    console.log('📡 [FileProcessor] Setting up socket handlers...', {\n      events: TASK_EVENTS,\n      socketReady: !!window.socket.connected\n    });\n\n    // Task started\n    const taskStartedHandler = (data) => {\n      console.log('📡 [FileProcessor] Task started event:', data);\n      if (data.task_id === this.state.currentTask?.id) {\n        this.handleTaskStarted(data);\n      }\n    };\n    window.socket.on(TASK_EVENTS.STARTED, taskStartedHandler);\n    this.state.socketListeners.add(() => window.socket.off(TASK_EVENTS.STARTED, taskStartedHandler));\n\n    // Progress updates\n    const progressHandler = (data) => {\n      console.log('📡 [FileProcessor] Progress event received:', data);\n      console.log('📡 [FileProcessor] Task comparison:', {\n        received: data.task_id,\n        current: this.state.currentTask?.id,\n        match: data.task_id === this.state.currentTask?.id\n      });\n      \n      if (data.task_id === this.state.currentTask?.id) {\n        this.handleProgressUpdate(data);\n      } else {\n        console.log('📡 [FileProcessor] Progress event ignored - task ID mismatch');\n      }\n    };\n    window.socket.on(TASK_EVENTS.PROGRESS, progressHandler);\n    this.state.socketListeners.add(() => window.socket.off(TASK_EVENTS.PROGRESS, progressHandler));\n\n    // Task completed\n    const completedHandler = (data) => {\n      if (data.task_id === this.state.currentTask?.id) {\n        this.handleTaskCompleted(data);\n      }\n    };\n    window.socket.on(TASK_EVENTS.COMPLETED, completedHandler);\n    this.state.socketListeners.add(() => window.socket.off(TASK_EVENTS.COMPLETED, completedHandler));\n\n    // Task error\n    const errorHandler = (data) => {\n      if (data.task_id === this.state.currentTask?.id) {\n        this.handleTaskError(data);\n      }\n    };\n    window.socket.on(TASK_EVENTS.ERROR, errorHandler);\n    this.state.socketListeners.add(() => window.socket.off(TASK_EVENTS.ERROR, errorHandler));\n\n    // File-specific events\n    const fileProcessedHandler = (data) => {\n      if (data.task_id === this.state.currentTask?.id) {\n        this.handleFileProcessed(data);\n      }\n    };\n    window.socket.on('file_processed', fileProcessedHandler);\n    this.state.socketListeners.add(() => window.socket.off('file_processed', fileProcessedHandler));\n  }\n\n  /**\n   * Setup form validation\n   */\n  setupFormValidation() {\n    const inputDir = this.state.elements.get('input-dir');\n    const outputFile = this.state.elements.get('output-file');\n\n    if (inputDir) {\n      inputDir.addEventListener('input', () => this.validateForm());\n    }\n    if (outputFile) {\n      outputFile.addEventListener('input', () => this.validateForm());\n    }\n  }\n\n  /**\n   * Setup input validation with real-time feedback\n   */\n  setupInputValidation() {\n    const inputDir = this.state.elements.get('input-dir');\n    const outputFile = this.state.elements.get('output-file');\n\n    if (inputDir) {\n      inputDir.addEventListener('blur', async () => {\n        const path = inputDir.value.trim();\n        if (path) {\n          await this.validatePath(path);\n        }\n      });\n    }\n\n    if (outputFile) {\n      outputFile.addEventListener('blur', () => {\n        const filename = outputFile.value.trim();\n        if (filename) {\n          this.validateOutputFilename(filename);\n        }\n      });\n    }\n  }\n\n  /**\n   * Validate file path using Blueprint API\n   */\n  async validatePath(path) {\n    try {\n      const result = await blueprintApi.verifyPath(path);\n      \n      const inputDir = this.state.elements.get('input-dir');\n      if (inputDir) {\n        inputDir.classList.remove('is-invalid', 'is-valid');\n        \n        if (result.valid) {\n          inputDir.classList.add('is-valid');\n          this.showFieldFeedback(inputDir, 'Valid directory path', 'valid');\n        } else {\n          inputDir.classList.add('is-invalid');\n          this.showFieldFeedback(inputDir, result.error || 'Invalid path', 'invalid');\n        }\n      }\n      \n      return result.valid;\n      \n    } catch (error) {\n      console.warn('Path validation failed:', error);\n      return true; // Allow processing to continue if validation fails\n    }\n  }\n\n  /**\n   * Validate output filename\n   */\n  validateOutputFilename(filename) {\n    const outputFile = this.state.elements.get('output-file');\n    if (!outputFile) return true;\n\n    outputFile.classList.remove('is-invalid', 'is-valid');\n\n    // Check filename length\n    if (filename.length > CONSTANTS.MAX_FILENAME_LENGTH) {\n      outputFile.classList.add('is-invalid');\n      this.showFieldFeedback(outputFile, 'Filename too long', 'invalid');\n      return false;\n    }\n\n    // Check for invalid characters (Windows compatibility)\n    if (CONSTANTS.WINDOWS_INVALID_CHARS.test(filename)) {\n      outputFile.classList.add('is-invalid');\n      this.showFieldFeedback(outputFile, 'Contains invalid characters', 'invalid');\n      return false;\n    }\n\n    // Check for reserved names\n    const baseName = filename.split('.')[0].toUpperCase();\n    if (CONSTANTS.WINDOWS_RESERVED_NAMES.includes(baseName)) {\n      outputFile.classList.add('is-invalid');\n      this.showFieldFeedback(outputFile, 'Reserved filename', 'invalid');\n      return false;\n    }\n\n    outputFile.classList.add('is-valid');\n    this.showFieldFeedback(outputFile, 'Valid filename', 'valid');\n    return true;\n  }\n\n  /**\n   * Show field validation feedback\n   */\n  showFieldFeedback(element, message, type) {\n    // Remove existing feedback\n    const existingFeedback = element.parentNode.querySelector('.feedback-message');\n    if (existingFeedback) {\n      existingFeedback.remove();\n    }\n\n    // Add new feedback\n    const feedback = document.createElement('div');\n    feedback.className = `feedback-message ${type === 'valid' ? 'text-success' : 'text-danger'} small mt-1`;\n    feedback.textContent = message;\n    element.parentNode.appendChild(feedback);\n  }\n\n  /**\n   * Validate entire form\n   */\n  validateForm() {\n    const inputDir = this.state.elements.get('input-dir')?.value.trim();\n    const outputFile = this.state.elements.get('output-file')?.value.trim();\n    const startBtn = this.state.elements.get('submit-btn');\n\n    const isValid = inputDir && outputFile && this.state.processingState === 'idle';\n\n    if (startBtn) {\n      startBtn.disabled = !isValid;\n    }\n\n    return isValid;\n  }\n\n  /**\n   * Handle form submission\n   */\n  async handleFormSubmit() {\n    console.log('📁 File Processor handleFormSubmit called');\n    \n    try {\n      if (!this.validateForm()) {\n        console.log('📁 Form validation failed');\n        return;\n      }\n      \n      console.log('📁 Form validation passed, starting processing...');\n      await this.startProcessing();\n      \n    } catch (error) {\n      console.error('❌ Form submission error:', error);\n      this.showNotification(`Form submission failed: ${error.message}`, 'error');\n    }\n  }\n\n  /**\n   * Enhanced SocketIO connection establishment with robust retry mechanisms\n   */\n  async waitForSocketConnection(timeoutMs = 15000) {\n    console.log('📡 [FileProcessor] Enhanced SocketIO connection check...');\n    \n    // Check if already connected\n    if (window.socket?.connected) {\n      console.log('✅ [FileProcessor] SocketIO already connected');\n      return { connected: true, fallback: false };\n    }\n    \n    // First, try to initialize SocketIO if it doesn't exist\n    if (!window.socket) {\n      console.log('🔧 [FileProcessor] SocketIO not found, attempting initialization...');\n      const initResult = await this.initializeSocketIO();\n      if (!initResult) {\n        console.warn('⚠️ [FileProcessor] Failed to initialize SocketIO');\n        return { connected: false, fallback: true };\n      }\n    }\n    \n    return new Promise((resolve) => {\n      const startTime = Date.now();\n      let attemptCount = 0;\n      const maxAttempts = 5;\n      const retryDelay = 1000; // 1 second between retries\n      \n      const attemptConnection = async () => {\n        attemptCount++;\n        console.log(`📡 [FileProcessor] Connection attempt ${attemptCount}/${maxAttempts}`);\n        \n        // Check current connection status\n        if (window.socket?.connected) {\n          console.log('✅ [FileProcessor] SocketIO connection established');\n          resolve({ connected: true, fallback: false });\n          return;\n        }\n        \n        // Check for timeout\n        const elapsed = Date.now() - startTime;\n        if (elapsed > timeoutMs) {\n          console.warn(`⚠️ [FileProcessor] SocketIO connection timeout after ${elapsed}ms`);\n          resolve({ connected: false, fallback: true });\n          return;\n        }\n        \n        // If we have attempts left, try to reconnect\n        if (attemptCount < maxAttempts && window.socket && !window.socket.connected) {\n          try {\n            console.log('🔄 [FileProcessor] Attempting manual reconnection...');\n            window.socket.connect();\n            \n            // Wait for connection result\n            setTimeout(() => {\n              if (window.socket?.connected) {\n                console.log('✅ [FileProcessor] Manual reconnection successful');\n                resolve({ connected: true, fallback: false });\n              } else {\n                // Try again after delay\n                setTimeout(attemptConnection, retryDelay);\n              }\n            }, 1500);\n          } catch (error) {\n            console.error('❌ [FileProcessor] Error during manual reconnection:', error);\n            setTimeout(attemptConnection, retryDelay);\n          }\n        } else if (attemptCount >= maxAttempts) {\n          console.warn('⚠️ [FileProcessor] Max connection attempts reached, falling back');\n          resolve({ connected: false, fallback: true });\n        } else {\n          // Continue checking\n          setTimeout(attemptConnection, 200);\n        }\n      };\n      \n      // Start connection attempts\n      attemptConnection();\n    });\n  }\n\n  /**\n   * Initialize SocketIO connection if not present\n   */\n  async initializeSocketIO() {\n    try {\n      // Check if Socket.IO library is loaded\n      if (typeof io === 'undefined') {\n        console.error('❌ [FileProcessor] Socket.IO library not loaded');\n        return false;\n      }\n      \n      // Check if socket is already being initialized\n      if (window._socketInitializing) {\n        console.log('🔄 [FileProcessor] Socket already being initialized, waiting...');\n        return new Promise((resolve) => {\n          const checkInit = () => {\n            if (!window._socketInitializing) {\n              resolve(!!window.socket);\n            } else {\n              setTimeout(checkInit, 100);\n            }\n          };\n          setTimeout(checkInit, 100);\n        });\n      }\n      \n      window._socketInitializing = true;\n      \n      console.log('🚀 [FileProcessor] Initializing SocketIO connection...');\n      \n      // Initialize socket with enhanced configuration\n      window.socket = io({\n        reconnection: true,\n        reconnectionAttempts: 10,\n        reconnectionDelay: 1000,\n        reconnectionDelayMax: 5000,\n        timeout: 10000,\n        forceNew: false,\n        multiplex: true,\n        transports: ['websocket', 'polling']\n      });\n      \n      // Set up connection event handlers\n      window.socket.on('connect', () => {\n        console.log('✅ [FileProcessor] SocketIO connected successfully');\n        window._socketInitializing = false;\n      });\n      \n      window.socket.on('connect_error', (error) => {\n        console.error('❌ [FileProcessor] SocketIO connection error:', error);\n      });\n      \n      window.socket.on('disconnect', (reason) => {\n        console.warn('⚠️ [FileProcessor] SocketIO disconnected:', reason);\n      });\n      \n      // Wait up to 5 seconds for initial connection\n      return new Promise((resolve) => {\n        const timeout = setTimeout(() => {\n          window._socketInitializing = false;\n          resolve(false);\n        }, 5000);\n        \n        window.socket.on('connect', () => {\n          clearTimeout(timeout);\n          window._socketInitializing = false;\n          resolve(true);\n        });\n      });\n      \n    } catch (error) {\n      console.error('❌ [FileProcessor] Error initializing SocketIO:', error);\n      window._socketInitializing = false;\n      return false;\n    }\n  }\n\n  /**\n   * Start file processing using Blueprint API\n   */\n  async startProcessing() {\n    try {\n      const inputDir = this.state.elements.get('input-dir')?.value.trim();\n      const outputFile = this.state.elements.get('output-file')?.value.trim();\n\n      if (!inputDir || !outputFile) {\n        this.showError('Please fill in all required fields');\n        return;\n      }\n\n      this.state.processingState = 'processing';\n      \n      // Reset completion state for new task\n      this.state.completionState = {\n        completed: false,\n        completionTime: null,\n        error: false,\n        cancelled: false\n      };\n      \n      // Initialize progress tracking\n      this.state.lastProgressTimestamp = Date.now();\n      this.state.lastReportedProgress = 0;\n      this.state.progressUpdateCount = 0;\n      this.state.progressRates = [];\n      this.state.processingStartTime = Date.now();\n      \n      this.updateUI();\n      \n      // Transition from form to progress container immediately\n      this.showProgressContainer();\n      this.showProgress(0, 'Waiting for SocketIO connection...');\n\n      // ENHANCED: Wait for SocketIO connection with improved retry logic\n      const connectionResult = await this.waitForSocketConnection(8000);\n      if (!connectionResult.connected) {\n        if (connectionResult.fallback) {\n          this.showProgress(5, 'No real-time connection, using fallback polling...');\n          this.showNotification('Using fallback mode - progress updates may be delayed', 'warning');\n        }\n      } else {\n        this.showProgress(10, 'Real-time connection established, starting processing...');\n        this.showNotification('Connected to real-time progress updates', 'success');\n      }\n\n      // Start processing using Blueprint API\n      const response = await blueprintApi.processFiles(inputDir, outputFile, {\n        formats: this.config.supportedFormats,\n        max_size: this.config.maxFileSize,\n        chunk_size: this.config.chunkSize\n      });\n      \n      // Update progress immediately after API call\n      this.showProgress(15, 'Processing request submitted, task started...');\n\n      // Store task information\n      this.state.currentTask = {\n        id: response.task_id,\n        inputDir,\n        outputFile,\n        startTime: Date.now()\n      };\n\n      console.log(`📁 File processing started: ${response.task_id}`);\n      console.log(`📁 Socket connected: ${!!window.socket?.connected}, Current task stored:`, this.state.currentTask);\n      \n      // Start progress tracking using existing progressHandler\n      await this.initializeProgressTracking(response.task_id);\n      \n      // Start enhanced fallback progress monitoring with HTTP polling\n      this.startEnhancedFallbackMonitoring(response.task_id, connectionResult.fallback);\n      \n      this.showInfo(`Processing started for: ${inputDir}`);\n\n    } catch (error) {\n      console.error('❌ Failed to start processing:', error);\n      this.handleTaskError({ error: error.message });\n    }\n  }\n\n\n  /**\n   * Start enhanced fallback progress monitoring with improved polling and multiple endpoints\n   */\n  startEnhancedFallbackMonitoring(taskId, forceFallback = false) {\n    console.log(`🔄 [FileProcessor] Starting enhanced fallback monitoring for: ${taskId} (force: ${forceFallback})`);\n    \n    // Clear any existing timers\n    this.clearAllTimers();\n    \n    // Set up enhanced monitoring parameters\n    let pollCount = 0;\n    let consecutiveErrors = 0;\n    let lastProgressUpdate = Date.now();\n    let lastReportedProgress = 0;\n    const maxPollAttempts = 150; // 12.5 minutes with 5s interval\n    const maxConsecutiveErrors = 5;\n    \n    // Different polling intervals based on connection status\n    const baseInterval = forceFallback ? 3000 : 5000; // 3s if forced fallback, 5s otherwise\n    let currentInterval = baseInterval;\n    \n    // Track polling status\n    this.state.statusPollingTimer = setInterval(async () => {\n      try {\n        pollCount++;\n        \n        // Stop polling if task is no longer active or completed\n        if (!this.state.currentTask || this.state.currentTask.id !== taskId || \n            this.state.processingState === 'completed' ||\n            this.state.completionState.completed) {\n          console.log(`🛑 [FileProcessor] Stopping fallback monitoring - task no longer active`);\n          this.clearAllTimers();\n          return;\n        }\n        \n        // Check if we've received recent SocketIO updates (only if not forced fallback)\n        if (!forceFallback) {\n          const timeSinceLastUpdate = Date.now() - this.state.lastProgressTimestamp;\n          if (timeSinceLastUpdate < 8000) {\n            console.log(`📡 [FileProcessor] Recent SocketIO updates detected, reducing polling frequency`);\n            currentInterval = Math.min(currentInterval * 1.5, 15000); // Gradually reduce frequency\n            return;\n          }\n        }\n        \n        // Try multiple API endpoints for better reliability\n        const statusData = await this.fetchTaskStatusFromMultipleEndpoints(taskId);\n        \n        if (statusData) {\n          consecutiveErrors = 0; // Reset error counter on success\n          \n          // Handle different status types\n          if (statusData.status === 'completed' || statusData.progress >= 100) {\n            console.log(`✅ [FileProcessor] Enhanced fallback detected completion for: ${taskId}`);\n            this.handleTaskCompleted({\n              task_id: taskId,\n              progress: 100,\n              message: 'Task completed successfully',\n              ...statusData\n            });\n            this.clearAllTimers();\n            return;\n          } \n          else if (statusData.status === 'error' || statusData.status === 'failed') {\n            console.log(`❌ [FileProcessor] Enhanced fallback detected error for: ${taskId}`);\n            this.handleTaskError({\n              task_id: taskId,\n              error: statusData.error || 'Task failed',\n              ...statusData\n            });\n            this.clearAllTimers();\n            return;\n          }\n          else if (statusData.status === 'cancelled') {\n            console.log(`🚫 [FileProcessor] Enhanced fallback detected cancellation for: ${taskId}`);\n            this.handleTaskCancelled({\n              task_id: taskId,\n              ...statusData\n            });\n            this.clearAllTimers();\n            return;\n          }\n          else if (statusData.progress !== undefined) {\n            // Update progress if it has changed significantly\n            if (Math.abs(statusData.progress - lastReportedProgress) >= 1) {\n              console.log(`📊 [FileProcessor] Enhanced fallback progress update: ${statusData.progress}%`);\n              this.handleProgressUpdate({\n                task_id: taskId,\n                progress: statusData.progress,\n                message: statusData.message || `Processing... ${statusData.progress.toFixed(1)}%`,\n                stats: statusData.stats || {}\n              });\n              lastReportedProgress = statusData.progress;\n              lastProgressUpdate = Date.now();\n              \n              // Reset interval on progress update\n              currentInterval = baseInterval;\n            }\n          }\n        } else {\n          consecutiveErrors++;\n          console.warn(`⚠️ [FileProcessor] Error fetching status (${consecutiveErrors}/${maxConsecutiveErrors})`);\n          \n          // If too many consecutive errors, slow down polling\n          if (consecutiveErrors >= maxConsecutiveErrors) {\n            currentInterval = Math.min(currentInterval * 2, 30000); // Max 30s interval\n            console.warn(`⚠️ [FileProcessor] Too many errors, slowing polling to ${currentInterval}ms`);\n          }\n        }\n        \n        // Check for stuck task (no progress for extended period)\n        const timeSinceProgress = Date.now() - lastProgressUpdate;\n        if (timeSinceProgress > 60000 && lastReportedProgress > 0 && lastReportedProgress < 100) {\n          console.warn(`⏰ [FileProcessor] Task appears stuck at ${lastReportedProgress}% for ${timeSinceProgress/1000}s`);\n          // Force a completion check\n          await this.forceCompletionCheck(taskId);\n        }\n        \n        // Stop polling after max attempts\n        if (pollCount > maxPollAttempts) {\n          console.warn(`⏰ [FileProcessor] Enhanced fallback polling timeout for: ${taskId} after ${pollCount} attempts`);\n          this.clearAllTimers();\n          \n          // Try one final completion check\n          await this.forceCompletionCheck(taskId);\n        }\n        \n      } catch (error) {\n        consecutiveErrors++;\n        console.error(`❌ [FileProcessor] Enhanced fallback polling error (attempt ${pollCount}):`, error);\n        \n        // If too many consecutive errors, give up\n        if (consecutiveErrors >= maxConsecutiveErrors * 2) {\n          console.error(`❌ [FileProcessor] Too many consecutive errors, stopping fallback monitoring`);\n          this.clearAllTimers();\n        }\n      }\n    }, currentInterval);\n    \n    console.log(`✅ [FileProcessor] Enhanced fallback monitoring started with ${currentInterval}ms interval`);\n  }\n\n  /**\n   * Clear all monitoring timers\n   */\n  clearAllTimers() {\n    if (this.state.fallbackTimer) {\n      clearInterval(this.state.fallbackTimer);\n      this.state.fallbackTimer = null;\n    }\n    if (this.state.statusPollingTimer) {\n      clearInterval(this.state.statusPollingTimer);\n      this.state.statusPollingTimer = null;\n    }\n    console.log('🧹 [FileProcessor] All monitoring timers cleared');\n  }\n\n  /**\n   * Fetch task status from multiple endpoints for better reliability\n   */\n  async fetchTaskStatusFromMultipleEndpoints(taskId) {\n    const endpoints = [\n      `/api/task/${taskId}/status`,\n      `/api/status/${taskId}`,\n      `/api/task_status/${taskId}`,\n      `/api/progress/${taskId}`\n    ];\n    \n    for (const endpoint of endpoints) {\n      try {\n        const response = await fetch(endpoint, {\n          method: 'GET',\n          headers: {\n            'Content-Type': 'application/json',\n            'Cache-Control': 'no-cache'\n          }\n        });\n        \n        if (response.ok) {\n          const data = await response.json();\n          console.log(`📡 [FileProcessor] Status fetched from ${endpoint}:`, data);\n          return data;\n        } else if (response.status === 404) {\n          // Task might be completed, try the next endpoint\n          continue;\n        }\n      } catch (error) {\n        console.warn(`⚠️ [FileProcessor] Error fetching from ${endpoint}:`, error.message);\n        continue;\n      }\n    }\n    \n    return null;\n  }\n\n  /**\n   * Force a completion check when task appears stuck\n   */\n  async forceCompletionCheck(taskId) {\n    try {\n      console.log(`🔍 [FileProcessor] Forcing completion check for potentially stuck task: ${taskId}`);\n      \n      // Try to get final status\n      const finalStatus = await this.fetchTaskStatusFromMultipleEndpoints(taskId);\n      \n      if (finalStatus) {\n        if (finalStatus.status === 'completed' || finalStatus.progress >= 100) {\n          console.log(`✅ [FileProcessor] Force check confirmed completion`);\n          this.handleTaskCompleted({\n            task_id: taskId,\n            progress: 100,\n            message: 'Task completed (force check)',\n            ...finalStatus\n          });\n        } else if (finalStatus.status === 'error' || finalStatus.status === 'failed') {\n          console.log(`❌ [FileProcessor] Force check detected error`);\n          this.handleTaskError({\n            task_id: taskId,\n            error: finalStatus.error || 'Task failed during force check',\n            ...finalStatus\n          });\n        } else {\n          console.log(`🔄 [FileProcessor] Force check shows task still running: ${finalStatus.progress}%`);\n        }\n      } else {\n        console.warn(`⚠️ [FileProcessor] Force check could not determine task status, assuming completion`);\n        // As a last resort, assume completion\n        this.handleTaskCompleted({\n          task_id: taskId,\n          progress: 100,\n          message: 'Task completed (assumed after timeout)',\n          stats: {}\n        });\n      }\n    } catch (error) {\n      console.error(`❌ [FileProcessor] Error in force completion check:`, error);\n    }\n  }\n\n  /**\n   * Initialize progress tracking using Enterprise ProgressHandler v6.0\n   */\n  async initializeProgressTracking(taskId) {\n    try {\n      console.log(`📊 [FileProcessor] Initializing Enterprise progress tracking for: ${taskId}`);\n      \n      // Import Enterprise progressHandler v6.0\n      const progressHandlerModule = await import('../utils/progressHandler.js');\n      const { trackProgress } = progressHandlerModule;\n      \n      // Initialize the progress handler if needed\n      if (typeof progressHandlerModule.default === 'function' && !window.progressHandlerInitialized) {\n        await progressHandlerModule.default();\n        window.progressHandlerInitialized = true;\n        console.log('📊 [FileProcessor] Enterprise ProgressHandler v6.0 initialized');\n      }\n      \n      // Start tracking this specific task with v6.0 Enterprise API\n      if (trackProgress) {\n        console.log(`📊 [FileProcessor] Starting Enterprise progress tracking...`);\n        const tracker = trackProgress(taskId, {\n          targetElement: 'progress-container',\n          taskType: 'file_processing',\n          module: 'file_processing',\n          elementPrefix: '', // File processing uses default IDs (no prefix)\n          buttonId: 'submit-btn', // Link to the submit button\n          // Let FileProcessor handle its own UI updates\n          customUIHandler: true\n        });\n        \n        // Store tracker for cleanup\n        this.state.progressTracker = tracker;\n        \n        console.log(`📊 [FileProcessor] Enterprise progress tracking active for task: ${taskId}`);\n        \n        // Ensure progress container is immediately visible and show connection status\n        if (window.socket?.connected) {\n          this.showProgress(20, 'Connected to processing service, monitoring progress...');\n        } else {\n          this.showProgress(20, 'Starting processing (limited real-time updates)...');\n        }\n      }\n      \n    } catch (error) {\n      console.error('❌ Failed to initialize Enterprise progress tracking:', error);\n      this.showNotification(`Progress tracking failed: ${error.message}`, 'warning');\n      // Continue without progress tracking - graceful degradation\n    }\n  }\n\n  /**\n   * Cancel current processing task\n   */\n  async cancelProcessing() {\n    if (!this.state.currentTask) return;\n\n    try {\n      const success = await blueprintApi.cancelTask(this.state.currentTask.id);\n      console.log(`🚫 Processing cancelled: ${this.state.currentTask.id}`);\n      \n      if (success) {\n        // Reset UI state immediately\n        this.state.processingState = 'cancelled';\n        this.state.currentTask = null;\n        \n        // Show form again\n        this.showForm();\n        \n        // Display cancellation message\n        this.showProgress(0, 'Processing cancelled by user');\n        \n        // Hide progress after brief delay\n        setTimeout(() => {\n          this.showForm();\n        }, 1500);\n      }\n      \n    } catch (error) {\n      console.error('❌ Failed to cancel processing:', error);\n      // Still reset UI on error to prevent stuck state\n      this.showForm();\n    }\n  }\n\n  /**\n   * Handle task started event\n   */\n  handleTaskStarted(data) {\n    console.log('🚀 File processing task started:', data);\n    this.showProgress(0, 'Starting file processing...');\n  }\n\n  /**\n   * Handle progress update with sophisticated completion detection and stuck task monitoring\n   */\n  handleProgressUpdate(data) {\n    try {\n      console.log(`📊 [FileProcessor] Progress update received:`, data);\n      \n      if (!data || !data.task_id || data.task_id !== this.state.currentTask?.id) {\n        console.log('📊 [FileProcessor] Progress update ignored - task ID mismatch');\n        return;\n      }\n      \n      let progress = Math.min(100, Math.max(0, data.progress || 0));\n      const message = data.message || `Processing... ${progress.toFixed(1)}%`;\n      \n      // Enhanced progress handling to avoid visual stutter at 99%\n      if (progress >= 99 && progress < 100) {\n        // If status indicates completion, jump to 100%\n        if (data.status === \"completed\" || this.isCompletionPhase(data)) {\n          progress = 100;\n          console.log(\"🎯 [FileProcessor] Forcing progress to 100% due to completion indicators\");\n        }\n        // If we're already showing 99%+ and status isn't completed, be conservative\n        else if (this.state.lastReportedProgress >= 99) {\n          if (progress > this.state.lastReportedProgress) {\n            console.log(`📊 [FileProcessor] Updating from ${this.state.lastReportedProgress}% to ${progress}%`);\n          } else {\n            console.log(`📊 [FileProcessor] Skipping progress update: current ${this.state.lastReportedProgress}%, new ${progress}%`);\n            return;\n          }\n        }\n      }\n      \n      // Store progress metrics for ETA calculation\n      this.updateProgressMetrics(progress);\n      \n      // Update progress display\n      this.showProgress(progress, message);\n      \n      // Update stats if available\n      if (data.stats) {\n        this.updateStats(data.stats);\n      }\n      \n      // Store last reported progress\n      this.state.lastReportedProgress = progress;\n      this.state.progressUpdateCount++;\n      \n      // Enhanced completion detection with multiple sophisticated triggers\n      const isCompleted = \n        (data.status === \"completed\") || \n        (progress >= 99 && data.stats && data.stats.status === \"completed\") ||\n        (progress >= 99.9) ||\n        (progress >= 99 && this.isCompletionPhase(data)) ||\n        (data.stats && data.stats.current_stage === 'Completed') ||\n        (data.stats && data.stats.completion_percentage >= 100) ||\n        (progress >= 99 && data.stats && \n         data.stats.processed_files === data.stats.total_files);\n      \n      if (isCompleted && this.state.processingState === 'processing' && !this.state.completionState.completed) {\n        console.log('🎉 [FileProcessor] Completion detected via progress update');\n        console.log('📊 [FileProcessor] Completion triggers:', {\n          progress_100: progress >= 100,\n          status_completed: data.status === \"completed\",\n          stage_completed: data.stats?.current_stage === 'Completed',\n          completion_pct_100: data.stats?.completion_percentage >= 100,\n          completion_phase: this.isCompletionPhase(data),\n          files_match: data.stats?.processed_files === data.stats?.total_files,\n          processing_state: this.state.processingState,\n          stats: data.stats\n        });\n        \n        // Force progress to 100% for completed tasks\n        this.showProgress(100, data.message || \"Task completed successfully\", data.stats);\n        \n        // Complete the task immediately - no delay needed\n        console.log('🎯 [FileProcessor] Completing task immediately...');\n        this.handleTaskCompleted(data);\n      }\n      else if (data.status === \"failed\" || data.status === \"error\") {\n        this.handleTaskError(data);\n      } \n      else if (data.status === \"cancelled\") {\n        this.handleTaskCancelled(data);\n      }\n      \n      // Monitor for stuck tasks at high progress\n      this.monitorTaskProgress(data);\n      \n    } catch (error) {\n      console.error('❌ [FileProcessor] Error handling progress update:', error);\n      this.showNotification(`Progress update error: ${error.message}`, 'warning', 'File Processor');\n    }\n  }\n\n  /**\n   * Handle file processed event\n   */\n  handleFileProcessed(data) {\n    console.log('📄 File processed:', data);\n    // Could show individual file progress here\n  }\n\n  /**\n   * Enhanced task completion with comprehensive validation and triggering\n   */\n  handleTaskCompleted(data) {\n    try {\n      console.log('✅ [FileProcessor] Task completion received:', data);\n      console.log('🔍 [FileProcessor] DEBUGGING - Full data structure:', JSON.stringify(data, null, 2));\n      console.log('🔍 [FileProcessor] DEBUGGING - Stats field:', data.stats);\n      console.log('🔍 [FileProcessor] DEBUGGING - Stats type:', typeof data.stats);\n      \n      // Enhanced completion validation with multiple checks\n      if (!this.validateTaskCompletion(data)) {\n        console.log(\"❌ [FileProcessor] Task completion validation failed, ignoring\");\n        return;\n      }\n      \n      // Check if already completed with enhanced duplicate prevention\n      if (this.state.completionState.completed && \n          this.state.completionState.completionTime && \n          (Date.now() - this.state.completionState.completionTime < 3000)) {\n        console.log(\"📊 [FileProcessor] Task already marked as completed recently, preventing duplicate\");\n        return;\n      }\n      \n      // Mark as completed to prevent duplicate processing\n      this.state.completionState.completed = true;\n      this.state.completionState.completionTime = Date.now();\n      this.state.processingState = 'completed';\n      \n      console.log(\"🎉 [FileProcessor] Processing task completion with enhanced cleanup\");\n      \n      // Enhanced cleanup with multiple fallback timers\n      this.performEnhancedCleanup();\n      \n      // Enhanced UI update with immediate feedback\n      this.updateCompletionUI(data);\n      \n      // Trigger enhanced completion notifications\n      this.triggerCompletionNotifications(data);\n      \n      // Enhanced result display with better UX\n      this.displayEnhancedResults(data);\n      \n      console.log(\"✅ [FileProcessor] Enhanced task completion processing completed successfully\");\n      \n    } catch (error) {\n      console.error('❌ [FileProcessor] Error in enhanced task completion:', error);\n      this.showNotification(`Completion handling error: ${error.message}`, 'error', 'File Processor');\n      \n      // Fallback completion handling\n      this.performFallbackCompletion(data);\n    }\n  }\n\n  /**\n   * Validate task completion with multiple criteria\n   */\n  validateTaskCompletion(data) {\n    // Basic data validation\n    if (!data) {\n      console.warn('❌ [FileProcessor] No completion data provided');\n      return false;\n    }\n    \n    // Task ID validation\n    if (!data.task_id) {\n      console.warn('❌ [FileProcessor] No task ID in completion data');\n      return false;\n    }\n    \n    // Current task validation\n    if (this.state.currentTask && data.task_id !== this.state.currentTask.id) {\n      console.warn(`❌ [FileProcessor] Task ID mismatch: ${data.task_id} vs ${this.state.currentTask.id}`);\n      return false;\n    }\n    \n    // State validation - ensure we're still processing\n    if (this.state.processingState === 'idle') {\n      console.warn('❌ [FileProcessor] Completion received but not in processing state');\n      return false;\n    }\n    \n    console.log('✅ [FileProcessor] Task completion validation passed');\n    return true;\n  }\n\n  /**\n   * Perform enhanced cleanup with multiple safeguards\n   */\n  performEnhancedCleanup() {\n    try {\n      // Clear all monitoring timers\n      this.clearCompletionMonitoring();\n      \n      // Clear fallback timer with multiple checks\n      if (this.state.fallbackTimer) {\n        clearInterval(this.state.fallbackTimer);\n        this.state.fallbackTimer = null;\n        console.log('🧹 [FileProcessor] Fallback timer cleared');\n      }\n      \n      // Clear any status polling\n      if (this.state.statusPollingTimer) {\n        clearInterval(this.state.statusPollingTimer);\n        this.state.statusPollingTimer = null;\n        console.log('🧹 [FileProcessor] Status polling timer cleared');\n      }\n      \n      // Clean up session storage with validation\n      this.cleanupSessionState();\n      \n      // Reset processing state with validation\n      this.resetProcessingState();\n      \n      console.log('🧹 [FileProcessor] Enhanced cleanup completed');\n    } catch (error) {\n      console.error('❌ [FileProcessor] Error in enhanced cleanup:', error);\n    }\n  }\n\n  /**\n   * Update completion UI with enhanced feedback\n   */\n  updateCompletionUI(data) {\n    try {\n      // Update UI state immediately\n      this.updateUI();\n      \n      // Force progress to 100% with enhanced validation\n      const finalMessage = data.message || \"Task completed successfully!\";\n      this.showProgress(100, finalMessage, data.stats);\n      \n      // Ensure progress bar visual completion\n      const progressBar = this.state.elements.get('progress-bar');\n      if (progressBar) {\n        progressBar.style.width = '100%';\n        progressBar.setAttribute('aria-valuenow', 100);\n        progressBar.textContent = '100%';\n        progressBar.classList.remove('progress-bar-striped', 'progress-bar-animated');\n        progressBar.classList.add('bg-success');\n      }\n      \n      console.log('🎨 [FileProcessor] Completion UI updated');\n    } catch (error) {\n      console.error('❌ [FileProcessor] Error updating completion UI:', error);\n    }\n  }\n\n  /**\n   * Trigger enhanced completion notifications\n   */\n  triggerCompletionNotifications(data) {\n    try {\n      // Show primary success notification\n      this.showNotification('Processing completed successfully!', 'success', 'File Processor');\n      \n      // Complete tracking in progressHandler if available\n      this.completeProgressHandler(data);\n      \n      // Update state manager if available\n      if (window.stateManager && typeof window.stateManager.setProcessingActive === 'function') {\n        window.stateManager.setProcessingActive(false);\n        console.log('📊 [FileProcessor] State manager updated');\n      }\n      \n      // Trigger completion event for other modules\n      if (window.eventRegistry && typeof window.eventRegistry.emit === 'function') {\n        window.eventRegistry.emit('file.processing.completed', data);\n        console.log('📡 [FileProcessor] Completion event emitted');\n      }\n      \n      // Add completed task to history with delay for stats finalization\n      setTimeout(() => {\n        this.addTaskToHistory(data);\n      }, 300);\n      \n      console.log('📢 [FileProcessor] Completion notifications triggered');\n    } catch (error) {\n      console.error('❌ [FileProcessor] Error triggering completion notifications:', error);\n    }\n  }\n\n  /**\n   * Display enhanced results with better UX\n   */\n  displayEnhancedResults(data) {\n    try {\n      // Prepare enhanced result data\n      const enhancedData = {\n        stats: data.stats || {},\n        output_file: data.output_file || this.state.currentTask?.outputFile,\n        task_id: data.task_id || this.state.currentTask?.id,\n        progress: 100,\n        message: 'Processing completed successfully!',\n        completionTime: this.state.completionState.completionTime,\n        duration: this.state.currentTask ? (Date.now() - this.state.currentTask.startTime) : 0\n      };\n      \n      // IMMEDIATE transition to results - no delay\n      console.log('🎯 [FileProcessor] Transitioning to results immediately...');\n      this.showResult(enhancedData);\n      \n      console.log('🎯 [FileProcessor] Enhanced results displayed immediately');\n    } catch (error) {\n      console.error('❌ [FileProcessor] Error displaying enhanced results:', error);\n      \n      // Fallback to basic result display - also immediate\n      this.showResult({\n        stats: data.stats || {},\n        output_file: data.output_file,\n        task_id: data.task_id,\n        progress: 100,\n        message: 'Processing completed successfully!'\n      });\n    }\n  }\n\n  /**\n   * Fallback completion handling for error cases\n   */\n  performFallbackCompletion(data) {\n    try {\n      console.log('🔄 [FileProcessor] Performing fallback completion handling');\n      \n      // Basic state updates\n      this.state.processingState = 'completed';\n      this.state.completionState.completed = true;\n      this.state.completionState.completionTime = Date.now();\n      \n      // Basic UI updates\n      this.updateUI();\n      this.showProgress(100, \"Task completed (fallback mode)\");\n      \n      // Basic notifications\n      this.showNotification('Task completed (using fallback method)', 'success', 'File Processor');\n      \n      // Basic result display - immediate\n      console.log('🎯 [FileProcessor] Fallback completion - showing result immediately...');\n      this.showResult({\n        stats: data?.stats || {},\n        output_file: data?.output_file,\n        task_id: data?.task_id,\n        progress: 100,\n        message: 'Processing completed!'\n      });\n      \n      console.log('✅ [FileProcessor] Fallback completion handling completed');\n    } catch (error) {\n      console.error('❌ [FileProcessor] Error in fallback completion:', error);\n    }\n  }\n\n  /**\n   * Handle task error\n   */\n  handleTaskError(data) {\n    console.error('❌ File processing error:', data);\n    \n    this.state.processingState = 'error';\n    this.state.completionState.error = true;\n    this.clearCompletionMonitoring();\n    \n    // Clear fallback timer\n    if (this.state.fallbackTimer) {\n      clearInterval(this.state.fallbackTimer);\n      this.state.fallbackTimer = null;\n    }\n    \n    this.showError(data.error || 'Processing failed');\n    this.updateUI();\n  }\n\n  /**\n   * Handle task cancellation\n   */\n  handleTaskCancelled(data) {\n    console.log('🚫 File processing cancelled:', data);\n    \n    this.state.processingState = 'cancelled';\n    this.state.completionState.cancelled = true;\n    this.clearCompletionMonitoring();\n    this.showForm();\n    this.showNotification('Processing cancelled', 'warning', 'File Processor');\n  }\n\n  /**\n   * Helper function to check if data indicates completion phase\n   */\n  isCompletionPhase(data) {\n    return (\n      data.status === \"completed\" || \n      (data.stats && data.stats.status === \"completed\") ||\n      (data.message && (\n        data.message.toLowerCase().includes(\"complet\") ||\n        data.message.toLowerCase().includes(\"done\") ||\n        data.message.toLowerCase().includes(\"finish\")\n      )) ||\n      (data.progress >= 99.5) ||\n      (data.progress >= 99 && data.stats && \n       data.stats.processed_files === data.stats.total_files)\n    );\n  }\n\n  /**\n   * Monitor task progress and detect potentially stuck tasks\n   */\n  monitorTaskProgress(data) {\n    if (!this.state.completionMonitoring.enabled) return;\n    \n    try {\n      const { progress, task_id } = data;\n      \n      // Only monitor tasks at high progress percentages\n      if (progress < 95) return;\n      \n      // Clear any existing timeout for this task\n      this.clearCompletionMonitoring();\n      \n      // Set a timeout to check if the task is stuck\n      const timeoutId = setTimeout(() => {\n        // Only proceed if still in processing state and not already completed\n        if (this.state.processingState !== 'processing' || this.state.completionState.completed) return;\n        \n        console.log(`🔍 [FileProcessor] Checking if task ${task_id} is stuck at ${progress}%`);\n        \n        const currentTime = Date.now();\n        const lastUpdateTime = this.state.lastProgressTimestamp || 0;\n        const timeSinceUpdate = currentTime - lastUpdateTime;\n        \n        // If no updates for a while and at high percentage, task may be stuck\n        if (timeSinceUpdate > this.state.completionMonitoring.maxStuckDurationMs && progress >= 95) {\n          console.warn(`⚠️ [FileProcessor] Task appears stuck at ${progress}% with no updates for ${timeSinceUpdate/1000}s`);\n          \n          // Force check completion status via API\n          this.checkTaskCompletionStatus(task_id);\n        }\n      }, this.state.completionMonitoring.checkIntervalMs);\n      \n      // Store the timeout ID\n      this.state.completionMonitoring.timeoutIds.add(timeoutId);\n    } catch (error) {\n      console.error('❌ [FileProcessor] Error in task progress monitoring:', error);\n    }\n  }\n\n  /**\n   * Clear any active completion monitoring timeouts\n   */\n  clearCompletionMonitoring() {\n    try {\n      for (const timeoutId of this.state.completionMonitoring.timeoutIds) {\n        clearTimeout(timeoutId);\n      }\n      this.state.completionMonitoring.timeoutIds.clear();\n    } catch (error) {\n      console.error('❌ [FileProcessor] Error clearing completion monitoring:', error);\n    }\n  }\n\n  /**\n   * Check task completion status via API for stuck tasks\n   */\n  async checkTaskCompletionStatus(taskId) {\n    try {\n      console.log(`🔍 [FileProcessor] Checking completion status of task ${taskId} via API`);\n      \n      const response = await fetch(`/api/status/${taskId}`);\n      \n      if (!response.ok) {\n        console.warn(`⚠️ [FileProcessor] Status check failed with status ${response.status}`);\n        return;\n      }\n      \n      const data = await response.json();\n      console.log(`📊 [FileProcessor] Task status from API: ${data.status}, progress: ${data.progress}%`);\n      \n      // If task is completed according to API but UI doesn't show it\n      if (data.status === \"completed\" || data.progress >= 100) {\n        console.log(\"🎯 [FileProcessor] Task is completed according to API, forcing completion in UI\");\n        \n        // Force progress to 100%\n        this.showProgress(100, \"Task completed successfully\", data.stats);\n        \n        // Mark as completed if not already\n        if (!this.state.completionState.completed) {\n          this.handleTaskCompleted(data);\n        }\n      }\n      // Handle other status cases\n      else if (data.status === \"error\" || data.status === \"failed\") {\n        if (!this.state.completionState.error) {\n          this.handleTaskError(data);\n        }\n      }\n      else if (data.status === \"cancelled\") {\n        if (!this.state.completionState.cancelled) {\n          this.handleTaskCancelled(data);\n        }\n      }\n      // Task is still running - update progress\n      else {\n        console.log(\"📊 [FileProcessor] Task is still running according to API\");\n        this.handleProgressUpdate(data);\n        \n        // Schedule another check in case the task gets stuck again\n        const timeoutId = setTimeout(() => {\n          this.checkTaskCompletionStatus(taskId);\n        }, this.state.completionMonitoring.checkIntervalMs * 2);\n        \n        this.state.completionMonitoring.timeoutIds.add(timeoutId);\n      }\n    } catch (error) {\n      console.error('❌ [FileProcessor] Error checking task completion status:', error);\n    }\n  }\n\n  /**\n   * Update progress metrics for ETA calculation\n   */\n  updateProgressMetrics(progress) {\n    const now = Date.now();\n    \n    if (!this.state.lastProgressTimestamp) {\n      this.state.lastProgressTimestamp = now;\n      this.state.processingStartTime = this.state.processingStartTime || now;\n      return;\n    }\n    \n    const lastProgress = this.state.lastReportedProgress;\n    const timeDelta = now - this.state.lastProgressTimestamp;\n    \n    // Only update if significant time and progress changes\n    if (timeDelta > 500 && progress > lastProgress) {\n      const progressDelta = progress - lastProgress;\n      const rate = progressDelta / timeDelta;\n      \n      // Store rate for averaging (keep last 10 rates)\n      this.state.progressRates.push(rate);\n      if (this.state.progressRates.length > 10) {\n        this.state.progressRates.shift();\n      }\n      \n      this.state.lastProgressTimestamp = now;\n    }\n  }\n\n  /**\n   * Clean up session storage and state\n   */\n  cleanupSessionState() {\n    try {\n      sessionStorage.removeItem('ongoingTaskId');\n      sessionStorage.removeItem('ongoingTaskType');\n      sessionStorage.removeItem('outputFile');\n      localStorage.removeItem('currentTask');\n      sessionStorage.setItem('taskCompletionTime', Date.now().toString());\n    } catch (error) {\n      console.warn('⚠️ [FileProcessor] Error cleaning session state:', error);\n    }\n  }\n\n  /**\n   * Reset processing state variables\n   */\n  resetProcessingState() {\n    this.state.currentTask = null;\n    this.state.lastProgressTimestamp = null;\n    this.state.lastReportedProgress = 0;\n    this.state.progressUpdateCount = 0;\n    this.state.progressRates = [];\n    this.state.processingStartTime = null;\n  }\n\n  /**\n   * Complete progress handler integration\n   */\n  completeProgressHandler(data) {\n    try {\n      // Try multiple approaches to complete progress tracking\n      if (window.progressHandler && typeof window.progressHandler.complete === 'function') {\n        window.progressHandler.complete(data);\n        console.log(\"📊 [FileProcessor] Progress handler completed task:\", data.task_id);\n      } else if (window.moduleInstances?.progressHandler?.completeTask) {\n        window.moduleInstances.progressHandler.completeTask(data.task_id, data);\n        console.log(\"📊 [FileProcessor] Module instance progressHandler completed task:\", data.task_id);\n      }\n    } catch (error) {\n      console.warn('⚠️ [FileProcessor] Error completing progress handler:', error);\n    }\n  }\n\n  /**\n   * Add task to history using multiple approaches\n   */\n  addTaskToHistory(data) {\n    try {\n      if (!data) return;\n      \n      console.log(\"📚 [FileProcessor] Adding task to history:\", data);\n      \n      // Prepare the task data for history\n      const taskData = {\n        task_id: data.task_id || this.state.currentTask?.id,\n        type: 'file',\n        status: 'completed',\n        timestamp: Date.now(),\n        filename: this.getFileNameFromPath(data.output_file),\n        inputPath: this.state.currentTask?.inputDir,\n        outputPath: data.output_file,\n        stats: data.stats || {}\n      };\n      \n      // Try historyManager if available\n      if (window.historyManager && typeof window.historyManager.addTaskToHistory === 'function') {\n        window.historyManager.addTaskToHistory(taskData);\n        console.log(\"📚 [FileProcessor] Task added to history successfully\");\n        \n        // Also add to recent files\n        if (data.output_file && typeof window.historyManager.addFileToRecent === 'function') {\n          window.historyManager.addFileToRecent({\n            path: data.output_file,\n            name: this.getFileNameFromPath(data.output_file),\n            lastAccessed: Date.now()\n          });\n        }\n        return true;\n      }\n      \n      // Try moduleInstances approach\n      if (window.moduleInstances?.historyManager?.addTaskToHistory) {\n        window.moduleInstances.historyManager.addTaskToHistory(taskData);\n        console.log(\"📚 [FileProcessor] Task added to history using moduleInstances\");\n        return true;\n      }\n      \n      // Try event registry approach\n      if (window.eventRegistry && typeof window.eventRegistry.emit === 'function') {\n        console.log(\"📚 [FileProcessor] Using event registry to add task to history\");\n        window.eventRegistry.emit('history.add', {\n          type: 'file',\n          name: data.output_file ? this.getFileNameFromPath(data.output_file) : 'Processed Data',\n          data: taskData\n        });\n      }\n      \n      // Fallback to localStorage\n      try {\n        const historyItems = JSON.parse(localStorage.getItem('fileProcessorHistory') || '[]');\n        historyItems.unshift({\n          type: 'file',\n          name: data.output_file ? this.getFileNameFromPath(data.output_file) : 'Processed Data',\n          data: taskData\n        });\n        \n        // Keep only last 50 items\n        if (historyItems.length > 50) historyItems.length = 50;\n        localStorage.setItem('fileProcessorHistory', JSON.stringify(historyItems));\n        console.log(\"📚 [FileProcessor] Task saved to localStorage history fallback\");\n      } catch (storageErr) {\n        console.warn('⚠️ [FileProcessor] Failed to save to localStorage:', storageErr);\n      }\n    } catch (error) {\n      console.error('❌ [FileProcessor] Error adding task to history:', error);\n    }\n  }\n\n  /**\n   * Extract filename from path\n   */\n  getFileNameFromPath(filePath) {\n    if (!filePath) return 'Unknown File';\n    return filePath.split('/').pop() || filePath.split('\\\\').pop() || 'Unknown File';\n  }\n\n  /**\n   * Show the main form container\n   */\n  showForm() {\n    try {\n      const formContainer = this.state.elements.get('form-container') || document.getElementById('form-container');\n      const progressContainer = this.state.elements.get('progress-container');\n      const resultContainer = this.state.elements.get('result-container');\n      const submitBtn = this.state.elements.get('submit-btn');\n\n      // Reset processing state\n      this.state.processingState = 'idle';\n      this.state.currentTask = null;\n\n      // Show form, hide other containers with smooth transitions\n      this.transitionToContainer(formContainer);\n      \n      // Update UI to reset button state properly\n      this.updateUI();\n\n      console.log('📁 [FileProcessor] Form container shown');\n    } catch (error) {\n      console.error('❌ Error showing form:', error);\n    }\n  }\n\n  /**\n   * Show the progress container with enhanced transitions\n   */\n  showProgressContainer() {\n    try {\n      const formContainer = this.state.elements.get('form-container') || document.getElementById('form-container');\n      const progressContainer = this.state.elements.get('progress-container');\n      const resultContainer = this.state.elements.get('result-container');\n\n      // Transition from form to progress\n      this.transitionToContainer(progressContainer);\n      \n      console.log('📊 [FileProcessor] Progress container shown');\n    } catch (error) {\n      console.error('❌ Error showing progress container:', error);\n    }\n  }\n\n  /**\n   * Show results with comprehensive stats display (NEW - enhanced showResult pattern)\n   */\n  showResult(data) {\n    console.log('🎯 [FileProcessor] showResult called with data:', data);\n    \n    try {\n      // Force immediate container transition\n      const resultContainer = this.state.elements.get('result-container');\n      \n      if (!resultContainer) {\n        console.error('❌ [FileProcessor] Result container not found!');\n        this.showNotification('Results container not available', 'error');\n        return;\n      }\n      \n      console.log('📦 [FileProcessor] Transitioning to result container...');\n      this.transitionToContainer(resultContainer);\n      \n      // Update result content immediately\n      console.log('📊 [FileProcessor] Updating result stats...');\n      this.updateResultStats(resultContainer, data);\n      \n      // Update quick stats display\n      const resultStatsElement = this.state.elements.get('result-stats');\n      if (resultStatsElement && data.stats) {\n        const quickStats = `\n          <div class=\"d-flex justify-content-between text-muted small\">\n            <span><i class=\"fas fa-file me-1\"></i>${data.stats.processed_files || 0} files processed</span>\n            <span><i class=\"fas fa-clock me-1\"></i>${data.stats.formatted_duration || 'Unknown'}</span>\n            <span><i class=\"fas fa-check-circle me-1\"></i>${data.stats.success_rate_percent || 100}% success</span>\n          </div>\n        `;\n        resultStatsElement.innerHTML = quickStats;\n        console.log('📈 [FileProcessor] Quick stats updated');\n      }\n      \n      // Show success notification\n      this.showNotification('Processing completed successfully!', 'success', 'File Processor');\n      \n      console.log('✅ [FileProcessor] Results displayed successfully');\n      \n    } catch (error) {\n      console.error('❌ [FileProcessor] Error in showResult:', error);\n      // Fallback to basic completion message\n      this.showNotification('Processing completed - check console for details', 'success');\n    }\n  }\n\n  /**\n   * Show the result container with comprehensive stats (LEGACY - keep for compatibility)\n   */\n  showResultContainer(data) {\n    console.log('🔄 [FileProcessor] showResultContainer called - redirecting to showResult');\n    this.showResult(data);\n  }\n\n  /**\n   * Smooth transition between containers\n   */\n  transitionToContainer(targetContainer) {\n    if (!targetContainer) return;\n\n    const allContainers = [\n      this.state.elements.get('form-container') || document.getElementById('form-container'),\n      this.state.elements.get('progress-container'),\n      this.state.elements.get('result-container')\n    ].filter(container => container);\n\n    // Hide all containers\n    allContainers.forEach(container => {\n      if (container !== targetContainer) {\n        container.classList.add('d-none');\n        container.style.display = 'none';\n      }\n    });\n\n    // Show target container with fade-in effect\n    if (targetContainer) {\n      targetContainer.classList.remove('d-none');\n      targetContainer.style.display = 'block';\n      \n      // Add fade-in animation\n      targetContainer.style.opacity = '0';\n      setTimeout(() => {\n        targetContainer.style.transition = 'opacity 0.3s ease-in-out';\n        targetContainer.style.opacity = '1';\n      }, 10);\n    }\n  }\n\n  /**\n   * Update UI based on current state - Enhanced for completion handling\n   */\n  updateUI() {\n    const startBtn = this.state.elements.get('submit-btn');\n    const cancelBtn = this.state.elements.get('cancel-btn');\n\n    console.log(`🔄 [FileProcessor] Updating UI, current state: ${this.state.processingState}`);\n\n    if (startBtn) {\n      // Update button based on processing state\n      switch (this.state.processingState) {\n        case 'processing':\n          startBtn.disabled = true;\n          startBtn.innerHTML = '<i class=\"fas fa-spinner fa-spin me-2\"></i> Processing...';\n          break;\n        case 'completed':\n          startBtn.disabled = false;\n          startBtn.innerHTML = '<i class=\"fas fa-check me-2\"></i> Completed';\n          startBtn.classList.remove('btn-primary');\n          startBtn.classList.add('btn-success');\n          break;\n        case 'error':\n          startBtn.disabled = false;\n          startBtn.innerHTML = '<i class=\"fas fa-exclamation-triangle me-2\"></i> Error - Retry';\n          startBtn.classList.remove('btn-primary', 'btn-success');\n          startBtn.classList.add('btn-warning');\n          break;\n        default: // 'idle'\n          startBtn.disabled = false;\n          startBtn.innerHTML = '<i class=\"fas fa-play me-2\"></i> Start Processing';\n          startBtn.classList.remove('btn-success', 'btn-warning');\n          startBtn.classList.add('btn-primary');\n          break;\n      }\n    }\n\n    if (cancelBtn) {\n      cancelBtn.style.display = this.state.processingState === 'processing' ? 'inline-block' : 'none';\n    }\n\n    console.log(`✅ [FileProcessor] UI updated for state: ${this.state.processingState}`);\n  }\n\n  /**\n   * Show progress update\n   */\n  showProgress(progress, message) {\n    const progressBar = this.state.elements.get('progress-bar');\n    const progressText = this.state.elements.get('progress-status');\n    const progressContainer = this.state.elements.get('progress-container');\n\n    // Ensure progress container is visible\n    if (progressContainer) {\n      progressContainer.classList.remove('d-none');\n      progressContainer.style.display = 'block';\n    }\n\n    if (progressBar) {\n      progressBar.style.width = `${progress}%`;\n      progressBar.setAttribute('aria-valuenow', progress);\n      // Format progress to 1 decimal place for consistency\n      progressBar.textContent = `${progress.toFixed(1)}%`;\n    }\n\n    if (progressText) {\n      progressText.textContent = message;\n    }\n  }\n\n  /**\n   * Update statistics display during processing\n   */\n  updateStats(stats) {\n    const statsContainer = this.state.elements.get('progress-stats');\n    if (!statsContainer) return;\n\n    // Use enhanced CustomFileStats fields if available\n    const processed = stats.processed_files || 0;\n    const total = stats.total_files || 0;\n    const size = stats.formatted_total_size || this.formatFileSize(stats.total_bytes || 0);\n    const duration = stats.formatted_duration || this.formatDuration(stats.elapsed_time || 0);\n    const rate = stats.formatted_processing_rate || `${stats.current_processing_rate || 0} files/sec`;\n    const stage = stats.current_stage || 'Processing';\n\n    // Enhanced real-time stats display\n    const statsHtml = `\n      <div class=\"row g-2 small\">\n        <div class=\"col-md-6\">\n          <i class=\"fas fa-files-o me-1\"></i><strong>Files:</strong> ${processed}/${total}\n        </div>\n        <div class=\"col-md-6\">\n          <i class=\"fas fa-database me-1\"></i><strong>Size:</strong> ${size}\n        </div>\n        <div class=\"col-md-6\">\n          <i class=\"fas fa-clock me-1\"></i><strong>Time:</strong> ${duration}\n        </div>\n        <div class=\"col-md-6\">\n          <i class=\"fas fa-tachometer-alt me-1\"></i><strong>Rate:</strong> ${rate}\n        </div>\n        <div class=\"col-12\">\n          <i class=\"fas fa-cog me-1\"></i><strong>Stage:</strong> ${stage}\n        </div>\n      </div>\n    `;\n\n    statsContainer.innerHTML = statsHtml;\n    statsContainer.style.display = 'block';\n  }\n\n  /**\n   * Update result statistics display with comprehensive formatting\n   */\n  updateResultStats(container, data) {\n    if (!container) return;\n\n    // Process stats data to ensure all values are present\n    const stats = this.processStatsData(data.stats || {});\n    const outputFile = data.output_file || this.state.currentTask?.outputFile;\n\n    const statsHtml = `\n      <style>\n        .stat-card {\n          background: var(--bs-body-bg);\n          border: 1px solid var(--bs-border-color);\n          border-radius: 0.5rem;\n          padding: 1rem;\n          margin-bottom: 0.5rem;\n          transition: all 0.2s ease;\n        }\n        .stat-card:hover {\n          box-shadow: 0 4px 8px rgba(0,0,0,0.1);\n          transform: translateY(-2px);\n        }\n        .stat-card .icon {\n          font-size: 1.5rem;\n          margin-right: 1rem;\n          color: var(--bs-primary);\n        }\n        .stat-card .value {\n          font-size: 1.8rem;\n          font-weight: 600;\n          margin-bottom: 0.25rem;\n        }\n        .stat-card .label {\n          font-size: 0.875rem;\n          color: var(--bs-secondary);\n          margin: 0;\n        }\n        .zero-value {\n          opacity: 0.6;\n        }\n        .performance-metric {\n          text-align: center;\n          padding: 1rem;\n          background: var(--bs-light);\n          border-radius: 0.5rem;\n          margin-bottom: 0.5rem;\n        }\n        .performance-metric .value {\n          font-size: 1.5rem;\n          font-weight: 600;\n          color: var(--bs-primary);\n        }\n        .performance-metric .label {\n          font-size: 0.875rem;\n          color: var(--bs-secondary);\n          margin-top: 0.25rem;\n        }\n        .time-badge {\n          background: var(--bs-primary);\n          color: white;\n          padding: 0.25rem 0.75rem;\n          border-radius: 1rem;\n          font-size: 0.875rem;\n        }\n        .stats-header {\n          display: flex;\n          justify-content: space-between;\n          align-items: center;\n        }\n      </style>\n      <div class=\"result-header mb-4\">\n        <div class=\"d-flex justify-content-between align-items-center\">\n          <h4><i class=\"fas fa-check-circle text-success me-2\"></i>Processing Complete!</h4>\n          <button class=\"btn btn-outline-secondary btn-sm\" onclick=\"window.fileProcessor.showForm()\">\n            <i class=\"fas fa-plus me-2\"></i>New Task\n          </button>\n        </div>\n        <p class=\"text-muted mb-0\">Successfully processed files from: <strong>${this.state.currentTask?.inputDir}</strong></p>\n        ${outputFile ? `<p class=\"text-muted\">Output file: <strong>${outputFile}</strong></p>` : ''}\n      </div>\n\n      <div class=\"stats-container\">\n        <div class=\"stats-header mb-4\">\n          <h5><i class=\"fas fa-chart-bar me-2\"></i>Processing Statistics</h5>\n          <div class=\"time-badge\">\n            <i class=\"fas fa-clock\"></i>\n            <span>${stats.formatted_duration || this.formatDuration((stats.total_duration_seconds || stats.processing_time || 0) * 1000)} total processing time</span>\n          </div>\n        </div>\n        \n        <!-- Enhanced Real-time Performance Metrics -->\n        ${stats.completion_percentage ? `\n        <div class=\"alert alert-success mb-3\">\n          <div class=\"row text-center\">\n            <div class=\"col-4\">\n              <div class=\"performance-metric\">\n                <div class=\"value\">${stats.completion_percentage}%</div>\n                <div class=\"label\">Completion</div>\n              </div>\n            </div>\n            <div class=\"col-4\">\n              <div class=\"performance-metric\">\n                <div class=\"value\">${stats.formatted_processing_rate || `${stats.files_per_second || 0} files/sec`}</div>\n                <div class=\"label\">Processing Rate</div>\n              </div>\n            </div>\n            <div class=\"col-4\">\n              <div class=\"performance-metric\">\n                <div class=\"value\">${stats.success_rate_percent || 0}%</div>\n                <div class=\"label\">Success Rate</div>\n              </div>\n            </div>\n          </div>\n        </div>\n        ` : ''}\n        \n        <div class=\"row mb-4\">\n          <div class=\"col-md-4\">\n            <div class=\"stat-card\">\n              <div class=\"d-flex align-items-center\">\n                <div class=\"icon\"><i class=\"fas fa-file\"></i></div>\n                <div>\n                  <div class=\"value ${stats.total_files === 0 ? 'zero-value' : ''}\">${stats.total_files}</div>\n                  <div class=\"label\">Total Files</div>\n                </div>\n              </div>\n            </div>\n          </div>\n          \n          <div class=\"col-md-4\">\n            <div class=\"stat-card\">\n              <div class=\"d-flex align-items-center\">\n                <div class=\"icon text-success\"><i class=\"fas fa-check-circle\"></i></div>\n                <div>\n                  <div class=\"value text-success\">${stats.processed_files}</div>\n                  <div class=\"label\">Processed Files</div>\n                </div>\n              </div>\n            </div>\n          </div>\n          \n          <div class=\"col-md-4\">\n            <div class=\"stat-card\">\n              <div class=\"d-flex align-items-center\">\n                <div class=\"icon text-danger\"><i class=\"fas fa-times-circle\"></i></div>\n                <div>\n                  <div class=\"value text-danger\">${stats.error_files}</div>\n                  <div class=\"label\">Error Files</div>\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n        \n        <div class=\"row mb-4\">\n          <div class=\"col-md-4\">\n            <div class=\"stat-card\">\n              <div class=\"d-flex align-items-center\">\n                <div class=\"icon text-warning\"><i class=\"fas fa-exclamation-circle\"></i></div>\n                <div>\n                  <div class=\"value text-warning\">${stats.skipped_files}</div>\n                  <div class=\"label\">Skipped Files</div>\n                </div>\n              </div>\n            </div>\n          </div>\n          \n          <div class=\"col-md-4\">\n            <div class=\"stat-card\">\n              <div class=\"d-flex align-items-center\">\n                <div class=\"icon text-info\"><i class=\"fas fa-database\"></i></div>\n                <div>\n                  <div class=\"value text-info\">${this.formatFileSize(stats.total_bytes)}</div>\n                  <div class=\"label\">Total Size</div>\n                </div>\n              </div>\n            </div>\n          </div>\n          \n          <div class=\"col-md-4\">\n            <div class=\"stat-card\">\n              <div class=\"d-flex align-items-center\">\n                <div class=\"icon text-primary\"><i class=\"fas fa-puzzle-piece\"></i></div>\n                <div>\n                  <div class=\"value text-primary\">${stats.total_chunks}</div>\n                  <div class=\"label\">Total Chunks</div>\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n\n        ${stats.pdf_files > 0 ? `\n        <div class=\"pdf-stats mb-4\">\n          <h6 class=\"mb-3\"><i class=\"fas fa-file-pdf me-2\"></i>PDF Statistics</h6>\n          <div class=\"row\">\n            <div class=\"col-md-4\">\n              <div class=\"stat-card\">\n                <div class=\"d-flex align-items-center\">\n                  <div class=\"icon\" style=\"color: #fd7e14;\"><i class=\"fas fa-file-pdf\"></i></div>\n                  <div>\n                    <div class=\"value\" style=\"color: #fd7e14;\">${stats.pdf_files}</div>\n                    <div class=\"label\">PDF Files</div>\n                  </div>\n                </div>\n              </div>\n            </div>\n            \n            <div class=\"col-md-4\">\n              <div class=\"stat-card\">\n                <div class=\"d-flex align-items-center\">\n                  <div class=\"icon\" style=\"color: #20c997;\"><i class=\"fas fa-table\"></i></div>\n                  <div>\n                    <div class=\"value\" style=\"color: #20c997;\">${stats.tables_extracted || 0}</div>\n                    <div class=\"label\">Tables Extracted</div>\n                  </div>\n                </div>\n              </div>\n            </div>\n            \n            <div class=\"col-md-4\">\n              <div class=\"stat-card\">\n                <div class=\"d-flex align-items-center\">\n                  <div class=\"icon\" style=\"color: #6f42c1;\"><i class=\"fas fa-quote-right\"></i></div>\n                  <div>\n                    <div class=\"value\" style=\"color: #6f42c1;\">${stats.references_extracted || 0}</div>\n                    <div class=\"label\">References Extracted</div>\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n        ` : ''}\n        \n        <div class=\"performance-metrics mb-4\">\n          <h6 class=\"mb-3\"><i class=\"fas fa-tachometer-alt me-2\"></i>Performance Metrics</h6>\n          <div class=\"row\">\n            <div class=\"col-md-4\">\n              <div class=\"performance-metric\">\n                <div class=\"value\">${this.formatDuration((stats.total_duration_seconds || stats.processing_time || 0) * 1000)}</div>\n                <div class=\"label\">Total Duration</div>\n              </div>\n            </div>\n            \n            <div class=\"col-md-4\">\n              <div class=\"performance-metric\">\n                <div class=\"value\">${this.formatDuration((stats.avg_file_processing_time || 0) * 1000)}</div>\n                <div class=\"label\">Avg. Time Per File</div>\n              </div>\n            </div>\n            \n            <div class=\"col-md-4\">\n              <div class=\"performance-metric\">\n                <div class=\"value\">${((stats.processed_files || 0) / Math.max(1, stats.total_duration_seconds || stats.processing_time || 1)).toFixed(2)}</div>\n                <div class=\"label\">Files Per Second</div>\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n      \n      <!-- Completion Summary Banner -->\n      <div class=\"alert alert-success mb-4\" style=\"border-left: 4px solid #198754;\">\n        <div class=\"row align-items-center\">\n          <div class=\"col-md-8\">\n            <h6 class=\"alert-heading mb-2\"><i class=\"fas fa-check-circle me-2\"></i>Task Completed Successfully!</h6>\n            <p class=\"mb-0\">\n              <strong>${stats.processed_files || 0}</strong> files processed successfully\n              ${stats.error_files > 0 ? `, <strong class=\"text-warning\">${stats.error_files}</strong> errors` : ''}\n              ${stats.skipped_files > 0 ? `, <strong class=\"text-info\">${stats.skipped_files}</strong> skipped` : ''}\n            </p>\n          </div>\n          <div class=\"col-md-4 text-end\">\n            <span class=\"badge bg-success fs-6 px-3 py-2\">\n              <i class=\"fas fa-thumbs-up me-2\"></i>100% Complete\n            </span>\n          </div>\n        </div>\n      </div>\n\n      ${outputFile ? `\n      <!-- File Actions Section -->\n      <div class=\"card mt-4\" style=\"border: 2px solid #198754;\">\n        <div class=\"card-header bg-success text-white\">\n          <h6 class=\"mb-0\"><i class=\"fas fa-download me-2\"></i>Output File Ready</h6>\n        </div>\n        <div class=\"card-body\">\n          <div class=\"mb-3\">\n            <label class=\"form-label text-muted small\">Output File Path:</label>\n            <div class=\"d-flex align-items-center\">\n              <input type=\"text\" class=\"form-control form-control-sm me-2\" value=\"${outputFile}\" readonly onclick=\"this.select()\">\n              <button class=\"btn btn-outline-secondary btn-sm\" onclick=\"navigator.clipboard.writeText('${outputFile}'); window.fileProcessor.showNotification('Path copied to clipboard!', 'success');\" title=\"Copy path\">\n                <i class=\"fas fa-copy\"></i>\n              </button>\n            </div>\n          </div>\n          <div class=\"d-flex gap-2 flex-wrap\">\n            <button class=\"btn btn-success\" onclick=\"window.fileProcessor.openFileOrFolder('${outputFile}')\">\n              <i class=\"fas fa-file-alt me-2\"></i>Open Result File\n            </button>\n            <button class=\"btn btn-outline-primary\" onclick=\"window.fileProcessor.openFileOrFolder('${outputFile}', true)\">\n              <i class=\"fas fa-folder-open me-2\"></i>Open Folder\n            </button>\n            <button class=\"btn btn-outline-secondary\" onclick=\"window.fileProcessor.downloadFile('${outputFile}')\">\n              <i class=\"fas fa-download me-2\"></i>Download\n            </button>\n            <button class=\"btn btn-outline-info\" onclick=\"window.fileProcessor.showFilePreview('${outputFile}')\">\n              <i class=\"fas fa-eye me-2\"></i>Preview\n            </button>\n          </div>\n        </div>\n      </div>\n      ` : ''}\n      \n      <!-- Action Buttons -->\n      <div class=\"d-flex gap-2 mt-4 justify-content-center\">\n        <button class=\"btn btn-primary btn-lg\" onclick=\"window.fileProcessor.showForm()\">\n          <i class=\"fas fa-plus me-2\"></i>New Task\n        </button>\n        <button class=\"btn btn-outline-secondary\" onclick=\"window.fileProcessor.viewHistory()\">\n          <i class=\"fas fa-history me-2\"></i>View History\n        </button>\n        <button class=\"btn btn-outline-info\" onclick=\"window.fileProcessor.exportStats('${data.task_id || 'unknown'}')\">\n          <i class=\"fas fa-file-export me-2\"></i>Export Stats\n        </button>\n      </div>\n    `;\n\n    container.innerHTML = statsHtml;\n    \n    // Add smooth entrance animation\n    container.style.opacity = '0';\n    setTimeout(() => {\n      container.style.transition = 'opacity 0.5s ease-in-out';\n      container.style.opacity = '1';\n    }, 100);\n  }\n\n  /**\n   * Process raw stats data to ensure all values are properly extracted\n   */\n  processStatsData(rawStats) {\n    const defaultStats = {\n      total_files: 0,\n      processed_files: 0,\n      skipped_files: 0,\n      error_files: 0,\n      total_bytes: 0,\n      total_chunks: 0,\n      duration_seconds: 0,\n      processing_time: 0,\n      total_duration_seconds: 0,\n      avg_file_processing_time: 0,\n      pdf_files: 0,\n      tables_extracted: 0,\n      references_extracted: 0\n    };\n    \n    if (!rawStats || typeof rawStats !== 'object') {\n      return defaultStats;\n    }\n    \n    // Handle nested stats structure\n    if (rawStats.stats && typeof rawStats.stats === 'object') {\n      rawStats = rawStats.stats;\n    }\n    \n    return { ...defaultStats, ...rawStats };\n  }\n\n  /**\n   * Open file or folder using system default application\n   */\n  openFileOrFolder(path, openFolder = false) {\n    // This would typically make a call to the backend to open the file/folder\n    console.log(`Opening ${openFolder ? 'folder for' : 'file'}: ${path}`);\n    \n    // For now, just show a notification\n    this.showNotification(\n      `Request sent to open ${openFolder ? 'folder containing' : ''} ${path}`, \n      'info', \n      'File System'\n    );\n  }\n\n  /**\n   * Download file to user's computer\n   */\n  downloadFile(filePath) {\n    console.log(`Downloading file: ${filePath}`);\n    \n    // Create a download link for the file\n    try {\n      const link = document.createElement('a');\n      link.href = `/api/download?file=${encodeURIComponent(filePath)}`;\n      link.download = filePath.split('/').pop();\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      \n      this.showNotification('Download started', 'success', 'File Processor');\n    } catch (error) {\n      console.error('Download error:', error);\n      this.showNotification('Download failed - file may not be accessible', 'error', 'File Processor');\n    }\n  }\n\n  /**\n   * Show file preview in modal or new window (Enhanced for multiple formats)\n   */\n  showFilePreview(filePath) {\n    console.log(`Showing preview for: ${filePath}`);\n    \n    // Detect file type and handle accordingly\n    const fileExtension = filePath.toLowerCase().split('.').pop();\n    \n    switch (fileExtension) {\n      case 'json':\n        this.previewJsonFile(filePath);\n        break;\n      case 'md':\n      case 'markdown':\n        this.previewMarkdownFile(filePath);\n        break;\n      case 'txt':\n      case 'log':\n        this.previewTextFile(filePath);\n        break;\n      default:\n        this.showNotification('Preview available for .json, .md, and .txt files', 'info', 'File Processor');\n    }\n  }\n\n  /**\n   * Preview JSON file content\n   */\n  async previewJsonFile(filePath) {\n    try {\n      const response = await fetch(`/api/file-content?file=${encodeURIComponent(filePath)}`);\n      if (response.ok) {\n        const content = await response.text();\n        const jsonData = JSON.parse(content);\n        \n        // Create enhanced JSON preview modal\n        const preview = `\n          <div class=\"modal fade\" id=\"filePreviewModal\" tabindex=\"-1\">\n            <div class=\"modal-dialog modal-xl\">\n              <div class=\"modal-content\">\n                <div class=\"modal-header\">\n                  <h5 class=\"modal-title\"><i class=\"fas fa-file-code me-2\"></i>JSON Preview: ${filePath.split('/').pop()}</h5>\n                  <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\"></button>\n                </div>\n                <div class=\"modal-body\">\n                  <div class=\"d-flex justify-content-between mb-3\">\n                    <span class=\"badge bg-primary\">JSON Format</span>\n                    <span class=\"text-muted small\">File size: ${(content.length / 1024).toFixed(1)} KB</span>\n                  </div>\n                  <pre style=\"max-height: 500px; overflow-y: auto; background: #f8f9fa; padding: 1rem; border-radius: 0.5rem; font-size: 0.85rem;\"><code>${JSON.stringify(jsonData, null, 2)}</code></pre>\n                </div>\n                <div class=\"modal-footer\">\n                  <button type=\"button\" class=\"btn btn-secondary\" data-bs-dismiss=\"modal\">Close</button>\n                  <button type=\"button\" class=\"btn btn-primary\" onclick=\"window.fileProcessor.downloadFile('${filePath}')\">Download</button>\n                </div>\n              </div>\n            </div>\n          </div>\n        `;\n        this.showPreviewModal(preview);\n        \n      } else {\n        throw new Error(`HTTP ${response.status}`);\n      }\n    } catch (error) {\n      console.error('JSON preview error:', error);\n      this.showNotification('Unable to preview JSON file - file may not be accessible', 'error', 'File Processor');\n    }\n  }\n\n  /**\n   * Preview Markdown file content\n   */\n  async previewMarkdownFile(filePath) {\n    try {\n      const response = await fetch(`/api/file-content?file=${encodeURIComponent(filePath)}`);\n      if (response.ok) {\n        const content = await response.text();\n        \n        // Basic markdown to HTML conversion for preview\n        const htmlContent = this.markdownToHtml(content);\n        \n        const preview = `\n          <div class=\"modal fade\" id=\"filePreviewModal\" tabindex=\"-1\">\n            <div class=\"modal-dialog modal-xl\">\n              <div class=\"modal-content\">\n                <div class=\"modal-header\">\n                  <h5 class=\"modal-title\"><i class=\"fas fa-file-alt me-2\"></i>Markdown Preview: ${filePath.split('/').pop()}</h5>\n                  <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\"></button>\n                </div>\n                <div class=\"modal-body\">\n                  <div class=\"d-flex justify-content-between mb-3\">\n                    <span class=\"badge bg-info\">Markdown Format</span>\n                    <div>\n                      <span class=\"text-muted small me-3\">File size: ${(content.length / 1024).toFixed(1)} KB</span>\n                      <button class=\"btn btn-sm btn-outline-secondary\" onclick=\"window.fileProcessor.toggleMarkdownView()\" id=\"toggleViewBtn\">Show Raw</button>\n                    </div>\n                  </div>\n                  <div id=\"markdownRendered\" style=\"max-height: 500px; overflow-y: auto; padding: 1rem; border: 1px solid #dee2e6; border-radius: 0.5rem;\">\n                    ${htmlContent}\n                  </div>\n                  <div id=\"markdownRaw\" style=\"max-height: 500px; overflow-y: auto; background: #f8f9fa; padding: 1rem; border-radius: 0.5rem; display: none;\">\n                    <pre><code>${content}</code></pre>\n                  </div>\n                </div>\n                <div class=\"modal-footer\">\n                  <button type=\"button\" class=\"btn btn-secondary\" data-bs-dismiss=\"modal\">Close</button>\n                  <button type=\"button\" class=\"btn btn-primary\" onclick=\"window.fileProcessor.downloadFile('${filePath}')\">Download</button>\n                </div>\n              </div>\n            </div>\n          </div>\n        `;\n        this.showPreviewModal(preview);\n        \n      } else {\n        throw new Error(`HTTP ${response.status}`);\n      }\n    } catch (error) {\n      console.error('Markdown preview error:', error);\n      this.showNotification('Unable to preview Markdown file - file may not be accessible', 'error', 'File Processor');\n    }\n  }\n\n  /**\n   * Preview text file content\n   */\n  async previewTextFile(filePath) {\n    try {\n      const response = await fetch(`/api/file-content?file=${encodeURIComponent(filePath)}`);\n      if (response.ok) {\n        const content = await response.text();\n        \n        const preview = `\n          <div class=\"modal fade\" id=\"filePreviewModal\" tabindex=\"-1\">\n            <div class=\"modal-dialog modal-lg\">\n              <div class=\"modal-content\">\n                <div class=\"modal-header\">\n                  <h5 class=\"modal-title\"><i class=\"fas fa-file-text me-2\"></i>Text Preview: ${filePath.split('/').pop()}</h5>\n                  <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\"></button>\n                </div>\n                <div class=\"modal-body\">\n                  <div class=\"d-flex justify-content-between mb-3\">\n                    <span class=\"badge bg-secondary\">Text Format</span>\n                    <span class=\"text-muted small\">File size: ${(content.length / 1024).toFixed(1)} KB</span>\n                  </div>\n                  <pre style=\"max-height: 500px; overflow-y: auto; background: #f8f9fa; padding: 1rem; border-radius: 0.5rem; font-size: 0.9rem; white-space: pre-wrap;\">${content}</pre>\n                </div>\n                <div class=\"modal-footer\">\n                  <button type=\"button\" class=\"btn btn-secondary\" data-bs-dismiss=\"modal\">Close</button>\n                  <button type=\"button\" class=\"btn btn-primary\" onclick=\"window.fileProcessor.downloadFile('${filePath}')\">Download</button>\n                </div>\n              </div>\n            </div>\n          </div>\n        `;\n        this.showPreviewModal(preview);\n        \n      } else {\n        throw new Error(`HTTP ${response.status}`);\n      }\n    } catch (error) {\n      console.error('Text preview error:', error);\n      this.showNotification('Unable to preview text file - file may not be accessible', 'error', 'File Processor');\n    }\n  }\n\n  /**\n   * Helper function to show preview modal\n   */\n  showPreviewModal(modalHtml) {\n    // Remove existing modal if any\n    const existing = document.getElementById('filePreviewModal');\n    if (existing) existing.remove();\n    \n    // Add modal to page and show it\n    document.body.insertAdjacentHTML('beforeend', modalHtml);\n    const modal = new bootstrap.Modal(document.getElementById('filePreviewModal'));\n    modal.show();\n  }\n\n  /**\n   * Toggle between rendered and raw markdown view\n   */\n  toggleMarkdownView() {\n    const rendered = document.getElementById('markdownRendered');\n    const raw = document.getElementById('markdownRaw');\n    const toggleBtn = document.getElementById('toggleViewBtn');\n    \n    if (rendered && raw && toggleBtn) {\n      if (rendered.style.display === 'none') {\n        rendered.style.display = 'block';\n        raw.style.display = 'none';\n        toggleBtn.textContent = 'Show Raw';\n      } else {\n        rendered.style.display = 'none';\n        raw.style.display = 'block';\n        toggleBtn.textContent = 'Show Rendered';\n      }\n    }\n  }\n\n  /**\n   * Basic markdown to HTML conversion for preview\n   */\n  markdownToHtml(markdown) {\n    let html = markdown;\n    \n    // Convert YAML frontmatter to formatted block\n    html = html.replace(/^---\\n([\\s\\S]*?)\\n---\\n/m, (_, frontmatter) => {\n      return `<div class=\"alert alert-light\"><strong>Frontmatter:</strong><pre class=\"mt-2 mb-0\">${frontmatter}</pre></div>\\n`;\n    });\n    \n    // Headers\n    html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');\n    html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');\n    html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');\n    \n    // Bold and italic\n    html = html.replace(/\\*\\*(.*?)\\*\\*/g, '<strong>$1</strong>');\n    html = html.replace(/\\*(.*?)\\*/g, '<em>$1</em>');\n    \n    // Code blocks\n    html = html.replace(/```([\\s\\S]*?)```/g, '<pre><code>$1</code></pre>');\n    html = html.replace(/`(.*?)`/g, '<code>$1</code>');\n    \n    // Links\n    html = html.replace(/\\[([^\\]]+)\\]\\(([^)]+)\\)/g, '<a href=\"$2\">$1</a>');\n    \n    // Lists\n    html = html.replace(/^\\* (.+)$/gm, '<li>$1</li>');\n    html = html.replace(/^- (.+)$/gm, '<li>$1</li>');\n    html = html.replace(/(<li>.*<\\/li>)/s, '<ul>$1</ul>');\n    \n    // Line breaks\n    html = html.replace(/\\n\\n/g, '</p><p>');\n    html = '<p>' + html + '</p>';\n    \n    // Clean up empty paragraphs and fix formatting\n    html = html.replace(/<p><\\/p>/g, '');\n    html = html.replace(/<p>(<h[1-6]>)/g, '$1');\n    html = html.replace(/(<\\/h[1-6]>)<\\/p>/g, '$1');\n    html = html.replace(/<p>(<ul>)/g, '$1');\n    html = html.replace(/(<\\/ul>)<\\/p>/g, '$1');\n    html = html.replace(/<p>(<pre>)/g, '$1');\n    html = html.replace(/(<\\/pre>)<\\/p>/g, '$1');\n    html = html.replace(/<p>(<div)/g, '$1');\n    html = html.replace(/(<\\/div>)<\\/p>/g, '$1');\n    \n    return html;\n  }\n\n  /**\n   * View processing history\n   */\n  viewHistory() {\n    console.log('Opening processing history...');\n    this.showNotification('Opening processing history...', 'info', 'File Processor');\n    \n    // This would typically navigate to history view or open history modal\n    if (window.NeuroGen?.modules?.historyManager) {\n      window.NeuroGen.modules.historyManager.show();\n    } else {\n      this.showNotification('History feature not available', 'warning', 'File Processor');\n    }\n  }\n\n  /**\n   * Export processing statistics\n   */\n  exportStats(taskId) {\n    console.log(`Exporting stats for task: ${taskId}`);\n    \n    try {\n      // Create stats export data\n      const exportData = {\n        taskId,\n        timestamp: new Date().toISOString(),\n        task: this.state.currentTask,\n        processingState: this.state.processingState,\n        exported: new Date().toLocaleString()\n      };\n      \n      // Download as JSON file\n      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });\n      const url = URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = `file-processor-stats-${taskId}-${Date.now()}.json`;\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n      URL.revokeObjectURL(url);\n      \n      this.showNotification('Stats exported successfully', 'success', 'File Processor');\n    } catch (error) {\n      console.error('Export error:', error);\n      this.showNotification('Failed to export stats', 'error', 'File Processor');\n    }\n  }\n\n  /**\n   * Show error message\n   */\n  showError(message) {\n    this.showToast('Processing Error', message, 'error');\n  }\n\n  /**\n   * Show info message\n   */\n  showInfo(message) {\n    this.showToast('File Processor', message, 'info');\n  }\n\n  /**\n   * Show toast notification\n   */\n  showToast(title, message, type = 'info') {\n    // Use existing toast system or create simple one\n    if (window.showToast) {\n      window.showToast(title, message, type);\n    } else {\n      console.log(`${type.toUpperCase()}: ${title} - ${message}`);\n    }\n  }\n\n  /**\n   * Format file size for display\n   */\n  formatFileSize(bytes) {\n    if (bytes === 0) return '0 Bytes';\n    \n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    \n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n\n  /**\n   * Format duration for display\n   */\n  formatDuration(seconds) {\n    if (seconds < 60) {\n      return `${seconds.toFixed(1)}s`;\n    } else if (seconds < 3600) {\n      const minutes = Math.floor(seconds / 60);\n      const remainingSeconds = Math.floor(seconds % 60);\n      return `${minutes}m ${remainingSeconds}s`;\n    } else {\n      const hours = Math.floor(seconds / 3600);\n      const minutes = Math.floor((seconds % 3600) / 60);\n      return `${hours}h ${minutes}m`;\n    }\n  }\n\n  /**\n   * Reset to initial state\n   */\n  reset() {\n    this.state.currentTask = null;\n    this.state.processingState = 'idle';\n    \n    // Clear UI\n    const progressContainer = this.state.elements.get('progress-container');\n    const statsContainer = this.state.elements.get('progress-stats');\n    const resultsContainer = this.state.elements.get('result-container');\n\n    if (progressContainer) progressContainer.style.display = 'none';\n    if (statsContainer) statsContainer.style.display = 'none';\n    if (resultsContainer) resultsContainer.style.display = 'none';\n\n    this.updateUI();\n  }\n\n  /**\n   * Cleanup event listeners and resources\n   */\n  cleanup() {\n    // Remove event listeners\n    this.state.eventListeners.forEach(removeListener => removeListener());\n    this.state.eventListeners.clear();\n\n    // Remove socket listeners\n    this.state.socketListeners.forEach(removeListener => removeListener());\n    this.state.socketListeners.clear();\n\n    // Cancel any ongoing task\n    if (this.state.currentTask) {\n      this.cancelProcessing();\n    }\n\n    // Cleanup progress tracker\n    if (this.state.progressTracker?.stop) {\n      this.state.progressTracker.stop();\n    }\n\n    this.state.isInitialized = false;\n  }\n}\n\n// Create singleton instance\nconst fileProcessor = new FileProcessor();\n\n// Export for use by other modules\nexport default fileProcessor;\n\n// Make available globally for debugging and integration\nwindow.fileProcessor = fileProcessor;\nif (window.NeuroGen) {\n  window.NeuroGen.fileProcessor = fileProcessor;\n}\n\n// Auto-initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => {\n    console.log('📁 DOM ready, initializing File Processor...');\n    fileProcessor.init();\n  });\n} else {\n  console.log('📁 DOM already ready, initializing File Processor immediately...');\n  fileProcessor.init();\n}\n\nconsole.log('📁 File Processor module loaded (Enhanced Blueprint Implementation)');","source":"/workspace/modules/static/js/modules/features/fileProcessor.js","title":"fileProcessor.js","language":"en"},{"content":"/**\n * helpMode.js\n * Provides interactive help tooltips and contextual guidance for the UI\n * Implements help overlay system that explains UI components\n */\n\nimport { registerEvents } from '../core/eventManager.js';\nimport { registerElement, getElement, getAllElements } from '../core/uiRegistry.js';\nimport { getState, setState } from '../core/stateManager.js';\n\nclass HelpMode {\n    constructor() {\n        this.helpModeActive = false;\n        this.helpTooltips = new Map(); // Maps element IDs to their help messages\n        this.currentTooltips = [];\n        this.initialize();\n    }\n\n    initialize() {\n        this.registerUIElements();\n        this.setupEventListeners();\n        this.defineHelpMessages();\n    }\n\n    registerUIElements() {\n        registerElement('helpModeToggle', '#help-mode-toggle');\n        registerElement('helpOverlay', '#help-overlay');\n        registerElement('helpTooltipContainer', '#help-tooltip-container');\n    }\n\n    setupEventListeners() {\n        registerEvents({\n            'click:helpModeToggle': () => this.toggleHelpMode(),\n            'mouseenter:.help-trigger': (e) => this.showHelpTooltip(e),\n            'mouseleave:.help-trigger': () => this.hideHelpTooltip()\n        });\n\n        // Close help mode when Escape key is pressed\n        document.addEventListener('keydown', (e) => {\n            if (e.key === 'Escape' && this.helpModeActive) {\n                this.disableHelpMode();\n            }\n        });\n    }\n\n    defineHelpMessages() {\n        // Define help messages for various UI elements\n        this.helpTooltips = new Map([\n            // Main navigation\n            ['file-processing-tab', 'Process files from your local system and convert them to structured JSON.'],\n            ['playlists-tab', 'Download and process YouTube playlists and videos.'],\n            ['scraper-tab', 'Extract content from websites and download PDFs.'],\n            ['academic-tab', 'Search and download academic papers from various sources.'],\n            \n            // File processing\n            ['input-dir-select', 'Select a directory containing the files you want to process.'],\n            ['output-file-input', 'Specify where the output JSON file should be saved.'],\n            ['process-btn', 'Start processing the files in the selected directory.'],\n            \n            // Playlist downloader\n            ['playlist-url-input', 'Enter YouTube playlist URLs (one per line).'],\n            ['playlist-root-dir', 'Select a directory where downloaded videos will be saved.'],\n            ['playlist-download-btn', 'Start downloading and processing the playlists.'],\n            \n            // Scraper\n            ['scraper-url-input', 'Enter a website URL to scrape content from.'],\n            ['scraper-setting-select', 'Select what type of content to extract from the URL.'],\n            ['scraper-pdf-processing', 'Configure options for processing downloaded PDFs.'],\n            ['scraper-start-btn', 'Start the scraping process with the current settings.'],\n            \n            // Academic search\n            ['academic-query-input', 'Enter keywords to search for academic papers.'],\n            ['academic-source-select', 'Select which academic source to search.'],\n            ['academic-search-btn', 'Start the academic search with the current query.'],\n            \n            // PDF processing\n            ['pdf-file-input', 'Select a PDF file to process or analyze.'],\n            ['pdf-extract-tables', 'Enable to extract tables from the PDF.'],\n            ['pdf-use-ocr', 'Enable to use Optical Character Recognition for scanned PDFs.'],\n            ['pdf-process-btn', 'Start processing the selected PDF file.'],\n            \n            // General actions\n            ['theme-toggle', 'Switch between light and dark themes.'],\n            ['help-mode-toggle', 'Toggle help mode to see tooltips explaining UI elements.']\n        ]);\n    }\n\n    toggleHelpMode() {\n        if (this.helpModeActive) {\n            this.disableHelpMode();\n        } else {\n            this.enableHelpMode();\n        }\n    }\n\n    enableHelpMode() {\n        this.helpModeActive = true;\n        setState('helpModeActive', true);\n        \n        // Update toggle button state\n        const helpToggle = getElement('helpModeToggle');\n        if (helpToggle) {\n            helpToggle.classList.add('active');\n            helpToggle.setAttribute('aria-pressed', 'true');\n        }\n        \n        // Show help overlay\n        const helpOverlay = getElement('helpOverlay');\n        if (helpOverlay) {\n            helpOverlay.style.display = 'block';\n        } else {\n            // Create overlay if it doesn't exist\n            this.createHelpOverlay();\n        }\n        \n        // Add help triggers to all elements with help messages\n        this.addHelpTriggers();\n        \n        // Broadcast event\n        document.dispatchEvent(new CustomEvent('helpModeEnabled'));\n    }\n\n    disableHelpMode() {\n        this.helpModeActive = false;\n        setState('helpModeActive', false);\n        \n        // Update toggle button state\n        const helpToggle = getElement('helpModeToggle');\n        if (helpToggle) {\n            helpToggle.classList.remove('active');\n            helpToggle.setAttribute('aria-pressed', 'false');\n        }\n        \n        // Hide help overlay\n        const helpOverlay = getElement('helpOverlay');\n        if (helpOverlay) {\n            helpOverlay.style.display = 'none';\n        }\n        \n        // Remove help triggers\n        this.removeHelpTriggers();\n        \n        // Hide any active tooltips\n        this.hideHelpTooltip();\n        \n        // Broadcast event\n        document.dispatchEvent(new CustomEvent('helpModeDisabled'));\n    }\n\n    createHelpOverlay() {\n        // Create overlay element\n        const overlay = document.createElement('div');\n        overlay.id = 'help-overlay';\n        overlay.className = 'help-overlay';\n        \n        // Create tooltip container\n        const tooltipContainer = document.createElement('div');\n        tooltipContainer.id = 'help-tooltip-container';\n        tooltipContainer.className = 'help-tooltip-container';\n        \n        // Add elements to document\n        document.body.appendChild(overlay);\n        document.body.appendChild(tooltipContainer);\n        \n        // Register the elements\n        registerElement('helpOverlay', '#help-overlay');\n        registerElement('helpTooltipContainer', '#help-tooltip-container');\n        \n        // Add click handler to close help mode when clicking outside\n        overlay.addEventListener('click', () => this.disableHelpMode());\n    }\n\n    addHelpTriggers() {\n        // Add help trigger class to all elements with help messages\n        for (const [elementId] of this.helpTooltips) {\n            const element = document.getElementById(elementId);\n            if (element) {\n                element.classList.add('help-trigger');\n                element.setAttribute('data-help-id', elementId);\n            }\n        }\n    }\n\n    removeHelpTriggers() {\n        // Remove help trigger class from all elements\n        const triggers = document.querySelectorAll('.help-trigger');\n        triggers.forEach(trigger => {\n            trigger.classList.remove('help-trigger');\n        });\n    }\n\n    showHelpTooltip(event) {\n        if (!this.helpModeActive) return;\n        \n        const target = event.target.closest('.help-trigger');\n        if (!target) return;\n        \n        const helpId = target.getAttribute('data-help-id') || target.id;\n        const helpMessage = this.helpTooltips.get(helpId);\n        \n        if (!helpMessage) return;\n        \n        // Create tooltip element\n        const tooltip = document.createElement('div');\n        tooltip.className = 'help-tooltip';\n        tooltip.innerHTML = `\n            <div class=\"help-tooltip-content\">\n                <p>${helpMessage}</p>\n            </div>\n            <div class=\"help-tooltip-arrow\"></div>\n        `;\n        \n        // Add to container\n        const container = getElement('helpTooltipContainer');\n        if (container) {\n            container.innerHTML = '';\n            container.appendChild(tooltip);\n            this.positionTooltip(tooltip, target);\n        }\n        \n        // Track current tooltip\n        this.currentTooltips.push(tooltip);\n    }\n\n    hideHelpTooltip() {\n        // Remove all current tooltips\n        const container = getElement('helpTooltipContainer');\n        if (container) {\n            container.innerHTML = '';\n        }\n        \n        this.currentTooltips = [];\n    }\n\n    positionTooltip(tooltip, target) {\n        if (!tooltip || !target) return;\n        \n        // Get element position\n        const targetRect = target.getBoundingClientRect();\n        const tooltipRect = tooltip.getBoundingClientRect();\n        \n        // Default position is above the element\n        let top = targetRect.top - tooltipRect.height - 10;\n        let left = targetRect.left + (targetRect.width / 2) - (tooltipRect.width / 2);\n        \n        // Check if tooltip would be off-screen\n        if (top < 10) {\n            // Position below instead\n            top = targetRect.bottom + 10;\n            tooltip.classList.add('tooltip-below');\n        } else {\n            tooltip.classList.remove('tooltip-below');\n        }\n        \n        // Ensure tooltip is not off-screen horizontally\n        if (left < 10) {\n            left = 10;\n        } else if (left + tooltipRect.width > window.innerWidth - 10) {\n            left = window.innerWidth - tooltipRect.width - 10;\n        }\n        \n        // Set position\n        tooltip.style.top = `${top}px`;\n        tooltip.style.left = `${left}px`;\n    }\n\n    // Function to show a guided tour\n    startGuidedTour(tourId) {\n        // Different tours can be defined here\n        const tours = {\n            'welcome': [\n                { elementId: 'file-processing-tab', message: 'Start here to process local files.' },\n                { elementId: 'playlists-tab', message: 'Download and process YouTube content.' },\n                { elementId: 'scraper-tab', message: 'Extract content from websites.' },\n                { elementId: 'academic-tab', message: 'Search for academic papers.' }\n            ],\n            'file-processing': [\n                { elementId: 'input-dir-select', message: 'First, select your input directory.' },\n                { elementId: 'output-file-input', message: 'Then specify where to save the output.' },\n                { elementId: 'process-btn', message: 'Finally, click here to start processing.' }\n            ],\n            'scraper': [\n                { elementId: 'scraper-url-input', message: 'Enter the URL you want to scrape.' },\n                { elementId: 'scraper-setting-select', message: 'Select what type of content to extract.' },\n                { elementId: 'scraper-pdf-processing', message: 'Configure PDF processing options if needed.' },\n                { elementId: 'scraper-start-btn', message: 'Start the scraping process.' }\n            ]\n        };\n        \n        // Get the tour steps\n        const tour = tours[tourId];\n        if (!tour) return;\n        \n        // Enable help mode\n        this.enableHelpMode();\n        \n        // Start the tour\n        this.currentTourSteps = tour;\n        this.currentTourStep = 0;\n        this.showTourStep();\n    }\n\n    showTourStep() {\n        if (!this.currentTourSteps || this.currentTourStep >= this.currentTourSteps.length) {\n            // Tour complete\n            this.endTour();\n            return;\n        }\n        \n        // Get current step\n        const step = this.currentTourSteps[this.currentTourStep];\n        \n        // Find the target element\n        const target = document.getElementById(step.elementId);\n        if (!target) {\n            // Skip to next step if element not found\n            this.currentTourStep++;\n            this.showTourStep();\n            return;\n        }\n        \n        // Create tour tooltip\n        const tooltip = document.createElement('div');\n        tooltip.className = 'help-tooltip tour-tooltip';\n        tooltip.innerHTML = `\n            <div class=\"help-tooltip-content\">\n                <p>${step.message}</p>\n                <div class=\"tour-controls\">\n                    <button class=\"btn btn-sm btn-outline tour-prev\" ${this.currentTourStep > 0 ? '' : 'disabled'}>Previous</button>\n                    <span class=\"tour-progress\">${this.currentTourStep + 1}/${this.currentTourSteps.length}</span>\n                    <button class=\"btn btn-sm btn-primary tour-next\">\n                        ${this.currentTourStep < this.currentTourSteps.length - 1 ? 'Next' : 'Finish'}\n                    </button>\n                </div>\n            </div>\n            <div class=\"help-tooltip-arrow\"></div>\n        `;\n        \n        // Add to container\n        const container = getElement('helpTooltipContainer');\n        if (container) {\n            container.innerHTML = '';\n            container.appendChild(tooltip);\n            this.positionTooltip(tooltip, target);\n        }\n        \n        // Highlight the target element\n        target.classList.add('help-highlight');\n        \n        // Add event listeners to buttons\n        const prevBtn = tooltip.querySelector('.tour-prev');\n        const nextBtn = tooltip.querySelector('.tour-next');\n        \n        if (prevBtn) {\n            prevBtn.addEventListener('click', () => this.prevTourStep());\n        }\n        \n        if (nextBtn) {\n            nextBtn.addEventListener('click', () => this.nextTourStep());\n        }\n        \n        // Track current tooltip\n        this.currentTooltips.push(tooltip);\n    }\n\n    nextTourStep() {\n        // Clear current step\n        this.clearTourStep();\n        \n        // Move to next step\n        this.currentTourStep++;\n        this.showTourStep();\n    }\n\n    prevTourStep() {\n        // Clear current step\n        this.clearTourStep();\n        \n        // Move to previous step\n        this.currentTourStep--;\n        this.showTourStep();\n    }\n\n    clearTourStep() {\n        // Remove highlight from any elements\n        const highlighted = document.querySelectorAll('.help-highlight');\n        highlighted.forEach(el => el.classList.remove('help-highlight'));\n        \n        // Clear tooltips\n        this.hideHelpTooltip();\n    }\n\n    endTour() {\n        this.clearTourStep();\n        this.currentTourSteps = null;\n        this.currentTourStep = 0;\n        \n        // Show completion message\n        const container = getElement('helpTooltipContainer');\n        if (container) {\n            const message = document.createElement('div');\n            message.className = 'help-tooltip tour-complete';\n            message.innerHTML = `\n                <div class=\"help-tooltip-content\">\n                    <h4>Tour Complete</h4>\n                    <p>You can always enable help mode again using the help button.</p>\n                    <button class=\"btn btn-primary tour-close\">Close</button>\n                </div>\n            `;\n            \n            container.innerHTML = '';\n            container.appendChild(message);\n            \n            // Position in center of screen\n            message.style.top = '50%';\n            message.style.left = '50%';\n            message.style.transform = 'translate(-50%, -50%)';\n            \n            // Add close button handler\n            const closeBtn = message.querySelector('.tour-close');\n            if (closeBtn) {\n                closeBtn.addEventListener('click', () => {\n                    this.disableHelpMode();\n                });\n            }\n        }\n    }\n\n    // Add a contextual help method that can be called from other modules\n    showContextualHelp(elementId, customMessage) {\n        // Enable help mode temporarily\n        const wasActive = this.helpModeActive;\n        if (!wasActive) {\n            this.enableHelpMode();\n        }\n        \n        // Find the target element\n        const target = document.getElementById(elementId);\n        if (!target) return;\n        \n        // Get help message (custom or from defined messages)\n        const message = customMessage || this.helpTooltips.get(elementId);\n        if (!message) return;\n        \n        // Create and show tooltip\n        const tooltip = document.createElement('div');\n        tooltip.className = 'help-tooltip contextual-tooltip';\n        tooltip.innerHTML = `\n            <div class=\"help-tooltip-content\">\n                <p>${message}</p>\n                <button class=\"btn btn-sm btn-outline-secondary tooltip-close\">Close</button>\n            </div>\n            <div class=\"help-tooltip-arrow\"></div>\n        `;\n        \n        // Add to container\n        const container = getElement('helpTooltipContainer');\n        if (container) {\n            container.innerHTML = '';\n            container.appendChild(tooltip);\n            this.positionTooltip(tooltip, target);\n        }\n        \n        // Highlight the target element\n        target.classList.add('help-highlight');\n        \n        // Add event listener to close button\n        const closeBtn = tooltip.querySelector('.tooltip-close');\n        if (closeBtn) {\n            closeBtn.addEventListener('click', () => {\n                target.classList.remove('help-highlight');\n                this.hideHelpTooltip();\n                \n                // Disable help mode if it wasn't active before\n                if (!wasActive) {\n                    this.disableHelpMode();\n                }\n            });\n        }\n        \n        // Auto-close after a delay\n        setTimeout(() => {\n            if (tooltip.parentNode) {\n                target.classList.remove('help-highlight');\n                this.hideHelpTooltip();\n                \n                // Disable help mode if it wasn't active before\n                if (!wasActive) {\n                    this.disableHelpMode();\n                }\n            }\n        }, 8000);\n        \n        // Track current tooltip\n        this.currentTooltips.push(tooltip);\n    }\n}\n\nconst helpMode = new HelpMode();\n\nexport default helpMode;\n\n// Export default module\nexport default tours;\n","source":"/workspace/modules/static/js/modules/features/helpMode.js","title":"helpMode.js","language":"en"},{"content":"/**\n * historyManager.js\n * Manages task history, recent activity, and previous operations\n * Provides persistence for past operations\n */\n\n// Core modules\nimport errorHandler from '../core/errorHandler.js';\nimport uiRegistry from '../core/uiRegistry.js';\nimport stateManager from '../core/stateManager.js';\nimport eventRegistry from '../core/eventRegistry.js';\nimport eventManager from '../core/eventManager.js';\n\n// Utility modules\nimport utils from '../utils/utils.js';\n\nclass HistoryManager {\n    constructor() {\n        this.maxHistoryItems = 50; // Maximum number of history items to store\n        this.history = {\n            tasks: [],           // Processing tasks\n            downloads: [],       // File downloads\n            searches: [],        // Academic searches\n            recentFiles: []      // Recently accessed files\n        };\n        this.initialized = false;\n    }\n\n    /**\n     * Initialize the history manager\n     * @returns {Promise<boolean>} Initialization success\n     */\n    async initialize() {\n        try {\n            if (this.initialized) {\n                console.log('History manager already initialized');\n                return true;\n            }\n\n            console.log('Initializing history manager...');\n            \n            this.registerUIElements();\n            this.setupEventListeners();\n            await this.loadHistoryFromStorage();\n            \n            this.initialized = true;\n            console.log('History manager initialized successfully');\n            \n            return true;\n        } catch (error) {\n            console.error('Failed to initialize history manager:', error);\n            errorHandler.handleError(error);\n            return false;\n        }\n    }\n\n    /**\n     * Register UI elements with the UI registry\n     */\n    registerUIElements() {\n        // Primary containers\n        uiRegistry.registerElement('historyContainer', '#history');\n        uiRegistry.registerElement('historyTableBody', '#history-table-body');\n        \n        // History tab components\n        uiRegistry.registerElement('historyRefreshBtn', '#history-refresh-btn');\n        uiRegistry.registerElement('historyClearBtn', '#history-clear-btn');\n        uiRegistry.registerElement('historySearch', '#history-search');\n        uiRegistry.registerElement('historyFilter', '#history-filter');\n        uiRegistry.registerElement('historySort', '#history-sort');\n        \n        // PDF summaries container\n        uiRegistry.registerElement('pdfSummariesContainer', '#pdf-summaries-container');\n    }\n\n    /**\n     * Set up event listeners using event registry\n     */\n    setupEventListeners() {\n        // Use event registry for events\n        if (eventRegistry) {\n            // Register for button clicks in UI\n            eventRegistry.on('history.refresh', () => this.refreshHistoryDisplay());\n            eventRegistry.on('history.clear', () => this.clearHistory());\n            eventRegistry.on('history.filter', (data) => this.filterHistory(data.type));\n            eventRegistry.on('history.search', (data) => this.searchHistory(data.query));\n            eventRegistry.on('history.sort', (data) => this.sortHistory(data.method));\n            \n            // Register for task and file events\n            eventRegistry.on('task.completed', (data) => this.addTaskToHistory(data));\n            eventRegistry.on('file.downloaded', (data) => this.addDownloadToHistory(data));\n            eventRegistry.on('search.performed', (data) => this.addSearchToHistory(data));\n            eventRegistry.on('file.accessed', (data) => this.addFileToRecent(data));\n        }\n        \n        // Set up direct DOM events for the buttons\n        const refreshBtn = uiRegistry.getElement('historyRefreshBtn');\n        if (refreshBtn) {\n            refreshBtn.addEventListener('click', () => this.refreshHistoryDisplay());\n        }\n        \n        const clearBtn = uiRegistry.getElement('historyClearBtn');\n        if (clearBtn) {\n            clearBtn.addEventListener('click', () => this.clearHistory());\n        }\n        \n        const historyFilter = uiRegistry.getElement('historyFilter');\n        if (historyFilter) {\n            historyFilter.addEventListener('change', (e) => this.filterHistory(e.target.value));\n        }\n        \n        const historySearch = uiRegistry.getElement('historySearch');\n        if (historySearch) {\n            historySearch.addEventListener('input', (e) => this.searchHistory(e.target.value));\n        }\n        \n        const historySort = uiRegistry.getElement('historySort');\n        if (historySort) {\n            historySort.addEventListener('change', (e) => this.sortHistory(e.target.value));\n        }\n        \n        // Setup delegated event handling for the history table\n        const historyTableBody = uiRegistry.getElement('historyTableBody');\n        if (historyTableBody) {\n            historyTableBody.addEventListener('click', (e) => {\n                // Find the clicked button\n                const viewBtn = e.target.closest('[data-action=\"view\"]');\n                const openBtn = e.target.closest('[data-action=\"open\"]');\n                \n                if (viewBtn) {\n                    const taskId = viewBtn.getAttribute('data-id');\n                    this.showTaskDetails(taskId);\n                    e.preventDefault();\n                    return;\n                }\n                \n                if (openBtn) {\n                    const taskId = openBtn.getAttribute('data-id');\n                    this.openTaskOutput(taskId);\n                    e.preventDefault();\n                    return;\n                }\n            });\n        }\n    }\n\n    /**\n     * Load history from localStorage\n     * @returns {Promise<boolean>} Success status\n     */\n    async loadHistoryFromStorage() {\n        try {\n            const savedHistory = localStorage.getItem('neurogenHistory');\n            if (savedHistory) {\n                const parsed = JSON.parse(savedHistory);\n                \n                // Validate the structure\n                if (parsed && typeof parsed === 'object') {\n                    // Ensure all expected properties exist\n                    this.history = {\n                        tasks: Array.isArray(parsed.tasks) ? parsed.tasks : [],\n                        downloads: Array.isArray(parsed.downloads) ? parsed.downloads : [],\n                        searches: Array.isArray(parsed.searches) ? parsed.searches : [],\n                        recentFiles: Array.isArray(parsed.recentFiles) ? parsed.recentFiles : []\n                    };\n                    \n                    console.log(`Loaded history: ${this.history.tasks.length} tasks, ${this.history.downloads.length} downloads, ${this.history.searches.length} searches, ${this.history.recentFiles.length} recent files`);\n                    this.refreshHistoryDisplay();\n                    return true;\n                }\n            }\n            \n            // If we got here, either no history or invalid format\n            console.log('No valid history found in storage, using defaults');\n            return false;\n        } catch (error) {\n            console.error('Failed to load history from storage:', error);\n            errorHandler.handleError(new Error(`Failed to load history: ${error.message}`));\n            return false;\n        }\n    }\n\n    /**\n     * Save history to localStorage\n     * @returns {boolean} Success status\n     */\n    saveHistoryToStorage() {\n        try {\n            localStorage.setItem('neurogenHistory', JSON.stringify(this.history));\n            return true;\n        } catch (error) {\n            console.error('Failed to save history to storage:', error);\n            errorHandler.handleError(new Error(`Failed to save history: ${error.message}`));\n            \n            // If quota exceeded, try to reduce history size\n            if (error.name === 'QuotaExceededError') {\n                this.reduceCachedHistorySize();\n                try {\n                    localStorage.setItem('neurogenHistory', JSON.stringify(this.history));\n                    return true;\n                } catch (retryError) {\n                    console.error('Failed to save history after reduction:', retryError);\n                    return false;\n                }\n            }\n            \n            return false;\n        }\n    }\n\n    /**\n     * Reduce the cached history size when localStorage quota is exceeded\n     */\n    reduceCachedHistorySize() {\n        // Cut all history arrays in half\n        this.history.tasks = this.history.tasks.slice(0, Math.max(5, Math.floor(this.history.tasks.length / 2)));\n        this.history.downloads = this.history.downloads.slice(0, Math.max(5, Math.floor(this.history.downloads.length / 2)));\n        this.history.searches = this.history.searches.slice(0, Math.max(5, Math.floor(this.history.searches.length / 2)));\n        this.history.recentFiles = this.history.recentFiles.slice(0, Math.max(5, Math.floor(this.history.recentFiles.length / 2)));\n        \n        console.warn('History size reduced due to storage quota limits');\n    }\n\n    /**\n     * Add a task to the history\n     * @param {Object} taskData - Task data to add\n     */\n    addTaskToHistory(taskData) {\n        if (!taskData) return;\n        \n        try {\n            // Create a sanitized task object with required fields\n            const task = {\n                id: taskData.task_id || taskData.id || `task-${Date.now()}`,\n                type: taskData.type || 'processing',\n                timestamp: taskData.timestamp || Date.now(),\n                status: taskData.status || 'completed',\n                filename: taskData.filename || (taskData.output_file ? this.getFileNameFromPath(taskData.output_file) : 'Unknown'),\n                inputPath: taskData.input_dir || taskData.inputPath,\n                outputPath: taskData.output_file || taskData.outputPath,\n                stats: this.sanitizeStats(taskData.stats || {})\n            };\n\n            // Add to history (avoid duplicates)\n            const existingIndex = this.history.tasks.findIndex(t => t.id === task.id);\n            if (existingIndex >= 0) {\n                // Update existing task\n                this.history.tasks[existingIndex] = {...this.history.tasks[existingIndex], ...task};\n            } else {\n                // Add new task\n                this.history.tasks.unshift(task);\n                \n                // Limit history size\n                if (this.history.tasks.length > this.maxHistoryItems) {\n                    this.history.tasks.pop();\n                }\n            }\n\n            // Update storage\n            this.saveHistoryToStorage();\n            \n            // Update UI if the history tab is active\n            const historyTab = document.querySelector('#history.active');\n            if (historyTab) {\n                this.refreshHistoryDisplay();\n            }\n\n            // Emit event via eventRegistry\n            if (eventRegistry) {\n                eventRegistry.emit('history.updated', { \n                    type: 'task', \n                    data: task \n                });\n            }\n            \n            return true;\n        } catch (error) {\n            console.error('Failed to add task to history:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Add a download to the history\n     * @param {Object} downloadData - Download data to add\n     */\n    addDownloadToHistory(downloadData) {\n        if (!downloadData) return;\n        \n        try {\n            // Create download object\n            const download = {\n                id: downloadData.id || downloadData.download_id || `download-${Date.now()}`,\n                timestamp: downloadData.timestamp || Date.now(),\n                url: downloadData.url,\n                filePath: downloadData.filePath || downloadData.path,\n                fileName: downloadData.fileName || this.getFileNameFromPath(downloadData.filePath || downloadData.path),\n                fileSize: downloadData.fileSize || downloadData.size,\n                fileType: downloadData.fileType || this.getFileTypeFromPath(downloadData.filePath || downloadData.path)\n            };\n\n            // Add to history (avoid duplicates)\n            const existingIndex = this.history.downloads.findIndex(d => \n                d.filePath === download.filePath || d.id === download.id\n            );\n            \n            if (existingIndex >= 0) {\n                // Update existing download\n                this.history.downloads[existingIndex] = {...this.history.downloads[existingIndex], ...download};\n            } else {\n                // Add new download\n                this.history.downloads.unshift(download);\n                \n                // Limit history size\n                if (this.history.downloads.length > this.maxHistoryItems) {\n                    this.history.downloads.pop();\n                }\n            }\n\n            // Update storage\n            this.saveHistoryToStorage();\n            \n            // Update recent files as well\n            this.addFileToRecent({\n                path: download.filePath,\n                name: download.fileName,\n                type: download.fileType,\n                size: download.fileSize,\n                lastAccessed: download.timestamp\n            });\n            \n            // Emit event via eventRegistry\n            if (eventRegistry) {\n                eventRegistry.emit('history.updated', { \n                    type: 'download', \n                    data: download \n                });\n            }\n            \n            return true;\n        } catch (error) {\n            console.error('Failed to add download to history:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Add a search to the history\n     * @param {Object} searchData - Search data to add\n     */\n    addSearchToHistory(searchData) {\n        if (!searchData || !searchData.query) return;\n        \n        try {\n            // Create search object\n            const search = {\n                id: searchData.id || `search-${Date.now()}`,\n                timestamp: searchData.timestamp || Date.now(),\n                query: searchData.query,\n                source: searchData.source || 'all',\n                resultsCount: searchData.resultsCount || 0\n            };\n\n            // Add to history (avoid exact duplicates in short time periods)\n            const existingIndex = this.history.searches.findIndex(s => \n                s.query === search.query && \n                s.source === search.source &&\n                // Only consider it a duplicate if within last hour\n                (search.timestamp - s.timestamp < 3600000)\n            );\n            \n            if (existingIndex >= 0) {\n                // Update existing search\n                this.history.searches[existingIndex] = {...this.history.searches[existingIndex], ...search};\n                // Move to top\n                const existingSearch = this.history.searches.splice(existingIndex, 1)[0];\n                this.history.searches.unshift(existingSearch);\n            } else {\n                // Add new search\n                this.history.searches.unshift(search);\n                \n                // Limit history size\n                if (this.history.searches.length > this.maxHistoryItems) {\n                    this.history.searches.pop();\n                }\n            }\n\n            // Update storage\n            this.saveHistoryToStorage();\n            \n            // Emit event via eventRegistry\n            if (eventRegistry) {\n                eventRegistry.emit('history.updated', { \n                    type: 'search', \n                    data: search \n                });\n            }\n            \n            return true;\n        } catch (error) {\n            console.error('Failed to add search to history:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Add a file to the recent files list\n     * @param {Object} fileData - File data to add\n     */\n    addFileToRecent(fileData) {\n        if (!fileData || !fileData.path) return;\n        \n        try {\n            // Normalize file data\n            const file = {\n                path: fileData.path,\n                name: fileData.name || this.getFileNameFromPath(fileData.path),\n                type: fileData.type || this.getFileTypeFromPath(fileData.path),\n                size: fileData.size,\n                lastAccessed: fileData.lastAccessed || Date.now()\n            };\n\n            // Check if file already exists in recent files\n            const existingIndex = this.history.recentFiles.findIndex(f => f.path === file.path);\n\n            if (existingIndex >= 0) {\n                // Update last accessed time and move to front\n                this.history.recentFiles[existingIndex].lastAccessed = file.lastAccessed;\n                \n                // Move to the front of the array\n                const existingFile = this.history.recentFiles.splice(existingIndex, 1)[0];\n                this.history.recentFiles.unshift(existingFile);\n            } else {\n                // Add new file to front\n                this.history.recentFiles.unshift(file);\n                \n                // Limit history size\n                if (this.history.recentFiles.length > this.maxHistoryItems) {\n                    this.history.recentFiles.pop();\n                }\n            }\n\n            // Update storage\n            this.saveHistoryToStorage();\n            \n            // Emit event via eventRegistry\n            if (eventRegistry) {\n                eventRegistry.emit('history.updated', { \n                    type: 'recentFile', \n                    data: file \n                });\n            }\n            \n            return true;\n        } catch (error) {\n            console.error('Failed to add file to recent files:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Extract a filename from a path\n     * @param {string} path - File path\n     * @returns {string} Filename\n     */\n    getFileNameFromPath(path) {\n        if (!path) return 'Unknown';\n        \n        // Handle both Windows and Unix paths\n        const parts = path.split(/[\\/\\\\]/);\n        return parts[parts.length - 1] || 'Unknown';\n    }\n\n    /**\n     * Determine file type from path\n     * @param {string} path - File path\n     * @returns {string} File type description\n     */\n    getFileTypeFromPath(path) {\n        if (!path) return 'Unknown File';\n        \n        const extension = path.split('.').pop().toLowerCase();\n        \n        const fileTypes = {\n            'pdf': 'PDF Document',\n            'json': 'JSON File',\n            'txt': 'Text File',\n            'csv': 'CSV Spreadsheet',\n            'xlsx': 'Excel Spreadsheet',\n            'docx': 'Word Document',\n            'png': 'PNG Image',\n            'jpg': 'JPEG Image',\n            'jpeg': 'JPEG Image',\n            'gif': 'GIF Image',\n            'mp3': 'MP3 Audio',\n            'mp4': 'MP4 Video',\n            'zip': 'ZIP Archive',\n            'html': 'HTML Document',\n            'js': 'JavaScript File',\n            'py': 'Python File'\n        };\n\n        return fileTypes[extension] || 'Unknown File';\n    }\n\n    /**\n     * Sanitize stats object for storage\n     * @param {Object} stats - Statistics object\n     * @returns {Object} Sanitized stats\n     */\n    sanitizeStats(stats) {\n        if (!stats || typeof stats !== 'object') return {};\n        \n        // Create a simple copy of the stats\n        const sanitized = {};\n        \n        // Only include primitive values and simple arrays\n        for (const [key, value] of Object.entries(stats)) {\n            // Skip functions, complex objects, etc.\n            if (value === null || value === undefined) continue;\n            \n            if (['string', 'number', 'boolean'].includes(typeof value)) {\n                sanitized[key] = value;\n            } else if (Array.isArray(value) && value.every(item => typeof item !== 'object')) {\n                sanitized[key] = [...value];\n            } else if (typeof value === 'object' && Object.keys(value).length < 10) {\n                // Include small objects\n                try {\n                    // Test if it's serializable\n                    JSON.stringify(value);\n                    sanitized[key] = {...value};\n                } catch (e) {\n                    // Skip if not serializable\n                }\n            }\n        }\n        \n        return sanitized;\n    }\n\n    /**\n     * Refresh the history display\n     */\n    refreshHistoryDisplay() {\n        try {\n            const historyTableBody = uiRegistry.getElement('historyTableBody');\n            if (!historyTableBody) return;\n            \n            // Get tasks and sort by timestamp (newest first)\n            const tasks = [...this.history.tasks].sort((a, b) => b.timestamp - a.timestamp);\n            \n            if (tasks.length === 0) {\n                historyTableBody.innerHTML = `\n                <tr class=\"history-empty-row\">\n                    <td colspan=\"5\" class=\"text-center py-4\">\n                        <i class=\"fas fa-info-circle me-2\"></i>No tasks in history\n                    </td>\n                </tr>`;\n                return;\n            }\n            \n            // Generate HTML for table rows\n            let html = '';\n            \n            tasks.forEach(task => {\n                // Format date\n                const date = new Date(task.timestamp);\n                const formattedDate = date.toLocaleString();\n                \n                // Set task type badge\n                let typeBadge = '';\n                switch (task.type) {\n                    case 'file':\n                        typeBadge = '<span class=\"badge bg-primary\">File</span>';\n                        break;\n                    case 'playlist':\n                        typeBadge = '<span class=\"badge bg-success\">Playlist</span>';\n                        break;\n                    case 'scraper':\n                        typeBadge = '<span class=\"badge bg-info\">Scraper</span>';\n                        break;\n                    default:\n                        typeBadge = '<span class=\"badge bg-secondary\">Other</span>';\n                }\n                \n                // Add row content\n                html += `\n                <tr>\n                    <td>${typeBadge}</td>\n                    <td>${task.filename || 'N/A'}</td>\n                    <td>${formattedDate}</td>\n                    <td>${this.formatTaskStats(task.stats)}</td>\n                    <td>\n                        <div class=\"btn-group\">\n                            <button class=\"btn btn-sm btn-outline-primary\" data-action=\"view\" data-id=\"${task.id}\">\n                                <i class=\"fas fa-eye\"></i>\n                            </button>\n                            <button class=\"btn btn-sm btn-outline-secondary\" data-action=\"open\" data-id=\"${task.id}\">\n                                <i class=\"fas fa-folder-open\"></i>\n                            </button>\n                        </div>\n                    </td>\n                </tr>`;\n            });\n            \n            historyTableBody.innerHTML = html;\n            \n            // Update PDF summaries if container exists\n            this.updatePDFSummaries();\n        } catch (error) {\n            console.error('Error refreshing history display:', error);\n        }\n    }\n\n    /**\n     * Format task stats for display\n     * @param {Object} stats - Task statistics\n     * @returns {string} Formatted stats\n     */\n    formatTaskStats(stats) {\n        if (!stats || typeof stats !== 'object') return 'N/A';\n        \n        // Try to extract the most relevant stats\n        const items = [];\n        \n        // Files processed\n        if (stats.total_files && stats.processed_files) {\n            items.push(`${stats.processed_files}/${stats.total_files} files`);\n        } else if (stats.processed_files) {\n            items.push(`${stats.processed_files} files`);\n        }\n        \n        // PDF info\n        if (stats.pdf_files) {\n            items.push(`${stats.pdf_files} PDFs`);\n        }\n        \n        // Tables\n        if (stats.tables_extracted) {\n            items.push(`${stats.tables_extracted} tables`);\n        }\n        \n        // File size\n        if (stats.total_bytes) {\n            items.push(this.formatBytes(stats.total_bytes));\n        } else if (stats.human_readable_size) {\n            items.push(stats.human_readable_size);\n        }\n        \n        // Return formatted string\n        return items.length > 0 ? items.join(', ') : 'N/A';\n    }\n\n    /**\n     * Format bytes to human-readable format\n     * @param {number} bytes - Bytes to format\n     * @returns {string} Formatted size\n     */\n    formatBytes(bytes) {\n        // Use utils if available\n        if (utils && typeof utils.formatBytes === 'function') {\n            return utils.formatBytes(bytes);\n        }\n        \n        // Fallback implementation\n        if (bytes === 0) return '0 Bytes';\n        \n        const k = 1024;\n        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n        const i = Math.floor(Math.log(bytes) / Math.log(k));\n        \n        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n    }\n\n    /**\n     * Update PDF summaries in the history tab\n     */\n    updatePDFSummaries() {\n        const container = uiRegistry.getElement('pdfSummariesContainer');\n        if (!container) return;\n        \n        // Find PDF files in recent history\n        const pdfTasks = this.history.tasks.filter(task => \n            task.outputPath && task.outputPath.toLowerCase().endsWith('.pdf') ||\n            task.filename && task.filename.toLowerCase().endsWith('.pdf')\n        );\n        \n        // Also check downloads\n        const pdfDownloads = this.history.downloads.filter(download =>\n            download.filePath && download.filePath.toLowerCase().endsWith('.pdf') ||\n            download.fileName && download.fileName.toLowerCase().endsWith('.pdf')\n        );\n        \n        // Combine and sort\n        const allPdfs = [...pdfTasks, ...pdfDownloads]\n            .sort((a, b) => b.timestamp - a.timestamp)\n            .slice(0, 6); // Show up to 6 items\n        \n        if (allPdfs.length === 0) {\n            container.innerHTML = `\n            <div class=\"col-12 text-center py-4 text-muted\">\n                <i class=\"fas fa-file-pdf me-2\"></i>No PDF summaries available\n            </div>`;\n            return;\n        }\n        \n        // Get the template\n        const template = document.getElementById('pdf-summary-card-template');\n        if (!template) {\n            console.warn('PDF summary card template not found');\n            return;\n        }\n        \n        // Clear container\n        container.innerHTML = '';\n        \n        // Add cards\n        allPdfs.forEach(pdf => {\n            // Clone template\n            const card = template.content.cloneNode(true);\n            \n            // Fill in data\n            card.querySelector('.pdf-title').textContent = pdf.filename || pdf.fileName || 'PDF Document';\n            \n            // Set badge type\n            const badge = card.querySelector('.pdf-type-badge');\n            if (badge) {\n                badge.textContent = pdf.type || 'Document';\n                \n                // Set badge color\n                const badgeClasses = {\n                    'file': 'bg-primary',\n                    'scraper': 'bg-info',\n                    'academic_paper': 'bg-success',\n                    'book': 'bg-warning',\n                    'report': 'bg-secondary'\n                };\n                \n                const classList = badgeClasses[pdf.type] || 'bg-secondary';\n                badge.classList.add(classList);\n            }\n            \n            // Set page count\n            const pagesCount = card.querySelector('.pages-count');\n            if (pagesCount) {\n                const pages = pdf.stats?.pdf_pages_processed || \n                            pdf.stats?.page_count || \n                            pdf.stats?.pages || \n                            '?';\n                pagesCount.textContent = pages;\n            }\n            \n            // Set tables count\n            const tablesCount = card.querySelector('.tables-count');\n            if (tablesCount) {\n                const tables = pdf.stats?.tables_extracted || \n                            pdf.stats?.tables_count || \n                            0;\n                tablesCount.textContent = tables;\n            }\n            \n            // Set file size\n            const fileSize = card.querySelector('.file-size');\n            if (fileSize) {\n                const size = pdf.stats?.file_size_mb || \n                            pdf.fileSize ? this.formatBytes(pdf.fileSize) : \n                            '?';\n                fileSize.textContent = size;\n            }\n            \n            // Set summary\n            const summary = card.querySelector('.pdf-summary');\n            if (summary) {\n                summary.textContent = pdf.stats?.summary || \n                                    'No summary available for this PDF.';\n            }\n            \n            // Set up button actions\n            const viewBtn = card.querySelector('.view-pdf-btn');\n            if (viewBtn) {\n                viewBtn.addEventListener('click', () => {\n                    const filePath = pdf.outputPath || pdf.filePath;\n                    if (filePath) {\n                        this.viewPdf(filePath);\n                    }\n                });\n            }\n            \n            const structureBtn = card.querySelector('.structure-pdf-btn');\n            if (structureBtn) {\n                structureBtn.addEventListener('click', () => {\n                    const filePath = pdf.outputPath || pdf.filePath;\n                    if (filePath) {\n                        this.viewPdfStructure(filePath);\n                    }\n                });\n            }\n            \n            const jsonBtn = card.querySelector('.view-json-btn');\n            if (jsonBtn) {\n                jsonBtn.addEventListener('click', () => {\n                    const filePath = pdf.outputPath || pdf.filePath;\n                    if (filePath) {\n                        // Try to find corresponding JSON file\n                        const jsonPath = filePath.replace(/\\.pdf$/i, '.json');\n                        this.openFile(jsonPath);\n                    }\n                });\n            }\n            \n            // Add to container\n            container.appendChild(card);\n        });\n    }\n\n    /**\n     * Filter history based on type\n     * @param {string} type - Type to filter by\n     */\n    filterHistory(type) {\n        if (!type || type === 'all') {\n            // Show all rows\n            document.querySelectorAll('#history-table-body tr').forEach(row => {\n                row.style.display = '';\n            });\n            return;\n        }\n        \n        // Hide rows that don't match\n        document.querySelectorAll('#history-table-body tr').forEach(row => {\n            const badgeEl = row.querySelector('.badge');\n            if (badgeEl) {\n                const badgeText = badgeEl.textContent.toLowerCase();\n                row.style.display = badgeText === type.toLowerCase() ? '' : 'none';\n            }\n        });\n    }\n\n    /**\n     * Search history based on query\n     * @param {string} query - Search query\n     */\n    searchHistory(query) {\n        if (!query) {\n            // Show all rows\n            document.querySelectorAll('#history-table-body tr').forEach(row => {\n                row.style.display = '';\n            });\n            return;\n        }\n        \n        const lowerQuery = query.toLowerCase();\n        \n        // Hide rows that don't match\n        document.querySelectorAll('#history-table-body tr').forEach(row => {\n            const text = row.textContent.toLowerCase();\n            row.style.display = text.includes(lowerQuery) ? '' : 'none';\n        });\n    }\n\n    /**\n     * Sort history based on method\n     * @param {string} method - Sort method\n     */\n    sortHistory(method) {\n        const historyTableBody = uiRegistry.getElement('historyTableBody');\n        if (!historyTableBody) return;\n        \n        // Get all rows as an array\n        const rows = Array.from(historyTableBody.querySelectorAll('tr'));\n        if (rows.length <= 1) return; // Nothing to sort\n        \n        // Sort rows based on method\n        switch (method) {\n            case 'newest':\n                // Sort by date (newest first)\n                rows.sort((a, b) => {\n                    const dateA = new Date(a.querySelector('td:nth-child(3)').textContent);\n                    const dateB = new Date(b.querySelector('td:nth-child(3)').textContent);\n                    return dateB - dateA;\n                });\n                break;\n                \n            case 'oldest':\n                // Sort by date (oldest first)\n                rows.sort((a, b) => {\n                    const dateA = new Date(a.querySelector('td:nth-child(3)').textContent);\n                    const dateB = new Date(b.querySelector('td:nth-child(3)').textContent);\n                    return dateA - dateB;\n                });\n                break;\n                \n            case 'type':\n                // Sort by type\n                rows.sort((a, b) => {\n                    const typeA = a.querySelector('td:nth-child(1)').textContent;\n                    const typeB = b.querySelector('td:nth-child(1)').textContent;\n                    return typeA.localeCompare(typeB);\n                });\n                break;\n                \n            case 'name':\n                // Sort by filename\n                rows.sort((a, b) => {\n                    const nameA = a.querySelector('td:nth-child(2)').textContent;\n                    const nameB = b.querySelector('td:nth-child(2)').textContent;\n                    return nameA.localeCompare(nameB);\n                });\n                break;\n                \n            default:\n                return; // Unknown sort method\n        }\n        \n        // Clear table and add sorted rows\n        historyTableBody.innerHTML = '';\n        rows.forEach(row => historyTableBody.appendChild(row));\n    }\n\n    /**\n     * Clear all history\n     */\n    clearHistory() {\n        // Show confirmation dialog\n        if (confirm('Are you sure you want to clear all history? This cannot be undone.')) {\n            // Reset history\n            this.history = {\n                tasks: [],\n                downloads: [],\n                searches: [],\n                recentFiles: []\n            };\n            \n            // Update storage\n            this.saveHistoryToStorage();\n            \n            // Update display\n            this.refreshHistoryDisplay();\n            \n            // Show toast notification if UI module is available\n            if (window.ui && typeof window.ui.showToast === 'function') {\n                window.ui.showToast('History Cleared', 'All history has been cleared', 'info');\n            }\n            \n            // Emit event via eventRegistry\n            if (eventRegistry) {\n                eventRegistry.emit('history.cleared');\n            }\n        }\n    }\n\n    /**\n     * Show task details in a modal\n     * @param {string} taskId - Task ID\n     */\n    showTaskDetails(taskId) {\n        if (!taskId) return;\n        \n        try {\n            // Find the task\n            const task = this.history.tasks.find(t => t.id === taskId);\n            if (!task) {\n                console.warn(`Task not found: ${taskId}`);\n                return;\n            }\n            \n            // Find or create modal\n            let modal = document.getElementById('task-details-modal');\n            if (!modal) {\n                console.warn('Task details modal not found in the DOM');\n                return;\n            }\n            \n            // Format date\n            const date = new Date(task.timestamp);\n            const formattedDate = date.toLocaleString();\n            \n            // Populate modal content\n            const contentEl = document.getElementById('task-details-content');\n            if (contentEl) {\n                // Create details HTML\n                let detailsHtml = `\n                    <div class=\"task-details\">\n                        <div class=\"row mb-3\">\n                            <div class=\"col-md-6\">\n                                <strong>Type:</strong> ${task.type || 'Unknown'}\n                            </div>\n                            <div class=\"col-md-6\">\n                                <strong>Created:</strong> ${formattedDate}\n                            </div>\n                        </div>\n                        <div class=\"row mb-3\">\n                            <div class=\"col-md-6\">\n                                <strong>File:</strong> ${task.filename || 'N/A'}\n                            </div>\n                            <div class=\"col-md-6\">\n                                <strong>Status:</strong> ${task.status || 'Completed'}\n                            </div>\n                        </div>\n                `;\n                \n                // Add stats if available\n                if (task.stats && Object.keys(task.stats).length > 0) {\n                    detailsHtml += `\n                        <div class=\"mt-3\">\n                            <h6>Statistics</h6>\n                            <div class=\"p-3 bg-light rounded\">\n                                <table class=\"table table-sm mb-0\">\n                                    <tbody>\n                    `;\n                    \n                    // Add each stat\n                    for (const [key, value] of Object.entries(task.stats)) {\n                        if (typeof value === 'object') continue;\n                        \n                        const formattedKey = key.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n                        \n                        detailsHtml += `\n                            <tr>\n                                <td>${formattedKey}</td>\n                                <td>${value}</td>\n                            </tr>\n                        `;\n                    }\n                    \n                    detailsHtml += `\n                                    </tbody>\n                                </table>\n                            </div>\n                        </div>\n                    `;\n                }\n                \n                // Add output path if available\n                if (task.outputPath) {\n                    detailsHtml += `\n                        <div class=\"mt-3\">\n                            <h6>Output File</h6>\n                            <div class=\"p-3 bg-light rounded\">\n                                ${task.outputPath}\n                            </div>\n                        </div>\n                    `;\n                }\n                \n                // Close the container\n                detailsHtml += '</div>';\n                \n                // Set content\n                contentEl.innerHTML = detailsHtml;\n            }\n            \n            // Set up open file button\n            const openButton = document.getElementById('open-task-file-btn');\n            if (openButton) {\n                openButton.onclick = () => this.openTaskOutput(taskId);\n                \n                // Enable/disable based on whether there's an output file\n                openButton.disabled = !task.outputPath;\n            }\n            \n            // Show modal using Bootstrap\n            const bsModal = bootstrap && bootstrap.Modal ? new bootstrap.Modal(modal) : null;\n            if (bsModal) {\n                bsModal.show();\n            } else {\n                // Fallback if Bootstrap is not available\n                modal.classList.add('show');\n                modal.style.display = 'block';\n                document.body.classList.add('modal-open');\n                \n                // Add backdrop if needed\n                if (!document.querySelector('.modal-backdrop')) {\n                    const backdrop = document.createElement('div');\n                    backdrop.className = 'modal-backdrop fade show';\n                    document.body.appendChild(backdrop);\n                }\n            }\n        } catch (error) {\n            console.error('Error showing task details:', error);\n            errorHandler.handleError(error);\n        }\n    }\n\n    /**\n     * Open the output file of a task\n     * @param {string} taskId - Task ID\n     */\n    openTaskOutput(taskId) {\n        if (!taskId) return;\n        \n        try {\n            // Find the task\n            const task = this.history.tasks.find(t => t.id === taskId);\n            if (!task || !task.outputPath) {\n                if (window.ui && typeof window.ui.showToast === 'function') {\n                    window.ui.showToast('Error', 'Output file not found for this task', 'error');\n                }\n                return;\n            }\n            \n            // Open the file\n            this.openFile(task.outputPath);\n        } catch (error) {\n            console.error('Error opening task output:', error);\n            errorHandler.handleError(error);\n        }\n    }\n\n    /**\n     * Open a file using the most appropriate method\n     * @param {string} filePath - Path to the file\n     */\n    async openFile(filePath) {\n        if (!filePath) return;\n        \n        try {\n            // First, try using the browser's file handler\n            if (typeof window.showOpenFilePicker === 'function' && window.moduleInstances.fileHandler) {\n                const result = await window.moduleInstances.fileHandler.openFile(filePath);\n                if (result) {\n                    return;\n                }\n            }\n            \n            // Different methods based on file type\n            const extension = filePath.split('.').pop().toLowerCase();\n            \n            // JSON files\n            if (extension === 'json') {\n                // Request from server\n                const response = await fetch(`/api/get-file?path=${encodeURIComponent(filePath)}`);\n                if (!response.ok) {\n                    throw new Error(`Failed to fetch file: ${response.statusText}`);\n                }\n                \n                // Get JSON content\n                const json = await response.json();\n                \n                // Display in a modal or a new tab\n                this.displayJsonContent(json, filePath);\n                return;\n            }\n            \n            // PDF files\n            if (extension === 'pdf') {\n                // Open PDF viewer\n                this.viewPdf(filePath);\n                return;\n            }\n            \n            // Text files\n            if (['txt', 'md', 'csv', 'js', 'py', 'html', 'css'].includes(extension)) {\n                // Request from server\n                const response = await fetch(`/api/get-file?path=${encodeURIComponent(filePath)}`);\n                if (!response.ok) {\n                    throw new Error(`Failed to fetch file: ${response.statusText}`);\n                }\n                \n                // Get text content\n                const text = await response.text();\n                \n                // Display in a modal\n                this.displayTextContent(text, filePath, extension);\n                return;\n            }\n            \n            // For other file types, try to download or open via API\n            if (window.ui && typeof window.ui.showToast === 'function') {\n                window.ui.showToast('Opening File', `Opening ${filePath}`, 'info');\n            }\n            \n            // Try opening file through backend API\n            const response = await fetch('/api/open-file', {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: JSON.stringify({ path: filePath })\n            });\n            \n            if (!response.ok) {\n                throw new Error(`Failed to open file via API: ${response.statusText}`);\n            }\n            \n            // Record the file access\n            this.addFileToRecent({\n                path: filePath,\n                name: this.getFileNameFromPath(filePath),\n                lastAccessed: Date.now()\n            });\n            \n        } catch (error) {\n            console.error('Error opening file:', error);\n            errorHandler.handleError(error);\n            \n            // Fallback: try to download the file\n            try {\n                window.open(`/api/download-file?path=${encodeURIComponent(filePath)}`, '_blank');\n            } catch (downloadError) {\n                console.error('Error downloading file:', downloadError);\n            }\n        }\n    }\n\n    /**\n     * Display JSON content in a modal\n     * @param {Object} json - JSON content\n     * @param {string} filePath - Path to the file\n     */\n    displayJsonContent(json, filePath) {\n        try {\n            // Use UI module if available\n            if (window.ui && typeof window.ui.showModal === 'function') {\n                const fileName = this.getFileNameFromPath(filePath);\n                \n                window.ui.showModal({\n                    title: `JSON Viewer: ${fileName}`,\n                    content: `\n                        <div class=\"json-viewer\">\n                            <pre class=\"language-json\">${JSON.stringify(json, null, 2)}</pre>\n                        </div>\n                    `,\n                    size: 'large',\n                    buttons: [\n                        {\n                            text: 'Close',\n                            type: 'btn-secondary'\n                        },\n                        {\n                            text: 'Download',\n                            type: 'btn-primary',\n                            handler: () => {\n                                // Create download link\n                                const blob = new Blob([JSON.stringify(json, null, 2)], { type: 'application/json' });\n                                const url = URL.createObjectURL(blob);\n                                const a = document.createElement('a');\n                                a.href = url;\n                                a.download = fileName;\n                                document.body.appendChild(a);\n                                a.click();\n                                document.body.removeChild(a);\n                                URL.revokeObjectURL(url);\n                            }\n                        }\n                    ]\n                });\n                \n                // Apply syntax highlighting if Prism.js is available\n                if (window.Prism) {\n                    Prism.highlightAll();\n                }\n                \n                return;\n            }\n            \n            // Fallback: Open JSON in a new window\n            const jsonString = JSON.stringify(json, null, 2);\n            const newWindow = window.open('', '_blank');\n            if (newWindow) {\n                newWindow.document.write(`\n                    <!DOCTYPE html>\n                    <html>\n                    <head>\n                        <title>JSON Viewer: ${this.getFileNameFromPath(filePath)}</title>\n                        <style>\n                            body { font-family: monospace; white-space: pre; }\n                        </style>\n                    </head>\n                    <body>${jsonString}</body>\n                    </html>\n                `);\n                newWindow.document.close();\n            } else {\n                // If popup blocked, try to download instead\n                this.downloadTextAsFile(jsonString, filePath);\n            }\n        } catch (error) {\n            console.error('Error displaying JSON content:', error);\n            errorHandler.handleError(error);\n        }\n    }\n\n    /**\n     * Display text content in a modal\n     * @param {string} text - Text content\n     * @param {string} filePath - Path to the file\n     * @param {string} extension - File extension\n     */\n    displayTextContent(text, filePath, extension) {\n        try {\n            // Use UI module if available\n            if (window.ui && typeof window.ui.showModal === 'function') {\n                const fileName = this.getFileNameFromPath(filePath);\n                \n                window.ui.showModal({\n                    title: `Text Viewer: ${fileName}`,\n                    content: `\n                        <div class=\"text-viewer\">\n                            <pre class=\"language-${extension}\">${text}</pre>\n                        </div>\n                    `,\n                    size: 'large',\n                    buttons: [\n                        {\n                            text: 'Close',\n                            type: 'btn-secondary'\n                        },\n                        {\n                            text: 'Download',\n                            type: 'btn-primary',\n                            handler: () => {\n                                this.downloadTextAsFile(text, fileName);\n                            }\n                        }\n                    ]\n                });\n                \n                // Apply syntax highlighting if Prism.js is available\n                if (window.Prism) {\n                    Prism.highlightAll();\n                }\n                \n                return;\n            }\n            \n            // Fallback: Open text in a new window\n            const newWindow = window.open('', '_blank');\n            if (newWindow) {\n                newWindow.document.write(`\n                    <!DOCTYPE html>\n                    <html>\n                    <head>\n                        <title>Text Viewer: ${this.getFileNameFromPath(filePath)}</title>\n                        <style>\n                            body { font-family: monospace; white-space: pre; }\n                        </style>\n                    </head>\n                    <body>${text}</body>\n                    </html>\n                `);\n                newWindow.document.close();\n            } else {\n                // If popup blocked, try to download instead\n                this.downloadTextAsFile(text, filePath);\n            }\n        } catch (error) {\n            console.error('Error displaying text content:', error);\n            errorHandler.handleError(error);\n        }\n    }\n\n    /**\n     * Download text content as a file\n     * @param {string} content - Text content\n     * @param {string} filename - File name\n     */\n    downloadTextAsFile(content, filename) {\n        try {\n            // Create a blob\n            const blob = new Blob([content], { type: 'text/plain' });\n            const url = URL.createObjectURL(blob);\n            \n            // Create download link\n            const a = document.createElement('a');\n            a.href = url;\n            a.download = this.getFileNameFromPath(filename);\n            document.body.appendChild(a);\n            a.click();\n            document.body.removeChild(a);\n            URL.revokeObjectURL(url);\n        } catch (error) {\n            console.error('Error downloading text as file:', error);\n            errorHandler.handleError(error);\n        }\n    }\n\n    /**\n     * View a PDF file\n     * @param {string} filePath - Path to the PDF file\n     */\n    viewPdf(filePath) {\n        try {\n            // If a PDF viewer modal exists, use it\n            const pdfViewerModal = document.getElementById('pdfViewerModal');\n            if (pdfViewerModal && window.pdfjsLib) {\n                // Get container and clear it\n                const pdfContainer = document.getElementById('pdf-viewer-container');\n                if (pdfContainer) {\n                    pdfContainer.innerHTML = '';\n                    \n                    // Set modal title\n                    const modalTitle = pdfViewerModal.querySelector('.modal-title');\n                    if (modalTitle) {\n                        modalTitle.textContent = `PDF Viewer: ${this.getFileNameFromPath(filePath)}`;\n                    }\n                    \n                    // Set download button\n                    const downloadBtn = document.getElementById('download-pdf-btn');\n                    if (downloadBtn) {\n                        downloadBtn.onclick = () => {\n                            window.open(`/api/download-file?path=${encodeURIComponent(filePath)}`, '_blank');\n                        };\n                    }\n                    \n                    // Show loading indicator\n                    const loadingIndicator = document.createElement('div');\n                    loadingIndicator.className = 'text-center p-5';\n                    loadingIndicator.innerHTML = `\n                        <div class=\"spinner-border text-primary\" role=\"status\">\n                            <span class=\"visually-hidden\">Loading PDF...</span>\n                        </div>\n                        <p class=\"mt-3\">Loading PDF...</p>\n                    `;\n                    pdfContainer.appendChild(loadingIndicator);\n                    \n                    // Show the modal\n                    const modal = new bootstrap.Modal(pdfViewerModal);\n                    modal.show();\n                    \n                    // Load the PDF\n                    this.loadPdfIntoViewer(filePath, pdfContainer);\n                    \n                    // Record the file access\n                    this.addFileToRecent({\n                        path: filePath,\n                        name: this.getFileNameFromPath(filePath),\n                        type: 'PDF Document',\n                        lastAccessed: Date.now()\n                    });\n                    \n                    return;\n                }\n            }\n            \n            // Fallback: Open PDF directly\n            window.open(`/api/view-pdf?path=${encodeURIComponent(filePath)}`, '_blank');\n            \n            // Record the file access\n            this.addFileToRecent({\n                path: filePath,\n                name: this.getFileNameFromPath(filePath),\n                type: 'PDF Document',\n                lastAccessed: Date.now()\n            });\n        } catch (error) {\n            console.error('Error viewing PDF:', error);\n            errorHandler.handleError(error);\n        }\n    }\n\n    /**\n     * Load a PDF into the viewer\n     * @param {string} filePath - Path to the PDF file\n     * @param {HTMLElement} container - Container element\n     */\n    async loadPdfIntoViewer(filePath, container) {\n        try {\n            // Ensure PDF.js is available\n            if (!window.pdfjsLib) {\n                throw new Error('PDF.js library not available');\n            }\n            \n            // Clear container\n            container.innerHTML = '';\n            \n            // Get PDF URL\n            const pdfUrl = `/api/download-file?path=${encodeURIComponent(filePath)}`;\n            \n            // Load the PDF document\n            const loadingTask = window.pdfjsLib.getDocument(pdfUrl);\n            const pdf = await loadingTask.promise;\n            \n            // Create PDF viewer\n            const viewer = document.createElement('div');\n            viewer.className = 'pdf-viewer';\n            container.appendChild(viewer);\n            \n            // Add page navigation controls\n            const controls = document.createElement('div');\n            controls.className = 'pdf-controls d-flex justify-content-between align-items-center bg-light p-2 sticky-top';\n            controls.innerHTML = `\n                <div class=\"d-flex align-items-center\">\n                    <button class=\"btn btn-sm btn-outline-primary me-2\" id=\"prev-page\">\n                        <i class=\"fas fa-chevron-left\"></i> Previous\n                    </button>\n                    <button class=\"btn btn-sm btn-outline-primary\" id=\"next-page\">\n                        Next <i class=\"fas fa-chevron-right\"></i>\n                    </button>\n                </div>\n                <div class=\"d-flex align-items-center\">\n                    <span>Page <span id=\"page-num\">1</span> of <span id=\"page-count\">${pdf.numPages}</span></span>\n                </div>\n                <div class=\"d-flex align-items-center\">\n                    <button class=\"btn btn-sm btn-outline-secondary me-2\" id=\"zoom-out\">\n                        <i class=\"fas fa-search-minus\"></i>\n                    </button>\n                    <button class=\"btn btn-sm btn-outline-secondary\" id=\"zoom-in\">\n                        <i class=\"fas fa-search-plus\"></i>\n                    </button>\n                </div>\n            `;\n            viewer.appendChild(controls);\n            \n            // Add canvas for PDF rendering\n            const pdfContainer = document.createElement('div');\n            pdfContainer.className = 'pdf-container mt-3';\n            viewer.appendChild(pdfContainer);\n            \n            // Render variables\n            let currentPage = 1;\n            let scale = 1.0;\n            \n            // Function to render a page\n            const renderPage = async (pageNum) => {\n                // Get page\n                const page = await pdf.getPage(pageNum);\n                \n                // Create canvas\n                const canvas = document.createElement('canvas');\n                const context = canvas.getContext('2d');\n                \n                // Set dimensions based on viewport\n                const viewport = page.getViewport({ scale });\n                canvas.height = viewport.height;\n                canvas.width = viewport.width;\n                \n                // Clear container and add canvas\n                pdfContainer.innerHTML = '';\n                pdfContainer.appendChild(canvas);\n                \n                // Render PDF page\n                const renderContext = {\n                    canvasContext: context,\n                    viewport: viewport\n                };\n                \n                await page.render(renderContext).promise;\n                \n                // Update page number display\n                document.getElementById('page-num').textContent = pageNum;\n            };\n            \n            // Render the first page\n            await renderPage(currentPage);\n            \n            // Add event listeners for controls\n            document.getElementById('prev-page').addEventListener('click', async () => {\n                if (currentPage <= 1) return;\n                currentPage--;\n                await renderPage(currentPage);\n            });\n            \n            document.getElementById('next-page').addEventListener('click', async () => {\n                if (currentPage >= pdf.numPages) return;\n                currentPage++;\n                await renderPage(currentPage);\n            });\n            \n            document.getElementById('zoom-out').addEventListener('click', async () => {\n                if (scale <= 0.5) return;\n                scale -= 0.1;\n                await renderPage(currentPage);\n            });\n            \n            document.getElementById('zoom-in').addEventListener('click', async () => {\n                if (scale >= 2.0) return;\n                scale += 0.1;\n                await renderPage(currentPage);\n            });\n            \n        } catch (error) {\n            console.error('Error loading PDF into viewer:', error);\n            // Show error in container\n            container.innerHTML = `\n                <div class=\"alert alert-danger m-3\">\n                    <h5>Error Loading PDF</h5>\n                    <p>${error.message}</p>\n                    <button class=\"btn btn-primary\" onclick=\"window.open('/api/download-file?path=${encodeURIComponent(filePath)}', '_blank')\">\n                        Try Direct Download\n                    </button>\n                </div>\n            `;\n        }\n    }\n\n    /**\n     * View the structure of a PDF file\n     * @param {string} filePath - Path to the PDF file\n     */\n    async viewPdfStructure(filePath) {\n        try {\n            // Request structure analysis from server\n            const response = await fetch(`/api/analyze-pdf-structure?path=${encodeURIComponent(filePath)}`);\n            if (!response.ok) {\n                throw new Error(`Failed to analyze PDF structure: ${response.statusText}`);\n            }\n            \n            const data = await response.json();\n            \n            // Use UI module if available\n            if (window.ui && typeof window.ui.showModal === 'function') {\n                const fileName = this.getFileNameFromPath(filePath);\n                \n                let structureHtml = `\n                    <div class=\"pdf-structure\">\n                        <div class=\"row mb-4\">\n                            <div class=\"col-md-6\">\n                                <div class=\"card h-100\">\n                                    <div class=\"card-header\">Document Information</div>\n                                    <div class=\"card-body\">\n                                        <table class=\"table table-sm\">\n                                            <tbody>\n                                                <tr>\n                                                    <td>Document Type</td>\n                                                    <td><span class=\"badge bg-${this.getDocTypeColor(data.document_type)}\">${data.document_type || 'Unknown'}</span></td>\n                                                </tr>\n                                                <tr>\n                                                    <td>Page Count</td>\n                                                    <td>${data.page_count || 'Unknown'}</td>\n                                                </tr>\n                                                <tr>\n                                                    <td>File Size</td>\n                                                    <td>${data.file_size_mb ? `${data.file_size_mb} MB` : 'Unknown'}</td>\n                                                </tr>\n                                                <tr>\n                                                    <td>Has Scanned Content</td>\n                                                    <td>${data.has_scanned_content ? 'Yes' : 'No'}</td>\n                                                </tr>\n                                                <tr>\n                                                    <td>Tables Count</td>\n                                                    <td>${data.tables_count || 0}</td>\n                                                </tr>\n                                            </tbody>\n                                        </table>\n                                    </div>\n                                </div>\n                            </div>\n                            <div class=\"col-md-6\">\n                                <div class=\"card h-100\">\n                                    <div class=\"card-header\">Metadata</div>\n                                    <div class=\"card-body\">\n                                        <table class=\"table table-sm\">\n                                            <tbody>\n                `;\n                \n                // Add metadata if available\n                if (data.metadata && Object.keys(data.metadata).length > 0) {\n                    for (const [key, value] of Object.entries(data.metadata)) {\n                        if (!value) continue;\n                        const formattedKey = key.replace(/_/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase());\n                        structureHtml += `\n                            <tr>\n                                <td>${formattedKey}</td>\n                                <td>${value}</td>\n                            </tr>\n                        `;\n                    }\n                } else {\n                    structureHtml += `\n                        <tr>\n                            <td colspan=\"2\" class=\"text-center text-muted\">No metadata available</td>\n                        </tr>\n                    `;\n                }\n                \n                structureHtml += `\n                                            </tbody>\n                                        </table>\n                                    </div>\n                                </div>\n                            </div>\n                        </div>\n                `;\n                \n                // Add sections if available\n                if (data.section_titles && data.section_titles.length > 0) {\n                    structureHtml += `\n                        <div class=\"card mb-4\">\n                            <div class=\"card-header\">Document Structure</div>\n                            <div class=\"card-body\">\n                                <ul class=\"list-group\">\n                    `;\n                    \n                    data.section_titles.forEach(title => {\n                        structureHtml += `<li class=\"list-group-item\">${title}</li>`;\n                    });\n                    \n                    structureHtml += `\n                                </ul>\n                            </div>\n                        </div>\n                    `;\n                }\n                \n                // Add tables info if available\n                if (data.tables_info && data.tables_info.length > 0) {\n                    structureHtml += `\n                        <div class=\"card\">\n                            <div class=\"card-header\">Tables</div>\n                            <div class=\"card-body\">\n                                <div class=\"table-responsive\">\n                                    <table class=\"table table-sm\">\n                                        <thead>\n                                            <tr>\n                                                <th>Table ID</th>\n                                                <th>Page</th>\n                                                <th>Rows</th>\n                                                <th>Columns</th>\n                                            </tr>\n                                        </thead>\n                                        <tbody>\n                    `;\n                    \n                    data.tables_info.forEach(table => {\n                        structureHtml += `\n                            <tr>\n                                <td>${table.table_id || 'Unknown'}</td>\n                                <td>${table.page || 'Unknown'}</td>\n                                <td>${table.rows || 0}</td>\n                                <td>${table.columns || 0}</td>\n                            </tr>\n                        `;\n                    });\n                    \n                    structureHtml += `\n                                        </tbody>\n                                    </table>\n                                </div>\n                            </div>\n                        </div>\n                    `;\n                }\n                \n                // Show the modal with the structure info\n                window.ui.showModal({\n                    title: `PDF Structure: ${fileName}`,\n                    content: structureHtml,\n                    size: 'large',\n                    buttons: [\n                        {\n                            text: 'Close',\n                            type: 'btn-secondary'\n                        },\n                        {\n                            text: 'View PDF',\n                            type: 'btn-primary',\n                            handler: () => this.viewPdf(filePath)\n                        }\n                    ]\n                });\n                \n                return;\n            }\n            \n            // Fallback if UI module is not available: show alert\n            alert(`PDF Structure Analysis for ${this.getFileNameFromPath(filePath)}:\\n\\n` +\n                `Document Type: ${data.document_type || 'Unknown'}\\n` +\n                `Pages: ${data.page_count || 'Unknown'}\\n` +\n                `Tables: ${data.tables_count || 0}`);\n            \n        } catch (error) {\n            console.error('Error viewing PDF structure:', error);\n            errorHandler.handleError(error);\n        }\n    }\n\n    /**\n     * Get badge color for document type\n     * @param {string} docType - Document type\n     * @returns {string} Bootstrap color class\n     */\n    getDocTypeColor(docType) {\n        if (!docType) return 'secondary';\n        \n        const typeColors = {\n            'academic_paper': 'success',\n            'report': 'info',\n            'scan': 'warning',\n            'book': 'primary',\n            'presentation': 'danger',\n            'article': 'info'\n        };\n        \n        return typeColors[docType] || 'secondary';\n    }\n\n    /**\n     * Get recent tasks\n     * @param {number} limit - Maximum number of tasks to return\n     * @returns {Array} Recent tasks\n     */\n    getRecentTasks(limit = 5) {\n        return this.history.tasks.slice(0, limit);\n    }\n\n    /**\n     * Get recent downloads\n     * @param {number} limit - Maximum number of downloads to return\n     * @returns {Array} Recent downloads\n     */\n    getRecentDownloads(limit = 5) {\n        return this.history.downloads.slice(0, limit);\n    }\n\n    /**\n     * Get recent searches\n     * @param {number} limit - Maximum number of searches to return\n     * @returns {Array} Recent searches\n     */\n    getRecentSearches(limit = 5) {\n        return this.history.searches.slice(0, limit);\n    }\n\n    /**\n     * Get recent files\n     * @param {number} limit - Maximum number of files to return\n     * @returns {Array} Recent files\n     */\n    getRecentFiles(limit = 5) {\n        return this.history.recentFiles.slice(0, limit);\n    }\n\n    /**\n     * Search history for a term\n     * @param {string} term - Search term\n     * @returns {Object} Search results by category\n     */\n    searchAllHistory(term) {\n        if (!term) {\n            return {\n                tasks: [],\n                downloads: [],\n                searches: [],\n                recentFiles: []\n            };\n        }\n        \n        const lowerTerm = term.toLowerCase();\n        \n        return {\n            tasks: this.history.tasks.filter(task => {\n                return (task.filename && task.filename.toLowerCase().includes(lowerTerm)) ||\n                    (task.outputPath && task.outputPath.toLowerCase().includes(lowerTerm)) ||\n                    (task.type && task.type.toLowerCase().includes(lowerTerm));\n            }),\n            \n            downloads: this.history.downloads.filter(download => {\n                return (download.fileName && download.fileName.toLowerCase().includes(lowerTerm)) ||\n                    (download.url && download.url.toLowerCase().includes(lowerTerm)) ||\n                    (download.fileType && download.fileType.toLowerCase().includes(lowerTerm));\n            }),\n            \n            searches: this.history.searches.filter(search => {\n                return (search.query && search.query.toLowerCase().includes(lowerTerm)) ||\n                    (search.source && search.source.toLowerCase().includes(lowerTerm));\n            }),\n            \n            recentFiles: this.history.recentFiles.filter(file => {\n                return (file.name && file.name.toLowerCase().includes(lowerTerm)) ||\n                    (file.path && file.path.toLowerCase().includes(lowerTerm)) ||\n                    (file.type && file.type.toLowerCase().includes(lowerTerm));\n            })\n        };\n    }\n\n    }\n\n// Create the singleton instance\nconst historyManager = new HistoryManager();\n\n// Export the singleton for other modules to use\nexport default historyManager;\n\n// Export individual methods for direct import\nexport const getRecentTasks = historyManager.getRecentTasks.bind(historyManager);\nexport const getRecentDownloads = historyManager.getRecentDownloads.bind(historyManager);\nexport const getRecentSearches = historyManager.getRecentSearches.bind(historyManager);\nexport const getRecentFiles = historyManager.getRecentFiles.bind(historyManager);","source":"/workspace/modules/static/js/modules/features/historyManager.js","title":"historyManager.js","language":"en"},{"content":"/**\n * Keyboard Shortcuts Module\n * \n * Handles keyboard shortcuts for the application\n * Extracted from index.html to prevent conflicts with the modular system\n */\n\nimport { showModal } from '../utils/ui.js';\n\nclass KeyboardShortcuts {\n  constructor() {\n    this.shortcuts = new Map();\n    this.enabled = true;\n    this.initialized = false;\n  }\n\n  /**\n   * Initialize keyboard shortcuts\n   */\n  initialize() {\n    if (this.initialized) {\n      console.warn('Keyboard shortcuts already initialized');\n      return;\n    }\n\n    this.setupDefaultShortcuts();\n    this.attachEventListeners();\n    this.initialized = true;\n    console.log('Keyboard shortcuts initialized');\n  }\n\n  /**\n   * Setup default keyboard shortcuts\n   */\n  setupDefaultShortcuts() {\n    // Tab navigation shortcuts (Ctrl + 1-4)\n    for (let i = 1; i <= 4; i++) {\n      this.register(`ctrl+${i}`, () => this.switchTab(i), `Switch to tab ${i}`);\n    }\n\n    // Ctrl + O to open JSON\n    this.register('ctrl+o', () => this.openJson(), 'Open JSON file');\n\n    // Ctrl + N for new task\n    this.register('ctrl+n', () => this.newTask(), 'Start new task');\n\n    // Ctrl + H for help\n    this.register('ctrl+h', () => this.showHelp(), 'Show keyboard shortcuts');\n\n    // Ctrl + D for dark mode toggle\n    this.register('ctrl+d', () => this.toggleDarkMode(), 'Toggle dark mode');\n\n    // Escape to close modals\n    this.register('escape', () => this.closeActiveModal(), 'Close active modal');\n  }\n\n  /**\n   * Register a keyboard shortcut\n   * @param {string} shortcut - Shortcut string (e.g., 'ctrl+s', 'alt+shift+n')\n   * @param {Function} handler - Function to execute\n   * @param {string} description - Description of the shortcut\n   */\n  register(shortcut, handler, description = '') {\n    const normalized = this.normalizeShortcut(shortcut);\n    this.shortcuts.set(normalized, { handler, description, shortcut });\n  }\n\n  /**\n   * Normalize shortcut string\n   * @param {string} shortcut - Shortcut string\n   * @returns {string} - Normalized shortcut\n   */\n  normalizeShortcut(shortcut) {\n    return shortcut\n      .toLowerCase()\n      .split('+')\n      .sort()\n      .join('+');\n  }\n\n  /**\n   * Parse keyboard event to shortcut string\n   * @param {KeyboardEvent} event - Keyboard event\n   * @returns {string} - Shortcut string\n   */\n  parseEvent(event) {\n    const parts = [];\n    \n    if (event.ctrlKey || event.metaKey) parts.push('ctrl');\n    if (event.altKey) parts.push('alt');\n    if (event.shiftKey) parts.push('shift');\n    \n    // Get the key\n    let key = event.key.toLowerCase();\n    \n    // Map special keys\n    const keyMap = {\n      ' ': 'space',\n      'arrowup': 'up',\n      'arrowdown': 'down',\n      'arrowleft': 'left',\n      'arrowright': 'right'\n    };\n    \n    key = keyMap[key] || key;\n    \n    // Handle digit keys\n    if (event.code && event.code.startsWith('Digit')) {\n      key = event.code.replace('Digit', '');\n    }\n    \n    parts.push(key);\n    \n    return parts.sort().join('+');\n  }\n\n  /**\n   * Attach keyboard event listeners\n   */\n  attachEventListeners() {\n    document.addEventListener('keydown', (event) => {\n      if (!this.enabled) return;\n      \n      // Don't handle shortcuts when typing in inputs\n      const activeElement = document.activeElement;\n      const isInput = activeElement && (\n        activeElement.tagName === 'INPUT' ||\n        activeElement.tagName === 'TEXTAREA' ||\n        activeElement.contentEditable === 'true'\n      );\n      \n      if (isInput && event.key !== 'Escape') return;\n      \n      const shortcut = this.parseEvent(event);\n      const handler = this.shortcuts.get(shortcut);\n      \n      if (handler) {\n        event.preventDefault();\n        event.stopPropagation();\n        \n        try {\n          handler.handler();\n        } catch (error) {\n          console.error('Error executing shortcut:', shortcut, error);\n        }\n      }\n    });\n  }\n\n  /**\n   * Switch to a specific tab\n   * @param {number} tabIndex - Tab index (1-based)\n   */\n  switchTab(tabIndex) {\n    const tabButtons = document.querySelectorAll('#processorTabs .nav-link');\n    if (tabButtons.length >= tabIndex) {\n      tabButtons[tabIndex - 1].click();\n    }\n  }\n\n  /**\n   * Open JSON file\n   */\n  openJson() {\n    const openButton = document.querySelector('.open-json-btn:not(.d-none)');\n    if (openButton) {\n      openButton.click();\n    }\n  }\n\n  /**\n   * Start new task\n   */\n  newTask() {\n    const newTaskBtn = document.querySelector(\n      '#new-task-btn:not(.d-none), ' +\n      '#playlist-new-task-btn:not(.d-none), ' +\n      '#scraper-new-task-btn:not(.d-none), ' +\n      '#cancelled-new-task-btn:not(.d-none)'\n    );\n    \n    if (newTaskBtn) {\n      newTaskBtn.click();\n    }\n  }\n\n  /**\n   * Show help modal\n   */\n  showHelp() {\n    const modal = document.getElementById('keyboard-shortcuts-modal');\n    if (modal) {\n      if (window.bootstrap) {\n        const bsModal = window.bootstrap.Modal.getInstance(modal) || new window.bootstrap.Modal(modal);\n        bsModal.show();\n      } else if (showModal) {\n        showModal('keyboard-shortcuts-modal');\n      }\n    }\n  }\n\n  /**\n   * Toggle dark mode\n   */\n  toggleDarkMode() {\n    const darkModeToggle = document.getElementById('darkModeToggle');\n    if (darkModeToggle) {\n      darkModeToggle.click();\n    }\n  }\n\n  /**\n   * Close active modal\n   */\n  closeActiveModal() {\n    const activeModal = document.querySelector('.modal.show');\n    if (activeModal && window.bootstrap) {\n      const bsModal = window.bootstrap.Modal.getInstance(activeModal);\n      if (bsModal) {\n        bsModal.hide();\n      }\n    }\n  }\n\n  /**\n   * Enable/disable shortcuts\n   * @param {boolean} enabled - Whether to enable shortcuts\n   */\n  setEnabled(enabled) {\n    this.enabled = enabled;\n  }\n\n  /**\n   * Get all registered shortcuts\n   * @returns {Array} - Array of shortcut objects\n   */\n  getShortcuts() {\n    const shortcuts = [];\n    this.shortcuts.forEach((value, key) => {\n      shortcuts.push({\n        keys: value.shortcut,\n        description: value.description\n      });\n    });\n    return shortcuts;\n  }\n}\n\n// Create and export singleton instance\nconst keyboardShortcuts = new KeyboardShortcuts();\nexport default keyboardShortcuts;\n\n// Auto-initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => keyboardShortcuts.initialize());\n} else {\n  keyboardShortcuts.initialize();\n}","source":"/workspace/modules/static/js/modules/features/keyboardShortcuts.js","title":"keyboardShortcuts.js","language":"en"},{"content":"/**\n * PDF Downloader Module\n * \n * Handles academic paper search, PDF discovery, and PDF downloading functionality.\n * Separated from webScraper.js for better organization and maintainability.\n * \n * Features:\n * - Academic paper search across multiple sources (arXiv, Semantic Scholar, PubMed, etc.)\n * - PDF discovery and extraction from web pages\n * - Multi-select PDF download queue management\n * - Real-time progress tracking for downloads\n * - Integration with backend academic search API\n * \n * @module features/pdfDownloader\n * @version 1.0.0\n */\n\n// Import dependencies from centralized config\nimport { API_ENDPOINTS, BLUEPRINT_ROUTES } from '../config/endpoints.js';\nimport { CONSTANTS, API_CONFIG, SOCKET_CONFIG } from '../config/constants.js';\nimport { SOCKET_EVENTS, TASK_EVENTS } from '../config/socketEvents.js';\n\n// PDF Downloader specific configuration from centralized config\nconst PDF_DOWNLOADER_CONFIG = {\n  endpoints: API_ENDPOINTS.PDF_DOWNLOADER,\n  blueprint: BLUEPRINT_ROUTES.pdf_downloader,\n  timeout: API_CONFIG.BLUEPRINT_TIMEOUTS?.pdf_downloader || API_CONFIG.API_TIMEOUT,\n  retryAttempts: API_CONFIG.API_RETRY_ATTEMPTS,\n  retryDelay: API_CONFIG.API_RETRY_DELAY\n};\n\nconst ACADEMIC_CONFIG = {\n  endpoints: API_ENDPOINTS.ACADEMIC,\n  blueprint: BLUEPRINT_ROUTES.academic_search\n};\n\n// Initialize module with config\nlet blueprintApi, moduleImports;\nasync function initializeImports() {\n  try {\n    // Import core modules\n    blueprintApi = window.NeuroGen?.modules?.blueprintApi;\n    moduleImports = window.NeuroGen?.modules?.moduleImports;\n    \n    if (!blueprintApi) {\n      console.warn('Blueprint API not available, using fetch fallback');\n    }\n    \n    return true;\n  } catch (error) {\n    console.error('Error initializing PDF downloader imports:', error);\n    return false;\n  }\n}\n\nclass PDFDownloader {\n  constructor() {\n    this.state = {\n      isInitialized: false,\n      elements: new Map(),\n      eventListeners: new Set(),\n      socketListeners: new Set(),\n      currentSearch: null,\n      searchResults: new Map(),\n      selectedPdfs: new Set(),\n      downloadQueue: new Map(),\n      activeDownloads: new Map(),\n      processingState: 'idle'\n    };\n    \n    // Use centralized configuration\n    this.config = {\n      maxResultsPerSource: CONSTANTS.SEARCH?.MAX_RESULTS_PER_SOURCE || 10,\n      defaultSources: CONSTANTS.ACADEMIC?.DEFAULT_SOURCES || ['arxiv', 'semantic_scholar'],\n      downloadConcurrency: API_CONFIG.API_CONCURRENT_REQUESTS || 3,\n      retryAttempts: PDF_DOWNLOADER_CONFIG.retryAttempts,\n      timeout: PDF_DOWNLOADER_CONFIG.timeout,\n      endpoints: PDF_DOWNLOADER_CONFIG.endpoints,\n      academicEndpoints: ACADEMIC_CONFIG.endpoints\n    };\n  }\n\n  /**\n   * Initialize the PDF Downloader module\n   */\n  async init() {\n    try {\n      console.log('🔍 Initializing PDF Downloader module...');\n      \n      // Initialize imports\n      const importSuccess = await initializeImports();\n      if (!importSuccess) {\n        console.warn('Some imports failed, continuing with fallbacks');\n      }\n      \n      // Test backend connectivity\n      await this.testBackendConnectivity();\n      \n      // Cache DOM elements\n      this.cacheElements();\n      \n      // Setup event handlers\n      this.setupEventHandlers();\n      \n      // Setup Socket.IO listeners\n      this.setupSocketListeners();\n      \n      // Initialize UI state\n      this.updateUI();\n      \n      this.state.isInitialized = true;\n      console.log('✅ PDF Downloader initialized successfully');\n      \n      // Register with module system if available\n      if (window.NeuroGen?.registerModule) {\n        window.NeuroGen.registerModule('pdfDownloader', this);\n      }\n      \n    } catch (error) {\n      console.error('❌ PDF Downloader initialization failed:', error);\n      this.state.isInitialized = true; // Allow graceful degradation\n    }\n  }\n\n  /**\n   * Test backend connectivity using health endpoint\n   */\n  async testBackendConnectivity() {\n    try {\n      console.log('🔍 Testing PDF Downloader backend connectivity...');\n      \n      const response = await fetch(this.config.endpoints.HEALTH, {\n        method: 'GET',\n        headers: {\n          'X-API-Key': localStorage.getItem('api_key') || ''\n        },\n        timeout: 5000\n      });\n      \n      if (response.ok) {\n        const healthData = await response.json();\n        console.log('✅ PDF Downloader backend is healthy:', healthData);\n        return true;\n      } else {\n        console.warn('⚠️ PDF Downloader backend health check failed:', response.status);\n        return false;\n      }\n    } catch (error) {\n      console.error('❌ PDF Downloader backend connectivity test failed:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Cache DOM elements for efficient access\n   */\n  cacheElements() {\n    const elementIds = [\n      // Academic search elements\n      'academic-search-input',\n      'academic-sources-select',\n      'academic-max-results',\n      'academic-search-btn',\n      'academic-results-container',\n      'academic-results-list',\n      \n      // PDF downloader tab elements\n      'pdf-single-form',\n      'pdf-single-url-input',\n      'pdf-single-filename',\n      'pdf-single-output-dir',\n      'pdf-single-browse-btn',\n      'pdf-single-download-btn',\n      \n      // Batch download elements\n      'pdf-batch-form',\n      'pdf-batch-urls-input',\n      'pdf-batch-output-dir',\n      'pdf-batch-browse-btn',\n      'pdf-batch-download-btn',\n      'pdf-concurrent-downloads',\n      \n      // Queue management elements\n      'pdf-clear-queue-btn',\n      'pdf-cancel-all-btn',\n      'pdf-queue-total',\n      'pdf-downloading-total',\n      'pdf-completed-total',\n      'pdf-failed-total',\n      \n      // Processing options\n      'pdf-process-structify',\n      'pdf-extract-tables',\n      'pdf-use-ocr',\n      \n      // Legacy elements (for backwards compatibility)\n      'pdf-select-all-btn',\n      'pdf-select-none-btn',\n      'pdf-download-selected-btn',\n      'selected-pdfs-count',\n      'download-queue-container',\n      'download-queue-list',\n      'queue-clear-btn',\n      'queue-download-all-btn',\n      'pdf-download-progress',\n      'current-download-status'\n    ];\n\n    elementIds.forEach(id => {\n      const element = document.getElementById(id);\n      if (element) {\n        this.state.elements.set(id, element);\n      }\n    });\n  }\n\n  /**\n   * Setup event handlers for PDF downloader functionality\n   */\n  setupEventHandlers() {\n    // Single PDF download form\n    const singleForm = this.state.elements.get('pdf-single-form');\n    if (singleForm) {\n      const submitHandler = (e) => {\n        e.preventDefault();\n        this.handleSingleDownload();\n      };\n      singleForm.addEventListener('submit', submitHandler);\n      this.state.eventListeners.add(() => singleForm.removeEventListener('submit', submitHandler));\n    }\n\n    // Single PDF download button\n    const singleDownloadBtn = this.state.elements.get('pdf-single-download-btn');\n    if (singleDownloadBtn) {\n      const clickHandler = (e) => {\n        e.preventDefault();\n        this.handleSingleDownload();\n      };\n      singleDownloadBtn.addEventListener('click', clickHandler);\n      this.state.eventListeners.add(() => singleDownloadBtn.removeEventListener('click', clickHandler));\n    }\n\n    // Batch PDF download form\n    const batchForm = this.state.elements.get('pdf-batch-form');\n    if (batchForm) {\n      const submitHandler = (e) => {\n        e.preventDefault();\n        this.handleBatchDownload();\n      };\n      batchForm.addEventListener('submit', submitHandler);\n      this.state.eventListeners.add(() => batchForm.removeEventListener('submit', submitHandler));\n    }\n\n    // Batch PDF download button\n    const batchDownloadBtn = this.state.elements.get('pdf-batch-download-btn');\n    if (batchDownloadBtn) {\n      const clickHandler = (e) => {\n        e.preventDefault();\n        this.handleBatchDownload();\n      };\n      batchDownloadBtn.addEventListener('click', clickHandler);\n      this.state.eventListeners.add(() => batchDownloadBtn.removeEventListener('click', clickHandler));\n    }\n\n    // Browse buttons\n    const singleBrowseBtn = this.state.elements.get('pdf-single-browse-btn');\n    if (singleBrowseBtn) {\n      const clickHandler = () => this.browseDirectory('single');\n      singleBrowseBtn.addEventListener('click', clickHandler);\n      this.state.eventListeners.add(() => singleBrowseBtn.removeEventListener('click', clickHandler));\n    }\n\n    const batchBrowseBtn = this.state.elements.get('pdf-batch-browse-btn');\n    if (batchBrowseBtn) {\n      const clickHandler = () => this.browseDirectory('batch');\n      batchBrowseBtn.addEventListener('click', clickHandler);\n      this.state.eventListeners.add(() => batchBrowseBtn.removeEventListener('click', clickHandler));\n    }\n\n    // Clear queue button\n    const clearQueueBtn = this.state.elements.get('pdf-clear-queue-btn');\n    if (clearQueueBtn) {\n      const clickHandler = () => this.clearDownloadQueue();\n      clearQueueBtn.addEventListener('click', clickHandler);\n      this.state.eventListeners.add(() => clearQueueBtn.removeEventListener('click', clickHandler));\n    }\n\n    // Cancel all button\n    const cancelAllBtn = this.state.elements.get('pdf-cancel-all-btn');\n    if (cancelAllBtn) {\n      const clickHandler = () => this.cancelAllDownloads();\n      cancelAllBtn.addEventListener('click', clickHandler);\n      this.state.eventListeners.add(() => cancelAllBtn.removeEventListener('click', clickHandler));\n    }\n\n    // Academic search button\n    const searchBtn = this.state.elements.get('academic-search-btn');\n    if (searchBtn) {\n      const clickHandler = () => this.startAcademicSearch();\n      searchBtn.addEventListener('click', clickHandler);\n      this.state.eventListeners.add(() => searchBtn.removeEventListener('click', clickHandler));\n    }\n\n    // Legacy PDF selection buttons (for backwards compatibility)\n    const selectAllBtn = this.state.elements.get('pdf-select-all-btn');\n    if (selectAllBtn) {\n      const clickHandler = () => this.selectAllPdfs();\n      selectAllBtn.addEventListener('click', clickHandler);\n      this.state.eventListeners.add(() => selectAllBtn.removeEventListener('click', clickHandler));\n    }\n\n    const selectNoneBtn = this.state.elements.get('pdf-select-none-btn');\n    if (selectNoneBtn) {\n      const clickHandler = () => this.selectNonePdfs();\n      selectNoneBtn.addEventListener('click', clickHandler);\n      this.state.eventListeners.add(() => selectNoneBtn.removeEventListener('click', clickHandler));\n    }\n\n    const downloadSelectedBtn = this.state.elements.get('pdf-download-selected-btn');\n    if (downloadSelectedBtn) {\n      const clickHandler = () => this.downloadSelectedPdfs();\n      downloadSelectedBtn.addEventListener('click', clickHandler);\n      this.state.eventListeners.add(() => downloadSelectedBtn.removeEventListener('click', clickHandler));\n    }\n  }\n\n  /**\n   * Setup Socket.IO event listeners\n   */\n  setupSocketListeners() {\n    if (!window.socket) {\n      console.warn('Socket.IO not available, real-time updates will be limited');\n      return;\n    }\n\n    console.log('📡 Setting up PDF Downloader SocketIO listeners...');\n\n    // Task progress events using centralized config\n    const progressHandler = (data) => {\n      if (this.isMyTask(data.task_id)) {\n        this.handleDownloadProgress(data);\n      }\n    };\n    window.socket.on(TASK_EVENTS.PROGRESS, progressHandler);\n    this.state.socketListeners.add(() => window.socket.off(TASK_EVENTS.PROGRESS, progressHandler));\n\n    // Task completion events\n    const completedHandler = (data) => {\n      if (this.isMyTask(data.task_id)) {\n        this.handleTaskCompleted(data);\n      }\n    };\n    window.socket.on(TASK_EVENTS.COMPLETED, completedHandler);\n    this.state.socketListeners.add(() => window.socket.off(TASK_EVENTS.COMPLETED, completedHandler));\n\n    // Task error events\n    const errorHandler = (data) => {\n      if (this.isMyTask(data.task_id)) {\n        this.handleTaskError(data);\n      }\n    };\n    window.socket.on(TASK_EVENTS.ERROR, errorHandler);\n    this.state.socketListeners.add(() => window.socket.off(TASK_EVENTS.ERROR, errorHandler));\n\n    // Task cancelled events\n    const cancelledHandler = (data) => {\n      if (this.isMyTask(data.task_id)) {\n        this.handleTaskCancelled(data);\n      }\n    };\n    window.socket.on(TASK_EVENTS.CANCELLED, cancelledHandler);\n    this.state.socketListeners.add(() => window.socket.off(TASK_EVENTS.CANCELLED, cancelledHandler));\n\n    // PDF-specific events\n    const pdfProgressHandler = (data) => {\n      if (this.isMyTask(data.task_id)) {\n        this.handlePdfDownloadProgress(data);\n      }\n    };\n    window.socket.on('pdf_download_progress', pdfProgressHandler);\n    this.state.socketListeners.add(() => window.socket.off('pdf_download_progress', pdfProgressHandler));\n\n    console.log('✅ PDF Downloader SocketIO listeners configured');\n  }\n\n  /**\n   * Start academic search\n   */\n  async startAcademicSearch() {\n    try {\n      const queryInput = this.state.elements.get('academic-search-input');\n      const sourcesSelect = this.state.elements.get('academic-sources-select');\n      const maxResultsInput = this.state.elements.get('academic-max-results');\n\n      if (!queryInput?.value.trim()) {\n        this.showError('Please enter a search query');\n        return;\n      }\n\n      const query = queryInput.value.trim();\n      const sources = this.getSelectedSources(sourcesSelect);\n      const maxResults = parseInt(maxResultsInput?.value) || this.config.maxResultsPerSource;\n\n      this.state.processingState = 'searching';\n      this.updateUI();\n\n      // Clear previous results\n      this.clearSearchResults();\n\n      // Start academic search using centralized config\n      const response = await fetch(ACADEMIC_CONFIG.endpoints.SEARCH, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-API-Key': localStorage.getItem('api_key') || ''\n        },\n        body: JSON.stringify({\n          query,\n          sources,\n          max_results: maxResults\n        })\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n\n      // Store search information\n      this.state.currentSearch = {\n        id: data.search_id,\n        query,\n        sources,\n        maxResults,\n        startTime: Date.now()\n      };\n\n      console.log(`📚 Academic search started: ${data.search_id}`);\n      this.showInfo(`Searching for: \"${query}\" across ${sources.length} source(s)`);\n\n    } catch (error) {\n      console.error('❌ Failed to start academic search:', error);\n      this.showError(`Search failed: ${error.message}`);\n      this.state.processingState = 'idle';\n      this.updateUI();\n    }\n  }\n\n  /**\n   * Handle PDF download progress events\n   */\n  handlePdfDownloadProgress(data) {\n    console.log('📄 PDF download progress:', data);\n    \n    if (data.task_id && this.state.downloadQueue.has(data.task_id)) {\n      const download = this.state.downloadQueue.get(data.task_id);\n      download.progress = data.progress || 0;\n      download.message = data.message || 'Downloading...';\n      \n      this.updateQueueUI();\n      this.showInfo(`${data.message || 'Download progress'}: ${data.progress || 0}%`);\n    }\n  }\n\n  /**\n   * Handle task completion events - Enhanced to match fileProcessor spec\n   */\n  handleTaskCompleted(data) {\n    try {\n      console.log('✅ Enhanced PDF download completion started:', data);\n      \n      // Validate completion data\n      if (!this.validateTaskCompletion(data)) {\n        return;\n      }\n      \n      // Update download queue status\n      if (data.task_id && this.state.downloadQueue.has(data.task_id)) {\n        const download = this.state.downloadQueue.get(data.task_id);\n        download.status = 'completed';\n        download.progress = 100;\n        download.file_path = data.file_path;\n        download.completedTime = Date.now();\n        download.fileSize = data.file_size || 0;\n        download.downloadSpeed = data.download_speed || 'N/A';\n      }\n      \n      // Update processing state\n      this.state.processingState = 'completed';\n      \n      // Enhanced cleanup\n      this.performEnhancedCleanup();\n      \n      // Update completion UI\n      this.updateCompletionUI(data);\n      \n      // Trigger completion notifications\n      this.triggerCompletionNotifications(data);\n      \n      // Display enhanced results with stats screen (like fileProcessor)\n      this.displayEnhancedResults(data);\n      \n    } catch (error) {\n      console.error('❌ Error in enhanced PDF download completion:', error);\n      this.performFallbackCompletion(data);\n    }\n  }\n\n  /**\n   * Validate task completion data\n   */\n  validateTaskCompletion(data) {\n    if (!data) {\n      console.warn('❌ No PDF completion data provided');\n      return false;\n    }\n    \n    if (!data.task_id) {\n      console.warn('❌ No task ID in completion data');\n      return false;\n    }\n    \n    return true;\n  }\n\n  /**\n   * Enhanced cleanup after task completion\n   */\n  performEnhancedCleanup() {\n    // Clear active downloads\n    this.state.activeDownloads.clear();\n    \n    // Update queue UI\n    this.updateQueueUI();\n    \n    // Clear any progress intervals\n    if (this.progressInterval) {\n      clearInterval(this.progressInterval);\n      this.progressInterval = null;\n    }\n  }\n\n  /**\n   * Update completion UI\n   */\n  updateCompletionUI(data) {\n    // Re-enable form submissions\n    const singleForm = this.state.elements.get('single-pdf-form');\n    const batchForm = this.state.elements.get('batch-pdf-form');\n    \n    if (singleForm) {\n      const submitBtn = singleForm.querySelector('button[type=\"submit\"]');\n      if (submitBtn) {\n        submitBtn.disabled = false;\n        submitBtn.textContent = 'Download PDF';\n      }\n    }\n    \n    if (batchForm) {\n      const submitBtn = batchForm.querySelector('button[type=\"submit\"]');\n      if (submitBtn) {\n        submitBtn.disabled = false;\n        submitBtn.textContent = 'Download Selected PDFs';\n      }\n    }\n  }\n\n  /**\n   * Trigger completion notifications\n   */\n  triggerCompletionNotifications(data) {\n    // Count totals for comprehensive notification\n    let totalCompleted = 0, totalFailed = 0, totalSize = 0;\n    this.state.downloadQueue.forEach(download => {\n      if (download.status === 'completed') {\n        totalCompleted++;\n        totalSize += download.fileSize || 0;\n      }\n      if (download.status === 'failed') totalFailed++;\n    });\n    \n    const message = `PDF downloads completed! ${totalCompleted} successful, ${totalFailed} failed. Total size: ${this.formatFileSize(totalSize)}`;\n    this.showSuccess(message);\n  }\n\n  /**\n   * Display enhanced results with comprehensive stats (like fileProcessor)\n   */\n  displayEnhancedResults(data) {\n    // Prepare comprehensive download statistics\n    const enhancedData = this.prepareEnhancedStats(data);\n    \n    // Show result UI with enhanced delay for better UX\n    setTimeout(() => {\n      this.showEnhancedResult(enhancedData);\n    }, 600);\n  }\n\n  /**\n   * Prepare enhanced statistics\n   */\n  prepareEnhancedStats(data) {\n    let totalCompleted = 0, totalFailed = 0, totalSize = 0, totalDuration = 0;\n    const completedDownloads = [];\n    const failedDownloads = [];\n    \n    this.state.downloadQueue.forEach(download => {\n      if (download.status === 'completed') {\n        totalCompleted++;\n        totalSize += download.fileSize || 0;\n        if (download.startTime && download.completedTime) {\n          totalDuration += (download.completedTime - download.startTime);\n        }\n        completedDownloads.push(download);\n      }\n      if (download.status === 'failed') {\n        totalFailed++;\n        failedDownloads.push(download);\n      }\n    });\n    \n    const avgDuration = totalCompleted > 0 ? totalDuration / totalCompleted : 0;\n    const successRate = totalCompleted + totalFailed > 0 ? (totalCompleted / (totalCompleted + totalFailed)) * 100 : 100;\n    const avgFileSize = totalCompleted > 0 ? totalSize / totalCompleted : 0;\n    \n    return {\n      task_id: data.task_id,\n      total_downloads: totalCompleted + totalFailed,\n      completed_downloads: totalCompleted,\n      failed_downloads: totalFailed,\n      total_size: totalSize,\n      avg_duration: avgDuration,\n      success_rate: successRate,\n      avg_file_size: avgFileSize,\n      completedTime: Date.now(),\n      completed_files: completedDownloads,\n      failed_files: failedDownloads,\n      output_directory: data.output_directory || 'Downloads folder'\n    };\n  }\n\n  /**\n   * Show enhanced result with container transitions (like fileProcessor)\n   */\n  showEnhancedResult(data) {\n    // Find or create result container\n    let resultContainer = this.state.elements.get('pdf-result-container');\n    if (!resultContainer) {\n      resultContainer = this.createResultContainer();\n    }\n    \n    // Transition to result container\n    this.transitionToContainer(resultContainer);\n    \n    // Update result content with comprehensive stats\n    this.updateEnhancedResultStats(resultContainer, data);\n    \n    // Show success notification\n    this.showSuccess('PDF downloads completed successfully!');\n  }\n\n  /**\n   * Create result container if it doesn't exist\n   */\n  createResultContainer() {\n    // Look for existing download queue container to insert result container after\n    const queueContainer = this.state.elements.get('pdf-queue-container') || \n                          document.getElementById('pdf-queue-container') ||\n                          document.querySelector('.pdf-queue-container');\n    \n    let resultContainer = document.getElementById('pdf-result-container');\n    if (!resultContainer) {\n      resultContainer = document.createElement('div');\n      resultContainer.id = 'pdf-result-container';\n      resultContainer.className = 'container-fluid mt-3';\n      resultContainer.style.display = 'none';\n      \n      // Insert after queue container or at end of body\n      if (queueContainer && queueContainer.parentNode) {\n        queueContainer.parentNode.insertBefore(resultContainer, queueContainer.nextSibling);\n      } else {\n        document.body.appendChild(resultContainer);\n      }\n      \n      this.state.elements.set('pdf-result-container', resultContainer);\n    }\n    \n    return resultContainer;\n  }\n\n  /**\n   * Transition to container (like fileProcessor)\n   */\n  transitionToContainer(targetContainer) {\n    // Hide queue container if it exists\n    const queueContainer = this.state.elements.get('pdf-queue-container');\n    if (queueContainer) {\n      queueContainer.style.display = 'none';\n    }\n    \n    // Show target container with smooth transition\n    if (targetContainer) {\n      targetContainer.style.display = 'block';\n      targetContainer.style.opacity = '0';\n      targetContainer.style.transition = 'opacity 0.3s ease-in-out';\n      \n      setTimeout(() => {\n        targetContainer.style.opacity = '1';\n      }, 50);\n    }\n  }\n\n  /**\n   * Update result stats with comprehensive display (enhanced like fileProcessor)\n   */\n  updateEnhancedResultStats(resultContainer, data) {\n    if (!resultContainer) return;\n    \n    const avgDurationSeconds = Math.round(data.avg_duration / 1000);\n    const avgDownloadSpeed = data.avg_duration > 0 ? Math.round(data.avg_file_size / (data.avg_duration / 1000)) : 0;\n    \n    const resultHTML = `\n      <div class=\"card shadow-sm\">\n        <div class=\"card-header bg-success text-white\">\n          <h5 class=\"mb-0\">\n            <i class=\"fas fa-check-circle me-2\"></i>\n            PDF Downloads Completed Successfully\n          </h5>\n        </div>\n        <div class=\"card-body\">\n          <!-- Summary Stats -->\n          <div class=\"row mb-4\">\n            <div class=\"col-md-3\">\n              <div class=\"stat-card text-center p-3 border rounded\">\n                <div class=\"stat-value text-primary\" style=\"font-size: 2.5rem; font-weight: bold;\">${data.completed_downloads}</div>\n                <div class=\"stat-label text-muted\">PDFs Downloaded</div>\n              </div>\n            </div>\n            <div class=\"col-md-3\">\n              <div class=\"stat-card text-center p-3 border rounded\">\n                <div class=\"stat-value text-info\" style=\"font-size: 2.5rem; font-weight: bold;\">${this.formatFileSize(data.total_size)}</div>\n                <div class=\"stat-label text-muted\">Total Size</div>\n              </div>\n            </div>\n            <div class=\"col-md-3\">\n              <div class=\"stat-card text-center p-3 border rounded\">\n                <div class=\"stat-value text-warning\" style=\"font-size: 2.5rem; font-weight: bold;\">${Math.round(data.success_rate)}%</div>\n                <div class=\"stat-label text-muted\">Success Rate</div>\n              </div>\n            </div>\n            <div class=\"col-md-3\">\n              <div class=\"stat-card text-center p-3 border rounded\">\n                <div class=\"stat-value text-success\" style=\"font-size: 2.5rem; font-weight: bold;\">${data.failed_downloads}</div>\n                <div class=\"stat-label text-muted\">Failed Downloads</div>\n              </div>\n            </div>\n          </div>\n\n          <!-- Performance Metrics -->\n          <div class=\"row mb-4\">\n            <div class=\"col-md-4\">\n              <div class=\"metric-item\">\n                <strong><i class=\"fas fa-clock me-2\"></i>Avg Duration:</strong>\n                <span class=\"ms-2\">${avgDurationSeconds}s per file</span>\n              </div>\n            </div>\n            <div class=\"col-md-4\">\n              <div class=\"metric-item\">\n                <strong><i class=\"fas fa-tachometer-alt me-2\"></i>Avg Speed:</strong>\n                <span class=\"ms-2\">${this.formatFileSize(avgDownloadSpeed)}/s</span>\n              </div>\n            </div>\n            <div class=\"col-md-4\">\n              <div class=\"metric-item\">\n                <strong><i class=\"fas fa-file-pdf me-2\"></i>Avg File Size:</strong>\n                <span class=\"ms-2\">${this.formatFileSize(data.avg_file_size)}</span>\n              </div>\n            </div>\n          </div>\n\n          <!-- Output Information -->\n          <div class=\"output-section mb-4\">\n            <h6><i class=\"fas fa-folder me-2\"></i>Download Location</h6>\n            <div class=\"d-flex align-items-center\">\n              <code class=\"me-3\">${data.output_directory}</code>\n              <div class=\"btn-group\" role=\"group\">\n                <button class=\"btn btn-sm btn-outline-primary\" onclick=\"openFolder('${data.output_directory}')\">\n                  <i class=\"fas fa-folder-open me-1\"></i>Open Folder\n                </button>\n              </div>\n            </div>\n          </div>\n\n          <!-- Downloaded Files List -->\n          ${data.completed_files.length > 0 ? `\n          <div class=\"files-section mb-4\">\n            <h6><i class=\"fas fa-file-pdf me-2\"></i>Downloaded Files (${data.completed_files.length})</h6>\n            <div class=\"files-list\" style=\"max-height: 300px; overflow-y: auto;\">\n              ${data.completed_files.map(file => `\n                <div class=\"file-item d-flex justify-content-between align-items-center p-2 border-bottom\">\n                  <div>\n                    <strong>${file.title || file.filename || 'Untitled'}</strong>\n                    <small class=\"text-muted d-block\">${this.formatFileSize(file.fileSize || 0)} • ${file.downloadSpeed || 'N/A'}</small>\n                  </div>\n                  <div class=\"btn-group btn-group-sm\">\n                    <button class=\"btn btn-outline-primary btn-sm\" onclick=\"openFile('${file.file_path}')\">\n                      <i class=\"fas fa-eye\"></i>\n                    </button>\n                    <button class=\"btn btn-outline-secondary btn-sm\" onclick=\"downloadFile('${file.file_path}')\">\n                      <i class=\"fas fa-download\"></i>\n                    </button>\n                  </div>\n                </div>\n              `).join('')}\n            </div>\n          </div>\n          ` : ''}\n\n          <!-- Failed Downloads -->\n          ${data.failed_files.length > 0 ? `\n          <div class=\"failed-section mb-4\">\n            <h6><i class=\"fas fa-exclamation-triangle me-2 text-warning\"></i>Failed Downloads (${data.failed_files.length})</h6>\n            <div class=\"failed-list\">\n              ${data.failed_files.map(file => `\n                <div class=\"failed-item p-2 border-bottom\">\n                  <strong>${file.title || file.url || 'Unknown'}</strong>\n                  <small class=\"text-muted d-block\">${file.error || 'Download failed'}</small>\n                </div>\n              `).join('')}\n            </div>\n          </div>\n          ` : ''}\n\n          <!-- Additional Details -->\n          <div class=\"details-section\">\n            <h6><i class=\"fas fa-info-circle me-2\"></i>Download Summary</h6>\n            <div class=\"row\">\n              <div class=\"col-md-6\">\n                <ul class=\"list-unstyled\">\n                  <li><strong>Task ID:</strong> <code>${data.task_id}</code></li>\n                  <li><strong>Total Downloads:</strong> ${data.total_downloads}</li>\n                  <li><strong>Completion Time:</strong> ${new Date(data.completedTime).toLocaleString()}</li>\n                </ul>\n              </div>\n              <div class=\"col-md-6\">\n                <ul class=\"list-unstyled\">\n                  <li><strong>Success Rate:</strong> ${Math.round(data.success_rate)}%</li>\n                  <li><strong>Total Data:</strong> ${this.formatFileSize(data.total_size)}</li>\n                  <li><strong>Average File Size:</strong> ${this.formatFileSize(data.avg_file_size)}</li>\n                </ul>\n              </div>\n            </div>\n          </div>\n\n          <!-- Quick Stats Display -->\n          <div class=\"d-flex justify-content-between text-muted small mt-3 pt-3 border-top\">\n            <span><i class=\"fas fa-file-pdf me-1\"></i>${data.completed_downloads} PDFs downloaded</span>\n            <span><i class=\"fas fa-hdd me-1\"></i>${this.formatFileSize(data.total_size)} total size</span>\n            <span><i class=\"fas fa-check-circle me-1\"></i>${Math.round(data.success_rate)}% success rate</span>\n          </div>\n        </div>\n      </div>\n    `;\n    \n    resultContainer.innerHTML = resultHTML;\n  }\n\n  /**\n   * Fallback completion handler\n   */\n  performFallbackCompletion(data) {\n    console.warn('Using fallback PDF completion handler');\n    \n    // Update download queue status (basic)\n    if (data.task_id && this.state.downloadQueue.has(data.task_id)) {\n      const download = this.state.downloadQueue.get(data.task_id);\n      download.status = 'completed';\n      download.progress = 100;\n      download.file_path = data.file_path;\n    }\n    \n    this.updateQueueUI();\n    this.showSuccess(`Download completed: ${data.file_path || 'PDF downloaded successfully'}`);\n  }\n\n  /**\n   * Handle task error events\n   */\n  handleTaskError(data) {\n    console.error('❌ Task error:', data);\n    \n    if (data.task_id && this.state.downloadQueue.has(data.task_id)) {\n      const download = this.state.downloadQueue.get(data.task_id);\n      download.status = 'failed';\n      download.error = data.error || 'Download failed';\n      \n      this.updateQueueUI();\n      this.showError(`Download failed: ${data.error || 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Handle task cancellation events\n   */\n  handleTaskCancelled(data) {\n    console.log('🚫 Task cancelled:', data);\n    \n    if (data.task_id && this.state.downloadQueue.has(data.task_id)) {\n      const download = this.state.downloadQueue.get(data.task_id);\n      download.status = 'cancelled';\n      \n      this.updateQueueUI();\n      this.showInfo(`Download cancelled: ${data.task_id}`);\n    }\n  }\n\n  /**\n   * Handle paper found event from backend (for academic search)\n   */\n  handlePaperFound(data) {\n    const paper = data.paper;\n    this.state.searchResults.set(paper.id, paper);\n    this.addPaperToResults(paper);\n  }\n\n  /**\n   * Handle search completion\n   */\n  handleSearchComplete(data) {\n    this.state.processingState = 'idle';\n    this.updateUI();\n    \n    const resultCount = this.state.searchResults.size;\n    this.showInfo(`Search complete! Found ${resultCount} papers.`);\n  }\n\n  /**\n   * Add paper to results display\n   */\n  addPaperToResults(paper) {\n    const resultsList = this.state.elements.get('academic-results-list');\n    if (!resultsList) return;\n\n    const paperElement = this.createPaperElement(paper);\n    resultsList.appendChild(paperElement);\n    \n    // Show results container if hidden\n    const resultsContainer = this.state.elements.get('academic-results-container');\n    if (resultsContainer) {\n      resultsContainer.style.display = 'block';\n    }\n  }\n\n  /**\n   * Create HTML element for a paper\n   */\n  createPaperElement(paper) {\n    const div = document.createElement('div');\n    div.className = 'card mb-3 paper-result';\n    div.dataset.paperId = paper.id;\n    \n    div.innerHTML = `\n      <div class=\"card-body\">\n        <div class=\"form-check mb-2\">\n          <input class=\"form-check-input\" type=\"checkbox\" id=\"paper-${paper.id}\" data-paper-id=\"${paper.id}\">\n          <label class=\"form-check-label fw-bold\" for=\"paper-${paper.id}\">\n            ${this.escapeHtml(paper.title)}\n          </label>\n        </div>\n        <p class=\"text-muted mb-2\">\n          <small>\n            <i class=\"fas fa-users me-1\"></i>${this.escapeHtml(paper.authors?.join(', ') || 'Unknown authors')}\n          </small>\n        </p>\n        <p class=\"mb-2\">${this.escapeHtml(paper.abstract?.substring(0, 200) || 'No abstract available')}...</p>\n        <div class=\"d-flex justify-content-between align-items-center\">\n          <div>\n            <span class=\"badge bg-primary me-1\">${this.escapeHtml(paper.source || 'Unknown')}</span>\n            ${paper.year ? `<span class=\"badge bg-secondary\">${paper.year}</span>` : ''}\n          </div>\n          <div>\n            ${paper.pdf_url ? `<button class=\"btn btn-sm btn-outline-success me-1\" onclick=\"window.NeuroGen.modules.pdfDownloader.downloadSinglePdf('${paper.id}')\">\n              <i class=\"fas fa-download me-1\"></i>Download PDF\n            </button>` : ''}\n            ${paper.url ? `<a href=\"${paper.url}\" target=\"_blank\" class=\"btn btn-sm btn-outline-primary\">\n              <i class=\"fas fa-external-link-alt me-1\"></i>View Paper\n            </a>` : ''}\n          </div>\n        </div>\n      </div>\n    `;\n\n    // Add change handler for checkbox\n    const checkbox = div.querySelector('input[type=\"checkbox\"]');\n    checkbox.addEventListener('change', (e) => {\n      if (e.target.checked) {\n        this.state.selectedPdfs.add(paper.id);\n      } else {\n        this.state.selectedPdfs.delete(paper.id);\n      }\n      this.updateSelectionUI();\n    });\n\n    return div;\n  }\n\n  /**\n   * Select all papers\n   */\n  selectAllPdfs() {\n    const checkboxes = document.querySelectorAll('.paper-result input[type=\"checkbox\"]');\n    checkboxes.forEach(checkbox => {\n      checkbox.checked = true;\n      this.state.selectedPdfs.add(checkbox.dataset.paperId);\n    });\n    this.updateSelectionUI();\n  }\n\n  /**\n   * Deselect all papers\n   */\n  selectNonePdfs() {\n    const checkboxes = document.querySelectorAll('.paper-result input[type=\"checkbox\"]');\n    checkboxes.forEach(checkbox => {\n      checkbox.checked = false;\n    });\n    this.state.selectedPdfs.clear();\n    this.updateSelectionUI();\n  }\n\n  /**\n   * Download selected PDFs\n   */\n  async downloadSelectedPdfs() {\n    if (this.state.selectedPdfs.size === 0) {\n      this.showError('Please select at least one PDF to download');\n      return;\n    }\n\n    const selectedPapers = Array.from(this.state.selectedPdfs).map(id => \n      this.state.searchResults.get(id)\n    ).filter(paper => paper && paper.pdf_url);\n\n    if (selectedPapers.length === 0) {\n      this.showError('No downloadable PDFs found in selection');\n      return;\n    }\n\n    this.showInfo(`Starting download of ${selectedPapers.length} PDFs...`);\n\n    // Add to download queue and start downloads\n    for (const paper of selectedPapers) {\n      this.addToDownloadQueue(paper);\n    }\n    \n    this.processDownloadQueue();\n  }\n\n  /**\n   * Download a single PDF\n   */\n  async downloadSinglePdf(paperId) {\n    const paper = this.state.searchResults.get(paperId);\n    if (!paper || !paper.pdf_url) {\n      this.showError('PDF not available for download');\n      return;\n    }\n\n    this.addToDownloadQueue(paper);\n    this.processDownloadQueue();\n  }\n\n  /**\n   * Add paper to download queue\n   */\n  addToDownloadQueue(paper) {\n    this.state.downloadQueue.set(paper.id, {\n      ...paper,\n      status: 'queued',\n      addedTime: Date.now()\n    });\n    this.updateQueueUI();\n  }\n\n  /**\n   * Process download queue\n   */\n  async processDownloadQueue() {\n    const queuedItems = Array.from(this.state.downloadQueue.values())\n      .filter(item => item.status === 'queued');\n\n    if (queuedItems.length === 0) return;\n\n    // Process downloads with concurrency limit\n    const activeCount = this.state.activeDownloads.size;\n    const available = this.config.downloadConcurrency - activeCount;\n    const toProcess = queuedItems.slice(0, available);\n\n    for (const item of toProcess) {\n      this.startPdfDownload(item);\n    }\n  }\n\n  /**\n   * Start individual PDF download\n   */\n  async startPdfDownload(paper) {\n    try {\n      // Mark as downloading\n      paper.status = 'downloading';\n      this.state.activeDownloads.set(paper.id, paper);\n      this.updateQueueUI();\n\n      const response = await fetch(PDF_DOWNLOADER_CONFIG.endpoints.DOWNLOAD, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-API-Key': localStorage.getItem('api_key') || ''\n        },\n        body: JSON.stringify({\n          url: paper.pdf_url,\n          filename: this.sanitizeFilename(`${paper.title}.pdf`),\n          paper_info: {\n            id: paper.id,\n            title: paper.title,\n            authors: paper.authors,\n            source: paper.source\n          }\n        })\n      });\n\n      if (!response.ok) {\n        throw new Error(`Download failed: ${response.status}`);\n      }\n\n      const data = await response.json();\n      \n      // Update status\n      paper.status = 'completed';\n      paper.task_id = data.task_id;\n      \n    } catch (error) {\n      console.error(`❌ Failed to download PDF ${paper.title}:`, error);\n      paper.status = 'failed';\n      paper.error = error.message;\n    } finally {\n      this.state.activeDownloads.delete(paper.id);\n      this.updateQueueUI();\n      \n      // Process next items in queue\n      setTimeout(() => this.processDownloadQueue(), 100);\n    }\n  }\n\n  /**\n   * Handle single PDF download\n   */\n  async handleSingleDownload() {\n    try {\n      console.log('🔍 Starting single PDF download...');\n      \n      const urlInput = this.state.elements.get('pdf-single-url-input');\n      const filenameInput = this.state.elements.get('pdf-single-filename');\n      const outputDirInput = this.state.elements.get('pdf-single-output-dir');\n      \n      if (!urlInput?.value?.trim()) {\n        this.showError('Please enter a PDF URL');\n        return;\n      }\n      \n      const url = urlInput.value.trim();\n      const customFilename = filenameInput?.value?.trim();\n      const outputDir = outputDirInput?.value?.trim();\n      \n      // Get processing options\n      const processStructify = this.state.elements.get('pdf-process-structify')?.checked || false;\n      const extractTables = this.state.elements.get('pdf-extract-tables')?.checked || false;\n      const useOcr = this.state.elements.get('pdf-use-ocr')?.checked || false;\n      \n      // Prepare request data\n      const requestData = {\n        url: url,\n        output_folder: outputDir || undefined,\n        options: {\n          process_with_structify: processStructify,\n          extract_tables: extractTables,\n          use_ocr: useOcr\n        }\n      };\n      \n      if (customFilename) {\n        requestData.filename = customFilename;\n      }\n      \n      // Call PDF download API using centralized config\n      const response = await fetch(PDF_DOWNLOADER_CONFIG.endpoints.DOWNLOAD, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-API-Key': localStorage.getItem('api_key') || ''\n        },\n        body: JSON.stringify(requestData)\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.error?.message || `HTTP ${response.status}`);\n      }\n      \n      const data = await response.json();\n      \n      this.showSuccess(`PDF download started: ${data.task_id}`);\n      this.updateQueueUI();\n      \n      // Clear form\n      urlInput.value = '';\n      if (filenameInput) filenameInput.value = '';\n      \n    } catch (error) {\n      console.error('❌ Single PDF download failed:', error);\n      this.showError(`Download failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Handle batch PDF download\n   */\n  async handleBatchDownload() {\n    try {\n      console.log('🔍 Starting batch PDF download...');\n      \n      const urlsInput = this.state.elements.get('pdf-batch-urls-input');\n      const outputDirInput = this.state.elements.get('pdf-batch-output-dir');\n      const concurrentSelect = this.state.elements.get('pdf-concurrent-downloads');\n      \n      if (!urlsInput?.value?.trim()) {\n        this.showError('Please enter PDF URLs (one per line)');\n        return;\n      }\n      \n      // Parse URLs\n      const urls = urlsInput.value.trim()\n        .split('\\n')\n        .map(url => url.trim())\n        .filter(url => url.length > 0);\n      \n      if (urls.length === 0) {\n        this.showError('No valid URLs found');\n        return;\n      }\n      \n      const outputDir = outputDirInput?.value?.trim();\n      const concurrentDownloads = parseInt(concurrentSelect?.value || '3');\n      \n      // Get processing options\n      const processStructify = this.state.elements.get('pdf-process-structify')?.checked || false;\n      const extractTables = this.state.elements.get('pdf-extract-tables')?.checked || false;\n      const useOcr = this.state.elements.get('pdf-use-ocr')?.checked || false;\n      \n      // Prepare request data\n      const requestData = {\n        urls: urls,\n        output_folder: outputDir || undefined,\n        options: {\n          concurrent_downloads: concurrentDownloads,\n          process_with_structify: processStructify,\n          extract_tables: extractTables,\n          use_ocr: useOcr\n        }\n      };\n      \n      // Call batch PDF download API using centralized config\n      const response = await fetch(PDF_DOWNLOADER_CONFIG.endpoints.BATCH_DOWNLOAD, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-API-Key': localStorage.getItem('api_key') || ''\n        },\n        body: JSON.stringify(requestData)\n      });\n      \n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(errorData.error?.message || `HTTP ${response.status}`);\n      }\n      \n      const data = await response.json();\n      \n      this.showSuccess(`Batch download started: ${urls.length} PDFs queued (Task: ${data.task_id})`);\n      this.updateQueueUI();\n      \n      // Clear form\n      urlsInput.value = '';\n      \n    } catch (error) {\n      console.error('❌ Batch PDF download failed:', error);\n      this.showError(`Batch download failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Browse for directory\n   */\n  async browseDirectory(type) {\n    try {\n      // Use file input dialog for directory selection\n      const dirInput = document.createElement('input');\n      dirInput.type = 'file';\n      dirInput.webkitdirectory = true;\n      dirInput.style.display = 'none';\n      \n      dirInput.addEventListener('change', (e) => {\n        if (e.target.files.length > 0) {\n          const path = e.target.files[0].webkitRelativePath;\n          const dirPath = path.substring(0, path.lastIndexOf('/'));\n          \n          if (type === 'single') {\n            const outputDirInput = this.state.elements.get('pdf-single-output-dir');\n            if (outputDirInput) outputDirInput.value = dirPath;\n          } else if (type === 'batch') {\n            const outputDirInput = this.state.elements.get('pdf-batch-output-dir');\n            if (outputDirInput) outputDirInput.value = dirPath;\n          }\n        }\n      });\n      \n      document.body.appendChild(dirInput);\n      dirInput.click();\n      document.body.removeChild(dirInput);\n      \n    } catch (error) {\n      console.error('❌ Directory browse failed:', error);\n      this.showError('Directory selection failed');\n    }\n  }\n\n  /**\n   * Clear download queue\n   */\n  clearDownloadQueue() {\n    this.state.downloadQueue.clear();\n    this.state.selectedPdfs.clear();\n    this.updateQueueUI();\n    this.showSuccess('Download queue cleared');\n  }\n\n  /**\n   * Cancel all downloads\n   */\n  async cancelAllDownloads() {\n    try {\n      const activeIds = Array.from(this.state.activeDownloads.keys());\n      \n      for (const id of activeIds) {\n        const download = this.state.activeDownloads.get(id);\n        if (download?.task_id) {\n          // Use centralized config for cancel endpoint\n          const cancelUrl = PDF_DOWNLOADER_CONFIG.endpoints.CANCEL.replace(':taskId', download.task_id);\n          await fetch(cancelUrl, {\n            method: 'POST',\n            headers: { 'X-API-Key': localStorage.getItem('api_key') || '' }\n          });\n        }\n      }\n      \n      this.state.activeDownloads.clear();\n      this.updateQueueUI();\n      this.showSuccess('All downloads cancelled');\n      \n    } catch (error) {\n      console.error('❌ Cancel all failed:', error);\n      this.showError('Failed to cancel all downloads');\n    }\n  }\n\n  /**\n   * Show success message with enhanced notification system\n   */\n  showSuccess(message) {\n    console.log('✅ PDF Downloader Success:', message);\n    \n    // Use multiple notification methods for better user experience\n    if (window.NeuroGen?.modules?.progressHandler?.showSuccess) {\n      window.NeuroGen.modules.progressHandler.showSuccess(message);\n    }\n    \n    // Use UI module if available\n    if (window.NeuroGen?.modules?.ui?.showToast) {\n      window.NeuroGen.modules.ui.showToast('PDF Download', message, 'success');\n    }\n    \n    // Emit custom event for other modules\n    if (window.NeuroGen?.modules?.eventManager?.emit) {\n      window.NeuroGen.modules.eventManager.emit('pdf.download.success', { message });\n    }\n  }\n\n  /**\n   * Show error message with enhanced notification system\n   */\n  showError(message) {\n    console.error('❌ PDF Downloader Error:', message);\n    \n    // Use multiple notification methods for better user experience\n    if (window.NeuroGen?.modules?.progressHandler?.showError) {\n      window.NeuroGen.modules.progressHandler.showError(message);\n    }\n    \n    // Use UI module if available\n    if (window.NeuroGen?.modules?.ui?.showToast) {\n      window.NeuroGen.modules.ui.showToast('PDF Download Error', message, 'error');\n    }\n    \n    // Emit custom event for other modules\n    if (window.NeuroGen?.modules?.eventManager?.emit) {\n      window.NeuroGen.modules.eventManager.emit('pdf.download.error', { message });\n    }\n  }\n\n  /**\n   * Show info message with enhanced notification system\n   */\n  showInfo(message) {\n    console.log('ℹ️ PDF Downloader Info:', message);\n    \n    // Use multiple notification methods\n    if (window.NeuroGen?.modules?.ui?.showToast) {\n      window.NeuroGen.modules.ui.showToast('PDF Download', message, 'info');\n    }\n    \n    // Emit custom event for other modules\n    if (window.NeuroGen?.modules?.eventManager?.emit) {\n      window.NeuroGen.modules.eventManager.emit('pdf.download.info', { message });\n    }\n  }\n\n  /**\n   * Update queue UI displays\n   */\n  updateQueueUI() {\n    // Update counters\n    const queueTotal = this.state.elements.get('pdf-queue-total');\n    const downloadingTotal = this.state.elements.get('pdf-downloading-total');\n    const completedTotal = this.state.elements.get('pdf-completed-total');\n    const failedTotal = this.state.elements.get('pdf-failed-total');\n    \n    if (queueTotal) queueTotal.textContent = this.state.downloadQueue.size;\n    if (downloadingTotal) downloadingTotal.textContent = this.state.activeDownloads.size;\n    \n    // Count completed and failed from download queue\n    let completed = 0, failed = 0;\n    this.state.downloadQueue.forEach(item => {\n      if (item.status === 'completed') completed++;\n      if (item.status === 'failed') failed++;\n    });\n    \n    if (completedTotal) completedTotal.textContent = completed;\n    if (failedTotal) failedTotal.textContent = failed;\n  }\n\n  /**\n   * Utility functions\n   */\n  getSelectedSources(sourcesSelect) {\n    if (!sourcesSelect) return this.config.defaultSources;\n    \n    const selected = Array.from(sourcesSelect.selectedOptions).map(option => option.value);\n    return selected.length > 0 ? selected : this.config.defaultSources;\n  }\n\n  clearSearchResults() {\n    this.state.searchResults.clear();\n    this.state.selectedPdfs.clear();\n    \n    const resultsList = this.state.elements.get('academic-results-list');\n    if (resultsList) {\n      resultsList.innerHTML = '';\n    }\n    \n    const resultsContainer = this.state.elements.get('academic-results-container');\n    if (resultsContainer) {\n      resultsContainer.style.display = 'none';\n    }\n  }\n\n  clearDownloadQueue() {\n    this.state.downloadQueue.clear();\n    this.updateQueueUI();\n  }\n\n  updateSelectionUI() {\n    const countElement = this.state.elements.get('selected-pdfs-count');\n    if (countElement) {\n      countElement.textContent = this.state.selectedPdfs.size;\n    }\n  }\n\n  updateQueueUI() {\n    // Update download queue display\n    const queueList = this.state.elements.get('download-queue-list');\n    if (!queueList) return;\n\n    queueList.innerHTML = '';\n    \n    this.state.downloadQueue.forEach(item => {\n      const queueItem = document.createElement('div');\n      queueItem.className = `list-group-item d-flex justify-content-between align-items-center`;\n      \n      let statusBadge = '';\n      switch (item.status) {\n        case 'queued':\n          statusBadge = '<span class=\"badge bg-secondary\">Queued</span>';\n          break;\n        case 'downloading':\n          statusBadge = '<span class=\"badge bg-primary\">Downloading</span>';\n          break;\n        case 'completed':\n          statusBadge = '<span class=\"badge bg-success\">Completed</span>';\n          break;\n        case 'failed':\n          statusBadge = '<span class=\"badge bg-danger\">Failed</span>';\n          break;\n      }\n      \n      queueItem.innerHTML = `\n        <div>\n          <strong>${this.escapeHtml(item.title)}</strong>\n          <br><small class=\"text-muted\">${this.escapeHtml(item.authors?.join(', ') || 'Unknown authors')}</small>\n        </div>\n        ${statusBadge}\n      `;\n      \n      queueList.appendChild(queueItem);\n    });\n  }\n\n  updateUI() {\n    // Update UI based on current state\n    const searchBtn = this.state.elements.get('academic-search-btn');\n    if (searchBtn) {\n      searchBtn.disabled = this.state.processingState === 'searching';\n      searchBtn.innerHTML = this.state.processingState === 'searching' \n        ? '<i class=\"fas fa-spinner fa-spin me-1\"></i>Searching...'\n        : '<i class=\"fas fa-search me-1\"></i>Search Papers';\n    }\n  }\n\n  isMySearch(searchId) {\n    return this.state.currentSearch && this.state.currentSearch.id === searchId;\n  }\n\n  isMyTask(taskId) {\n    return Array.from(this.state.downloadQueue.values()).some(item => item.task_id === taskId);\n  }\n\n  sanitizeFilename(filename) {\n    return filename.replace(/[<>:\"/\\\\|?*]/g, '_').substring(0, 255);\n  }\n\n  escapeHtml(text) {\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n  }\n\n  showError(message) {\n    console.error('❌ PDF Downloader Error:', message);\n    // You can add UI notification here\n  }\n\n  showInfo(message) {\n    console.log('ℹ️ PDF Downloader Info:', message);\n    \n    // Use enhanced notification system\n    if (window.NeuroGen?.modules?.ui?.showToast) {\n      window.NeuroGen.modules.ui.showToast('PDF Download', message, 'info');\n    }\n  }\n\n  /**\n   * Get health status of the PDF downloader module\n   * @returns {Object} - Health status information\n   */\n  async getHealthStatus() {\n    const status = {\n      module: 'pdfDownloader',\n      initialized: this.state.isInitialized,\n      backend_connected: false,\n      config_loaded: !!this.config.endpoints,\n      socket_connected: !!window.socket?.connected,\n      active_downloads: this.state.activeDownloads.size,\n      queued_downloads: this.state.downloadQueue.size,\n      endpoints: this.config.endpoints,\n      version: '2.0.0_optimized'\n    };\n    \n    // Test backend connectivity\n    try {\n      const response = await fetch(this.config.endpoints.HEALTH, {\n        method: 'GET',\n        headers: { 'X-API-Key': localStorage.getItem('api_key') || '' },\n        timeout: 3000\n      });\n      status.backend_connected = response.ok;\n      if (response.ok) {\n        const healthData = await response.json();\n        status.backend_info = healthData;\n      }\n    } catch (error) {\n      status.backend_error = error.message;\n    }\n    \n    return status;\n  }\n\n  /**\n   * Cleanup method\n   */\n  destroy() {\n    // Remove event listeners\n    this.state.eventListeners.forEach(removeListener => removeListener());\n    this.state.socketListeners.forEach(removeListener => removeListener());\n    \n    // Clear state\n    this.state.searchResults.clear();\n    this.state.selectedPdfs.clear();\n    this.state.downloadQueue.clear();\n    this.state.activeDownloads.clear();\n    \n    console.log('🧹 PDF Downloader module destroyed');\n  }\n}\n\n// Auto-initialize if running in browser\nif (typeof window !== 'undefined') {\n  // Wait for DOM and other modules to be ready\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', () => {\n      setTimeout(() => {\n        window.pdfDownloader = new PDFDownloader();\n        window.pdfDownloader.init();\n      }, 100);\n    });\n  } else {\n    setTimeout(() => {\n      window.pdfDownloader = new PDFDownloader();\n      window.pdfDownloader.init();\n    }, 100);\n  }\n}\n\n// Export for module systems\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = PDFDownloader;\n}","source":"/workspace/modules/static/js/modules/features/pdfDownloader.js","title":"pdfDownloader.js","language":"en"},{"content":"/**\n * PDF Processor Module - Optimized Blueprint Implementation v4.0\n * \n * Advanced PDF processing module optimized for the new Blueprint architecture.\n * Features configuration-driven architecture, enhanced error handling, and\n * comprehensive integration with the centralized progress tracking system.\n * \n * NEW v4.0 Features:\n * - Configuration-driven architecture using centralized endpoints\n * - Enhanced 4-method notification system (Toast + Console + System + Error)\n * - Backend connectivity testing with health checks\n * - ES6 module imports with centralized configuration\n * - Optimized for Blueprint architecture integration\n * - Enhanced progressHandler v4.0 integration\n * - Advanced error handling and recovery mechanisms\n * \n * Legacy Features (Enhanced):\n * - PDF text extraction with page information\n * - Table detection and parsing\n * - Document structure analysis\n * - Document type classification\n * - Memory-efficient processing for large PDFs\n * - Optical Character Recognition (OCR) for scanned documents\n * \n * @module features/pdfProcessor\n * @version 4.0.0 - Blueprint Architecture Optimization\n */\n\n// Import dependencies from centralized config\nimport { API_ENDPOINTS, BLUEPRINT_ROUTES } from '../config/endpoints.js';\nimport { CONSTANTS, API_CONFIG, SOCKET_CONFIG } from '../config/constants.js';\nimport { SOCKET_EVENTS, TASK_EVENTS } from '../config/socketEvents.js';\n\nimport uiRegistry from '../core/uiRegistry.js';\nimport errorHandler from '../core/errorHandler.js';\nimport eventRegistry from '../core/eventRegistry.js';\nimport stateManager from '../core/stateManager.js';\nimport utils from '../utils/utils.js';\nimport fileHandler from '../utils/fileHandler.js';\nimport progressHandler from '../utils/progressHandler.js';\n\n// Configuration shorthand\nconst PDF_PROCESSOR_CONFIG = {\n  endpoints: API_ENDPOINTS.PDF_PROCESSOR,\n  blueprint: BLUEPRINT_ROUTES.pdf_processor,\n  constants: CONSTANTS.PDF_PROCESSOR || {},\n  api: API_CONFIG,\n  socket: SOCKET_CONFIG\n};\n\n/**\n * PDF Processor for handling PDF file operations\n */\nconst pdfProcessor = {\n  // Module state\n  initialized: false,\n  isProcessing: false,\n  currentFile: null,\n  processingMode: 'normal', // 'normal', 'memory-efficient', 'ocr'\n  backendConnected: false,\n  lastHealthCheck: null,\n  \n  // Processing options\n  config: {\n    chunkSize: PDF_PROCESSOR_CONFIG.constants.CHUNK_SIZE || 4096,\n    allowOcr: PDF_PROCESSOR_CONFIG.constants.ALLOW_OCR !== false,\n    extractTables: PDF_PROCESSOR_CONFIG.constants.EXTRACT_TABLES !== false,\n    extractImages: PDF_PROCESSOR_CONFIG.constants.EXTRACT_IMAGES || false,\n    maxPagesToProcess: PDF_PROCESSOR_CONFIG.constants.MAX_PAGES || 1000,\n    useWorkers: PDF_PROCESSOR_CONFIG.constants.USE_WORKERS !== false,\n    debug: false\n  },\n  \n  // Text extraction settings\n  extractionSettings: {\n    preserveFormatting: true,\n    includeHyphenation: false,\n    normalizeSpaces: true,\n    includePunctuations: true,\n    includeLineBreaks: true\n  },\n\n  /**\n   * Enhanced notification system with 4-method delivery\n   * @param {string} message - Notification message\n   * @param {string} type - Type of notification (info, success, warning, error)\n   * @param {string} title - Notification title\n   */\n  showNotification(message, type = 'info', title = 'PDF Processor') {\n    // Method 1: Toast notifications\n    if (window.NeuroGen?.ui?.showToast) {\n      window.NeuroGen.ui.showToast(title, message, type);\n    }\n    \n    // Method 2: Console logging with styling\n    const styles = {\n      error: 'color: #dc3545; font-weight: bold;',\n      warning: 'color: #fd7e14; font-weight: bold;',\n      success: 'color: #198754; font-weight: bold;',\n      info: 'color: #0d6efd;'\n    };\n    console.log(`%c[${title}] ${message}`, styles[type] || styles.info);\n    \n    // Method 3: System notification (if available)\n    if (window.NeuroGen?.notificationHandler) {\n      window.NeuroGen.notificationHandler.show({\n        title, message, type, module: 'pdfProcessor'\n      });\n    }\n    \n    // Method 4: Error reporting to centralized handler\n    if (type === 'error' && window.NeuroGen?.errorHandler) {\n      window.NeuroGen.errorHandler.logError({\n        module: 'pdfProcessor', message, severity: type\n      });\n    }\n  },\n\n  /**\n   * Test backend connectivity for PDF processor\n   * @returns {Promise<Object>} Backend connectivity status\n   */\n  async testBackendConnectivity() {\n    const results = {\n      overall: false,\n      details: {},\n      timestamp: new Date().toISOString(),\n      errors: []\n    };\n\n    try {\n      // Test PDF processor health endpoint\n      const healthResponse = await fetch(PDF_PROCESSOR_CONFIG.endpoints?.HEALTH || '/api/pdf/health', {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' }\n      });\n\n      results.details.health = {\n        status: healthResponse.status,\n        ok: healthResponse.ok,\n        endpoint: PDF_PROCESSOR_CONFIG.endpoints?.HEALTH || '/api/pdf/health'\n      };\n\n      if (healthResponse.ok) {\n        // Test PDF processor process endpoint (if available)\n        if (PDF_PROCESSOR_CONFIG.endpoints?.PROCESS) {\n          const testResponse = await fetch(PDF_PROCESSOR_CONFIG.endpoints.PROCESS, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n              file_path: '/tmp/connectivity_test.pdf',\n              action: 'validate'\n            })\n          });\n\n          results.details.process = {\n            status: testResponse.status,\n            ok: testResponse.ok,\n            endpoint: PDF_PROCESSOR_CONFIG.endpoints.PROCESS\n          };\n        }\n\n        results.overall = true;\n        this.backendConnected = true;\n        this.lastHealthCheck = new Date();\n        this.showNotification('Backend connectivity verified', 'success', 'PDF Processor');\n      }\n\n      if (!results.overall && !PDF_PROCESSOR_CONFIG.endpoints?.PROCESS) {\n        // If only health endpoint is available and it works, consider it successful\n        results.overall = healthResponse.ok;\n        this.backendConnected = healthResponse.ok;\n        this.lastHealthCheck = new Date();\n        if (healthResponse.ok) {\n          this.showNotification('Backend connectivity verified', 'success', 'PDF Processor');\n        }\n      }\n\n      if (!results.overall) {\n        throw new Error(`Health endpoint returned ${healthResponse.status}`);\n      }\n\n    } catch (error) {\n      results.errors.push({\n        endpoint: PDF_PROCESSOR_CONFIG.endpoints?.HEALTH || '/api/pdf/health',\n        error: error.message\n      });\n      this.backendConnected = false;\n      this.showNotification(`Backend connectivity failed: ${error.message}`, 'error', 'PDF Processor');\n    }\n\n    return results;\n  },\n\n  /**\n   * Get PDF processor health status\n   * @returns {Object} Health status information\n   */\n  getHealthStatus() {\n    return {\n      module: 'pdfProcessor',\n      version: '4.0.0',\n      status: this.initialized ? 'healthy' : 'initializing',\n      features: {\n        configurationDriven: true,\n        enhancedNotifications: true,\n        backendConnectivity: true,\n        pdfProcessing: true,\n        ocrSupport: this.config.allowOcr,\n        tableExtraction: this.config.extractTables\n      },\n      configuration: {\n        endpoints: PDF_PROCESSOR_CONFIG.endpoints,\n        chunkSize: this.config.chunkSize,\n        maxPages: this.config.maxPagesToProcess,\n        allowOcr: this.config.allowOcr,\n        extractTables: this.config.extractTables\n      },\n      state: {\n        initialized: this.initialized,\n        isProcessing: this.isProcessing,\n        currentFile: this.currentFile,\n        processingMode: this.processingMode,\n        backendConnected: this.backendConnected,\n        lastHealthCheck: this.lastHealthCheck\n      }\n    };\n  },\n  \n  /**\n   * Initialize the PDF processor with enhanced Blueprint architecture integration\n   * @param {Object} options - Configuration options\n   * @returns {Promise<boolean>} - Success state\n   */\n  async initialize(options = {}) {\n    try {\n      // Don't initialize twice\n      if (this.initialized) {\n        this.showNotification(\"PDF processor already initialized\", 'info', 'PDF Processor');\n        return true;\n      }\n      \n      this.showNotification('Initializing PDF Processor v4.0', 'info', 'PDF Processor');\n      \n      // Test backend connectivity on initialization\n      await this.testBackendConnectivity();\n      \n      // Merge configuration options\n      this.config = {\n        ...this.config,\n        ...options\n      };\n      \n      // Check for developer mode\n      if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {\n        this.config.debug = true;\n      }\n      \n      // Register events for PDF processing\n      this.registerEvents();\n      \n      this.initialized = true;\n      this.showNotification('PDF Processor v4.0 initialized successfully', 'success', 'PDF Processor');\n      return true;\n    } catch (error) {\n      this.showNotification(`PDF Processor initialization failed: ${error.message}`, 'error', 'PDF Processor');\n      errorHandler.handleError(error, 'PDF_PROCESSOR');\n      return false;\n    }\n  },\n  \n  /**\n   * Register events for PDF processing\n   */\n  registerEvents() {\n    // Register for file processor events that involve PDFs\n    eventRegistry.on('file.selected', (data) => {\n      if (data.files && data.files.length > 0) {\n        const pdfFiles = Array.from(data.files).filter(file => \n          file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')\n        );\n        \n        if (pdfFiles.length > 0) {\n          // Store information about selected PDF files\n          this.updateSelectedPdfInfo(pdfFiles);\n        }\n      }\n    });\n    \n    // Register for PDF extraction button clicks\n    eventRegistry.registerEvent('pdfProcessor.extractText', {\n      selector: '#extract-pdf-text-btn',\n      type: 'click',\n      callback: (event) => {\n        const fileInput = document.getElementById('pdf-file-input');\n        if (fileInput && fileInput.files.length > 0) {\n          this.processFiles(Array.from(fileInput.files));\n        } else {\n          // Show error using UI module\n          this.showError('No PDF file selected', 'Please select a PDF file to extract text from.');\n        }\n      }\n    });\n    \n    console.log(\"PDF processor events registered\");\n  },\n  \n  /**\n   * Update information about selected PDF files\n   * @param {Array<File>} pdfFiles - Array of selected PDF files\n   */\n  updateSelectedPdfInfo(pdfFiles) {\n    try {\n      // Update state manager with selected PDF info\n      if (stateManager && typeof stateManager.setState === 'function') {\n        stateManager.setState('selectedPdfFiles', pdfFiles.map(file => ({\n          name: file.name,\n          size: file.size,\n          lastModified: new Date(file.lastModified).toISOString()\n        })));\n      }\n      \n      // Update UI if PDF info container exists\n      const pdfInfoContainer = uiRegistry.getElement('pdfTab.fileInfo') || \n                               document.getElementById('pdf-file-info');\n      \n      if (pdfInfoContainer) {\n        const fileCount = pdfFiles.length;\n        const totalSize = pdfFiles.reduce((total, file) => total + file.size, 0);\n        \n        pdfInfoContainer.innerHTML = `\n          <div class=\"alert alert-info\">\n            <strong>${fileCount} PDF file${fileCount !== 1 ? 's' : ''} selected</strong>\n            <br>\n            Total size: ${utils.formatBytes(totalSize)}\n          </div>\n          <ul class=\"list-group mt-2\">\n            ${pdfFiles.map(file => `\n              <li class=\"list-group-item d-flex justify-content-between align-items-center\">\n                <span>${file.name}</span>\n                <span class=\"badge bg-primary rounded-pill\">${utils.formatBytes(file.size)}</span>\n              </li>\n            `).join('')}\n          </ul>\n        `;\n      }\n    } catch (error) {\n      console.error(\"Error updating PDF info:\", error);\n      errorHandler.handleError(error, 'PDF_PROCESSOR');\n    }\n  },\n  \n  /**\n   * Process PDF files for text extraction\n   * @param {Array<File>} files - Array of PDF files to process\n   * @returns {Promise<Object>} - Processing results\n   */\n  async processFiles(files) {\n    if (this.isProcessing) {\n      console.warn(\"PDF processing already in progress\");\n      return { success: false, error: \"Processing already in progress\" };\n    }\n    \n    try {\n      this.isProcessing = true;\n      \n      // Filter to include only PDF files\n      const pdfFiles = files.filter(file => \n        file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')\n      );\n      \n      if (pdfFiles.length === 0) {\n        throw new Error(\"No PDF files to process\");\n      }\n      \n      // Show processing UI\n      this.showProcessingUI();\n      \n      // Emit processing started event\n      eventRegistry.emit('pdf.processing.started', {\n        files: pdfFiles.map(f => f.name),\n        count: pdfFiles.length,\n        timestamp: new Date().toISOString()\n      });\n      \n      // Process each PDF file sequentially\n      const results = [];\n      \n      for (let i = 0; i < pdfFiles.length; i++) {\n        const file = pdfFiles[i];\n        this.currentFile = file;\n        \n        // Update progress\n        this.updateProgress((i / pdfFiles.length) * 100, `Processing ${file.name} (${i+1}/${pdfFiles.length})...`);\n        \n        // Determine processing mode based on file size\n        this.determineProcessingMode(file);\n        \n        // Extract text from the PDF\n        const result = await this.extractTextFromPdf(file);\n        \n        // Process result\n        if (result.success) {\n          results.push({\n            fileName: file.name,\n            data: result.data,\n            tables: result.tables || [],\n            images: result.images || [],\n            structure: result.structure || null\n          });\n          \n          // Update progress with success\n          this.updateProgress(\n            ((i + 1) / pdfFiles.length) * 100, \n            `Successfully processed ${file.name} (${i+1}/${pdfFiles.length})`\n          );\n        } else {\n          // Handle failed processing\n          results.push({\n            fileName: file.name,\n            error: result.error || \"Unknown error during processing\",\n            success: false\n          });\n          \n          // Update progress with error\n          this.updateProgress(\n            ((i + 1) / pdfFiles.length) * 100, \n            `Error processing ${file.name} (${i+1}/${pdfFiles.length})`\n          );\n          \n          // Log the error\n          console.error(`Error processing PDF file ${file.name}:`, result.error);\n          errorHandler.handleError(new Error(result.error), 'PDF_PROCESSOR', false);\n        }\n      }\n      \n      // Show results UI\n      this.showResultsUI(results);\n      \n      // Emit processing completed event\n      eventRegistry.emit('pdf.processing.completed', {\n        results,\n        count: results.length,\n        successCount: results.filter(r => !r.error).length,\n        errorCount: results.filter(r => r.error).length,\n        timestamp: new Date().toISOString()\n      });\n      \n      // Reset processing state\n      this.isProcessing = false;\n      this.currentFile = null;\n      \n      return {\n        success: true,\n        results\n      };\n    } catch (error) {\n      console.error(\"Error processing PDF files:\", error);\n      errorHandler.handleError(error, 'PDF_PROCESSOR');\n      \n      // Show error UI\n      this.showErrorUI(error.message || \"Failed to process PDF files\");\n      \n      // Emit processing error event\n      eventRegistry.emit('pdf.processing.error', {\n        error: error.message || \"Unknown error\",\n        timestamp: new Date().toISOString()\n      });\n      \n      // Reset processing state\n      this.isProcessing = false;\n      this.currentFile = null;\n      \n      return {\n        success: false,\n        error: error.message || \"Unknown error\"\n      };\n    }\n  },\n  \n  /**\n   * Determine the appropriate processing mode based on file size\n   * @param {File} file - The PDF file to analyze\n   */\n  determineProcessingMode(file) {\n    const fileSizeInMB = file.size / (1024 * 1024);\n    \n    if (fileSizeInMB > 100) {\n      // Use memory efficient mode for very large files\n      this.processingMode = 'memory-efficient';\n      console.log(`Using memory efficient mode for large file (${fileSizeInMB.toFixed(2)} MB)`);\n    } else if (fileSizeInMB > 20) {\n      // Use normal mode with reduced chunk size for large files\n      this.processingMode = 'normal';\n      this.config.chunkSize = 2048; // Reduced chunk size\n      console.log(`Using normal mode with reduced chunk size for file (${fileSizeInMB.toFixed(2)} MB)`);\n    } else {\n      // Use normal mode for regular files\n      this.processingMode = 'normal';\n      this.config.chunkSize = 4096; // Standard chunk size\n      console.log(`Using normal mode for file (${fileSizeInMB.toFixed(2)} MB)`);\n    }\n  },\n  \n  /**\n   * Extract text from a PDF file\n   * @param {File} file - The PDF file to process\n   * @returns {Promise<Object>} - Extraction results\n   */\n  async extractTextFromPdf(file) {\n    try {\n      // Convert the file to an ArrayBuffer for processing\n      const arrayBuffer = await this.readFileAsArrayBuffer(file);\n      \n      // Use the appropriate processing method based on mode\n      if (this.processingMode === 'memory-efficient') {\n        return await this.memoryEfficientProcessing(arrayBuffer, file.name);\n      } else {\n        return await this.standardProcessing(arrayBuffer, file.name);\n      }\n    } catch (error) {\n      console.error(`Error extracting text from PDF ${file.name}:`, error);\n      return {\n        success: false,\n        error: error.message || \"Failed to extract text from PDF\"\n      };\n    }\n  },\n  \n  /**\n   * Read a file as ArrayBuffer\n   * @param {File} file - The file to read\n   * @returns {Promise<ArrayBuffer>} - File contents as ArrayBuffer\n   */\n  readFileAsArrayBuffer(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      \n      reader.onload = (event) => {\n        resolve(event.target.result);\n      };\n      \n      reader.onerror = (error) => {\n        reject(new Error(`Error reading file: ${error.message}`));\n      };\n      \n      reader.readAsArrayBuffer(file);\n    });\n  },\n  \n  /**\n   * Standard PDF processing method\n   * @param {ArrayBuffer} arrayBuffer - The PDF file content\n   * @param {string} fileName - The name of the file\n   * @returns {Promise<Object>} - Processing results\n   */\n  async standardProcessing(arrayBuffer, fileName) {\n    try {\n      // This implementation would use the PDF.js library to process the PDF\n      // For demonstration, we'll simulate the processing\n      \n      // In a real implementation, this would use PDF.js to load and process the document\n      console.log(`Standard processing of ${fileName} started`);\n      \n      // Simulate API call to backend for PDF processing\n      const formData = new FormData();\n      const blob = new Blob([arrayBuffer], { type: 'application/pdf' });\n      formData.append('file', blob, fileName);\n      \n      // Extraction settings\n      formData.append('extractTables', this.config.extractTables);\n      formData.append('extractImages', this.config.extractImages);\n      formData.append('preserveFormatting', this.extractionSettings.preserveFormatting);\n      \n      // Make request to backend API\n      const response = await fetch('/api/process-pdf', {\n        method: 'POST',\n        body: formData\n      });\n      \n      if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`Server error: ${errorText}`);\n      }\n      \n      const result = await response.json();\n      \n      // Process results and structure data\n      const processedData = this.processExtractionResults(result);\n      \n      return {\n        success: true,\n        data: processedData,\n        tables: result.tables || [],\n        images: result.images || [],\n        structure: result.structure || null\n      };\n    } catch (error) {\n      console.error(`Error in standard PDF processing for ${fileName}:`, error);\n      return {\n        success: false,\n        error: error.message || \"PDF processing failed\"\n      };\n    }\n  },\n  \n  /**\n   * Memory-efficient PDF processing method for large files\n   * @param {ArrayBuffer} arrayBuffer - The PDF file content\n   * @param {string} fileName - The name of the file\n   * @returns {Promise<Object>} - Processing results\n   */\n  async memoryEfficientProcessing(arrayBuffer, fileName) {\n    try {\n      console.log(`Memory-efficient processing of ${fileName} started`);\n      \n      // In a real implementation, this would process the PDF in chunks\n      // Here we'll simulate by making an API call with a memory_efficient flag\n      \n      const formData = new FormData();\n      const blob = new Blob([arrayBuffer], { type: 'application/pdf' });\n      formData.append('file', blob, fileName);\n      formData.append('mode', 'memory_efficient');\n      formData.append('chunkSize', this.config.chunkSize);\n      \n      // Make request to backend API\n      const response = await fetch('/api/process-pdf', {\n        method: 'POST',\n        body: formData\n      });\n      \n      if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`Server error: ${errorText}`);\n      }\n      \n      const result = await response.json();\n      \n      // Process results\n      const processedData = this.processExtractionResults(result);\n      \n      return {\n        success: true,\n        data: processedData,\n        tables: result.tables || [],\n        structure: result.structure || null\n      };\n    } catch (error) {\n      console.error(`Error in memory-efficient PDF processing for ${fileName}:`, error);\n      return {\n        success: false,\n        error: error.message || \"PDF processing failed\"\n      };\n    }\n  },\n  \n  /**\n   * Process extraction results into a structured format\n   * @param {Object} result - Raw extraction results\n   * @returns {Object} - Processed data\n   */\n  processExtractionResults(result) {\n    try {\n      // Process raw extraction results into a structured format\n      const processedData = {\n        title: result.metadata?.title || \"Untitled Document\",\n        authors: result.metadata?.author || \"Unknown Author\",\n        creationDate: result.metadata?.creationDate || null,\n        pages: result.pageCount || 0,\n        text: result.fullText || \"\",\n        byPage: result.pages || [],\n        metadata: result.metadata || {},\n        keywords: result.keywords || [],\n        language: result.language || \"unknown\"\n      };\n      \n      return processedData;\n    } catch (error) {\n      console.error(\"Error processing extraction results:\", error);\n      return {\n        title: \"Error Processing Document\",\n        text: \"An error occurred while processing the extraction results.\"\n      };\n    }\n  },\n  \n  /**\n   * Update progress during PDF processing\n   * @param {number} percent - Progress percentage (0-100)\n   * @param {string} message - Progress message\n   */\n  updateProgress(percent, message) {\n    try {\n      // Update progress using progress handler if available\n      if (progressHandler && typeof progressHandler.updateProgress === 'function') {\n        progressHandler.updateProgress(percent, message);\n      } else {\n        // Fallback to direct DOM manipulation\n        const progressBar = uiRegistry.getElement('pdfTab.progressBar') || \n                            document.getElementById('pdf-progress-bar');\n        const progressText = uiRegistry.getElement('pdfTab.progressText') || \n                             document.getElementById('pdf-progress-text');\n        \n        if (progressBar) {\n          progressBar.style.width = `${percent}%`;\n          progressBar.setAttribute('aria-valuenow', Math.round(percent));\n        }\n        \n        if (progressText) {\n          progressText.textContent = message;\n        }\n      }\n      \n      // Emit progress event\n      eventRegistry.emit('pdf.processing.progress', {\n        percent,\n        message,\n        file: this.currentFile?.name,\n        mode: this.processingMode,\n        timestamp: new Date().toISOString()\n      });\n    } catch (error) {\n      console.error(\"Error updating progress:\", error);\n    }\n  },\n  \n  /**\n   * Show processing UI during PDF extraction\n   */\n  showProcessingUI() {\n    try {\n      // Hide form container and show progress container\n      const formContainer = uiRegistry.getElement('pdfTab.formContainer') || \n                            document.getElementById('pdf-form-container');\n      const progressContainer = uiRegistry.getElement('pdfTab.progressContainer') || \n                                document.getElementById('pdf-progress-container');\n      const resultsContainer = uiRegistry.getElement('pdfTab.resultsContainer') || \n                               document.getElementById('pdf-results-container');\n      const errorContainer = uiRegistry.getElement('pdfTab.errorContainer') || \n                             document.getElementById('pdf-error-container');\n      \n      if (formContainer) formContainer.classList.add('d-none');\n      if (progressContainer) progressContainer.classList.remove('d-none');\n      if (resultsContainer) resultsContainer.classList.add('d-none');\n      if (errorContainer) errorContainer.classList.add('d-none');\n      \n      // Reset progress bar\n      const progressBar = uiRegistry.getElement('pdfTab.progressBar') || \n                          document.getElementById('pdf-progress-bar');\n      const progressText = uiRegistry.getElement('pdfTab.progressText') || \n                           document.getElementById('pdf-progress-text');\n      \n      if (progressBar) {\n        progressBar.style.width = '0%';\n        progressBar.setAttribute('aria-valuenow', '0');\n      }\n      \n      if (progressText) {\n        progressText.textContent = 'Preparing to process PDF...';\n      }\n    } catch (error) {\n      console.error(\"Error showing processing UI:\", error);\n    }\n  },\n  \n  /**\n   * Show results UI after PDF extraction\n   * @param {Array<Object>} results - Processing results\n   */\n  showResultsUI(results) {\n    try {\n      // Hide progress container and show results container\n      const progressContainer = uiRegistry.getElement('pdfTab.progressContainer') || \n                                document.getElementById('pdf-progress-container');\n      const resultsContainer = uiRegistry.getElement('pdfTab.resultsContainer') || \n                               document.getElementById('pdf-results-container');\n      \n      if (progressContainer) progressContainer.classList.add('d-none');\n      if (resultsContainer) resultsContainer.classList.remove('d-none');\n      \n      // Display results\n      const resultsContent = uiRegistry.getElement('pdfTab.resultsContent') || \n                             document.getElementById('pdf-results-content');\n      \n      if (resultsContent) {\n        const successCount = results.filter(r => !r.error).length;\n        const totalCount = results.length;\n        \n        let html = `\n          <div class=\"alert alert-${successCount === totalCount ? 'success' : 'info'}\">\n            <h5>Processing Complete</h5>\n            <p>Successfully processed ${successCount} of ${totalCount} PDF files.</p>\n          </div>\n        `;\n        \n        // Add results for each file\n        html += '<div class=\"list-group mt-3\">';\n        \n        results.forEach(result => {\n          if (result.error) {\n            // Error result\n            html += `\n              <div class=\"list-group-item list-group-item-danger\">\n                <div class=\"d-flex w-100 justify-content-between\">\n                  <h5 class=\"mb-1\">${result.fileName}</h5>\n                  <span class=\"badge bg-danger\">Error</span>\n                </div>\n                <p class=\"mb-1\">${result.error}</p>\n              </div>\n            `;\n          } else {\n            // Success result\n            html += `\n              <div class=\"list-group-item list-group-item-success\">\n                <div class=\"d-flex w-100 justify-content-between\">\n                  <h5 class=\"mb-1\">${result.fileName}</h5>\n                  <span class=\"badge bg-success\">Success</span>\n                </div>\n                <p class=\"mb-1\">\n                  <strong>Title:</strong> ${result.data.title}<br>\n                  <strong>Pages:</strong> ${result.data.pages}<br>\n                  <strong>Tables:</strong> ${result.tables.length}<br>\n                </p>\n                <div class=\"d-flex justify-content-end\">\n                  <button class=\"btn btn-sm btn-outline-primary me-2 view-pdf-result\" \n                          data-index=\"${results.indexOf(result)}\">\n                    View Details\n                  </button>\n                  <button class=\"btn btn-sm btn-outline-secondary copy-pdf-text\" \n                          data-index=\"${results.indexOf(result)}\">\n                    Copy Text\n                  </button>\n                </div>\n              </div>\n            `;\n          }\n        });\n        \n        html += '</div>';\n        \n        // Add a new task button\n        html += `\n          <div class=\"mt-3\">\n            <button id=\"pdf-new-task-btn\" class=\"btn btn-primary\">\n              Process Another PDF\n            </button>\n          </div>\n        `;\n        \n        resultsContent.innerHTML = html;\n        \n        // Add event listeners for buttons\n        const viewButtons = resultsContent.querySelectorAll('.view-pdf-result');\n        const copyButtons = resultsContent.querySelectorAll('.copy-pdf-text');\n        const newTaskButton = resultsContent.querySelector('#pdf-new-task-btn');\n        \n        viewButtons.forEach(button => {\n          button.addEventListener('click', (event) => {\n            const index = parseInt(event.currentTarget.getAttribute('data-index'));\n            this.showPdfResultDetails(results[index]);\n          });\n        });\n        \n        copyButtons.forEach(button => {\n          button.addEventListener('click', (event) => {\n            const index = parseInt(event.currentTarget.getAttribute('data-index'));\n            this.copyPdfText(results[index]);\n          });\n        });\n        \n        if (newTaskButton) {\n          newTaskButton.addEventListener('click', () => {\n            this.resetToForm();\n          });\n        }\n      }\n    } catch (error) {\n      console.error(\"Error showing results UI:\", error);\n      errorHandler.handleError(error, 'PDF_PROCESSOR');\n    }\n  },\n  \n  /**\n   * Show error UI when PDF processing fails\n   * @param {string} errorMessage - Error message to display\n   */\n  showErrorUI(errorMessage) {\n    try {\n      // Hide other containers and show error container\n      const formContainer = uiRegistry.getElement('pdfTab.formContainer') || \n                            document.getElementById('pdf-form-container');\n      const progressContainer = uiRegistry.getElement('pdfTab.progressContainer') || \n                                document.getElementById('pdf-progress-container');\n      const resultsContainer = uiRegistry.getElement('pdfTab.resultsContainer') || \n                               document.getElementById('pdf-results-container');\n      const errorContainer = uiRegistry.getElement('pdfTab.errorContainer') || \n                             document.getElementById('pdf-error-container');\n      \n      if (formContainer) formContainer.classList.add('d-none');\n      if (progressContainer) progressContainer.classList.add('d-none');\n      if (resultsContainer) resultsContainer.classList.add('d-none');\n      if (errorContainer) errorContainer.classList.remove('d-none');\n      \n      // Display error message\n      const errorText = uiRegistry.getElement('pdfTab.errorText') || \n                        document.getElementById('pdf-error-text');\n      \n      if (errorText) {\n        errorText.textContent = errorMessage;\n      }\n      \n      // Set up retry button\n      const retryButton = uiRegistry.getElement('pdfTab.retryButton') || \n                          document.getElementById('pdf-retry-button');\n      \n      if (retryButton) {\n        retryButton.addEventListener('click', () => {\n          this.resetToForm();\n        });\n      }\n    } catch (error) {\n      console.error(\"Error showing error UI:\", error);\n      // Last resort fallback\n      alert(`Error processing PDF: ${errorMessage}`);\n    }\n  },\n  \n  /**\n   * Reset UI to the form view\n   */\n  resetToForm() {\n    try {\n      // Hide other containers and show form container\n      const formContainer = uiRegistry.getElement('pdfTab.formContainer') || \n                            document.getElementById('pdf-form-container');\n      const progressContainer = uiRegistry.getElement('pdfTab.progressContainer') || \n                                document.getElementById('pdf-progress-container');\n      const resultsContainer = uiRegistry.getElement('pdfTab.resultsContainer') || \n                               document.getElementById('pdf-results-container');\n      const errorContainer = uiRegistry.getElement('pdfTab.errorContainer') || \n                             document.getElementById('pdf-error-container');\n      \n      if (formContainer) formContainer.classList.remove('d-none');\n      if (progressContainer) progressContainer.classList.add('d-none');\n      if (resultsContainer) resultsContainer.classList.add('d-none');\n      if (errorContainer) errorContainer.classList.add('d-none');\n      \n      // Reset file input\n      const fileInput = document.getElementById('pdf-file-input');\n      if (fileInput) {\n        fileInput.value = '';\n      }\n      \n      // Reset file info container\n      const pdfInfoContainer = uiRegistry.getElement('pdfTab.fileInfo') || \n                               document.getElementById('pdf-file-info');\n      \n      if (pdfInfoContainer) {\n        pdfInfoContainer.innerHTML = '<div class=\"alert alert-info\">No PDF file selected</div>';\n      }\n      \n      // Reset processing state\n      this.isProcessing = false;\n      this.currentFile = null;\n    } catch (error) {\n      console.error(\"Error resetting to form:\", error);\n    }\n  },\n  \n  /**\n   * Show detailed view of a PDF processing result\n   * @param {Object} result - The processing result to display\n   */\n  showPdfResultDetails(result) {\n    try {\n      // Create a modal to show the details\n      const modalHtml = `\n        <div class=\"modal fade\" id=\"pdfResultModal\" tabindex=\"-1\" aria-labelledby=\"pdfResultModalLabel\" aria-hidden=\"true\">\n          <div class=\"modal-dialog modal-lg modal-dialog-scrollable\">\n            <div class=\"modal-content\">\n              <div class=\"modal-header\">\n                <h5 class=\"modal-title\" id=\"pdfResultModalLabel\">${result.fileName}</h5>\n                <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>\n              </div>\n              <div class=\"modal-body\">\n                <ul class=\"nav nav-tabs\" id=\"pdfResultTabs\" role=\"tablist\">\n                  <li class=\"nav-item\" role=\"presentation\">\n                    <button class=\"nav-link active\" id=\"pdf-text-tab\" data-bs-toggle=\"tab\" \n                            data-bs-target=\"#pdf-text-content\" type=\"button\" role=\"tab\" \n                            aria-controls=\"pdf-text-content\" aria-selected=\"true\">Text</button>\n                  </li>\n                  <li class=\"nav-item\" role=\"presentation\">\n                    <button class=\"nav-link\" id=\"pdf-meta-tab\" data-bs-toggle=\"tab\" \n                            data-bs-target=\"#pdf-meta-content\" type=\"button\" role=\"tab\" \n                            aria-controls=\"pdf-meta-content\" aria-selected=\"false\">Metadata</button>\n                  </li>\n                  ${result.tables && result.tables.length > 0 ? `\n                    <li class=\"nav-item\" role=\"presentation\">\n                      <button class=\"nav-link\" id=\"pdf-tables-tab\" data-bs-toggle=\"tab\" \n                              data-bs-target=\"#pdf-tables-content\" type=\"button\" role=\"tab\" \n                              aria-controls=\"pdf-tables-content\" aria-selected=\"false\">Tables</button>\n                    </li>\n                  ` : ''}\n                </ul>\n                <div class=\"tab-content mt-3\" id=\"pdfResultTabContent\">\n                  <div class=\"tab-pane fade show active\" id=\"pdf-text-content\" role=\"tabpanel\" aria-labelledby=\"pdf-text-tab\">\n                    <pre class=\"text-content\">${result.data.text}</pre>\n                  </div>\n                  <div class=\"tab-pane fade\" id=\"pdf-meta-content\" role=\"tabpanel\" aria-labelledby=\"pdf-meta-tab\">\n                    <div class=\"table-responsive\">\n                      <table class=\"table table-striped\">\n                        <tbody>\n                          <tr>\n                            <th>Title</th>\n                            <td>${result.data.title}</td>\n                          </tr>\n                          <tr>\n                            <th>Author</th>\n                            <td>${result.data.authors}</td>\n                          </tr>\n                          <tr>\n                            <th>Pages</th>\n                            <td>${result.data.pages}</td>\n                          </tr>\n                          <tr>\n                            <th>Creation Date</th>\n                            <td>${result.data.creationDate || 'Unknown'}</td>\n                          </tr>\n                          <tr>\n                            <th>Language</th>\n                            <td>${result.data.language || 'Unknown'}</td>\n                          </tr>\n                          <tr>\n                            <th>Keywords</th>\n                            <td>${result.data.keywords && result.data.keywords.length ? \n                                  result.data.keywords.join(', ') : 'None'}</td>\n                          </tr>\n                        </tbody>\n                      </table>\n                    </div>\n                  </div>\n                  ${result.tables && result.tables.length > 0 ? `\n                    <div class=\"tab-pane fade\" id=\"pdf-tables-content\" role=\"tabpanel\" aria-labelledby=\"pdf-tables-tab\">\n                      <div class=\"mb-3\">\n                        <h6>Found ${result.tables.length} tables</h6>\n                      </div>\n                      ${result.tables.map((table, index) => `\n                        <div class=\"card mb-3\">\n                          <div class=\"card-header\">\n                            Table ${index + 1} (Page ${table.page || 'Unknown'})\n                          </div>\n                          <div class=\"card-body\">\n                            <div class=\"table-responsive\">\n                              <table class=\"table table-bordered table-sm\">\n                                <thead>\n                                  <tr>\n                                    ${table.columns ? table.columns.map(col => `<th>${col}</th>`).join('') : \n                                     table.data && table.data[0] ? table.data[0].map((_, colIndex) => `<th>Column ${colIndex + 1}</th>`).join('') : ''}\n                                  </tr>\n                                </thead>\n                                <tbody>\n                                  ${table.data ? table.data.map(row => `\n                                    <tr>\n                                      ${row.map(cell => `<td>${cell}</td>`).join('')}\n                                    </tr>\n                                  `).join('') : ''}\n                                </tbody>\n                              </table>\n                            </div>\n                          </div>\n                        </div>\n                      `).join('')}\n                    </div>\n                  ` : ''}\n                </div>\n              </div>\n              <div class=\"modal-footer\">\n                <button type=\"button\" class=\"btn btn-outline-secondary\" data-bs-dismiss=\"modal\">Close</button>\n                <button type=\"button\" class=\"btn btn-primary\" id=\"copy-modal-text\">Copy Text</button>\n              </div>\n            </div>\n          </div>\n        </div>\n      `;\n      \n      // Add modal to the body\n      const modalContainer = document.createElement('div');\n      modalContainer.innerHTML = modalHtml;\n      document.body.appendChild(modalContainer);\n      \n      // Initialize the modal using Bootstrap if available\n      let modal;\n      if (typeof bootstrap !== 'undefined' && typeof bootstrap.Modal !== 'undefined') {\n        modal = new bootstrap.Modal(document.getElementById('pdfResultModal'));\n        modal.show();\n      } else {\n        // Fallback for showing the modal\n        const modalElement = document.getElementById('pdfResultModal');\n        modalElement.classList.add('show');\n        modalElement.style.display = 'block';\n        document.body.classList.add('modal-open');\n        \n        // Add backdrop\n        const backdrop = document.createElement('div');\n        backdrop.className = 'modal-backdrop fade show';\n        document.body.appendChild(backdrop);\n      }\n      \n      // Set up copy button\n      document.getElementById('copy-modal-text').addEventListener('click', () => {\n        this.copyPdfText(result);\n      });\n      \n      // Handle modal close event\n      document.getElementById('pdfResultModal').addEventListener('hidden.bs.modal', function (event) {\n        // Remove modal from DOM when hidden\n        this.remove();\n        const backdrop = document.querySelector('.modal-backdrop');\n        if (backdrop) backdrop.remove();\n        document.body.classList.remove('modal-open');\n      });\n    } catch (error) {\n      console.error(\"Error showing PDF result details:\", error);\n      errorHandler.handleError(error, 'PDF_PROCESSOR');\n    }\n  },\n  \n  /**\n   * Copy PDF text to clipboard\n   * @param {Object} result - The processing result containing the text to copy\n   */\n  copyPdfText(result) {\n    try {\n      if (!result || !result.data || !result.data.text) {\n        throw new Error(\"No text available to copy\");\n      }\n      \n      // Use Clipboard API if available\n      if (navigator.clipboard && window.isSecureContext) {\n        navigator.clipboard.writeText(result.data.text)\n          .then(() => {\n            // Show success message\n            this.showMessage('Success', 'Text copied to clipboard', 'success');\n          })\n          .catch(() => {\n            // Fallback to textarea method\n            this.copyTextareaFallback(result.data.text);\n          });\n      } else {\n        // Use textarea fallback method for non-secure contexts\n        this.copyTextareaFallback(result.data.text);\n      }\n    } catch (error) {\n      console.error(\"Error copying PDF text:\", error);\n      this.showMessage('Error', 'Failed to copy text to clipboard', 'error');\n    }\n  },\n  \n  /**\n   * Fallback method for copying text using textarea\n   * @param {string} text - Text to copy\n   */\n  copyTextareaFallback(text) {\n    try {\n      // Create textarea element\n      const textArea = document.createElement('textarea');\n      textArea.value = text;\n      \n      // Make the textarea out of viewport\n      textArea.style.position = 'fixed';\n      textArea.style.left = '-999999px';\n      textArea.style.top = '-999999px';\n      document.body.appendChild(textArea);\n      \n      // Select and copy\n      textArea.focus();\n      textArea.select();\n      \n      const successful = document.execCommand('copy');\n      \n      // Clean up\n      document.body.removeChild(textArea);\n      \n      if (successful) {\n        this.showMessage('Success', 'Text copied to clipboard', 'success');\n      } else {\n        throw new Error(\"execCommand copy failed\");\n      }\n    } catch (error) {\n      console.error(\"Error in textarea copy fallback:\", error);\n      this.showMessage('Error', 'Failed to copy text to clipboard', 'error');\n    }\n  },\n  \n  /**\n   * Show a message to the user\n   * @param {string} title - Message title\n   * @param {string} message - Message content\n   * @param {string} type - Message type (success, error, warning, info)\n   */\n  showMessage(title, message, type = 'info') {\n    try {\n      // Use UI toast if available\n      if (window.ui && typeof window.ui.showToast === 'function') {\n        window.ui.showToast(title, message, type);\n        return;\n      }\n      \n      // Create a bootstrap toast if UI module not available\n      const toastHtml = `\n        <div class=\"toast align-items-center text-white bg-${type === 'error' ? 'danger' : type} border-0\" role=\"alert\" aria-live=\"assertive\" aria-atomic=\"true\">\n          <div class=\"d-flex\">\n            <div class=\"toast-body\">\n              <strong>${title}</strong>: ${message}\n            </div>\n            <button type=\"button\" class=\"btn-close btn-close-white me-2 m-auto\" data-bs-dismiss=\"toast\" aria-label=\"Close\"></button>\n          </div>\n        </div>\n      `;\n      \n      // Check if toast container exists, create if not\n      let toastContainer = document.getElementById('toast-container');\n      if (!toastContainer) {\n        toastContainer = document.createElement('div');\n        toastContainer.id = 'toast-container';\n        toastContainer.className = 'toast-container position-fixed bottom-0 end-0 p-3';\n        document.body.appendChild(toastContainer);\n      }\n      \n      // Add toast to container\n      const toastElement = document.createElement('div');\n      toastElement.innerHTML = toastHtml;\n      const toast = toastElement.firstElementChild;\n      toastContainer.appendChild(toast);\n      \n      // Show the toast using Bootstrap if available\n      if (typeof bootstrap !== 'undefined' && typeof bootstrap.Toast !== 'undefined') {\n        const bsToast = new bootstrap.Toast(toast);\n        bsToast.show();\n      } else {\n        // Manual fallback\n        toast.classList.add('show');\n        setTimeout(() => {\n          toast.classList.remove('show');\n          setTimeout(() => {\n            toastContainer.removeChild(toast);\n          }, 300);\n        }, 5000);\n      }\n    } catch (error) {\n      console.error(\"Error showing message:\", error);\n    }\n  },\n  \n  /**\n   * Show error message\n   * @param {string} title - Error title\n   * @param {string} message - Error message\n   */\n  showError(title, message) {\n    this.showMessage(title, message, 'error');\n  },\n  \n  /**\n   * Extract tables from PDF\n   * @param {ArrayBuffer} arrayBuffer - PDF file content\n   * @param {string} fileName - Name of the file\n   * @returns {Promise<Array>} - Extracted tables\n   */\n  async extractTablesFromPdf(arrayBuffer, fileName) {\n    try {\n      // This would be implemented with PDF.js or a backend API call\n      console.log(`Extracting tables from ${fileName}`);\n      \n      // Simulate API call for table extraction\n      const formData = new FormData();\n      const blob = new Blob([arrayBuffer], { type: 'application/pdf' });\n      formData.append('file', blob, fileName);\n      formData.append('extractTables', true);\n      \n      const response = await fetch('/api/extract-tables', {\n        method: 'POST',\n        body: formData\n      });\n      \n      if (!response.ok) {\n        throw new Error(`Failed to extract tables: ${response.status}`);\n      }\n      \n      const result = await response.json();\n      return result.tables || [];\n    } catch (error) {\n      console.error(`Error extracting tables from PDF ${fileName}:`, error);\n      return [];\n    }\n  },\n  \n  /**\n   * Detect document type (scan, text, mixed)\n   * @param {ArrayBuffer} arrayBuffer - PDF file content\n   * @param {string} fileName - Name of the file\n   * @returns {Promise<string>} - Document type ('scan', 'text', 'mixed')\n   */\n  async detectDocumentType(arrayBuffer, fileName) {\n    try {\n      // This would be implemented with PDF.js or a backend API call\n      console.log(`Detecting document type for ${fileName}`);\n      \n      // Simulate API call for document type detection\n      const formData = new FormData();\n      const blob = new Blob([arrayBuffer], { type: 'application/pdf' });\n      formData.append('file', blob, fileName);\n      \n      const response = await fetch('/api/detect-document-type', {\n        method: 'POST',\n        body: formData\n      });\n      \n      if (!response.ok) {\n        throw new Error(`Failed to detect document type: ${response.status}`);\n      }\n      \n      const result = await response.json();\n      return result.documentType || 'text';\n    } catch (error) {\n      console.error(`Error detecting document type for ${fileName}:`, error);\n      return 'text'; // Default to text\n    }\n  },\n  \n  /**\n   * Extract text using OCR for scanned documents\n   * @param {ArrayBuffer} arrayBuffer - PDF file content\n   * @param {string} fileName - Name of the file\n   * @returns {Promise<Object>} - OCR results\n   */\n  async extractTextWithOcr(arrayBuffer, fileName) {\n    try {\n      console.log(`Extracting text with OCR from ${fileName}`);\n      \n      // Simulate API call for OCR processing\n      const formData = new FormData();\n      const blob = new Blob([arrayBuffer], { type: 'application/pdf' });\n      formData.append('file', blob, fileName);\n      formData.append('useOcr', true);\n      \n      const response = await fetch('/api/ocr-pdf', {\n        method: 'POST',\n        body: formData\n      });\n      \n      if (!response.ok) {\n        throw new Error(`OCR processing failed: ${response.status}`);\n      }\n      \n      const result = await response.json();\n      \n      return {\n        success: true,\n        data: {\n          title: result.metadata?.title || fileName,\n          authors: result.metadata?.author || \"Unknown Author\",\n          pages: result.pageCount || 0,\n          text: result.fullText || \"\",\n          byPage: result.pages || []\n        },\n        tables: [],\n        ocrApplied: true\n      };\n    } catch (error) {\n      console.error(`Error in OCR processing for ${fileName}:`, error);\n      return {\n        success: false,\n        error: `OCR processing failed: ${error.message}`,\n        ocrApplied: true\n      };\n    }\n  },\n  \n  /**\n   * Process a PDF file and return results\n   * @param {File|Blob} file - PDF file to process\n   * @param {Object} options - Processing options\n   * @returns {Promise<Object>} - Processing results\n   */\n  async processPdf(file, options = {}) {\n    // Merge options with defaults\n    const mergedOptions = {\n      ...this.config,\n      ...options\n    };\n    \n    try {\n      if (this.isProcessing) {\n        return {\n          success: false,\n          error: \"Processing already in progress\"\n        };\n      }\n      \n      this.isProcessing = true;\n      this.currentFile = file;\n      \n      // Update state\n      if (stateManager && typeof stateManager.setState === 'function') {\n        stateManager.setState('pdf.processing', true);\n        stateManager.setState('pdf.currentFile', file.name);\n      }\n      \n      // Emit processing started event\n      eventRegistry.emit('pdf.processing.started', {\n        file: file.name,\n        size: file.size,\n        options: mergedOptions,\n        timestamp: new Date().toISOString()\n      });\n      \n      // Read file as ArrayBuffer\n      const arrayBuffer = await this.readFileAsArrayBuffer(file);\n      \n      // Determine processing mode based on file size\n      this.determineProcessingMode(file);\n      \n      // Detect document type (scan, text, mixed)\n      const documentType = await this.detectDocumentType(arrayBuffer, file.name);\n      \n      // Choose processing method based on document type\n      let result;\n      if (documentType === 'scan' && mergedOptions.allowOcr) {\n        // Use OCR for scanned documents\n        result = await this.extractTextWithOcr(arrayBuffer, file.name);\n      } else if (this.processingMode === 'memory-efficient') {\n        // Use memory-efficient processing for large files\n        result = await this.memoryEfficientProcessing(arrayBuffer, file.name);\n      } else {\n        // Use standard processing for normal files\n        result = await this.standardProcessing(arrayBuffer, file.name);\n      }\n      \n      // Extract tables if needed and not already included\n      if (mergedOptions.extractTables && result.success && (!result.tables || result.tables.length === 0)) {\n        const tables = await this.extractTablesFromPdf(arrayBuffer, file.name);\n        result.tables = tables;\n      }\n      \n      // Add document type to result\n      result.documentType = documentType;\n      \n      // Emit processing completed event\n      eventRegistry.emit('pdf.processing.completed', {\n        file: file.name,\n        success: result.success,\n        documentType,\n        tablesExtracted: result.tables?.length || 0,\n        timestamp: new Date().toISOString()\n      });\n      \n      // Update state\n      if (stateManager && typeof stateManager.setState === 'function') {\n        stateManager.setState('pdf.processing', false);\n        stateManager.setState('pdf.lastProcessed', {\n          fileName: file.name,\n          timestamp: new Date().toISOString(),\n          success: result.success\n        });\n      }\n      \n      // Reset processing state\n      this.isProcessing = false;\n      this.currentFile = null;\n      \n      return result;\n    } catch (error) {\n      console.error(`Error processing PDF ${file.name}:`, error);\n      \n      // Emit processing error event\n      eventRegistry.emit('pdf.processing.error', {\n        file: file.name,\n        error: error.message,\n        timestamp: new Date().toISOString()\n      });\n      \n      // Update state\n      if (stateManager && typeof stateManager.setState === 'function') {\n        stateManager.setState('pdf.processing', false);\n        stateManager.setState('pdf.lastError', {\n          fileName: file.name,\n          error: error.message,\n          timestamp: new Date().toISOString()\n        });\n      }\n      \n      // Reset processing state\n      this.isProcessing = false;\n      this.currentFile = null;\n      \n      return {\n        success: false,\n        error: error.message || \"Unknown error processing PDF\",\n        fileName: file.name\n      };\n    }\n  },\n  \n  /**\n   * Check if a file is a valid PDF\n   * @param {File|Blob} file - File to check\n   * @returns {Promise<boolean>} - Whether the file is a valid PDF\n   */\n  async isValidPdf(file) {\n    try {\n      // Check file type\n      if (file.type !== 'application/pdf' && !file.name.toLowerCase().endsWith('.pdf')) {\n        return false;\n      }\n      \n      // Read the first 1024 bytes to check for PDF signature\n      const chunk = await this.readFileChunk(file, 0, 1024);\n      const signature = new Uint8Array(chunk).slice(0, 5);\n      const decoder = new TextDecoder('ascii');\n      const header = decoder.decode(signature);\n      \n      // Check for PDF signature (%PDF-)\n      return header.startsWith('%PDF-');\n    } catch (error) {\n      console.error(\"Error validating PDF:\", error);\n      return false;\n    }\n  },\n  \n  /**\n   * Read a chunk of a file\n   * @param {File|Blob} file - File to read from\n   * @param {number} start - Start position\n   * @param {number} length - Number of bytes to read\n   * @returns {Promise<ArrayBuffer>} - File chunk\n   */\n  readFileChunk(file, start, length) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = (e) => resolve(e.target.result);\n      reader.onerror = reject;\n      \n      // Read only the specified chunk\n      const chunk = file.slice(start, start + length);\n      reader.readAsArrayBuffer(chunk);\n    });\n  },\n  \n  /**\n   * Export PDF processing results to JSON\n   * @param {Object} result - Processing result to export\n   * @returns {string} - JSON string\n   */\n  exportToJson(result) {\n    try {\n      // Create export object with relevant data\n      const exportData = {\n        fileName: result.fileName,\n        documentType: result.documentType,\n        metadata: result.data.metadata || {},\n        title: result.data.title,\n        authors: result.data.authors,\n        pages: result.data.pages,\n        text: result.data.text,\n        tables: result.tables || [],\n        exportDate: new Date().toISOString()\n      };\n      \n      // Convert to JSON string with formatting\n      return JSON.stringify(exportData, null, 2);\n    } catch (error) {\n      console.error(\"Error exporting to JSON:\", error);\n      throw new Error(`Failed to export to JSON: ${error.message}`);\n    }\n  }\n};\n\n// Export the module\nexport default pdfProcessor;\n// Named exports for each method\nexport const initialize = pdfProcessor.initialize.bind(pdfProcessor);\nexport const log = pdfProcessor.log.bind(pdfProcessor);\nexport const registerEvents = pdfProcessor.registerEvents.bind(pdfProcessor);\nexport const error = pdfProcessor.error.bind(pdfProcessor);\nexport const handleError = pdfProcessor.handleError.bind(pdfProcessor);\nexport const on = pdfProcessor.on.bind(pdfProcessor);\nexport const from = pdfProcessor.from.bind(pdfProcessor);\nexport const filter = pdfProcessor.filter.bind(pdfProcessor);\nexport const endsWith = pdfProcessor.endsWith.bind(pdfProcessor);\nexport const updateSelectedPdfInfo = pdfProcessor.updateSelectedPdfInfo.bind(pdfProcessor);\nexport const registerEvent = pdfProcessor.registerEvent.bind(pdfProcessor);\nexport const getElementById = pdfProcessor.getElementById.bind(pdfProcessor);\nexport const processFiles = pdfProcessor.processFiles.bind(pdfProcessor);\nexport const showError = pdfProcessor.showError.bind(pdfProcessor);\nexport const setState = pdfProcessor.setState.bind(pdfProcessor);\nexport const toISOString = pdfProcessor.toISOString.bind(pdfProcessor);\nexport const getElement = pdfProcessor.getElement.bind(pdfProcessor);\nexport const reduce = pdfProcessor.reduce.bind(pdfProcessor);\nexport const formatBytes = pdfProcessor.formatBytes.bind(pdfProcessor);\nexport const map = pdfProcessor.map.bind(pdfProcessor);\nexport const join = pdfProcessor.join.bind(pdfProcessor);\nexport const warn = pdfProcessor.warn.bind(pdfProcessor);\nexport const Error = pdfProcessor.Error.bind(pdfProcessor);\nexport const showProcessingUI = pdfProcessor.showProcessingUI.bind(pdfProcessor);\nexport const emit = pdfProcessor.emit.bind(pdfProcessor);\nexport const Date = pdfProcessor.Date.bind(pdfProcessor);\nexport const updateProgress = pdfProcessor.updateProgress.bind(pdfProcessor);\nexport const determineProcessingMode = pdfProcessor.determineProcessingMode.bind(pdfProcessor);\nexport const extractTextFromPdf = pdfProcessor.extractTextFromPdf.bind(pdfProcessor);\nexport const push = pdfProcessor.push.bind(pdfProcessor);\nexport const showResultsUI = pdfProcessor.showResultsUI.bind(pdfProcessor);\nexport const showErrorUI = pdfProcessor.showErrorUI.bind(pdfProcessor);\nexport const readFileAsArrayBuffer = pdfProcessor.readFileAsArrayBuffer.bind(pdfProcessor);\nexport const memoryEfficientProcessing = pdfProcessor.memoryEfficientProcessing.bind(pdfProcessor);\nexport const standardProcessing = pdfProcessor.standardProcessing.bind(pdfProcessor);\nexport const Promise = pdfProcessor.Promise.bind(pdfProcessor);\nexport const FileReader = pdfProcessor.FileReader.bind(pdfProcessor);\nexport const resolve = pdfProcessor.resolve.bind(pdfProcessor);\nexport const reject = pdfProcessor.reject.bind(pdfProcessor);\nexport const readAsArrayBuffer = pdfProcessor.readAsArrayBuffer.bind(pdfProcessor);\nexport const FormData = pdfProcessor.FormData.bind(pdfProcessor);\nexport const Blob = pdfProcessor.Blob.bind(pdfProcessor);\nexport const append = pdfProcessor.append.bind(pdfProcessor);\nexport const fetch = pdfProcessor.fetch.bind(pdfProcessor);\nexport const text = pdfProcessor.text.bind(pdfProcessor);\nexport const json = pdfProcessor.json.bind(pdfProcessor);\nexport const processExtractionResults = pdfProcessor.processExtractionResults.bind(pdfProcessor);\nexport const percentage = pdfProcessor.percentage.bind(pdfProcessor);\nexport const setAttribute = pdfProcessor.setAttribute.bind(pdfProcessor);\nexport const add = pdfProcessor.add.bind(pdfProcessor);\nexport const remove = pdfProcessor.remove.bind(pdfProcessor);\nexport const forEach = pdfProcessor.forEach.bind(pdfProcessor);\nexport const indexOf = pdfProcessor.indexOf.bind(pdfProcessor);\nexport const querySelectorAll = pdfProcessor.querySelectorAll.bind(pdfProcessor);\nexport const querySelector = pdfProcessor.querySelector.bind(pdfProcessor);\nexport const parseInt = pdfProcessor.parseInt.bind(pdfProcessor);\nexport const showPdfResultDetails = pdfProcessor.showPdfResultDetails.bind(pdfProcessor);\nexport const copyPdfText = pdfProcessor.copyPdfText.bind(pdfProcessor);\nexport const addEventListener = pdfProcessor.addEventListener.bind(pdfProcessor);\nexport const resetToForm = pdfProcessor.resetToForm.bind(pdfProcessor);\nexport const alert = pdfProcessor.alert.bind(pdfProcessor);\nexport const createElement = pdfProcessor.createElement.bind(pdfProcessor);\nexport const appendChild = pdfProcessor.appendChild.bind(pdfProcessor);\nexport const Modal = pdfProcessor.Modal.bind(pdfProcessor);\nexport const show = pdfProcessor.show.bind(pdfProcessor);\nexport const writeText = pdfProcessor.writeText.bind(pdfProcessor);\nexport const then = pdfProcessor.then.bind(pdfProcessor);\nexport const showMessage = pdfProcessor.showMessage.bind(pdfProcessor);\nexport const copyTextareaFallback = pdfProcessor.copyTextareaFallback.bind(pdfProcessor);\nexport const focus = pdfProcessor.focus.bind(pdfProcessor);\nexport const select = pdfProcessor.select.bind(pdfProcessor);\nexport const execCommand = pdfProcessor.execCommand.bind(pdfProcessor);\nexport const removeChild = pdfProcessor.removeChild.bind(pdfProcessor);\nexport const type = pdfProcessor.type.bind(pdfProcessor);\nexport const showToast = pdfProcessor.showToast.bind(pdfProcessor);\nexport const Toast = pdfProcessor.Toast.bind(pdfProcessor);\nexport const setTimeout = pdfProcessor.setTimeout.bind(pdfProcessor);\nexport const extractTablesFromPdf = pdfProcessor.extractTablesFromPdf.bind(pdfProcessor);\nexport const detectDocumentType = pdfProcessor.detectDocumentType.bind(pdfProcessor);\nexport const extractTextWithOcr = pdfProcessor.extractTextWithOcr.bind(pdfProcessor);\nexport const processPdf = pdfProcessor.processPdf.bind(pdfProcessor);\nexport const isValidPdf = pdfProcessor.isValidPdf.bind(pdfProcessor);\nexport const readFileChunk = pdfProcessor.readFileChunk.bind(pdfProcessor);\nexport const Uint8Array = pdfProcessor.Uint8Array.bind(pdfProcessor);\nexport const slice = pdfProcessor.slice.bind(pdfProcessor);\nexport const TextDecoder = pdfProcessor.TextDecoder.bind(pdfProcessor);\nexport const decode = pdfProcessor.decode.bind(pdfProcessor);\nexport const signature = pdfProcessor.signature.bind(pdfProcessor);\nexport const startsWith = pdfProcessor.startsWith.bind(pdfProcessor);\nexport const exportToJson = pdfProcessor.exportToJson.bind(pdfProcessor);\nexport const stringify = pdfProcessor.stringify.bind(pdfProcessor);\n","source":"/workspace/modules/static/js/modules/features/pdfProcessor.js","title":"pdfProcessor.js","language":"en"},{"content":"/**\n * performanceOptimizer.js\n * Optimizes frontend performance with dynamic resource management\n * Implements memory-efficient handling of large datasets and UI interactions\n */\n\nimport { registerEvents } from '../core/eventManager.js';\nimport { getState, setState } from '../core/stateManager.js';\nimport { showError } from '../core/errorHandler.js';\n\nclass PerformanceOptimizer {\n    constructor() {\n        this.memoryWarningThreshold = 90; // % of memory used before warning\n        this.idleCallbacks = new Map();\n        this.pendingTasks = new Set();\n        this.frameRateSamples = [];\n        this.perfConfig = {\n            enableLazyLoading: true,\n            enableVirtualization: true,\n            enableIdleProcessing: true,\n            maxItemsPerPage: 100,\n            monitorPerformance: true,\n            automaticCleanup: true\n        };\n        this.initialize();\n    }\n\n    initialize() {\n        // Load saved configuration\n        this.loadConfig();\n        \n        // Setup performance monitoring\n        if (this.perfConfig.monitorPerformance) {\n            this.startPerformanceMonitoring();\n        }\n        \n        // Setup cleanup cycle\n        if (this.perfConfig.automaticCleanup) {\n            this.setupAutomaticCleanup();\n        }\n        \n        // Add resize handler for adaptive optimizations\n        window.addEventListener('resize', this.debounce(() => {\n            this.adaptToViewport();\n        }, 200));\n        \n        // Listen for visibility change to pause/resume intensive operations\n        document.addEventListener('visibilitychange', () => {\n            if (document.hidden) {\n                this.pauseNonEssentialOperations();\n            } else {\n                this.resumeOperations();\n            }\n        });\n    }\n\n    loadConfig() {\n        const savedConfig = localStorage.getItem('performanceConfig');\n        if (savedConfig) {\n            try {\n                const parsedConfig = JSON.parse(savedConfig);\n                this.perfConfig = { ...this.perfConfig, ...parsedConfig };\n            } catch (e) {\n                console.error('Failed to parse performance config:', e);\n            }\n        }\n    }\n\n    saveConfig() {\n        try {\n            localStorage.setItem('performanceConfig', JSON.stringify(this.perfConfig));\n        } catch (e) {\n            console.error('Failed to save performance config:', e);\n        }\n    }\n\n    startPerformanceMonitoring() {\n        // Setup FPS monitoring\n        this.fpsMonitorId = this.startFpsMonitoring();\n        \n        // Check memory usage periodically\n        this.memoryCheckIntervalId = setInterval(() => {\n            this.checkMemoryUsage();\n        }, 30000); // Check every 30 seconds\n    }\n\n    stopPerformanceMonitoring() {\n        if (this.fpsMonitorId) {\n            cancelAnimationFrame(this.fpsMonitorId);\n            this.fpsMonitorId = null;\n        }\n        \n        if (this.memoryCheckIntervalId) {\n            clearInterval(this.memoryCheckIntervalId);\n            this.memoryCheckIntervalId = null;\n        }\n    }\n\n    startFpsMonitoring() {\n        let lastTime = performance.now();\n        let frames = 0;\n        \n        const loop = (time) => {\n            // Calculate FPS\n            frames++;\n            \n            if (time - lastTime >= 1000) {\n                const fps = Math.round((frames * 1000) / (time - lastTime));\n                \n                // Store FPS sample\n                this.frameRateSamples.push(fps);\n                if (this.frameRateSamples.length > 10) {\n                    this.frameRateSamples.shift();\n                }\n                \n                // Check if FPS is low\n                if (fps < 30) {\n                    this.handleLowFrameRate(fps);\n                }\n                \n                frames = 0;\n                lastTime = time;\n            }\n            \n            this.fpsMonitorId = requestAnimationFrame(loop);\n        };\n        \n        return requestAnimationFrame(loop);\n    }\n\n    checkMemoryUsage() {\n        // Memory API only available in Chrome\n        if (!performance.memory) return;\n        \n        const memoryUsed = performance.memory.usedJSHeapSize;\n        const memoryLimit = performance.memory.jsHeapSizeLimit;\n        const percentUsed = (memoryUsed / memoryLimit) * 100;\n        \n        // Check if memory usage is high\n        if (percentUsed > this.memoryWarningThreshold) {\n            this.handleHighMemoryUsage(percentUsed);\n        }\n    }\n\n    handleLowFrameRate(fps) {\n        console.warn(`Low frame rate detected: ${fps} FPS`);\n        \n        // Check if we need to take action\n        if (this.frameRateSamples.length >= 3) {\n            const avgFps = this.frameRateSamples.reduce((sum, val) => sum + val, 0) / this.frameRateSamples.length;\n            \n            if (avgFps < 25) {\n                // Performance is consistently poor, take action\n                this.applyPerformanceOptimizations();\n            }\n        }\n    }\n\n    handleHighMemoryUsage(percentUsed) {\n        console.warn(`High memory usage detected: ${percentUsed.toFixed(1)}%`);\n        \n        // Force garbage collection if available (only works in some debug modes)\n        if (window.gc) {\n            window.gc();\n        }\n        \n        // Apply memory optimizations\n        this.cleanupUnusedResources();\n    }\n\n    applyPerformanceOptimizations() {\n        // Check if already optimized\n        if (getState('performanceMode') === 'high') return;\n        \n        // Set high performance mode\n        setState('performanceMode', 'high');\n        \n        // Apply optimizations\n        this.perfConfig.maxItemsPerPage = 50; // Reduce items per page\n        this.scheduleIdleTask('clearImageCache', () => this.clearImageCache());\n        \n        // Update config settings\n        this.saveConfig();\n        \n        console.log('Applied performance optimizations due to low frame rate');\n    }\n\n    cleanupUnusedResources() {\n        // Clean up large arrays in state\n        const state = getState();\n        let cleanedUp = false;\n        \n        // Look for large arrays in state that aren't currently visible\n        for (const key in state) {\n            if (Array.isArray(state[key]) && state[key].length > 100) {\n                const containerVisible = this.isContainerVisible(key);\n                \n                if (!containerVisible) {\n                    // Replace with empty array or truncated version\n                    const newArray = state[key].slice(0, 20); // Keep first 20 items\n                    setState(key, newArray);\n                    cleanedUp = true;\n                    console.log(`Cleaned up large array: ${key}`);\n                }\n            }\n        }\n        \n        // Clear any cached data not needed\n        this.clearImageCache();\n        \n        // Force update state with cleaned data\n        if (cleanedUp) {\n            console.log('Cleaned up unused resources');\n        }\n    }\n\n    clearImageCache() {\n        // Clear any blob URLs that might be stored\n        const urls = getState('cachedBlobUrls') || [];\n        urls.forEach(url => {\n            if (url.startsWith('blob:')) {\n                URL.revokeObjectURL(url);\n            }\n        });\n        \n        setState('cachedBlobUrls', []);\n        console.log('Image cache cleared');\n    }\n\n    isContainerVisible(stateKey) {\n        // Map state keys to possible container IDs\n        const containerMap = {\n            'searchResults': ['search-results-container', 'academic-results-container'],\n            'pdfResults': ['pdf-result-container', 'pdf-preview-container'],\n            'scraperResults': ['scraper-results-container'],\n            'fileProcessingResults': ['processing-results-container']\n        };\n        \n        const possibleContainers = containerMap[stateKey] || [];\n        \n        // Check if any container is visible\n        return possibleContainers.some(id => {\n            const element = document.getElementById(id);\n            return element && this.isElementVisible(element);\n        });\n    }\n\n    isElementVisible(element) {\n        if (!element) return false;\n        \n        const rect = element.getBoundingClientRect();\n        return (\n            rect.top >= 0 &&\n            rect.left >= 0 &&\n            rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n            rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n        );\n    }\n\n    pauseNonEssentialOperations() {\n        // Cancel pending idle callbacks\n        this.idleCallbacks.forEach((id, task) => {\n            cancelIdleCallback(id);\n            this.pendingTasks.add(task);\n        });\n        \n        // Clear map\n        this.idleCallbacks.clear();\n        \n        // Stop performance monitoring\n        this.stopPerformanceMonitoring();\n    }\n\n    resumeOperations() {\n        // Restart pending tasks\n        this.pendingTasks.forEach(task => {\n            this.scheduleIdleTask(task, this.idleCallbacks.get(task));\n        });\n        \n        // Clear pending tasks\n        this.pendingTasks.clear();\n        \n        // Restart performance monitoring\n        if (this.perfConfig.monitorPerformance) {\n            this.startPerformanceMonitoring();\n        }\n    }\n\n    adaptToViewport() {\n        // Get viewport dimensions\n        const width = window.innerWidth;\n        const height = window.innerHeight;\n        \n        // Adjust rendering based on screen size\n        if (width < 768) {\n            // Mobile view\n            this.perfConfig.maxItemsPerPage = 20;\n            this.perfConfig.enableVirtualization = true;\n        } else if (width < 1200) {\n            // Tablet view\n            this.perfConfig.maxItemsPerPage = 50;\n        } else {\n            // Desktop view\n            this.perfConfig.maxItemsPerPage = 100;\n        }\n        \n        // Update state\n        setState('viewport', { width, height });\n        \n        // Save config\n        this.saveConfig();\n    }\n\n    setupAutomaticCleanup() {\n        // Automatic garbage collection attempts on page idle\n        this.scheduleIdleTask('periodicCleanup', () => {\n            this.cleanupUnusedResources();\n            \n            // Reschedule for the future\n            setTimeout(() => {\n                this.setupAutomaticCleanup();\n            }, 60000); // Run every 1 minute when idle\n        });\n    }\n\n    // Virtualization for large lists\n    virtualizeList(items, containerSelector, itemRenderer, options = {}) {\n        const defaults = {\n            itemHeight: 40,\n            overscan: 5,\n            onVisibilityChange: null\n        };\n        \n        const config = { ...defaults, ...options };\n        const container = document.querySelector(containerSelector);\n        \n        if (!container || !items || !items.length) return;\n        \n        // Get container dimensions\n        const containerHeight = container.clientHeight;\n        const visibleItems = Math.ceil(containerHeight / config.itemHeight) + config.overscan;\n        \n        // Get scroll position\n        const scrollTop = container.scrollTop;\n        const startIndex = Math.floor(scrollTop / config.itemHeight);\n        const endIndex = Math.min(startIndex + visibleItems, items.length);\n        \n        // Generate only visible items\n        const visibleData = items.slice(startIndex, endIndex);\n        \n        // Calculate spacer heights\n        const topSpacerHeight = startIndex * config.itemHeight;\n        const bottomSpacerHeight = (items.length - endIndex) * config.itemHeight;\n        \n        // Create wrapper HTML\n        let html = `\n            <div class=\"virtualized-list\" style=\"position: relative; height: ${items.length * config.itemHeight}px;\">\n                <div class=\"top-spacer\" style=\"height: ${topSpacerHeight}px;\"></div>\n                <div class=\"visible-items\">\n        `;\n        \n        // Add visible items\n        visibleData.forEach((item, index) => {\n            const actualIndex = startIndex + index;\n            html += itemRenderer(item, actualIndex);\n        });\n        \n        html += `\n                </div>\n                <div class=\"bottom-spacer\" style=\"height: ${bottomSpacerHeight}px;\"></div>\n            </div>\n        `;\n        \n        // Update container\n        container.innerHTML = html;\n        \n        // Add scroll event listener\n        container.addEventListener('scroll', this.debounce(() => {\n            this.virtualizeList(items, containerSelector, itemRenderer, config);\n        }, 50));\n        \n        // Call visibility change callback if provided\n        if (config.onVisibilityChange) {\n            config.onVisibilityChange(startIndex, endIndex);\n        }\n    }\n\n    // Utility: Lazy loading for images\n    setupLazyLoading(selector = 'img[data-src]') {\n        if (!this.perfConfig.enableLazyLoading) return;\n        \n        const images = document.querySelectorAll(selector);\n        \n        if (!('IntersectionObserver' in window)) {\n            // Fallback for browsers without IntersectionObserver\n            images.forEach(img => {\n                img.src = img.dataset.src;\n            });\n            return;\n        }\n        \n        const imageObserver = new IntersectionObserver((entries) => {\n            entries.forEach(entry => {\n                if (entry.isIntersecting) {\n                    const img = entry.target;\n                    img.src = img.dataset.src;\n                    imageObserver.unobserve(img);\n                }\n            });\n        });\n        \n        images.forEach(img => {\n            imageObserver.observe(img);\n        });\n    }\n\n    // Utility: Schedule a task to run during idle time\n    scheduleIdleTask(key, callback) {\n        if (!this.perfConfig.enableIdleProcessing || !('requestIdleCallback' in window)) {\n            // Fallback: Run immediately if idle processing not available\n            setTimeout(callback, 1);\n            return;\n        }\n        \n        // Cancel existing callback with same key\n        if (this.idleCallbacks.has(key)) {\n            cancelIdleCallback(this.idleCallbacks.get(key));\n        }\n        \n        // Schedule new callback\n        const id = requestIdleCallback((deadline) => {\n            if (deadline.timeRemaining() > 0 || deadline.didTimeout) {\n                callback();\n            } else {\n                // Not enough time, reschedule\n                this.scheduleIdleTask(key, callback);\n            }\n        }, { timeout: 2000 }); // 2 second timeout\n        \n        this.idleCallbacks.set(key, id);\n    }\n\n    // Utility: Debounce function\n    debounce(func, delay) {\n        let timeout;\n        return function(...args) {\n            clearTimeout(timeout);\n            timeout = setTimeout(() => func.apply(this, args), delay);\n        };\n    }\n\n    // Utility: Throttle function\n    throttle(func, limit) {\n        let inThrottle;\n        return function(...args) {\n            if (!inThrottle) {\n                func.apply(this, args);\n                inThrottle = true;\n                setTimeout(() => inThrottle = false, limit);\n            }\n        };\n    }\n\n    // Public API: Get pagination parameters\n    getPaginationParams(totalItems, currentPage = 1) {\n        const itemsPerPage = this.perfConfig.maxItemsPerPage;\n        const totalPages = Math.ceil(totalItems / itemsPerPage);\n        const startIndex = (currentPage - 1) * itemsPerPage;\n        const endIndex = Math.min(startIndex + itemsPerPage, totalItems);\n        \n        return {\n            itemsPerPage,\n            totalPages,\n            currentPage,\n            startIndex,\n            endIndex,\n            hasNextPage: currentPage < totalPages,\n            hasPreviousPage: currentPage > 1\n        };\n    }\n\n    // Public API: Optimize large JSON data\n    optimizeJsonData(data) {\n        // If data is already a string, parse it\n        if (typeof data === 'string') {\n            try {\n                data = JSON.parse(data);\n            } catch (e) {\n                return data; // Return original if parsing fails\n            }\n        }\n        \n        // Function to recursively process objects\n        const processObject = (obj, depth = 0) => {\n            // Don't process too deep\n            if (depth > 10) return obj;\n            \n            // Handle arrays\n            if (Array.isArray(obj)) {\n                // Limit array size if very large\n                if (obj.length > 1000) {\n                    return obj.slice(0, 1000); // Truncate very large arrays\n                }\n                \n                // Process array items\n                return obj.map(item => processObject(item, depth + 1));\n            }\n            \n            // Handle objects\n            if (obj && typeof obj === 'object') {\n                const result = {};\n                \n                // Process each property\n                for (const key in obj) {\n                    // Skip functions\n                    if (typeof obj[key] === 'function') continue;\n                    \n                    // Process nested objects/arrays\n                    result[key] = processObject(obj[key], depth + 1);\n                }\n                \n                return result;\n            }\n            \n            // Return primitives as is\n            return obj;\n        };\n        \n        return processObject(data);\n    }\n\n    // Public API: Update configuration\n    updateConfig(newConfig) {\n        this.perfConfig = { ...this.perfConfig, ...newConfig };\n        this.saveConfig();\n        \n        // Apply changes\n        if (newConfig.monitorPerformance !== undefined) {\n            if (newConfig.monitorPerformance) {\n                this.startPerformanceMonitoring();\n            } else {\n                this.stopPerformanceMonitoring();\n            }\n        }\n    }\n}\n\nconst performanceOptimizer = new PerformanceOptimizer();\n\nexport default performanceOptimizer;\n\n// Export default module\nexport default containerMap;\n","source":"/workspace/modules/static/js/modules/features/performanceOptimizer.js","title":"performanceOptimizer.js","language":"en"},{"content":"/**\n * Playlist Downloader Module - Optimized Blueprint Implementation\n * \n * Advanced YouTube playlist downloading module with transcript extraction and comprehensive\n * task management. Fully optimized with centralized configuration and enhanced error handling.\n * \n * Features:\n * - Configuration-driven architecture using centralized endpoints\n * - Enhanced error handling with multiple notification systems\n * - Improved SocketIO integration using TASK_EVENTS\n * - Backend connectivity testing with health checks\n * - Consolidated code with removed redundancies\n * \n * @module features/playlistDownloader\n * @version 3.1.0 - Optimized with Config Integration\n */\n\n// Import dependencies from centralized config\nimport { API_ENDPOINTS, BLUEPRINT_ROUTES } from '../config/endpoints.js';\nimport { CONSTANTS, API_CONFIG, SOCKET_CONFIG } from '../config/constants.js';\nimport { SOCKET_EVENTS, TASK_EVENTS } from '../config/socketEvents.js';\n\n// Import DOM utilities from domUtils.js\nimport { getElement, getElements, getUIElements, toggleElementVisibility } from '../utils/domUtils.js';\n\n// Configuration shorthand\nconst PLAYLIST_CONFIG = {\n  endpoints: API_ENDPOINTS.PLAYLIST,\n  blueprint: BLUEPRINT_ROUTES.playlist_downloader,\n  constants: CONSTANTS.PLAYLIST_DOWNLOADER || {},\n  api: API_CONFIG,\n  socket: SOCKET_CONFIG\n};\n\n// Import core modules - use dynamic imports with fallbacks for error resilience \nlet errorHandler, uiRegistry, eventRegistry, stateManager, historyManager;\n\n// Define progress stages to match server-side stages\nconst PROGRESS_STAGES = {\n  INIT: { name: 'initialization', min: 0, max: 4 },\n  VIDEO_IDS: { name: 'retrieving_videos', min: 4, max: 20 },\n  TITLES: { name: 'retrieving_titles', min: 20, max: 30 },\n  DOWNLOAD: { name: 'downloading_transcripts', min: 30, max: 90 },\n  FINALIZE: { name: 'finalizing', min: 90, max: 100 }\n};\n\n// Constants\nconst UI_UPDATE_DEBOUNCE_MS = 100; // Debounce time for UI updates\nconst MAX_PROGRESS_RATES = 10; // Number of progress rates to keep for averaging\nconst API_TIMEOUT_MS = 30000; // API request timeout\nconst PROGRESS_POLL_INTERVAL_MS = 2000; // Status polling interval if websocket fails\nconst TASK_COMPLETION_DELAY = 250; // Short delay before showing completion UI\n\n// Module state (private)\nconst state = {\n  initialized: false,\n  processing: false,\n  backendConnected: false,\n  currentTaskId: null,\n  outputFilePath: null,\n  processingStartTime: null,\n  isProcessingCancelled: false,\n  progressUpdateCount: 0,\n  lastProgressTimestamp: null,\n  progressRates: [], // For ETA calculation\n  pendingRequests: {}, // For tracking API requests that may need cancellation\n  socketReconnectAttempts: 0,\n  maxSocketReconnects: 5,\n  apiRetryCount: 3, // Maximum number of API retry attempts\n  apiRetryDelay: 1000, // Base delay for retries in ms\n  statusPollInterval: null,\n  lastReportedProgress: -1, // Track last reported progress to prevent UI flicker\n  progressTracker: null, // Track the progress handler instance\n  lastSavedOutputDir: null, // Last used output directory for persistence\n  uiElements: {}, // Cache for UI elements\n  // Add a completion marker to prevent duplicate completions\n  completionState: {\n    completed: false,\n    completionTime: null,\n    error: false,\n    cancelled: false\n  },\n  // Add taskData to persist across functions\n  taskData: {},\n  // Track UI state\n  uiState: {\n    isResultShown: false,\n    isErrorShown: false,\n    isCancelledShown: false,\n    isFormShown: false\n  },\n  // Add completion monitoring\n  completionMonitoring: {\n    enabled: true,\n    timeoutIds: new Set(),\n    checkIntervalMs: 10000, // Check every 10 seconds\n    maxStuckDurationMs: 120000 // 2 minutes max stuck time\n  },\n  // A Set to track which playlist completion events have been handled\n  completionHandled: new Set(),\n  // Track current stage for progress reporting\n  currentStage: null,\n  stageProgress: 0,\n  // Track for absolute and relative paths to match server-side behavior\n  pathTypes: {\n    isWindowsPath: false,\n    isUnixPath: false,\n    hasSeparators: false\n  }\n};\n\n/**\n * Utility function to load dependencies dynamically with fallbacks\n * @returns {Promise<boolean>} Success state\n */\nasync function loadDependencies() {\n  try {\n    // Import core modules\n    errorHandler = await import('../core/errorHandler.js')\n      .then(m => m.default)\n      .catch(() => {\n        console.warn('Failed to load errorHandler, using fallback');\n        return {\n          registerModule: () => {},\n          reportError: (error, context) => console.error(`Error in ${context?.module || 'unknown'}: ${error.message}`)\n        };\n      });\n\n    uiRegistry = await import('../core/uiRegistry.js')\n      .then(m => m.default)\n      .catch(() => {\n        console.warn('Failed to load uiRegistry, using fallback');\n        return {\n          registerElements: () => {},\n          getElement: (id) => document.getElementById(id)\n        };\n      });\n\n    eventRegistry = await import('../core/eventRegistry.js')\n      .then(m => m.default)\n      .catch(() => {\n        console.warn('Failed to load eventRegistry, using fallback');\n        return {\n          on: () => {},\n          emit: () => {},\n          off: () => {}\n        };\n      });\n\n    stateManager = await import('../core/stateManager.js')\n      .then(m => m.default)\n      .catch(() => {\n        console.warn('Failed to load stateManager, using fallback');\n        return {\n          setProcessingActive: () => {},\n          setCurrentTaskId: () => {},\n          getState: () => ({})\n        };\n      });\n\n    // Import history manager\n    historyManager = await import('../features/historyManager.js')\n      .then(m => m.default)\n      .catch(() => {\n        console.warn('Failed to load historyManager, using fallback');\n        return {\n          addTaskToHistory: () => {},\n          addFileToRecent: () => {},\n          getFileNameFromPath: (path) => {\n            if (!path) return 'Unknown';\n            const parts = path.split(/[\\/\\\\]/);\n            return parts[parts.length - 1] || 'Unknown';\n          }\n        };\n      });\n\n    // Import utility modules with fallbacks\n    const utils = await import('../utils/utils.js')\n      .then(m => m.default)\n      .catch(() => {\n        console.warn('Failed to load utils module, using fallback');\n        return {\n          formatBytes: (bytes) => {\n            if (bytes === 0) return '0 Bytes';\n            const k = 1024;\n            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n            const i = Math.floor(Math.log(bytes) / Math.log(k));\n            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n          },\n          formatDuration: (seconds) => {\n            if (!seconds) return '0s';\n            const h = Math.floor(seconds / 3600);\n            const m = Math.floor((seconds % 3600) / 60);\n            const s = Math.floor(seconds % 60);\n            return `${h > 0 ? h + 'h ' : ''}${m > 0 ? m + 'm ' : ''}${s}s`;\n          },\n          debounce: (func, wait) => {\n            let timeout;\n            return function(...args) {\n              const context = this;\n              clearTimeout(timeout);\n              timeout = setTimeout(() => func.apply(context, args), wait);\n            };\n          }\n        };\n      });\n      \n    // Attach utils to window for compatibility\n    window.utils = utils;\n\n    const ui = await import('../utils/ui.js')\n      .then(m => m.default)\n      .catch(() => {\n        console.warn('Failed to load UI module, using fallback');\n        return {\n          showToast: (title, message, type = 'info') => {\n            console.log(`TOAST [${type}]: ${title} - ${message}`);\n            try {\n              const toastContainer = document.getElementById('toast-container') || \n                (() => {\n                  const container = document.createElement('div');\n                  container.id = 'toast-container';\n                  container.className = 'toast-container position-fixed bottom-0 end-0 p-3';\n                  document.body.appendChild(container);\n                  return container;\n                })();\n              \n              const toast = document.createElement('div');\n              toast.className = `toast show bg-${type === 'error' ? 'danger' : type}`;\n              toast.setAttribute('role', 'alert');\n              toast.innerHTML = `\n                <div class=\"toast-header\">\n                  <strong class=\"me-auto\">${title}</strong>\n                  <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"toast\"></button>\n                </div>\n                <div class=\"toast-body text-white\">\n                  ${message}\n                </div>\n              `;\n              \n              toastContainer.appendChild(toast);\n              setTimeout(() => toast.remove(), 5000);\n            } catch (e) {\n              console.error('Failed to create fallback toast:', e);\n            }\n          },\n          toggleElementVisibility,\n          transitionBetweenElements: (fromElement, toElement) => {\n            if (!fromElement || !toElement) return;\n            if (fromElement) toggleElementVisibility(fromElement, false);\n            if (toElement) toggleElementVisibility(toElement, true);\n          },\n          updateProgressBarElement: (progressBar, progress) => {\n            if (!progressBar) return;\n            const percent = Math.round(progress);\n            progressBar.style.width = `${percent}%`;\n            progressBar.setAttribute('aria-valuenow', percent);\n            progressBar.textContent = `${percent}%`;\n          },\n          updateProgressStatus: (statusElement, message) => {\n            if (!statusElement) return;\n            statusElement.textContent = message;\n          }\n        };\n      });\n\n    // Attach UI to window for compatibility\n    window.ui = ui;\n\n    const fileHandler = await import('../utils/fileHandler.js')\n      .then(m => m.default)\n      .catch(() => {\n        console.warn('Failed to load fileHandler module, using fallback');\n        return {\n          browseForDirectory: () => Promise.reject(new Error('File browsing not available')),\n          openFile: () => Promise.reject(new Error('File opening not available')),\n          openContainingFolder: () => Promise.reject(new Error('Folder opening not available'))\n        };\n      });\n\n    // Attach fileHandler to window for compatibility\n    window.fileHandler = fileHandler;\n\n    // Import progressHandler conditionally\n    const progressHandler = await import('../utils/progressHandler.js')\n      .then(m => {\n        // If the module exports multiple functions, extract them\n        const handler = m.default || {};\n        const setupTaskProgress = m.setupTaskProgress || handler.setupTaskProgress;\n        const trackProgress = m.trackProgress || handler.trackProgress;\n        const updateProgressUI = m.updateProgressUI || handler.updateProgressUI;\n        const cancelTracking = m.cancelTracking || handler.cancelTracking;\n        const createProgressUI = m.createProgressUI || handler.createProgressUI;\n        \n        return {\n          ...handler,\n          setupTaskProgress,\n          trackProgress,\n          updateProgressUI,\n          cancelTracking,\n          createProgressUI\n        };\n      })\n      .catch(() => {\n        console.warn('Failed to load progressHandler module, using fallback');\n        return {\n          setupTaskProgress: () => ({}),\n          trackProgress: () => ({}),\n          updateProgressUI: () => {},\n          cancelTracking: () => {},\n          createProgressUI: () => {}\n        };\n      });\n\n    // Attach progressHandler to window for compatibility\n    window.progressHandler = progressHandler;\n\n    return true;\n  } catch (error) {\n    console.error('Error loading dependencies:', error);\n    return false;\n  }\n}\n\n/**\n * Playlist Downloader module\n */\nconst playlistDownloader = {\n  /**\n   * Initialize file processing module\n   * @returns {Promise<boolean>} - Success state\n   */\n  async initialize() {\n    try {\n      console.log('Initializing playlist downloader module...');\n      \n      // Skip if already initialized\n      if (state.initialized) {\n        console.log('Playlist downloader module already initialized');\n        return true;\n      }\n      \n      // Load dependencies first\n      await loadDependencies();\n      \n      // Test backend connectivity and configuration\n      await this.testBackendConnectivity();\n      \n      // Register error handler for the module\n      if (errorHandler && typeof errorHandler.registerModule === 'function') {\n        errorHandler.registerModule('playlistDownloader', {\n          onError: (error, context) => this.handleModuleError(error, context)\n        });\n      }\n      \n      // Safety check - if DOM not ready, defer initialization\n      if (document.readyState === 'loading') {\n        console.log('DOM not ready, deferring initialization');\n        document.addEventListener('DOMContentLoaded', () => {\n          setTimeout(() => this.initializeAfterDOMReady(), 0);\n        });\n        return false;\n      } else {\n        setTimeout(() => this.initializeAfterDOMReady(), 0);\n      }\n      \n      // Register with module system\n      this.registerWithModuleSystem();\n      \n      // Start progress monitoring\n      this.startProgressMonitoring();\n      \n      // Register UI elements with uiRegistry if available\n      this.registerUIElements();\n      \n      // Mark as initialized\n      state.initialized = true;\n      console.log('✅ Playlist Downloader initialized successfully with config integration');\n      \n      // Show success notification\n      this.showNotification('Playlist Downloader module loaded successfully', 'success');\n      \n      return true;\n    } catch (error) {\n      console.error('❌ Playlist Downloader initialization failed:', error);\n      this.showNotification('Playlist Downloader initialization failed - some features may be limited', 'warning');\n      \n      // Report to error handler\n      if (window.NeuroGen?.errorHandler) {\n        window.NeuroGen.errorHandler.logError({\n          module: 'playlistDownloader',\n          action: 'initialization',\n          error: error.message,\n          severity: 'error'\n        });\n      }\n      \n      // Allow module to work with limited functionality\n      state.initialized = true;\n      return false;\n    }\n  },\n  \n  /**\n   * Handle module errors\n   * @param {Error} error - The error that occurred\n   * @param {Object} context - Error context information\n   */\n  handleModuleError(error, context) {\n    console.error(`Module error in playlistDownloader (${context.method || 'unknown'}):`, error);\n    \n    // If we're processing, show error in UI\n    if (state.processing) {\n      this.showPlaylistError(`An error occurred: ${error.message}`);\n    } else {\n      // Just show toast notification if not actively processing\n      this.showToast('Error', error.message, 'error');\n    }\n  },\n\n  /**\n   * Register UI elements with uiRegistry\n   */\n  registerUIElements() {\n    if (uiRegistry && typeof uiRegistry.registerElements === 'function') {\n      uiRegistry.registerElements('playlistDownloader', {\n        form: 'playlist-form',\n        formContainer: 'playlist-form-container',\n        progressContainer: 'playlist-progress-container',\n        resultsContainer: 'playlist-results-container',\n        errorContainer: 'playlist-error-container',\n        progressBar: 'playlist-progress-bar',\n        progressStatus: 'playlist-progress-status',\n        progressStats: 'playlist-progress-stats',\n        submitButton: 'playlist-submit-btn',\n        cancelButton: 'playlist-cancel-btn',\n        newTaskButton: 'playlist-new-task-btn'\n      });\n    }\n  },\n\n  /**\n   * Register with global module system if available\n   */\n  registerWithModuleSystem() {\n    if (window.moduleRegistry?.register) {\n      window.moduleRegistry.register('playlistDownloader', {\n        name: 'playlistDownloader',\n        version: '1.0.0',\n        initialize: this.initialize.bind(this),\n        cleanup: this.cleanup.bind(this),\n        handlePlaylistSubmit: this.handlePlaylistSubmit.bind(this),\n        handlePlaylistCompletion: this.handlePlaylistCompletion.bind(this),\n        cancelDownload: this.cancelDownload.bind(this),\n        isInitialized: () => state.initialized\n      });\n      \n      console.log('Registered with module registry');\n    }\n  },\n\n  /**\n   * Second phase of initialization after DOM is ready\n   * @returns {Promise<boolean>} - Success state\n   */\n  async initializeAfterDOMReady() {\n    try {\n      console.log('Completing playlist downloader initialization after DOM ready');\n      \n      // Initialize progressHandler if available and not already initialized\n      if (window.progressHandler && typeof window.progressHandler.initialize === 'function' && \n          !window.progressHandler.initialized) {\n        await window.progressHandler.initialize();\n        console.log('Progress handler initialized');\n      }\n      \n      // Register event handlers\n      this.registerEventHandlers();\n      \n      // Set up direct event handlers for UI elements\n      this.setupDirectEventHandlers();\n      \n      // Initialize input/output relationship for better UX\n      this.initializeInputOutputRelationship();\n      \n      // Check for ongoing tasks from previous sessions\n      this.checkForOngoingTasks();\n      \n      // Create progress UI if needed but not present\n      this.ensureProgressUIElements();\n      \n      console.log('Playlist downloader module fully initialized');\n      return true;\n    } catch (error) {\n      console.error('Error in post-DOM initialization:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'initializeAfterDOMReady',\n          context: 'DOM initialization'\n        });\n      }\n      return false;\n    }\n  },\n\n  /**\n   * Register event handlers with event registry\n   */\n  registerEventHandlers() {\n    try {\n      if (eventRegistry && typeof eventRegistry.on === 'function') {\n        // Socket.IO event handlers\n        eventRegistry.on('socket.progress_update', (data) => {\n          if (data?.task_id === state.currentTaskId) {\n            this.processStatusUpdate(data);\n          }\n        });\n        \n        eventRegistry.on('socket.playlist_progress', (data) => {\n          if (data?.task_id === state.currentTaskId) {\n            this.processStatusUpdate(data);\n          }\n        });\n        \n        eventRegistry.on('socket.task_completed', (data) => {\n          if (data?.task_id === state.currentTaskId) {\n            this.handlePlaylistCompletion(data);\n          }\n        });\n        \n        eventRegistry.on('socket.playlist_completed', (data) => {\n          if (data?.task_id === state.currentTaskId) {\n            this.handlePlaylistCompletion(data);\n          }\n        });\n        \n        eventRegistry.on('socket.task_error', (data) => {\n          if (data?.task_id === state.currentTaskId) {\n            this.handleTaskError(data);\n          }\n        });\n        \n        eventRegistry.on('socket.playlist_error', (data) => {\n          if (data?.task_id === state.currentTaskId) {\n            this.handleTaskError(data);\n          }\n        });\n        \n        eventRegistry.on('socket.task_cancelled', (data) => {\n          if (data?.task_id === state.currentTaskId) {\n            this.handleTaskCancelled(data);\n          }\n        });\n        \n        eventRegistry.on('socket.playlist_cancelled', (data) => {\n          if (data?.task_id === state.currentTaskId) {\n            this.handleTaskCancelled(data);\n          }\n        });\n        \n        // Socket connection/disconnection events\n        eventRegistry.on('socket.connected', () => {\n          this.handleSocketConnected();\n        });\n        \n        eventRegistry.on('socket.disconnected', () => {\n          this.handleSocketDisconnected();\n        });\n        \n        // App-specific events\n        eventRegistry.on('playlist.processing.resume', (data) => {\n          if (data?.task_id && !state.currentTaskId) {\n            this.resumeTaskProcessing(data.task_id);\n          }\n        });\n        \n        console.log('Event handlers registered with event registry');\n      } else {\n        console.warn('Event registry not available for registering events');\n      }\n    } catch (error) {\n      console.error('Error registering event handlers:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'registerEventHandlers',\n          context: 'event registration'\n        });\n      }\n    }\n  },\n\n  /**\n   * Handle socket connected event\n   */\n  handleSocketConnected() {\n    console.log('Socket connected, checking for ongoing tasks');\n    \n    // Request status update for ongoing task\n    if (state.currentTaskId && state.processing) {\n      if (window.socket && typeof window.socket.emit === 'function') {\n        window.socket.emit(SOCKET_EVENTS.CLIENT_TO_SERVER.REQUEST_TASK_STATUS, { task_id: state.currentTaskId });\n      }\n    }\n    \n    // Reset reconnect attempts\n    state.socketReconnectAttempts = 0;\n  },\n\n  /**\n   * Handle socket disconnected event\n   */\n  handleSocketDisconnected() {\n    console.warn('Socket disconnected');\n    \n    // Start polling if we have an active task\n    if (state.currentTaskId && state.processing) {\n      this.startStatusPolling(state.currentTaskId);\n    }\n  },\n\n  /**\n   * Set up direct event handlers for UI elements\n   */\n  setupDirectEventHandlers() {\n    try {\n      console.log('Setting up direct event handlers');\n      \n      // Form submission handler\n      const form = getElement('playlist-form');\n      if (form) {\n        // Remove any existing handlers to avoid duplicates\n        const newForm = form.cloneNode(true);\n        if (form.parentNode) {\n          form.parentNode.replaceChild(newForm, form);\n        }\n        \n        // Add the submit handler\n        newForm.addEventListener('submit', (e) => {\n          e.preventDefault();\n          this.handlePlaylistSubmit(e);\n        });\n        \n        console.log('Form submission handler registered');\n      } else {\n        console.warn('Playlist form element not found');\n      }\n      \n      // Add URL button handler\n      const addUrlBtn = getElement('add-playlist-btn');\n      if (addUrlBtn) {\n        addUrlBtn.addEventListener('click', this.addPlaylistField.bind(this));\n        console.log('Add URL button handler registered');\n      }\n      \n      // Cancel button handler\n      const cancelBtn = getElement('playlist-cancel-btn');\n      if (cancelBtn) {\n        cancelBtn.addEventListener('click', this.handleCancelButtonClick.bind(this));\n        console.log('Cancel button handler registered');\n      }\n      \n      // New task button handler\n      const newTaskBtn = getElement('playlist-new-task-btn');\n      if (newTaskBtn) {\n        newTaskBtn.addEventListener('click', this.handleNewTaskClick.bind(this));\n        console.log('New task button handler registered');\n      }\n      \n      // Open output file button handler\n      const openBtn = getElement('open-playlist-json');\n      if (openBtn) {\n        openBtn.addEventListener('click', () => {\n          const outputFile = openBtn.getAttribute('data-output-file');\n          if (outputFile) {\n            this.openFileOrFolder(outputFile);\n          }\n        });\n        console.log('Open button handler registered');\n      }\n      \n      // Browse button handler if available\n      const browseBtn = getElement('playlist-browse-btn');\n      if (browseBtn && window.fileHandler && typeof window.fileHandler.browseForDirectory === 'function') {\n        browseBtn.addEventListener('click', () => {\n          this.handleBrowseClick();\n        });\n        console.log('Browse button handler registered');\n      }\n      \n      // Remove URL button delegation handler\n      document.addEventListener('click', (e) => {\n        if (e.target.classList.contains('remove-url') || e.target.closest('.remove-url')) {\n          const button = e.target.classList.contains('remove-url') ? \n                       e.target : e.target.closest('.remove-url');\n          const urlContainer = button.closest('.input-group');\n          if (urlContainer) {\n            urlContainer.remove();\n          }\n        }\n      });\n      \n      console.log('Direct event handlers setup complete');\n    } catch (error) {\n      console.error('Error setting up direct event handlers:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'setupDirectEventHandlers',\n          context: 'event registration'\n        });\n      }\n    }\n  },\n\n  /**\n   * Handle browse button click\n   */\n  async handleBrowseClick() {\n    try {\n      if (!window.fileHandler || typeof window.fileHandler.browseForDirectory !== 'function') {\n        console.warn('File handler not available for browsing');\n        return;\n      }\n      \n      const result = await window.fileHandler.browseForDirectory();\n      if (result && result.path) {\n        const rootDirField = getElement('playlist-root');\n        if (rootDirField) {\n          rootDirField.value = result.path;\n          \n          // Save this for future use\n          state.lastSavedOutputDir = result.path;\n          localStorage.setItem('lastPlaylistOutputDir', result.path);\n          \n          // Determine path type\n          this.analyzePathType(result.path);\n          \n          // Trigger change event to update output suggestion\n          const event = new Event('change', { bubbles: true });\n          rootDirField.dispatchEvent(event);\n        }\n      }\n    } catch (error) {\n      console.error('Error browsing for directory:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'handleBrowseClick',\n          context: 'directory browsing'\n        });\n      }\n      this.showToast('Error', 'Failed to browse for directory', 'error');\n    }\n  },\n\n  /**\n   * Analyze path type to match server-side path resolution\n   * @param {string} path - Path to analyze\n   */\n  analyzePathType(path) {\n    // Reset path types\n    state.pathTypes = {\n      isWindowsPath: false,\n      isUnixPath: false,\n      hasSeparators: false\n    };\n    \n    if (!path) return;\n    \n    // Check for Windows path with drive letter\n    if (/^[A-Za-z]:/.test(path)) {\n      state.pathTypes.isWindowsPath = true;\n    }\n    \n    // Check for Unix absolute path\n    if (path.startsWith('/')) {\n      state.pathTypes.isUnixPath = true;\n    }\n    \n    // Check for path with separators\n    if (path.includes('/') || path.includes('\\\\')) {\n      state.pathTypes.hasSeparators = true;\n    }\n    \n    console.log('Path type analysis:', state.pathTypes);\n  },\n\n  /**\n   * Initialize input/output relationship for auto-suggestion\n   */\n  initializeInputOutputRelationship() {\n    try {\n      const rootDirField = getElement('playlist-root');\n      const outputFileField = getElement('playlist-output');\n      \n      if (!rootDirField || !outputFileField) {\n        console.warn('Root dir or output file fields not found');\n        return;\n      }\n      \n      // Auto-suggest output filename based on input directory\n      const inputHandler = function() {\n        if (this.value.trim() && !outputFileField.value.trim()) {\n          // Extract folder name for output suggestion\n          const dirPath = this.value.trim();\n          const folderName = dirPath.split(/[/\\\\]/).pop();\n          \n          if (folderName) {\n            // Set suggested output name\n            outputFileField.value = `${folderName}_playlists`;\n            \n            // Add visual feedback\n            outputFileField.classList.add('bg-light');\n            setTimeout(() => outputFileField.classList.remove('bg-light'), 1500);\n          }\n        }\n        \n        // Analyze path type when changed\n        playlistDownloader.analyzePathType(this.value.trim());\n      };\n      \n      // Check for last saved directory and populate if available\n      const lastDir = localStorage.getItem('lastPlaylistOutputDir');\n      if (lastDir && !rootDirField.value) {\n        rootDirField.value = lastDir;\n        state.lastSavedOutputDir = lastDir;\n        \n        // Analyze path type\n        this.analyzePathType(lastDir);\n        \n        // Also trigger the change event to populate the output field\n        const event = new Event('change', { bubbles: true });\n        rootDirField.dispatchEvent(event);\n      }\n      \n      // Use debounced input event for more responsive feedback\n      if (window.utils && window.utils.debounce) {\n        rootDirField.addEventListener('input', window.utils.debounce(inputHandler, UI_UPDATE_DEBOUNCE_MS));\n      } else {\n        rootDirField.addEventListener('input', inputHandler);\n      }\n      rootDirField.addEventListener('change', inputHandler);\n      \n      // Also analyze output file path changes\n      if (window.utils && window.utils.debounce) {\n        outputFileField.addEventListener('input', window.utils.debounce((e) => {\n          this.analyzePathType(e.target.value.trim());\n        }, UI_UPDATE_DEBOUNCE_MS));\n      }\n      \n      console.log('Input/output relationship initialized');\n    } catch (error) {\n      console.error('Error initializing input/output relationship:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'initializeInputOutputRelationship',\n          context: 'UI initialization'\n        });\n      }\n    }\n  },\n\n  /**\n   * Check for ongoing tasks from previous sessions\n   */\n  checkForOngoingTasks() {\n    try {\n      const taskId = sessionStorage.getItem('ongoingTaskId');\n      const taskType = sessionStorage.getItem('ongoingTaskType');\n      \n      if (taskId && taskType === 'playlist') {\n        console.log(`Found ongoing playlist task: ${taskId}`);\n        \n        // Set current task ID\n        state.currentTaskId = taskId;\n        state.processing = true;\n        state.outputFilePath = sessionStorage.getItem('outputFile');\n        \n        // Get task start time if available\n        const startTimeStr = sessionStorage.getItem('taskStartTime');\n        if (startTimeStr) {\n          state.processingStartTime = parseInt(startTimeStr, 10);\n        } else {\n          state.processingStartTime = Date.now();\n        }\n        \n        // Show progress UI\n        this.showProgress();\n        \n        // Set up progress tracking using progressHandler\n        const progress = window.progressHandler && typeof window.progressHandler.trackProgress === 'function' ? \n          window.progressHandler.trackProgress(taskId, {\n            elementPrefix: 'playlist',\n            taskType: 'playlist',\n            saveToSessionStorage: true,\n            outputFile: state.outputFilePath\n          }) : null;\n        \n        // Store the progress handler in state\n        state.progressTracker = progress;\n        \n        // Emit event to trigger status polling\n        if (eventRegistry && typeof eventRegistry.emit === 'function') {\n          eventRegistry.emit('playlist.processing.resume', { task_id: taskId });\n        }\n        \n        // Start manual status polling as a fallback\n        this.startStatusPolling(taskId);\n        \n        // Update state manager\n        if (stateManager && typeof stateManager.setProcessingActive === 'function') {\n          stateManager.setProcessingActive(true);\n        }\n        \n        if (stateManager && typeof stateManager.setCurrentTaskId === 'function') {\n          stateManager.setCurrentTaskId(taskId);\n        }\n        \n        // Request initial status update\n        if (window.socket && typeof window.socket.emit === 'function') {\n          window.socket.emit(SOCKET_EVENTS.CLIENT_TO_SERVER.REQUEST_TASK_STATUS, { task_id: taskId });\n        }\n      }\n    } catch (error) {\n      console.error('Error checking for ongoing tasks:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'checkForOngoingTasks',\n          context: 'task resumption'\n        });\n      }\n    }\n  },\n\n  /**\n   * Resume task processing\n   * @param {string} taskId - Task ID to resume\n   */\n  resumeTaskProcessing(taskId) {\n    try {\n      if (!taskId) return;\n      \n      console.log(`Resuming task processing for ${taskId}`);\n      \n      // Set current task ID\n      state.currentTaskId = taskId;\n      state.processing = true;\n      \n      // Show progress UI\n      this.showProgress();\n      \n      // Set up progress tracking\n      this.setupProgressTracking(taskId);\n      \n      // Setup direct socket listeners as fallback\n      this.setupDirectSocketListeners(taskId);\n      \n      // Start status polling as another fallback\n      this.startStatusPolling(taskId);\n      \n      // Request initial status update\n      if (window.socket && typeof window.socket.emit === 'function') {\n        window.socket.emit(SOCKET_EVENTS.CLIENT_TO_SERVER.REQUEST_TASK_STATUS, { task_id: taskId });\n      }\n    } catch (error) {\n      console.error('Error resuming task processing:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'resumeTaskProcessing',\n          context: 'task resumption',\n          taskId: taskId\n        });\n      }\n    }\n  },\n\n  /**\n   * Ensure all progress UI elements exist\n   */\n  ensureProgressUIElements() {\n    try {\n      // Check if progress container exists\n      const progressContainer = getElement('playlist-progress-container');\n      if (!progressContainer) {\n        console.warn('Progress container not found in DOM');\n        return;\n      }\n      \n      // Check for progress bar\n      const progressBar = getElement('playlist-progress-bar');\n      if (!progressBar) {\n        // Create progress UI elements if they don't exist\n        console.log('Creating progress UI elements');\n        if (window.progressHandler && typeof window.progressHandler.createProgressUI === 'function') {\n          const progressUI = window.progressHandler.createProgressUI('playlist-progress-container', 'playlist');\n          if (progressUI) {\n            console.log('Progress UI created successfully');\n          }\n        } else {\n          console.warn('createProgressUI function not available');\n        }\n      } else {\n        console.log('Progress UI elements already exist');\n      }\n    } catch (error) {\n      console.error('Error ensuring progress UI elements:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'ensureProgressUIElements',\n          context: 'UI initialization'\n        });\n      }\n    }\n  },\n\n  /**\n   * Start progress monitoring to detect stuck progress\n   */\n  startProgressMonitoring() {\n    console.log('Starting progress monitoring');\n    \n    // Set up a timer to check for stuck progress at 5%\n    const checkForStuckProgress = () => {\n      // Only check if we're processing and not already completed\n      if (!state.processing || state.completionState.completed) {\n        return;\n      }\n      \n      // Check if progress is stuck at a low value for too long\n      const now = Date.now();\n      const lastUpdateTime = state.lastProgressTimestamp || state.processingStartTime || now;\n      const timeSinceLastUpdate = now - lastUpdateTime;\n      \n      // If we've been stuck at a low progress for too long, try to recover\n      if (state.lastReportedProgress > 0 && \n          state.lastReportedProgress < 15 && \n          timeSinceLastUpdate > 30000) { // 30 seconds stuck at a low value\n        \n        console.warn(`Progress appears stuck at ${state.lastReportedProgress}% for ${Math.round(timeSinceLastUpdate / 1000)}s`);\n        \n        // Force a status update request\n        if (state.currentTaskId) {\n          this.requestTaskStatus(state.currentTaskId);\n        }\n      }\n    };\n    \n    // Set up a timer to check progress completion when progress is high\n    const checkHighProgressCompletion = () => {\n      // Only check if we're processing and not already completed\n      if (!state.processing || state.completionState.completed) {\n        return;\n      }\n      \n      // Check if progress is high but not yet marked as complete\n      if (state.lastReportedProgress >= 98) {\n        const now = Date.now();\n        const lastUpdateTime = state.lastProgressTimestamp || state.processingStartTime || now;\n        const timeSinceLastUpdate = now - lastUpdateTime;\n        \n        // If we've been at high progress for a while, assume it's done\n        if (timeSinceLastUpdate > 10000) { // 10 seconds at high progress\n          console.log('High progress detected for extended period, assuming completion');\n          \n          // Create a completion data object\n          const completionData = {\n            task_id: state.currentTaskId,\n            status: 'completed',\n            progress: 100,\n            message: 'Processing completed',\n            output_file: state.outputFilePath\n          };\n          \n          // Force completion\n          this.handlePlaylistCompletion(completionData);\n        }\n      }\n    };\n    \n    // Set up a timer to check overall task completion\n    const checkTaskCompletion = () => {\n      // Only check if we're processing and not already completed\n      if (!state.processing || state.completionState.completed) {\n        return;\n      }\n      \n      // Check if the task has been running for too long\n      const now = Date.now();\n      const taskRunTime = now - (state.processingStartTime || now);\n      \n      // If the task has been running for over 1 hour, check if it's still active\n      if (taskRunTime > 3600000) { // 1 hour\n        console.warn(`Task has been running for ${Math.round(taskRunTime / 60000)} minutes`);\n        \n        // Request a status update to see if it's still active\n        if (state.currentTaskId) {\n          this.requestTaskStatus(state.currentTaskId);\n        }\n      }\n    };\n    \n    // Set timers to run these checks periodically\n    setInterval(checkForStuckProgress, 15000); // Every 15 seconds\n    setInterval(checkHighProgressCompletion, 5000); // Every 5 seconds\n    setInterval(checkTaskCompletion, 60000); // Every minute\n    \n    return true;\n  },\n\n  /**\n   * Add a new playlist URL field\n   */\n  addPlaylistField() {\n    const container = getElement('playlist-urls-container');\n    if (!container) return;\n    \n    const templateHtml = `\n      <div class=\"input-group mb-2\">\n        <input type=\"url\" class=\"form-control playlist-url\" placeholder=\"Enter YouTube Playlist URL\" required>\n        <button type=\"button\" class=\"btn btn-outline-danger remove-url\">\n          <i class=\"fas fa-trash\"></i>\n        </button>\n      </div>\n    `;\n    \n    // Create a temporary div to hold the HTML\n    const tempDiv = document.createElement('div');\n    tempDiv.innerHTML = templateHtml.trim();\n    \n    // Add the new field to the container\n    container.appendChild(tempDiv.firstChild);\n  },\n\n  /**\n   * Get playlist URLs from input fields\n   * @returns {Array<string>} - Array of playlist URLs\n   */\n  getPlaylistURLs() {\n    const urlInputs = getElements('.playlist-url');\n    const urls = [];\n    \n    urlInputs.forEach(input => {\n      const url = input.value.trim();\n      if (url) {\n        urls.push(url);\n      }\n    });\n    \n    return urls;\n  },\n\n  /**\n   * Validate root directory\n   * @returns {string} - Validated directory path\n   */\n  validateRootDirectory() {\n    const rootDirInput = getElement('playlist-root');\n    if (!rootDirInput) {\n      throw new Error('Root directory input not found');\n    }\n    \n    const dir = rootDirInput.value.trim();\n    if (!dir) {\n      throw new Error('Please enter a root directory');\n    }\n    \n    // Save this for future use\n    state.lastSavedOutputDir = dir;\n    localStorage.setItem('lastPlaylistOutputDir', dir);\n    \n    // Analyze path type\n    this.analyzePathType(dir);\n    \n    return dir;\n  },\n\n  /**\n   * Resolve output file path to match server-side behavior\n   * @param {string} outputFile - Output filename\n   * @param {string} rootDirectory - Root directory\n   * @returns {string} - Sanitized output file path\n   */\n  resolveOutputFilePath(outputFile, rootDirectory) {\n    if (!outputFile) {\n      return rootDirectory ? `${rootDirectory}/playlists.json` : 'playlists.json';\n    }\n    \n    // Check if it already has a .json extension\n    const hasExtension = outputFile.toLowerCase().endsWith('.json');\n    \n    // CASE 1: Complete Windows path with drive letter\n    if (/^[A-Za-z]:/.test(outputFile)) {\n      // If it's a complete path with directory, use as-is\n      if (outputFile.includes('\\\\') || outputFile.includes('/')) {\n        return hasExtension ? outputFile : `${outputFile}.json`;\n      }\n    }\n    \n    // CASE 2: Unix absolute path\n    if (outputFile.startsWith('/')) {\n      return hasExtension ? outputFile : `${outputFile}.json`;\n    }\n    \n    // CASE 3: Path with separators but not absolute\n    if (outputFile.includes('\\\\') || outputFile.includes('/')) {\n      // Extract just the filename to avoid path confusion\n      const parts = outputFile.split(/[\\/\\\\]/);\n      const filename = parts[parts.length - 1];\n      \n      // Ensure it has .json extension\n      const finalFilename = hasExtension ? filename : `${filename}.json`;\n      \n      // Join with root directory\n      return `${rootDirectory}/${finalFilename}`;\n    }\n    \n    // CASE 4: Just a filename\n    const finalFilename = hasExtension ? outputFile : `${outputFile}.json`;\n    return `${rootDirectory}/${finalFilename}`;\n  },\n\n  /**\n   * Initialize progress bar to exactly 0% to fix the 5% stuck issue\n   */\n  explicitlyInitializeProgressToZero() {\n    const progressBar = getElement('playlist-progress-bar');\n    if (progressBar) {\n      progressBar.style.width = '0%';\n      progressBar.setAttribute('aria-valuenow', 0);\n      progressBar.textContent = '0%';\n      \n      // Make sure progress bar has the right styling\n      this.initializeProgressBarStyling(progressBar);\n    }\n    \n    // Reset the progress state\n    state.lastReportedProgress = 0;\n    state.progressUpdateCount = 0;\n    \n    // Set stage to initialization\n    state.currentStage = PROGRESS_STAGES.INIT.name;\n    state.stageProgress = 0;\n  },\n\n  /**\n   * Initialize progress bar styling\n   * @param {HTMLElement} progressBar - Progress bar element\n   */\n  initializeProgressBarStyling(progressBar) {\n    if (!progressBar) {\n      progressBar = getElement('playlist-progress-bar');\n      if (!progressBar) return;\n    }\n    \n    // Set initial styling\n    progressBar.classList.remove('bg-danger', 'bg-warning', 'bg-info', 'bg-success');\n    progressBar.classList.add('bg-primary');\n    \n    // Make sure transitions are applied\n    progressBar.style.transition = 'width 0.5s ease-in-out';\n  },\n\n  /**\n   * Update progress based on current stage to match server-side progress calculation\n   * @param {string} stage - Current stage name\n   * @param {number} current - Current progress in this stage\n   * @param {number} total - Total items in this stage\n   * @returns {number} - Calculated overall progress percentage\n   */\n  calculateStageProgress(stage, current, total) {\n    // Find the stage configuration\n    let stageConfig = null;\n    for (const [key, config] of Object.entries(PROGRESS_STAGES)) {\n      if (config.name === stage) {\n        stageConfig = config;\n        break;\n      }\n    }\n    \n    // If stage not found, use the provided progress directly\n    if (!stageConfig) {\n      return Math.min(100, Math.max(0, current));\n    }\n    \n    // Calculate stage progress (0-1 ratio)\n    const stageProgress = total > 0 ? current / total : 0;\n    \n    // Calculate absolute progress within the stage's range\n    const stageRange = stageConfig.max - stageConfig.min;\n    const calculatedProgress = stageConfig.min + (stageProgress * stageRange);\n    \n    // Update stage tracking\n    state.currentStage = stage;\n    state.stageProgress = stageProgress;\n    \n    // Return calculated progress, ensuring it's within bounds\n    return Math.min(100, Math.max(0, calculatedProgress));\n  },\n\n  /**\n   * Handle form submission\n   * @param {Event} e - Submit event\n   */\n  async handlePlaylistSubmit(e) {\n    if (e) {\n      e.preventDefault();\n    }\n    \n    console.log('Playlist form submitted');\n    \n    // Get form elements\n    const urlsContainer = getElement('playlist-urls-container');\n    const rootDirInput = getElement('playlist-root');\n    const outputFileInput = getElement('playlist-output');\n    const submitBtn = getElement('playlist-submit-btn');\n    \n    try {\n      // Validate inputs\n      if (!urlsContainer || !rootDirInput || !outputFileInput) {\n        throw new Error('Form elements not found');\n      }\n      \n      // Get playlist URLs\n      const playlistURLs = this.getPlaylistURLs();\n      if (playlistURLs.length === 0) {\n        throw new Error('Please enter at least one playlist URL');\n      }\n      \n      // Validate root directory\n      const rootDir = this.validateRootDirectory();\n      if (!rootDir) {\n        throw new Error('Please enter a root directory');\n      }\n      \n      // Validate output file\n      const outputFile = outputFileInput.value.trim();\n      if (!outputFile) {\n        throw new Error('Please enter an output filename');\n      }\n      \n      // Show loading state\n      if (submitBtn) {\n        submitBtn.disabled = true;\n        submitBtn.innerHTML = '<i class=\"fas fa-spinner fa-spin me-2\"></i>Starting...';\n      }\n      \n      // Resolve output file path in a way that matches the server-side behavior\n      const resolvedOutput = this.resolveOutputFilePath(outputFile, rootDir);\n      \n      // Show progress UI immediately\n      this.showProgress();\n      \n      // CRITICAL FIX: Initialize progress to exactly 0%\n      this.explicitlyInitializeProgressToZero();\n      \n      try {\n        // Send API request to start download using centralized configuration\n        const response = await fetch(PLAYLIST_CONFIG.endpoints.START, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'X-API-Key': localStorage.getItem('api_key') || ''\n          },\n          body: JSON.stringify({\n            playlists: playlistURLs,\n            root_directory: rootDir,\n            output_file: resolvedOutput\n          }),\n          timeout: PLAYLIST_CONFIG.api?.API_TIMEOUT || API_TIMEOUT_MS\n        });\n\n        if (!response.ok) {\n          const errorData = await response.json().catch(() => ({ error: 'Network error' }));\n          throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);\n        }\n\n        const result = await response.json();\n        console.log('API response:', result);\n        \n        if (result.error) {\n          throw new Error(result.error);\n        }\n        \n        // Setup download task with returned task ID\n        await this.setupDownloadTask(result.task_id, result.output_file || resolvedOutput);\n        \n        this.showNotification('Your playlists are being downloaded', 'info', 'Download Started');\n        \n      } catch (apiError) {\n        console.error('API error:', apiError);\n        this.showPlaylistError(`API Error: ${apiError.message}`);\n        \n        // Reset button state\n        if (submitBtn) {\n          submitBtn.disabled = false;\n          submitBtn.innerHTML = '<i class=\"fas fa-play me-2\"></i>Start Processing';\n        }\n        \n        // Show form again\n        this.showPlaylistForm();\n      }\n    } catch (error) {\n      console.error('Form submission error:', error);\n      this.showPlaylistError(error.message);\n      \n      // Reset button state\n      if (submitBtn) {\n        submitBtn.disabled = false;\n        submitBtn.innerHTML = '<i class=\"fas fa-play me-2\"></i>Start Processing';\n      }\n    }\n  },\n\n  /**\n   * Setup download task with task ID\n   * @param {string} taskId - Task ID from server\n   * @param {string} outputFile - Output file path\n   */\n  async setupDownloadTask(taskId, outputFile) {\n    console.log(`Setting up download task: ${taskId}, output: ${outputFile}`);\n    \n    // Store task ID and output path\n    state.currentTaskId = taskId;\n    window.currentTaskId = taskId; // For compatibility with other modules\n    state.outputFilePath = outputFile;\n    \n    // Set initial state\n    state.processing = true;\n    state.processingStartTime = Date.now();\n    state.progressUpdateCount = 0;\n    state.lastProgressTimestamp = Date.now();\n    \n    // Reset completion state\n    state.completionState = {\n      completed: false,\n      error: false,\n      cancelled: false\n    };\n    \n    // Reset progress rates\n    state.progressRates = [];\n    \n    // Save to session storage for persistence across page reloads\n    sessionStorage.setItem('ongoingTaskId', taskId);\n    sessionStorage.setItem('ongoingTaskType', 'playlist');\n    sessionStorage.setItem('outputFile', outputFile);\n    sessionStorage.setItem('taskStartTime', Date.now().toString());\n    \n    // Update state manager\n    if (stateManager && typeof stateManager.setProcessingActive === 'function') {\n      stateManager.setProcessingActive(true, taskId);\n    }\n    \n    if (stateManager && typeof stateManager.setCurrentTaskId === 'function') {\n      stateManager.setCurrentTaskId(taskId);\n    }\n    \n    // Setup progress tracking using the imported setupTaskProgress function\n    let taskProgress = null;\n    if (window.progressHandler && typeof window.progressHandler.setupTaskProgress === 'function') {\n      taskProgress = window.progressHandler.setupTaskProgress(taskId, {\n        elementPrefix: 'playlist',\n        taskType: 'playlist',\n        saveToSessionStorage: true,\n        outputFile: outputFile\n      });\n    }\n    \n    state.progressTracker = taskProgress;\n    \n    // CRITICAL FIX: Set up direct Socket.IO listeners as backup\n    this.setupDirectSocketListeners(taskId);\n    \n    // Start status polling as a fallback\n    this.startStatusPolling(taskId);\n    \n    // Return success\n    return true;\n  },\n\n  /**\n   * Setup progress tracking for a task\n   * @param {string} taskId - Task ID\n   */\n  setupProgressTracking(taskId) {\n    if (!taskId) {\n      console.warn('Cannot setup progress tracking without task ID');\n      return;\n    }\n    \n    console.log(`Setting up progress tracking for task: ${taskId}`);\n    \n    try {\n      // Use the imported setupTaskProgress function to set up the task\n      if (window.progressHandler && typeof window.progressHandler.setupTaskProgress === 'function') {\n        state.progressTracker = window.progressHandler.setupTaskProgress(taskId, {\n          elementPrefix: 'playlist',\n          taskType: 'playlist',\n          saveToSessionStorage: true,\n          outputFile: state.outputFilePath\n        });\n      }\n      \n      console.log('Progress tracking setup complete');\n    } catch (err) {\n      console.warn('Error setting up progress tracking:', err);\n      \n      // Fallback to direct socket listeners\n      this.setupDirectSocketListeners(taskId);\n      \n      // Start polling as fallback\n      this.startStatusPolling(taskId);\n    }\n    \n    // Set up completion monitoring\n    this.setupCompletionMonitoring(taskId);\n  },\n\n  /**\n   * Setup direct Socket.IO listeners\n   * @param {string} taskId - Task ID\n   */\n  setupDirectSocketListeners(taskId) {\n    if (!window.socket) {\n      console.warn('Socket.IO not available for direct listeners');\n      return;\n    }\n    \n    try {\n      console.log('Setting up direct Socket.IO listeners');\n      \n      // Remove existing listeners to prevent duplicates\n      const events = [\n        'progress_update', 'task_completed', 'task_error',\n        'playlist_completed', 'playlist_error', 'playlist_cancelled'\n      ];\n      \n      events.forEach(event => window.socket.off(event));\n      \n      // Progress update events\n      window.socket.on('progress_update', (data) => {\n        if (data && data.task_id === taskId) {\n          this.processStatusUpdate(data);\n        }\n      });\n      \n      window.socket.on('playlist_progress', (data) => {\n        if (data && data.task_id === taskId) {\n          this.processStatusUpdate(data);\n        }\n      });\n      \n      // Completion events\n      window.socket.on('task_completed', (data) => {\n        if (data && data.task_id === taskId) {\n          this.handlePlaylistCompletion(data);\n        }\n      });\n      \n      window.socket.on('playlist_completed', (data) => {\n        if (data && data.task_id === taskId) {\n          this.handlePlaylistCompletion(data);\n        }\n      });\n      \n      // Error events\n      window.socket.on('task_error', (data) => {\n        if (data && data.task_id === taskId) {\n          this.handleTaskError(data);\n        }\n      });\n      \n      window.socket.on('playlist_error', (data) => {\n        if (data && data.task_id === taskId) {\n          this.handleTaskError(data);\n        }\n      });\n      \n      // Cancellation events\n      window.socket.on('task_cancelled', (data) => {\n        if (data && data.task_id === taskId) {\n          this.handleTaskCancelled(data);\n        }\n      });\n      \n      window.socket.on('playlist_cancelled', (data) => {\n        if (data && data.task_id === taskId) {\n          this.handleTaskCancelled(data);\n        }\n      });\n      \n      // Request initial status\n      window.socket.emit(SOCKET_EVENTS.CLIENT_TO_SERVER.REQUEST_TASK_STATUS, { task_id: taskId });\n      \n      console.log('Direct Socket.IO listeners setup complete');\n    } catch (error) {\n      console.error('Error setting up Socket.IO listeners:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'setupDirectSocketListeners',\n          context: 'socket setup',\n          taskId: taskId\n        });\n      }\n    }\n  },\n\n  /**\n   * Start status polling as a fallback\n   * @param {string} taskId - Task ID\n   */\n  startStatusPolling(taskId) {\n    if (!taskId) return;\n    \n    // Clear any existing interval\n    if (state.statusPollInterval) {\n      clearInterval(state.statusPollInterval);\n      state.statusPollInterval = null;\n    }\n    \n    console.log(`Starting status polling for task: ${taskId}`);\n    \n    // Create a new polling interval\n    state.statusPollInterval = setInterval(() => {\n      // Skip if socket is connected (prefer socket updates)\n      if (window.socket && window.socket.connected) {\n        return;\n      }\n      \n      // Skip if processing is canceled or completed\n      if (!state.processing || state.completionState.completed) {\n        clearInterval(state.statusPollInterval);\n        state.statusPollInterval = null;\n        return;\n      }\n      \n      // Request status update\n      this.requestTaskStatus(taskId);\n    }, PROGRESS_POLL_INTERVAL_MS);\n  },\n\n  /**\n   * Request task status from server\n   * @param {string} taskId - Task ID\n   */\n  async requestTaskStatus(taskId) {\n    if (!taskId) return;\n    \n    try {\n      // Use socket if available\n      if (window.socket && window.socket.connected) {\n        window.socket.emit(SOCKET_EVENTS.CLIENT_TO_SERVER.REQUEST_TASK_STATUS, { task_id: taskId });\n        return;\n      }\n      \n      // Otherwise, use centralized configuration\n      const statusEndpoint = PLAYLIST_CONFIG.endpoints.STATUS.replace(':taskId', taskId);\n      fetch(statusEndpoint, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-API-Key': localStorage.getItem('api_key') || ''\n        },\n        timeout: 5000\n      })\n        .then(response => response.json())\n        .then(data => {\n          // Process status update\n          if (data) {\n            this.processStatusUpdate(data);\n          }\n          \n          // Remove from pending requests\n          delete state.pendingRequests[taskId];\n        })\n        .catch(error => {\n          if (error.name !== 'AbortError') {\n            console.warn(`Error fetching task status: ${error.message}`);\n          }\n          // Remove from pending requests\n          delete state.pendingRequests[taskId];\n        });\n    } catch (error) {\n      console.error('Error requesting task status:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'requestTaskStatus',\n          context: 'API request',\n          taskId: taskId\n        });\n      }\n    }\n  },\n\n  /**\n   * Set up completion monitoring\n   * @param {string} taskId - Task ID\n   */\n  setupCompletionMonitoring(taskId) {\n    if (!taskId || !state.completionMonitoring.enabled) return;\n    \n    // Clear previous monitoring\n    this.clearCompletionMonitoring();\n    \n    console.log(`Setting up completion monitoring for task: ${taskId}`);\n    \n    // Create a monitoring function\n    const monitorCompletion = () => {\n      // Skip if task is already completed or cancelled\n      if (state.completionState.completed || \n          state.completionState.error || \n          state.completionState.cancelled || \n          !state.processing) {\n        this.clearCompletionMonitoring();\n        return;\n      }\n      \n      // Check for stuck progress\n      const currentTime = Date.now();\n      const timeSinceLastUpdate = state.lastProgressTimestamp ? \n                                (currentTime - state.lastProgressTimestamp) : 0;\n      \n      // If no updates for a long time, check if task is complete\n      if (timeSinceLastUpdate > state.completionMonitoring.maxStuckDurationMs) {\n        console.log(`No progress updates for ${Math.round(timeSinceLastUpdate/1000)}s, checking completion status...`);\n        \n        // Request current status\n        this.requestTaskStatus(taskId);\n        \n        // If progress is high, task might be complete\n        if (state.lastReportedProgress >= 95) {\n          console.log('High progress detected, task may be complete');\n          \n          // Force a check after a short delay\n          setTimeout(() => {\n            // If still not marked as complete after check, force completion\n            if (!state.completionState.completed && state.lastReportedProgress >= 95) {\n              console.log('Forcing completion based on high progress');\n              \n              // Create a minimal completion data object\n              const completionData = {\n                task_id: taskId,\n                status: 'completed',\n                progress: 100,\n                output_file: state.outputFilePath,\n                message: 'Task completed (detected by monitoring)'\n              };\n              \n              this.handlePlaylistCompletion(completionData);\n            }\n          }, 5000);\n        }\n      }\n      \n      // Schedule next check\n      const timeoutId = setTimeout(monitorCompletion, state.completionMonitoring.checkIntervalMs);\n      state.completionMonitoring.timeoutIds.add(timeoutId);\n    };\n    \n    // Start monitoring\n    const timeoutId = setTimeout(monitorCompletion, state.completionMonitoring.checkIntervalMs);\n    state.completionMonitoring.timeoutIds.add(timeoutId);\n  },\n\n  /**\n   * Clear completion monitoring timeouts\n   */\n  clearCompletionMonitoring() {\n    for (const timeoutId of state.completionMonitoring.timeoutIds) {\n      clearTimeout(timeoutId);\n    }\n    state.completionMonitoring.timeoutIds.clear();\n  },\n\n  /**\n   * Process a status update from server\n   * @param {Object} data - Status update data\n   */\n  processStatusUpdate(data) {\n    try {\n      // Validate the update data\n      if (!data || !data.task_id || data.task_id !== state.currentTaskId) {\n        return;\n      }\n      \n      // Skip if task already completed\n      if (state.completionState.completed) {\n        return;\n      }\n      \n      console.log(`Processing status update for task ${data.task_id}: ${data.progress}%`);\n      \n      // Update tracking information\n      state.lastProgressTimestamp = Date.now();\n      state.progressUpdateCount++;\n      \n      // Update stage information if available\n      if (data.details && data.details.current_stage) {\n        state.currentStage = data.details.current_stage;\n        state.stageProgress = data.details.stage_progress || 0;\n      }\n      \n      // Store task data for future use\n      if (data.stats) {\n        state.taskData = { ...state.taskData, ...data };\n      }\n      \n      // Add to progress rates for ETA calculation\n      if (state.progressRates.length < MAX_PROGRESS_RATES && data.progress > 0) {\n        const now = Date.now();\n        const elapsed = now - state.processingStartTime;\n        \n        // Only calculate after at least 5 seconds\n        if (elapsed > 5000) {\n          // Calculate progress rate (% per second)\n          const progressRate = data.progress / (elapsed / 1000);\n          \n          // Add to the progress rates array\n          state.progressRates.push(progressRate);\n        }\n      }\n      \n      // Determine adjusted progress\n      let displayProgress = data.progress;\n      \n      // CRITICAL FIX: Stage-based progress adjustment\n      if (state.currentStage) {\n        // Find the matching stage\n        for (const [key, stage] of Object.entries(PROGRESS_STAGES)) {\n          if (stage.name === state.currentStage) {\n            // If we're in a known stage but the progress is inconsistent,\n            // calculate progress based on the stage\n            const stageMin = stage.min;\n            const stageMax = stage.max;\n            const stageRange = stageMax - stageMin;\n            \n            // If server progress is low but we're in a later stage, adjust it\n            if (data.progress < stageMin) {\n              displayProgress = stageMin + (state.stageProgress * stageRange);\n              console.log(`Adjusted progress to match stage ${state.currentStage}: ${displayProgress}%`);\n            }\n            // If we're in early stages and stuck at 5%, boost gradually\n            else if (data.progress <= 5 && state.progressUpdateCount > 2) {\n              displayProgress = Math.min(15, 5 + (state.progressUpdateCount - 2));\n              console.log(`Adjusted early progress from ${data.progress}% to ${displayProgress}%`);\n            }\n            break;\n          }\n        }\n      }\n      \n      // Check for completion\n      const isCompleted = this.isCompletionPhase(data);\n      \n      // Update UI with progress handler if available\n      if (window.progressHandler && typeof window.progressHandler.updateProgressUI === 'function') {\n        window.progressHandler.updateProgressUI(data.task_id, displayProgress, data.message || 'Processing...', data.stats);\n        \n        // Handle completion\n        if (isCompleted && !state.completionState.completed) {\n          console.log(`Task ${data.task_id} completion detected via progress update`);\n          \n          // Force progress to 100%\n          window.progressHandler.updateProgressUI(data.task_id, 100, data.message || 'Task completed successfully', data.stats);\n          \n          // Complete the task after a short delay\n          setTimeout(() => {\n            this.handlePlaylistCompletion(data);\n          }, TASK_COMPLETION_DELAY);\n        }\n      } else {\n        // Direct UI update\n        this.updateProgressDisplay(displayProgress, data.message, data.stats);\n        \n        // Handle completion\n        if (isCompleted && !state.completionState.completed) {\n          console.log(`Task ${data.task_id} completion detected via direct update`);\n          \n          // Force progress to 100%\n          this.updateProgressDisplay(100, data.message || 'Task completed successfully', data.stats);\n          \n          // Complete the task after a short delay\n          setTimeout(() => {\n            this.handlePlaylistCompletion(data);\n          }, TASK_COMPLETION_DELAY);\n        }\n      }\n      \n      // Handle specific status values\n      if (data.status === 'error' || data.status === 'failed') {\n        this.handleTaskError(data);\n      } else if (data.status === 'cancelled') {\n        this.handleTaskCancelled(data);\n      }\n      \n      // Store last reported progress\n      state.lastReportedProgress = displayProgress;\n    } catch (error) {\n      console.error('Error processing status update:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'processStatusUpdate',\n          context: 'status update processing',\n          data: {\n            taskId: data?.task_id,\n            progress: data?.progress,\n            status: data?.status\n          }\n        });\n      }\n    }\n  },\n\n  /**\n   * Check if data indicates completion phase\n   * @param {Object} data - Status update data\n   * @returns {boolean} - Whether this indicates completion\n   */\n  isCompletionPhase(data) {\n    return (\n      // Status-based checks\n      data.status === 'completed' || \n      (data.stats && data.stats.status === 'completed') ||\n      \n      // Stage-based check\n      (data.details && data.details.current_stage === PROGRESS_STAGES.FINALIZE.name &&\n       data.details.stage_progress > 0.8) ||\n      \n      // Message-based checks (case insensitive)\n      (data.message && (\n        /complet(ed|ion)/i.test(data.message) ||\n        /done/i.test(data.message) ||\n        /finish(ed)/i.test(data.message) ||\n        /success/i.test(data.message)\n      )) ||\n      \n      // Progress-based checks\n      (data.progress >= 98) ||\n      (data.progress >= 90 && data.stats && \n        (data.stats.processed_files >= (data.stats.total_files || 1) ||\n         data.stats.processed_videos >= (data.stats.total_videos || 1) ||\n         data.stats.processed_playlists >= (data.stats.total_playlists || 1)))\n    );\n  },\n\n  /**\n   * Update progress display\n   * @param {number} progress - Progress percentage\n   * @param {string} message - Status message\n   * @param {Object} stats - Optional statistics\n   */\n  updateProgressDisplay(progress, message, stats = null) {\n    try {\n      // Get UI elements\n      const progressBar = getElement('playlist-progress-bar');\n      const progressStatus = getElement('playlist-progress-status');\n      const progressStats = getElement('playlist-progress-stats');\n      const stageLabel = getElement('playlist-stage-label');\n      \n      // Update progress bar\n      if (progressBar) {\n        const displayProgress = Math.max(0, Math.min(100, progress));\n        progressBar.style.width = `${displayProgress}%`;\n        progressBar.setAttribute('aria-valuenow', displayProgress);\n        progressBar.textContent = `${Math.round(displayProgress)}%`;\n        \n        // Add appropriate styling based on progress\n        progressBar.classList.remove('bg-danger', 'bg-warning', 'bg-info', 'bg-primary', 'bg-success');\n        \n        if (displayProgress >= 100) {\n          progressBar.classList.add('bg-success');\n        } else if (displayProgress >= 75) {\n          progressBar.classList.add('bg-info');\n        } else if (displayProgress >= 50) {\n          progressBar.classList.add('bg-primary');\n        } else if (displayProgress >= 25) {\n          progressBar.classList.add('bg-primary');\n        } else {\n          progressBar.classList.add('bg-primary');\n        }\n      }\n      \n      // Update status message\n      if (progressStatus && message) {\n        progressStatus.textContent = message;\n      }\n      \n      // Update stage label if available\n      if (stageLabel && state.currentStage) {\n        const stageName = state.currentStage\n          .replace(/_/g, ' ')\n          .replace(/\\b\\w/g, l => l.toUpperCase());\n        stageLabel.textContent = `Stage: ${stageName}`;\n        stageLabel.classList.remove('d-none');\n      }\n      \n      // Update stats if available\n      if (progressStats && stats) {\n        this.updateProgressStats(progressStats, stats);\n      }\n      \n      // Store last reported progress\n      state.lastReportedProgress = progress;\n    } catch (error) {\n      console.error('Error updating progress display:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'updateProgressDisplay',\n          context: 'UI update'\n        });\n      }\n    }\n  },\n\n  /**\n   * Update progress stats\n   * @param {HTMLElement} element - Stats container element\n   * @param {Object} stats - Statistics object\n   */\n  updateProgressStats(element, stats) {\n    if (!element || !stats) return;\n    \n    try {\n      // Format stats for display\n      let statsHtml = '<div class=\"stats-container p-2\">';\n      \n      // Format based on available stats\n      if (stats.total_playlists !== undefined) {\n        // Playlist stats\n        statsHtml += `\n          <div class=\"row g-2\">\n            <div class=\"col-md-6\">\n              <div class=\"d-flex gap-2 flex-wrap\">\n                <span class=\"badge bg-primary\">Playlists: ${stats.total_playlists || 0}</span>\n                <span class=\"badge bg-success\">Processed: ${stats.processed_playlists || 0}</span>\n                <span class=\"badge bg-warning\">Skipped: ${stats.skipped_playlists || 0}</span>\n                <span class=\"badge bg-danger\">Errors: ${stats.failed_playlists || 0}</span>\n              </div>\n            </div>\n            <div class=\"col-md-6\">\n              <div class=\"d-flex gap-2 flex-wrap\">\n                <span class=\"badge bg-info\">Videos: ${stats.total_videos || 0}</span>\n                <span class=\"badge bg-success\">Downloaded: ${stats.processed_videos || 0}</span>\n              </div>\n            </div>\n          </div>\n        `;\n        \n        // Add elapsed time if available\n        if (stats.elapsed_seconds || stats.elapsed_time_seconds) {\n          const duration = stats.elapsed_seconds || stats.elapsed_time_seconds || 0;\n          statsHtml += `<div class=\"mt-2 text-muted\">Elapsed time: ${this.formatDuration(duration)}</div>`;\n        }\n        \n        // Add current stage if available\n        if (state.currentStage) {\n          const stageName = state.currentStage\n            .replace(/_/g, ' ')\n            .replace(/\\b\\w/g, l => l.toUpperCase());\n          \n          statsHtml += `<div class=\"mt-2 text-muted\">Current stage: ${stageName}</div>`;\n        }\n      } else if (stats.total_files !== undefined) {\n        // Generic file processing stats\n        statsHtml += `\n          <div class=\"row\">\n            <div class=\"col-md-6 mb-2\">\n              <span class=\"badge bg-primary\">Files: ${stats.total_files || 0}</span>\n              <span class=\"badge bg-success mx-1\">Processed: ${stats.processed_files || 0}</span>\n              <span class=\"badge bg-warning mx-1\">Skipped: ${stats.skipped_files || 0}</span>\n              <span class=\"badge bg-danger mx-1\">Errors: ${stats.error_files || 0}</span>\n            </div>\n            <div class=\"col-md-6 mb-2\">\n              <span class=\"badge bg-info\">Chunks: ${stats.total_chunks || 0}</span>\n              ${stats.total_bytes ? \n                `<span class=\"badge bg-secondary mx-1\">Size: ${this.formatBytes(stats.total_bytes)}</span>` : ''}\n            </div>\n          </div>\n        `;\n      }\n      \n      // Add current file/video if available\n      if (stats.current_video || stats.current_file) {\n        statsHtml += `\n          <div class=\"mt-2 small\">\n            <i class=\"fas fa-spinner fa-spin me-1\"></i> \n            ${stats.current_video || stats.current_file}\n          </div>\n        `;\n      }\n      \n      statsHtml += '</div>';\n      \n      // Update the element\n      element.innerHTML = statsHtml;\n    } catch (error) {\n      console.error('Error updating progress stats:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'updateProgressStats',\n          context: 'UI update'\n        });\n      }\n    }\n  },\n\n  /**\n   * Format bytes to human-readable size\n   * @param {number} bytes - Bytes to format\n   * @returns {string} - Formatted size\n   */\n  formatBytes(bytes) {\n    if (bytes === 0) return '0 Bytes';\n    \n    // Check if we already have a formatted string\n    if (typeof bytes === 'string' && bytes.includes('B')) {\n      return bytes;\n    }\n    \n    // Use utils if available\n    if (window.utils && typeof window.utils.formatBytes === 'function') {\n      return window.utils.formatBytes(bytes);\n    }\n    \n    // Fallback implementation\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  },\n\n  /**\n   * Format duration in seconds to human-readable form\n   * @param {number} seconds - Duration in seconds\n   * @returns {string} - Formatted duration\n   */\n  formatDuration(seconds) {\n    if (!seconds || seconds <= 0) return '0s';\n    \n    // Check if we already have a formatted string\n    if (typeof seconds === 'string' && (seconds.includes('s') || seconds.includes('m') || seconds.includes('h'))) {\n      return seconds;\n    }\n    \n    // Use utils if available\n    if (window.utils && typeof window.utils.formatDuration === 'function') {\n      return window.utils.formatDuration(seconds);\n    }\n    \n    // Fallback implementation\n    const h = Math.floor(seconds / 3600);\n    const m = Math.floor((seconds % 3600) / 60);\n    const s = Math.floor(seconds % 60);\n    \n    return [\n      h > 0 ? `${h}h` : '',\n      m > 0 ? `${m}m` : '',\n      s > 0 || (h === 0 && m === 0) ? `${s}s` : ''\n    ].filter(Boolean).join(' ');\n  },\n\n  /**\n   * Handle playlist completion\n   * @param {Object} data - Completion data\n   */\n  handlePlaylistCompletion(data) {\n    try {\n      // Skip if already completed or duplicate event for same task ID\n      if (state.completionState.completed || state.completionHandled.has(data.task_id)) {\n        console.log('Task already marked as completed, skipping duplicate completion');\n        return;\n      }\n      \n      // Add task to handled set to prevent duplicates\n      state.completionHandled.add(data.task_id);\n      \n      console.log('Handling playlist completion:', data);\n      \n      // Mark as completed\n      state.completionState.completed = true;\n      state.completionState.completionTime = Date.now();\n      \n      // Force progress to 100%\n      this.updateProgressDisplay(100, 'Task completed successfully', data.stats);\n      \n      // Clean up session storage\n      sessionStorage.removeItem('ongoingTaskId');\n      sessionStorage.removeItem('ongoingTaskType');\n      sessionStorage.removeItem('outputFile');\n      sessionStorage.setItem('taskCompletionTime', Date.now().toString());\n      \n      // Update state\n      state.processing = false;\n      state.currentTaskId = null;\n      window.currentTaskId = null; // For compatibility\n      \n      // Complete tracking in progressHandler if available\n      if (state.progressTracker && typeof state.progressTracker.complete === 'function') {\n        state.progressTracker.complete(data);\n      } else if (window.progressHandler && typeof window.progressHandler.completeTask === 'function') {\n        window.progressHandler.completeTask(data.task_id, data);\n      }\n      \n      // Add to history\n      this.addTaskToHistory(data);\n      \n      // Show results UI\n      setTimeout(() => {\n        this.showResult(data);\n      }, TASK_COMPLETION_DELAY);\n      \n      // Update state manager\n      if (stateManager && typeof stateManager.setProcessingActive === 'function') {\n        stateManager.setProcessingActive(false);\n      }\n      \n      // Show success notification\n      this.showNotification('Your playlists have been processed successfully', 'success', 'Processing Complete');\n      \n      // Stop polling\n      if (state.statusPollInterval) {\n        clearInterval(state.statusPollInterval);\n        state.statusPollInterval = null;\n      }\n      \n      // Clear completion monitoring\n      this.clearCompletionMonitoring();\n      \n      // Emit completion event\n      if (eventRegistry && typeof eventRegistry.emit === 'function') {\n        eventRegistry.emit('playlist.processing.completed', data);\n      }\n    } catch (error) {\n      console.error('Error handling playlist completion:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'handlePlaylistCompletion',\n          context: 'task completion',\n          data: {\n            taskId: data?.task_id,\n            status: data?.status\n          }\n        });\n      }\n      \n      // Try to show results anyway\n      try {\n        this.showResult(data || { output_file: state.outputFilePath });\n      } catch (e) {\n        console.error('Failed to show results after error:', e);\n      }\n    }\n  },\n\n  /**\n   * Handle task error\n   * @param {Object} data - Error data\n   */\n  handleTaskError(data) {\n    try {\n      // Skip if already handled\n      if (state.completionState.error) {\n        return;\n      }\n      \n      console.log('Handling task error:', data);\n      \n      // Mark as error\n      state.completionState.error = true;\n      state.processing = false;\n      \n      // Clean up session storage\n      sessionStorage.removeItem('ongoingTaskId');\n      sessionStorage.removeItem('ongoingTaskType');\n      \n      // Handle error in progressHandler\n      if (state.progressTracker && typeof state.progressTracker.error === 'function') {\n        state.progressTracker.error(data.error || 'Unknown error');\n      } else if (window.progressHandler && typeof window.progressHandler.errorTask === 'function') {\n        window.progressHandler.errorTask(data.task_id, data.error || 'Unknown error', data);\n      }\n      \n      // Update UI\n      this.showPlaylistError(data.error || 'An error occurred during processing');\n      \n      // Update state manager\n      if (stateManager && typeof stateManager.setProcessingActive === 'function') {\n        stateManager.setProcessingActive(false);\n      }\n      \n      // Clear polling\n      if (state.statusPollInterval) {\n        clearInterval(state.statusPollInterval);\n        state.statusPollInterval = null;\n      }\n      \n      // Clear completion monitoring\n      this.clearCompletionMonitoring();\n      \n      // Emit error event\n      if (eventRegistry && typeof eventRegistry.emit === 'function') {\n        eventRegistry.emit('playlist.processing.error', data);\n      }\n    } catch (error) {\n      console.error('Error handling task error:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'handleTaskError',\n          context: 'error handling',\n          data: {\n            taskId: data?.task_id,\n            error: data?.error\n          }\n        });\n      }\n      \n      // Try to show form anyway\n      this.showPlaylistForm();\n    }\n  },\n\n  /**\n   * Handle task cancellation\n   * @param {Object} data - Cancellation data\n   */\n  handleTaskCancelled(data) {\n    try {\n      // Skip if already handled\n      if (state.completionState.cancelled) {\n        return;\n      }\n      \n      console.log('Handling task cancellation:', data);\n      \n      // Mark as cancelled\n      state.completionState.cancelled = true;\n      state.processing = false;\n      \n      // Clean up session storage\n      sessionStorage.removeItem('ongoingTaskId');\n      sessionStorage.removeItem('ongoingTaskType');\n      \n      // Handle cancellation in progressHandler\n      if (state.progressTracker && typeof state.progressTracker.cancel === 'function') {\n        state.progressTracker.cancel();\n      } else if (window.progressHandler && typeof window.progressHandler.cancelTracking === 'function') {\n        window.progressHandler.cancelTracking(data.task_id || state.currentTaskId);\n      }\n      \n      // Show form\n      this.showPlaylistForm();\n      \n      // Update state manager\n      if (stateManager && typeof stateManager.setProcessingActive === 'function') {\n        stateManager.setProcessingActive(false);\n      }\n      \n      // Clear polling\n      if (state.statusPollInterval) {\n        clearInterval(state.statusPollInterval);\n        state.statusPollInterval = null;\n      }\n      \n      // Clear completion monitoring\n      this.clearCompletionMonitoring();\n      \n      // Show notification\n      this.showNotification('The playlist processing has been cancelled', 'warning', 'Task Cancelled');\n      \n      // Emit cancelled event\n      if (eventRegistry && typeof eventRegistry.emit === 'function') {\n        eventRegistry.emit('playlist.processing.cancelled', data);\n      }\n    } catch (error) {\n      console.error('Error handling task cancellation:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'handleTaskCancelled',\n          context: 'task cancellation',\n          data: {\n            taskId: data?.task_id\n          }\n        });\n      }\n      \n      // Try to show form anyway\n      this.showPlaylistForm();\n    }\n  },\n\n  /**\n     * Add task to history\n     * @param {Object} data - Task data\n     */\n  addTaskToHistory(data) {\n    if (!data) return;\n    \n    try {\n      console.log('Adding task to history:', data);\n      \n      // Prepare task data\n      const taskData = {\n        task_id: data.task_id || state.currentTaskId,\n        type: 'playlist',\n        status: 'completed',\n        timestamp: Date.now(),\n        filename: this.getFileNameFromPath(data.output_file),\n        inputPath: data.root_directory,\n        outputPath: data.output_file,\n        stats: data.stats || {}\n      };\n      \n      // Use historyManager if available\n      if (historyManager && typeof historyManager.addTaskToHistory === 'function') {\n        historyManager.addTaskToHistory(taskData);\n        \n        // Also add to recent files if output file is available\n        if (data.output_file && typeof historyManager.addFileToRecent === 'function') {\n          historyManager.addFileToRecent({\n            path: data.output_file,\n            name: this.getFileNameFromPath(data.output_file),\n            lastAccessed: Date.now()\n          });\n        }\n        \n        return true;\n      }\n      \n      // Try to emit event to add history\n      if (eventRegistry && typeof eventRegistry.emit === 'function') {\n        eventRegistry.emit('history.add', {\n          type: 'playlist',\n          name: data.output_file ? this.getFileNameFromPath(data.output_file) : 'Playlist Data',\n          data: taskData\n        });\n        \n        return true;\n      }\n      \n      // Fallback to localStorage\n      try {\n        const historyItems = JSON.parse(localStorage.getItem('taskHistory') || '[]');\n        historyItems.unshift(taskData);\n        \n        // Limit history items\n        if (historyItems.length > 50) {\n          historyItems.length = 50;\n        }\n        \n        localStorage.setItem('taskHistory', JSON.stringify(historyItems));\n        return true;\n      } catch (storageError) {\n        console.warn('Failed to store task in localStorage:', storageError);\n      }\n      \n      return false;\n    } catch (error) {\n      console.error('Error adding task to history:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'addTaskToHistory',\n          context: 'history management'\n        });\n      }\n      return false;\n    }\n  },\n\n  /**\n   * Get filename from path\n   * @param {string} path - File path\n   * @returns {string} - Filename\n   */\n  getFileNameFromPath(path) {\n    if (!path) return 'Unknown';\n    \n    // Use historyManager if available\n    if (historyManager && typeof historyManager.getFileNameFromPath === 'function') {\n      return historyManager.getFileNameFromPath(path);\n    }\n    \n    try {\n      // Extract file name from path\n      const parts = path.split(/[\\/\\\\]/);\n      return parts[parts.length - 1] || 'Unknown';\n    } catch (error) {\n      console.warn('Error extracting filename from path:', error);\n      return 'Unknown';\n    }\n  },\n\n  /**\n   * Show playlist form\n   */\n  showPlaylistForm() {\n    try {\n      // Get UI elements\n      const formContainer = getElement('playlist-form-container');\n      const progressContainer = getElement('playlist-progress-container');\n      const resultsContainer = getElement('playlist-results-container');\n      const errorContainer = getElement('playlist-error-container');\n      \n      // Hide all other containers\n      if (progressContainer) toggleElementVisibility(progressContainer, false);\n      if (resultsContainer) toggleElementVisibility(resultsContainer, false);\n      if (errorContainer) toggleElementVisibility(errorContainer, false);\n      \n      // Show form container\n      if (formContainer) toggleElementVisibility(formContainer, true);\n      \n      // Reset UI state\n      state.uiState = {\n        isFormShown: true,\n        isResultShown: false,\n        isErrorShown: false,\n        isCancelledShown: false\n      };\n      \n      // Reset any button states\n      const submitBtn = getElement('playlist-submit-btn');\n      if (submitBtn) {\n        submitBtn.disabled = false;\n        submitBtn.innerHTML = '<i class=\"fas fa-play me-2\"></i>Start Processing';\n      }\n    } catch (error) {\n      console.error('Error showing playlist form:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'showPlaylistForm',\n          context: 'UI update'\n        });\n      }\n    }\n  },\n\n  /**\n   * Show progress UI\n   */\n  showProgress() {\n    try {\n      // Get UI elements\n      const formContainer = getElement('playlist-form-container');\n      const progressContainer = getElement('playlist-progress-container');\n      const resultsContainer = getElement('playlist-results-container');\n      const errorContainer = getElement('playlist-error-container');\n      \n      // Hide all other containers\n      if (formContainer) toggleElementVisibility(formContainer, false);\n      if (resultsContainer) toggleElementVisibility(resultsContainer, false);\n      if (errorContainer) toggleElementVisibility(errorContainer, false);\n      \n      // Show progress container\n      if (progressContainer) toggleElementVisibility(progressContainer, true);\n      \n      // Reset progress display if needed\n      const progressBar = getElement('playlist-progress-bar');\n      if (progressBar) {\n        // Initialize progress bar styling\n        this.initializeProgressBarStyling(progressBar);\n        \n        // Set initial progress value\n        progressBar.style.width = '0%';\n        progressBar.setAttribute('aria-valuenow', 0);\n        progressBar.textContent = '0%';\n      }\n      \n      // Reset progress status\n      const progressStatus = getElement('playlist-progress-status');\n      if (progressStatus) {\n        progressStatus.textContent = 'Initializing...';\n      }\n      \n      // Reset progress stats\n      const progressStats = getElement('playlist-progress-stats');\n      if (progressStats) {\n        progressStats.innerHTML = '';\n      }\n      \n      // Update UI state\n      state.uiState = {\n        isFormShown: false,\n        isProgressShown: true,\n        isResultShown: false,\n        isErrorShown: false\n      };\n    } catch (error) {\n      console.error('Error showing progress UI:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'showProgress',\n          context: 'UI update'\n        });\n      }\n    }\n  },\n\n  /**\n   * Show result UI\n   * @param {Object} data - Result data\n   */\n  showResult(data) {\n    try {\n      // Skip if already showing result\n      if (state.uiState.isResultShown) {\n        return;\n      }\n      \n      console.log('Showing result UI:', data);\n      \n      // Get UI elements\n      const formContainer = getElement('playlist-form-container');\n      const progressContainer = getElement('playlist-progress-container');\n      const resultsContainer = getElement('playlist-results-container');\n      const errorContainer = getElement('playlist-error-container');\n      \n      // Hide all other containers\n      if (formContainer) toggleElementVisibility(formContainer, false);\n      if (progressContainer) toggleElementVisibility(progressContainer, false);\n      if (errorContainer) toggleElementVisibility(errorContainer, false);\n      \n      // Update result elements\n      const jsonPath = getElement('playlist-json-path');\n      if (jsonPath) {\n        const outputFile = data.output_file || state.outputFilePath;\n        jsonPath.textContent = outputFile || 'Unknown';\n      }\n      \n      // Set output file for the open button\n      const openBtn = getElement('open-playlist-json');\n      if (openBtn) {\n        openBtn.setAttribute('data-output-file', data.output_file || state.outputFilePath || '');\n      }\n      \n      // Update statistics if available\n      const statsContainer = getElement('playlist-result-stats');\n      if (statsContainer && data.stats) {\n        let statsHtml = '<div class=\"stats-container p-3\">';\n        \n        // Add playlists stats\n        if (data.stats.total_playlists !== undefined) {\n          statsHtml += `\n            <h6 class=\"mb-3\">Processing Summary</h6>\n            <div class=\"row g-3 mb-3\">\n              <div class=\"col-md-6\">\n                <div class=\"card h-100\">\n                  <div class=\"card-body\">\n                    <h6 class=\"card-title\"><i class=\"fas fa-list me-2\"></i>Playlists</h6>\n                    <div class=\"d-flex flex-wrap gap-2 mt-3\">\n                      <span class=\"badge bg-primary\">Total: ${data.stats.total_playlists || 0}</span>\n                      <span class=\"badge bg-success\">Processed: ${data.stats.processed_playlists || 0}</span>\n                      <span class=\"badge bg-warning\">Skipped: ${data.stats.skipped_playlists || 0}</span>\n                      <span class=\"badge bg-danger\">Errors: ${data.stats.failed_playlists || 0}</span>\n                    </div>\n                  </div>\n                </div>\n              </div>\n              <div class=\"col-md-6\">\n                <div class=\"card h-100\">\n                  <div class=\"card-body\">\n                    <h6 class=\"card-title\"><i class=\"fas fa-video me-2\"></i>Videos</h6>\n                    <div class=\"d-flex flex-wrap gap-2 mt-3\">\n                      <span class=\"badge bg-primary\">Total: ${data.stats.total_videos || 0}</span>\n                      <span class=\"badge bg-success\">Downloaded: ${data.stats.processed_videos || 0}</span>\n                      <span class=\"badge bg-warning\">Skipped: ${data.stats.skipped_videos || 0}</span>\n                      <span class=\"badge bg-danger\">Errors: ${data.stats.failed_videos || 0}</span>\n                    </div>\n                  </div>\n                </div>\n              </div>\n            </div>\n          `;\n        }\n        \n        // Add processing time if available\n        if (data.stats.elapsed_seconds || data.stats.elapsed_time_seconds || \n            (state.processingStartTime && state.completionState.completionTime)) {\n          \n          const elapsedSeconds = data.stats.elapsed_seconds || data.stats.elapsed_time_seconds || \n                              ((state.completionState.completionTime - state.processingStartTime) / 1000);\n          \n          statsHtml += `\n            <div class=\"row mb-3\">\n              <div class=\"col-12\">\n                <div class=\"card\">\n                  <div class=\"card-body\">\n                    <h6 class=\"card-title\"><i class=\"fas fa-clock me-2\"></i>Processing Time</h6>\n                    <p class=\"mb-0 mt-2\">${this.formatDuration(elapsedSeconds)}</p>\n                  </div>\n                </div>\n              </div>\n            </div>\n          `;\n        }\n        \n        // Add output file details\n        const outputFile = data.output_file || state.outputFilePath;\n        if (outputFile) {\n          statsHtml += `\n            <div class=\"row\">\n              <div class=\"col-12\">\n                <div class=\"card\">\n                  <div class=\"card-body\">\n                    <h6 class=\"card-title\"><i class=\"fas fa-file-alt me-2\"></i>Output File</h6>\n                    <p class=\"mb-0 mt-2 text-truncate\">\n                      <code>${outputFile}</code>\n                    </p>\n                  </div>\n                </div>\n              </div>\n            </div>\n          `;\n        }\n        \n        statsHtml += '</div>';\n        statsContainer.innerHTML = statsHtml;\n      }\n      \n      // Show results container\n      if (resultsContainer) toggleElementVisibility(resultsContainer, true);\n      \n      // Update UI state\n      state.uiState = {\n        isFormShown: false,\n        isProgressShown: false,\n        isResultShown: true,\n        isErrorShown: false\n      };\n    } catch (error) {\n      console.error('Error showing result UI:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'showResult',\n          context: 'UI update'\n        });\n      }\n    }\n  },\n\n  /**\n   * Show error UI\n   * @param {string} errorMessage - Error message\n   */\n  showPlaylistError(errorMessage) {\n    try {\n      // Skip if already showing error\n      if (state.uiState.isErrorShown) {\n        return;\n      }\n      \n      console.log('Showing error UI:', errorMessage);\n      \n      // Get UI elements\n      const formContainer = getElement('playlist-form-container');\n      const progressContainer = getElement('playlist-progress-container');\n      const resultsContainer = getElement('playlist-results-container');\n      const errorContainer = getElement('playlist-error-container');\n      const errorText = getElement('playlist-error-text');\n      \n      // Hide all other containers\n      if (formContainer) toggleElementVisibility(formContainer, false);\n      if (progressContainer) toggleElementVisibility(progressContainer, false);\n      if (resultsContainer) toggleElementVisibility(resultsContainer, false);\n      \n      // Update error message\n      if (errorText) {\n        errorText.textContent = errorMessage || 'An unknown error occurred';\n      }\n      \n      // Show error container\n      if (errorContainer) toggleElementVisibility(errorContainer, true);\n      \n      // Update UI state\n      state.uiState = {\n        isFormShown: false,\n        isProgressShown: false,\n        isResultShown: false,\n        isErrorShown: true\n      };\n      \n      // Update state\n      state.processing = false;\n      state.completionState.error = true;\n      \n      // Show error toast\n      this.showToast('Error', errorMessage || 'An unknown error occurred', 'error');\n    } catch (error) {\n      console.error('Error showing error UI:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'showPlaylistError',\n          context: 'UI update'\n        });\n      }\n      \n      // Fallback - alert\n      if (errorMessage) {\n        alert(`Error: ${errorMessage}`);\n      }\n    }\n  },\n\n  /**\n   * Show toast notification\n   * @param {string} title - Toast title\n   * @param {string} message - Toast message\n   * @param {string} type - Toast type (info, success, warning, error)\n   */\n  showToast(title, message, type = 'info') {\n    try {\n      // Use UI module if available\n      if (window.ui && typeof window.ui.showToast === 'function') {\n        window.ui.showToast(title, message, type);\n        return;\n      }\n      \n      // Fallback: Find toast container\n      const toastContainer = document.getElementById('toast-container') || \n        (() => {\n          const container = document.createElement('div');\n          container.id = 'toast-container';\n          container.className = 'toast-container position-fixed bottom-0 end-0 p-3';\n          document.body.appendChild(container);\n          return container;\n        })();\n      \n      // Create toast element\n      const toast = document.createElement('div');\n      toast.className = `toast show bg-${type === 'error' ? 'danger' : type}`;\n      toast.setAttribute('role', 'alert');\n      toast.innerHTML = `\n        <div class=\"toast-header\">\n          <strong class=\"me-auto\">${title}</strong>\n          <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"toast\"></button>\n        </div>\n        <div class=\"toast-body text-white\">\n          ${message}\n        </div>\n      `;\n      \n      // Add to container\n      toastContainer.appendChild(toast);\n      \n      // Auto remove after delay\n      setTimeout(() => toast.remove(), 5000);\n    } catch (error) {\n      console.error('Error showing toast:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'showToast',\n          context: 'UI update'\n        });\n      }\n    }\n  },\n\n  /**\n   * Handle cancel button click\n   */\n  handleCancelButtonClick() {\n    try {\n      if (!state.currentTaskId || !state.processing) {\n        console.warn('No active task to cancel');\n        return;\n      }\n      \n      // Confirm cancellation\n      if (confirm('Are you sure you want to cancel the current download?')) {\n        this.cancelDownload(state.currentTaskId);\n      }\n    } catch (error) {\n      console.error('Error handling cancel button click:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'handleCancelButtonClick',\n          context: 'UI interaction'\n        });\n      }\n    }\n  },\n\n  /**\n   * Handle new task button click\n   */\n  handleNewTaskClick() {\n    try {\n      // Reset state\n      state.currentTaskId = null;\n      state.processing = false;\n      state.completionState = {\n        completed: false,\n        completionTime: null,\n        error: false,\n        cancelled: false\n      };\n      \n      // Clear session storage\n      sessionStorage.removeItem('ongoingTaskId');\n      sessionStorage.removeItem('ongoingTaskType');\n      sessionStorage.removeItem('outputFile');\n      \n      // Show form\n      this.showPlaylistForm();\n    } catch (error) {\n      console.error('Error handling new task click:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'handleNewTaskClick',\n          context: 'UI interaction'\n        });\n      }\n    }\n  },\n\n  /**\n   * Cancel download\n   * @param {string} taskId - Task ID to cancel\n   * @returns {Promise<boolean>} - Success state\n   */\n  async cancelDownload(taskId) {\n    try {\n      const targetTaskId = taskId || state.currentTaskId;\n      if (!targetTaskId) {\n        console.warn('No task ID provided for cancellation');\n        return false;\n      }\n      \n      console.log(`Cancelling download task: ${targetTaskId}`);\n      \n      // Mark as cancelled in state\n      state.isProcessingCancelled = true;\n      state.processing = false;\n      state.completionState.cancelled = true;\n      \n      // Use socket for cancellation if available\n      if (window.socket && typeof window.socket.emit === 'function') {\n        window.socket.emit(SOCKET_EVENTS.CLIENT_TO_SERVER.CANCEL_TASK, { task_id: targetTaskId });\n        \n        // As a fallback, also try API\n        try {\n          const cancelEndpoint = PLAYLIST_CONFIG.endpoints.CANCEL.replace(':taskId', targetTaskId);\n          await fetch(cancelEndpoint, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n              'X-API-Key': localStorage.getItem('api_key') || ''\n            },\n            timeout: 5000\n          });\n        } catch (apiError) {\n          console.warn('API cancellation failed, socket cancellation may still succeed');\n        }\n      } else {\n        // Use centralized configuration directly\n        const cancelEndpoint = PLAYLIST_CONFIG.endpoints.CANCEL.replace(':taskId', targetTaskId);\n        await fetch(cancelEndpoint, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'X-API-Key': localStorage.getItem('api_key') || ''\n          },\n          timeout: 5000\n        });\n      }\n      \n      // Cancel any pending requests\n      if (state.pendingRequests[targetTaskId]) {\n        state.pendingRequests[targetTaskId].abort();\n        delete state.pendingRequests[targetTaskId];\n      }\n      \n      // Cancel progress tracking\n      if (state.progressTracker && typeof state.progressTracker.cancel === 'function') {\n        state.progressTracker.cancel();\n      }\n      \n      // Stop status polling\n      if (state.statusPollInterval) {\n        clearInterval(state.statusPollInterval);\n        state.statusPollInterval = null;\n      }\n      \n      // Remove from session storage\n      sessionStorage.removeItem('ongoingTaskId');\n      sessionStorage.removeItem('ongoingTaskType');\n      \n      // Update state manager\n      if (stateManager && typeof stateManager.setProcessingActive === 'function') {\n        stateManager.setProcessingActive(false);\n      }\n      \n      // Show form UI\n      this.showPlaylistForm();\n      \n      // Show notification\n      this.showToast('Cancelled', 'Download has been cancelled', 'warning');\n      \n      // Emit event\n      if (eventRegistry && typeof eventRegistry.emit === 'function') {\n        eventRegistry.emit('playlist.processing.cancelled', { task_id: targetTaskId });\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('Error cancelling download:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'cancelDownload',\n          context: 'task cancellation',\n          taskId: taskId\n        });\n      }\n      return false;\n    }\n  },\n\n  /**\n   * Open file or folder\n   * @param {string} path - Path to open\n   */\n  async openFileOrFolder(path) {\n    try {\n      if (!path) {\n        console.warn('No path provided to open');\n        return;\n      }\n      \n      // Check if fileHandler is available\n      if (window.fileHandler && typeof window.fileHandler.openFile === 'function') {\n        await window.fileHandler.openFile(path);\n        return;\n      }\n      \n      // Use Blueprint API as fallback\n      await blueprintApi.openFile(path);\n      \n      console.log(`File opened: ${path}`);\n    } catch (error) {\n      console.error('Error opening file or folder:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'openFileOrFolder',\n          context: 'file operation',\n          path: path\n        });\n      }\n      \n      this.showToast('Error', `Failed to open file: ${error.message}`, 'error');\n    }\n  },\n\n  /**\n   * Fetch with retry for API requests\n   * @param {string} url - URL to fetch\n   * @param {Object} options - Fetch options\n   * @returns {Promise<Response>} - Fetch response\n   */\n  async fetchWithRetry(url, options = {}) {\n    let retries = 0;\n    let lastError = null;\n    \n    while (retries < state.apiRetryCount) {\n      try {\n        // Add timeout\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), API_TIMEOUT_MS);\n        \n        const response = await fetch(url, {\n          ...options,\n          signal: controller.signal\n        });\n        \n        // Clear timeout\n        clearTimeout(timeoutId);\n        \n        return response;\n      } catch (error) {\n        lastError = error;\n        retries++;\n        \n        // If processing is cancelled, don't retry\n        if (state.isProcessingCancelled) {\n          throw new Error('Operation cancelled');\n        }\n        \n        // Don't retry if AbortError (timeout or cancellation)\n        if (error.name === 'AbortError') {\n          throw error;\n        }\n        \n        // Exponential backoff\n        const delay = state.apiRetryDelay * Math.pow(2, retries - 1);\n        \n        console.warn(`API request failed, retrying (${retries}/${state.apiRetryCount}) in ${delay}ms:`, error);\n        \n        // Wait before retrying\n        await new Promise(resolve => setTimeout(resolve, delay));\n      }\n    }\n    \n    // If we get here, all retries failed\n    throw lastError || new Error('API request failed after retries');\n  },\n\n  /**\n   * Cleanup resources\n   */\n  cleanup() {\n    try {\n      console.log('Cleaning up playlist downloader module...');\n      \n      // Cancel any active downloads\n      if (state.currentTaskId && state.processing) {\n        try {\n          this.cancelDownload(state.currentTaskId);\n        } catch (cancelError) {\n          console.warn('Error during cancellation on cleanup:', cancelError);\n        }\n      }\n      \n      // Clear status polling\n      if (state.statusPollInterval) {\n        clearInterval(state.statusPollInterval);\n        state.statusPollInterval = null;\n      }\n      \n      // Cancel any pending requests\n      Object.keys(state.pendingRequests).forEach(taskId => {\n        try {\n          state.pendingRequests[taskId].abort();\n        } catch (abortError) {\n          console.warn(`Error aborting request for task ${taskId}:`, abortError);\n        }\n        delete state.pendingRequests[taskId];\n      });\n      \n      // Clear monitoring timeouts\n      this.clearCompletionMonitoring();\n      \n      // Reset state\n      state.initialized = false;\n      state.processing = false;\n      state.currentTaskId = null;\n      \n      // Remove event listeners if eventRegistry is available\n      if (eventRegistry && typeof eventRegistry.off === 'function') {\n        eventRegistry.off('socket.progress_update');\n        eventRegistry.off('socket.playlist_progress');\n        eventRegistry.off('socket.task_completed');\n        eventRegistry.off('socket.playlist_completed');\n        eventRegistry.off('socket.task_error');\n        eventRegistry.off('socket.playlist_error');\n        eventRegistry.off('socket.task_cancelled');\n        eventRegistry.off('socket.playlist_cancelled');\n        eventRegistry.off('socket.connected');\n        eventRegistry.off('socket.disconnected');\n        eventRegistry.off('playlist.processing.resume');\n      }\n      \n      console.log('Playlist downloader module cleanup complete');\n      return true;\n    } catch (error) {\n      console.error('Error during playlist downloader cleanup:', error);\n      if (errorHandler && typeof errorHandler.reportError === 'function') {\n        errorHandler.reportError(error, {\n          module: 'playlistDownloader',\n          method: 'cleanup',\n          context: 'module cleanup'\n        });\n      }\n      return false;\n    }\n  }\n  };\n\n// Export default function to create and initialize the module\nexport default function initPlaylistDownloader() {\n// Initialize immediately (async) but don't wait\nplaylistDownloader.initialize();\n\n// Return the module API\nreturn {\n  initialize: playlistDownloader.initialize.bind(playlistDownloader),\n  handlePlaylistSubmit: playlistDownloader.handlePlaylistSubmit.bind(playlistDownloader),\n  cancelDownload: playlistDownloader.cancelDownload.bind(playlistDownloader),\n  addPlaylistField: playlistDownloader.addPlaylistField.bind(playlistDownloader),\n  showPlaylistForm: playlistDownloader.showPlaylistForm.bind(playlistDownloader),\n  showResult: playlistDownloader.showResult.bind(playlistDownloader),\n  handleNewTaskClick: playlistDownloader.handleNewTaskClick.bind(playlistDownloader),\n  cleanup: playlistDownloader.cleanup.bind(playlistDownloader),\n  isInitialized: () => state.initialized,\n  isProcessing: () => state.processing,\n  getState: () => ({\n    currentTaskId: state.currentTaskId,\n    processing: state.processing,\n    completed: state.completionState.completed,\n    error: state.completionState.error,\n    cancelled: state.completionState.cancelled,\n    progress: state.lastReportedProgress\n  }),\n\n  /**\n   * Test backend connectivity and configuration\n   */\n  async testBackendConnectivity() {\n    try {\n      console.log('🔗 Testing Playlist Downloader backend connectivity...');\n      \n      const response = await fetch(PLAYLIST_CONFIG.endpoints.HEALTH, {\n        method: 'GET',\n        headers: {\n          'X-API-Key': localStorage.getItem('api_key') || ''\n        },\n        timeout: 5000\n      });\n      \n      if (response.ok) {\n        const data = await response.json();\n        console.log('✅ Playlist Downloader backend connectivity confirmed:', data);\n        state.backendConnected = true;\n        return true;\n      } else {\n        console.warn('⚠️ Playlist Downloader backend health check failed:', response.status);\n        state.backendConnected = false;\n        return false;\n      }\n    } catch (error) {\n      console.warn('⚠️ Playlist Downloader backend connectivity test failed:', error.message);\n      state.backendConnected = false;\n      return false;\n    }\n  },\n\n  /**\n   * Enhanced notification system with 4-method delivery\n   */\n  showNotification(message, type = 'info', title = 'Playlist Downloader') {\n    // Method 1: Toast notifications\n    this.showToast(title, message, type);\n    \n    // Method 2: Console logging with styling\n    const styles = {\n      error: 'color: #dc3545; font-weight: bold;',\n      warning: 'color: #fd7e14; font-weight: bold;',\n      success: 'color: #198754; font-weight: bold;',\n      info: 'color: #0d6efd;'\n    };\n    console.log(`%c[${title}] ${message}`, styles[type] || styles.info);\n    \n    // Method 3: System notification (if available)\n    if (window.NeuroGen?.notificationHandler) {\n      window.NeuroGen.notificationHandler.show({\n        title,\n        message,\n        type,\n        module: 'playlistDownloader'\n      });\n    }\n    \n    // Method 4: Error reporting to centralized handler\n    if (type === 'error' && window.NeuroGen?.errorHandler) {\n      window.NeuroGen.errorHandler.logError({\n        module: 'playlistDownloader',\n        message,\n        severity: type\n      });\n    }\n  },\n\n  /**\n   * Get module health status with configuration details\n   */\n  getHealthStatus() {\n    return {\n      module: 'playlistDownloader',\n      version: '3.1.0',\n      initialized: state.initialized,\n      processing: state.processing,\n      backendConnected: state.backendConnected || false,\n      currentTask: state.currentTaskId ? {\n        id: state.currentTaskId,\n        startTime: state.processingStartTime,\n        progress: state.lastReportedProgress || 0\n      } : null,\n      configuration: {\n        endpoints: {\n          start: PLAYLIST_CONFIG.endpoints.START,\n          cancel: PLAYLIST_CONFIG.endpoints.CANCEL,\n          health: PLAYLIST_CONFIG.endpoints.HEALTH,\n          configLoaded: !!PLAYLIST_CONFIG.endpoints\n        },\n        constants: {\n          maxProgressRates: MAX_PROGRESS_RATES,\n          apiTimeout: API_TIMEOUT_MS,\n          pollInterval: PROGRESS_POLL_INTERVAL_MS\n        }\n      },\n      dependencies: {\n        socket: !!window.socket?.connected,\n        constants: !!CONSTANTS,\n        taskEvents: !!TASK_EVENTS,\n        socketEvents: !!SOCKET_EVENTS\n      },\n      state: {\n        currentTaskId: state.currentTaskId,\n        processing: state.processing,\n        completed: state.completionState.completed,\n        error: state.completionState.error,\n        cancelled: state.completionState.cancelled,\n        outputFilePath: state.outputFilePath\n      }\n    };\n  }\n};\n}","source":"/workspace/modules/static/js/modules/features/playlistDownloader.js","title":"playlistDownloader.js","language":"en"},{"content":"/**\n * Create results UI with improved design and functionality\n * This updated function implements better stats display with enhanced styling and animations\n * @param {Object} data - Completion data from the server\n * @returns {boolean} - Success status\n */\nfunction createResultsUI(data = {}) {\n  try {\n    console.log(\"Creating results UI elements with enhanced display\");\n    \n    // Find a suitable container using multiple fallback approaches\n    let container = document.getElementById('playlist-tab');\n    \n    if (!container) {\n      container = document.getElementById('main-content');\n    }\n    \n    if (!container) {\n      container = document.querySelector('.container');\n    }\n    \n    if (!container) {\n      container = document.body;\n    }\n    \n    if (!container) {\n      console.error(\"Could not find any container for results UI\");\n      return false;\n    }\n    \n    // Check if results container already exists\n    const existingContainer = document.getElementById('playlist-results-container');\n    if (existingContainer) {\n      console.log(\"Results UI elements already exist, updating content\");\n      // Update existing stats display\n      const statsElement = document.getElementById('playlist-stats');\n      if (statsElement && data.stats) {\n        updateResultStats(statsElement, data.stats, data.output_file);\n      }\n      \n      // Update the open JSON button\n      const openJsonBtn = document.getElementById('open-playlist-json');\n      if (openJsonBtn && data.output_file) {\n        openJsonBtn.setAttribute('data-output-file', data.output_file);\n        openJsonBtn.disabled = false;\n      }\n      \n      // Ensure event listeners are attached\n      ensureEventListenersOnResults();\n      \n      // Make sure the container is visible\n      existingContainer.style.display = 'block';\n      existingContainer.classList.remove('d-none');\n      \n      return true;\n    }\n    \n    // Create results container with modern design\n    const resultsContainer = document.createElement('div');\n    resultsContainer.id = 'playlist-results-container';\n    resultsContainer.className = 'card border-0 shadow-lg mb-4 animate__animated animate__fadeIn';\n    resultsContainer.style.display = 'none';\n    \n    // Create results UI with dynamic layout - improved look and feel\n    resultsContainer.innerHTML = `\n      <div class=\"card-header bg-light py-3\">\n        <div class=\"d-flex align-items-center\">\n          <div class=\"success-icon-container me-3\">\n            <div class=\"success-icon-circle\">\n              <i class=\"fas fa-check text-success fa-2x\"></i>\n            </div>\n          </div>\n          <div>\n            <h5 class=\"card-title mb-0 text-success\">Playlist Download Complete</h5>\n            <div class=\"text-muted small\">Your playlists have been successfully downloaded and processed</div>\n          </div>\n        </div>\n      </div>\n      \n      <div class=\"card-body\">\n        <div id=\"playlist-stats\" class=\"mt-2 mb-3\">\n          <!-- Stats will be populated here -->\n          <div class=\"text-center py-4\">\n            <div class=\"spinner-border text-primary\" role=\"status\">\n              <span class=\"visually-hidden\">Loading...</span>\n            </div>\n            <p class=\"mt-2 text-muted\">Loading statistics data...</p>\n          </div>\n        </div>\n        \n        <div class=\"d-flex justify-content-between mt-4 action-buttons\">\n          <div>\n            <button id=\"open-playlist-json\" class=\"btn btn-primary\" disabled>\n              <i class=\"fas fa-file-alt me-2\"></i>Open JSON File\n            </button>\n            <button id=\"open-playlist-folder\" class=\"btn btn-outline-secondary ms-2\">\n              <i class=\"fas fa-folder-open me-2\"></i>Open Folder\n            </button>\n          </div>\n          <div>\n            <button id=\"playlist-new-task-btn\" class=\"btn btn-outline-primary\">\n              <i class=\"fas fa-plus me-2\"></i>New Download\n            </button>\n          </div>\n        </div>\n      </div>\n      \n      <div class=\"card-footer bg-light p-3\">\n        <div class=\"d-flex align-items-center justify-content-between\">\n          <div class=\"small text-muted\">\n            <i class=\"fas fa-info-circle me-1\"></i> \n            Playlists can be accessed from the JSON file or the individual folders\n          </div>\n          <div class=\"actions-menu\">\n            <button id=\"add-to-favorites\" class=\"btn btn-sm btn-outline-warning me-2\">\n              <i class=\"fas fa-star me-1\"></i>Add to Favorites\n            </button>\n            <button id=\"copy-output-path\" class=\"btn btn-sm btn-outline-secondary\">\n              <i class=\"fas fa-copy me-1\"></i>Copy Path\n            </button>\n          </div>\n        </div>\n      </div>\n    `;\n    \n    // Add to container\n    container.appendChild(resultsContainer);\n    \n    // Add event listeners with improved error handling\n    attachEventListeners(resultsContainer, data);\n    \n    // Add custom CSS\n    addCustomResultsCSS();\n    \n    // Show the results container with animation\n    resultsContainer.style.display = 'block';\n    \n    // Update stats if available\n    if (data.stats) {\n      const statsElement = document.getElementById('playlist-stats');\n      if (statsElement) {\n        // Small delay for animation effect\n        setTimeout(() => {\n          updateResultStats(statsElement, data.stats, data.output_file);\n        }, 300);\n      }\n    }\n    \n    console.log(\"Results UI elements created successfully\");\n    return true;\n  } catch (error) {\n    console.error(\"Error creating results UI elements:\", error);\n    \n    // Try an even simpler approach as fallback\n    try {\n      console.log(\"Attempting simpler fallback UI creation\");\n      const container = document.body;\n      \n      const simpleResults = document.createElement('div');\n      simpleResults.id = 'playlist-results-container';\n      simpleResults.className = 'card m-3';\n      simpleResults.innerHTML = `\n        <div class=\"card-body\">\n          <h5 class=\"card-title text-success\">Download Complete</h5>\n          <div id=\"playlist-stats\" class=\"mt-3\"></div>\n          <button id=\"playlist-new-task-btn\" class=\"btn btn-primary mt-3\">\n            New Download\n          </button>\n        </div>\n      `;\n      \n      container.appendChild(simpleResults);\n      \n      // Add minimal event listener\n      const newTaskBtn = document.getElementById('playlist-new-task-btn');\n      if (newTaskBtn) {\n        newTaskBtn.addEventListener('click', handleNewTaskClick);\n      }\n      \n      // Update stats if available\n      if (data.stats) {\n        const statsElement = document.getElementById('playlist-stats');\n        if (statsElement) {\n          // Use simpler stats display for fallback\n          statsElement.innerHTML = `\n            <div class=\"alert alert-success\">\n              <p><strong>Output File:</strong> ${data.output_file || 'Unknown'}</p>\n              <p><strong>Playlists Processed:</strong> ${data.stats.total_playlists || 1}</p>\n              <p><strong>Videos Processed:</strong> ${data.stats.total_videos || 0}</p>\n            </div>\n          `;\n        }\n      }\n      \n      return true;\n    } catch (fallbackError) {\n      console.error(\"Error creating fallback UI:\", fallbackError);\n      return false;\n    }\n  }\n}\n\n/**\n * Attach event listeners to results UI elements with error handling\n * @param {HTMLElement} container - Results container\n * @param {Object} data - Completion data\n */\nfunction attachEventListeners(container, data) {\n  try {\n    // Open JSON button\n    const openJsonBtn = container.querySelector('#open-playlist-json');\n    if (openJsonBtn) {\n      openJsonBtn.addEventListener('click', function() {\n        const outputFile = this.getAttribute('data-output-file');\n        if (outputFile) {\n          fetch(`/api/open-file`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ path: outputFile })\n          })\n            .then(response => {\n              if (!response.ok) {\n                throw new Error(`Server responded with ${response.status}`);\n              }\n              return response.json();\n            })\n            .then(result => {\n              if (result.success) {\n                showToast('File Opened', 'JSON file has been opened', 'success');\n              } else {\n                showToast('Error', result.message || 'Could not open file', 'error');\n              }\n            })\n            .catch(error => {\n              console.error(\"Error opening file:\", error);\n              showToast('Error', 'Failed to open file: ' + error.message, 'error');\n            });\n        }\n      });\n      \n      // Set the output file if available\n      if (data.output_file) {\n        openJsonBtn.setAttribute('data-output-file', data.output_file);\n        openJsonBtn.disabled = false;\n      }\n    }\n    \n    // Open folder button with improved path extraction\n    const openFolderBtn = container.querySelector('#open-playlist-folder');\n    if (openFolderBtn) {\n      openFolderBtn.addEventListener('click', function() {\n        // Try to get folder path from the JSON button or from data\n        const jsonBtn = document.getElementById('open-playlist-json');\n        const outputFile = jsonBtn ? jsonBtn.getAttribute('data-output-file') : data.output_file;\n        \n        if (outputFile) {\n          // Extract directory from output file using more reliable path handling\n          const folderPath = outputFile.substring(0, Math.max(\n            outputFile.lastIndexOf('\\\\'), \n            outputFile.lastIndexOf('/')\n          ));\n          \n          // Open the folder with improved error handling\n          fetch(`/api/open-file`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ path: folderPath, isDirectory: true })\n          })\n            .then(response => {\n              if (!response.ok) {\n                throw new Error(`Server responded with ${response.status}`);\n              }\n              return response.json();\n            })\n            .then(result => {\n              if (result.success) {\n                showToast('Folder Opened', 'Output folder has been opened', 'success');\n              } else {\n                showToast('Error', result.message || 'Could not open folder', 'error');\n              }\n            })\n            .catch(error => {\n              console.error(\"Error opening folder:\", error);\n              showToast('Error', 'Failed to open folder: ' + error.message, 'error');\n            });\n        } else {\n          showToast('Error', 'Could not determine folder path', 'warning');\n        }\n      });\n    }\n    \n    // New task button\n    const newTaskBtn = container.querySelector('#playlist-new-task-btn');\n    if (newTaskBtn) {\n      newTaskBtn.addEventListener('click', handleNewTaskClick);\n    }\n    \n    // Add to favorites button with improved history manager support\n    const addToFavoritesBtn = container.querySelector('#add-to-favorites');\n    if (addToFavoritesBtn) {\n      addToFavoritesBtn.addEventListener('click', function() {\n        const jsonBtn = document.getElementById('open-playlist-json');\n        const outputFile = jsonBtn ? jsonBtn.getAttribute('data-output-file') : data.output_file;\n        \n        if (!outputFile) {\n          showToast('Error', 'Output file path not available', 'warning');\n          return;\n        }\n        \n        // Try multiple history manager options\n        try {\n          // First try imported historyManager\n          if (historyManager && typeof historyManager.addFavorite === 'function') {\n            historyManager.addFavorite({\n              type: 'playlist',\n              path: outputFile,\n              name: getFileNameFromPath(outputFile),\n              timestamp: Date.now()\n            });\n            \n            showToast('Added to Favorites', 'Playlist has been added to your favorites', 'success');\n            return;\n          }\n          \n          // Then try progressHandler's historyManager\n          if (progressHandler?.historyManager?.addFavorite) {\n            progressHandler.historyManager.addFavorite({\n              type: 'playlist',\n              path: outputFile,\n              name: getFileNameFromPath(outputFile),\n              timestamp: Date.now()\n            });\n            \n            showToast('Added to Favorites', 'Playlist has been added to your favorites', 'success');\n            return;\n          }\n          \n          // Try global historyManager\n          if (window.historyManager && typeof window.historyManager.addFavorite === 'function') {\n            window.historyManager.addFavorite({\n              type: 'playlist',\n              path: outputFile,\n              name: getFileNameFromPath(outputFile),\n              timestamp: Date.now()\n            });\n            \n            showToast('Added to Favorites', 'Playlist has been added to your favorites', 'success');\n            return;\n          }\n          \n          // Fallback - save to localStorage\n          const favorites = JSON.parse(localStorage.getItem('favorites') || '[]');\n          \n          // Check if already in favorites\n          const alreadyExists = favorites.some(fav => fav.path === outputFile);\n          if (alreadyExists) {\n            showToast('Already in Favorites', 'This playlist is already in your favorites', 'info');\n            return;\n          }\n          \n          // Add to favorites\n          favorites.unshift({\n            type: 'playlist',\n            path: outputFile,\n            name: getFileNameFromPath(outputFile),\n            timestamp: Date.now()\n          });\n          \n          // Limit favorites size\n          if (favorites.length > 50) {\n            favorites.pop();\n          }\n          \n          localStorage.setItem('favorites', JSON.stringify(favorites));\n          showToast('Added to Favorites', 'Playlist has been added to your favorites', 'success');\n        } catch (error) {\n          console.error(\"Error adding to favorites:\", error);\n          showToast('Error', 'Failed to add to favorites: ' + error.message, 'error');\n        }\n      });\n    }\n    \n    // Copy path button (new feature)\n    const copyPathBtn = container.querySelector('#copy-output-path');\n    if (copyPathBtn) {\n      copyPathBtn.addEventListener('click', function() {\n        const jsonBtn = document.getElementById('open-playlist-json');\n        const outputFile = jsonBtn ? jsonBtn.getAttribute('data-output-file') : data.output_file;\n        \n        if (outputFile) {\n          try {\n            // Modern clipboard API\n            navigator.clipboard.writeText(outputFile)\n              .then(() => {\n                showToast('Path Copied', 'Output file path copied to clipboard', 'success');\n                \n                // Highlight button for visual feedback\n                copyPathBtn.classList.add('btn-success');\n                copyPathBtn.classList.remove('btn-outline-secondary');\n                setTimeout(() => {\n                  copyPathBtn.classList.remove('btn-success');\n                  copyPathBtn.classList.add('btn-outline-secondary');\n                }, 1500);\n              })\n              .catch(err => {\n                console.error('Could not copy text: ', err);\n                showToast('Error', 'Could not copy to clipboard', 'error');\n              });\n          } catch (error) {\n            console.error(\"Error copying to clipboard:\", error);\n            \n            // Fallback for browsers that don't support clipboard API\n            try {\n              const tempInput = document.createElement('input');\n              tempInput.value = outputFile;\n              document.body.appendChild(tempInput);\n              tempInput.select();\n              document.execCommand('copy');\n              document.body.removeChild(tempInput);\n              \n              showToast('Path Copied', 'Output file path copied to clipboard', 'success');\n            } catch (fallbackError) {\n              console.error(\"Error using fallback clipboard method:\", fallbackError);\n              showToast('Error', 'Failed to copy path to clipboard', 'error');\n            }\n          }\n        } else {\n          showToast('Error', 'Output file path not available', 'warning');\n        }\n      });\n    }\n  } catch (error) {\n    console.error(\"Error attaching event listeners:\", error);\n  }\n}\n\n/**\n * Ensure event listeners are attached to the results UI elements\n * This is useful when the UI is already created but we need to ensure events are attached\n */\nfunction ensureEventListenersOnResults() {\n  try {\n    // Open JSON button\n    const openJsonBtn = document.getElementById('open-playlist-json');\n    if (openJsonBtn && !openJsonBtn._listenerAttached) {\n      openJsonBtn.addEventListener('click', function() {\n        const outputFile = this.getAttribute('data-output-file');\n        if (outputFile) {\n          fetch(`/api/open-file`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ path: outputFile })\n          })\n            .catch(error => console.error(\"Error opening file:\", error));\n        }\n      });\n      openJsonBtn._listenerAttached = true;\n    }\n    \n    // Open folder button\n    const openFolderBtn = document.getElementById('open-playlist-folder');\n    if (openFolderBtn && !openFolderBtn._listenerAttached) {\n      openFolderBtn.addEventListener('click', function() {\n        const jsonBtn = document.getElementById('open-playlist-json');\n        const outputFile = jsonBtn ? jsonBtn.getAttribute('data-output-file') : null;\n        \n        if (outputFile) {\n          const folderPath = outputFile.substring(0, Math.max(\n            outputFile.lastIndexOf('\\\\'), \n            outputFile.lastIndexOf('/')\n          ));\n          \n          fetch(`/api/open-file`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ path: folderPath, isDirectory: true })\n          })\n            .catch(error => console.error(\"Error opening folder:\", error));\n        }\n      });\n      openFolderBtn._listenerAttached = true;\n    }\n    \n    // New task button\n    const newTaskBtn = document.getElementById('playlist-new-task-btn');\n    if (newTaskBtn && !newTaskBtn._listenerAttached) {\n      newTaskBtn.addEventListener('click', handleNewTaskClick);\n      newTaskBtn._listenerAttached = true;\n    }\n    \n    // Add to favorites button\n    const addToFavoritesBtn = document.getElementById('add-to-favorites');\n    if (addToFavoritesBtn && !addToFavoritesBtn._listenerAttached) {\n      addToFavoritesBtn.addEventListener('click', function() {\n        const jsonBtn = document.getElementById('open-playlist-json');\n        const outputFile = jsonBtn ? jsonBtn.getAttribute('data-output-file') : null;\n        \n        if (outputFile) {\n          try {\n            // Try different historyManager implementations\n            if (historyManager && typeof historyManager.addFavorite === 'function') {\n              historyManager.addFavorite({\n                type: 'playlist',\n                path: outputFile,\n                name: getFileNameFromPath(outputFile),\n                timestamp: Date.now()\n              });\n            } else if (window.historyManager && typeof window.historyManager.addFavorite === 'function') {\n              window.historyManager.addFavorite({\n                type: 'playlist',\n                path: outputFile,\n                name: getFileNameFromPath(outputFile),\n                timestamp: Date.now()\n              });\n            } else {\n              // Fallback to localStorage\n              const favorites = JSON.parse(localStorage.getItem('favorites') || '[]');\n              favorites.unshift({\n                type: 'playlist',\n                path: outputFile,\n                name: getFileNameFromPath(outputFile),\n                timestamp: Date.now()\n              });\n              localStorage.setItem('favorites', JSON.stringify(favorites));\n            }\n            \n            showToast('Added to Favorites', 'Playlist has been added to your favorites', 'success');\n          } catch (error) {\n            console.error(\"Error adding to favorites:\", error);\n            showToast('Error', 'Failed to add to favorites', 'error');\n          }\n        } else {\n          showToast('Error', 'Output file path not available', 'warning');\n        }\n      });\n      addToFavoritesBtn._listenerAttached = true;\n    }\n    \n    // Copy path button\n    const copyPathBtn = document.getElementById('copy-output-path');\n    if (copyPathBtn && !copyPathBtn._listenerAttached) {\n      copyPathBtn.addEventListener('click', function() {\n        const jsonBtn = document.getElementById('open-playlist-json');\n        const outputFile = jsonBtn ? jsonBtn.getAttribute('data-output-file') : null;\n        \n        if (outputFile) {\n          try {\n            navigator.clipboard.writeText(outputFile)\n              .then(() => {\n                showToast('Path Copied', 'Output file path copied to clipboard', 'success');\n              })\n              .catch(err => {\n                console.error('Could not copy text: ', err);\n                \n                // Fallback method\n                const tempInput = document.createElement('input');\n                tempInput.value = outputFile;\n                document.body.appendChild(tempInput);\n                tempInput.select();\n                document.execCommand('copy');\n                document.body.removeChild(tempInput);\n                \n                showToast('Path Copied', 'Output file path copied to clipboard', 'success');\n              });\n          } catch (error) {\n            console.error(\"Error copying to clipboard:\", error);\n            showToast('Error', 'Failed to copy path to clipboard', 'error');\n          }\n        }\n      });\n      copyPathBtn._listenerAttached = true;\n    }\n  } catch (error) {\n    console.error(\"Error ensuring event listeners on results UI:\", error);\n  }\n}\n\n/**\n * Add custom CSS for results UI with enhanced styling\n */\nfunction addCustomResultsCSS() {\n  try {\n    // Check if we've already added the style\n    if (!document.querySelector('style[data-ui-style=\"playlist-results\"]')) {\n      const style = document.createElement('style');\n      style.setAttribute('data-ui-style', 'playlist-results');\n      style.textContent = `\n        /* Enhanced styling for results UI */\n        .success-icon-container {\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          width: 50px;\n          height: 50px;\n        }\n        \n        .success-icon-circle {\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          width: 42px;\n          height: 42px;\n          border-radius: 50%;\n          background-color: rgba(25, 135, 84, 0.1);\n          transition: all 0.3s ease;\n        }\n        \n        .success-icon-circle:hover {\n          transform: scale(1.1);\n          background-color: rgba(25, 135, 84, 0.2);\n        }\n        \n        .stats-container {\n          background-color: #f8f9fa;\n          border-radius: 12px;\n          margin-bottom: 20px;\n          transition: all 0.3s ease;\n          overflow: hidden;\n        }\n        \n        .stats-container:hover {\n          box-shadow: 0 10px 25px rgba(0,0,0,0.1);\n          transform: translateY(-3px);\n        }\n        \n        .stats-header {\n          padding: 18px 24px;\n          border-bottom: 1px solid rgba(0,0,0,0.08);\n          background-color: rgba(0,0,0,0.02);\n        }\n        \n        .stat-card {\n          background-color: white;\n          border-radius: 10px;\n          padding: 20px;\n          margin-bottom: 16px;\n          border: 1px solid rgba(0,0,0,0.05);\n          transition: transform 0.3s, box-shadow 0.3s;\n          box-shadow: 0 4px 12px rgba(0,0,0,0.03);\n        }\n        \n        .stat-card:hover {\n          transform: translateY(-5px);\n          box-shadow: 0 10px 20px rgba(0,0,0,0.1);\n        }\n        \n        .stat-card .icon {\n          font-size: 1.75rem;\n          margin-right: 15px;\n          color: #0d6efd;\n        }\n        \n        .stat-card .value {\n          font-size: 2rem;\n          font-weight: 700;\n          color: #212529;\n        }\n        \n        .stat-card .label {\n          font-size: 0.875rem;\n          color: #6c757d;\n          margin-top: 4px;\n        }\n        \n        .time-badge {\n          background-color: #6c757d;\n          color: white;\n          border-radius: 30px;\n          padding: 6px 12px;\n          font-weight: 600;\n          display: inline-flex;\n          align-items: center;\n        }\n        \n        .time-badge i {\n          margin-right: 8px;\n        }\n        \n        .icon-container {\n          display: flex;\n          align-items: center;\n          justify-content: center;\n          width: 56px;\n          height: 56px;\n          border-radius: 12px;\n          background-color: rgba(0,0,0,0.04);\n          transition: all 0.3s ease;\n        }\n        \n        .card:hover .icon-container {\n          transform: scale(1.05);\n        }\n        \n        /* Button animation for feedback */\n        .action-buttons .btn {\n          transition: all 0.2s ease;\n        }\n        \n        .action-buttons .btn:active {\n          transform: scale(0.95);\n        }\n        \n        /* Progress bar animations */\n        .progress {\n          overflow: hidden;\n          position: relative;\n        }\n        \n        .progress-bar {\n          transition: width 0.8s ease-in-out;\n        }\n        \n        .progress-bar::after {\n          content: '';\n          position: absolute;\n          top: 0;\n          left: 0;\n          right: 0;\n          bottom: 0;\n          background: linear-gradient(\n            90deg,\n            rgba(255,255,255,0) 0%,\n            rgba(255,255,255,0.2) 50%,\n            rgba(255,255,255,0) 100%\n          );\n          width: 50%;\n          background-size: 200% 200%;\n          animation: shimmer 2s infinite;\n        }\n        \n        @keyframes shimmer {\n          0% { background-position: -200% 0; }\n          100% { background-position: 200% 0; }\n        }\n        \n        /* Responsive adjustments */\n        @media (max-width: 768px) {\n          .row .col-md-4 {\n            margin-bottom: 15px;\n          }\n          \n          .action-buttons {\n            flex-direction: column;\n            gap: 10px;\n          }\n          \n          .action-buttons > div {\n            width: 100%;\n            display: flex;\n            justify-content: center;\n          }\n          \n          .action-buttons .btn {\n            flex-grow: 1;\n          }\n        }\n      `;\n      \n      document.head.appendChild(style);\n      console.log(\"Added enhanced custom styling for results UI\");\n    }\n  } catch (error) {\n    console.error(\"Error adding custom CSS styles:\", error);\n  }\n}\n\n/**\n * Process and normalize stats data to ensure consistent format with improved validation\n * @param {Object} stats - The original stats object\n * @returns {Object} - Normalized stats object with all required fields\n */\nfunction processStatsData(stats) {\n  // Ensure we have a stats object to work with\n  if (!stats || typeof stats !== 'object') {\n    console.warn(\"Invalid stats object provided:\", stats);\n    return {\n      total_playlists: 1,\n      processed_playlists: 1,\n      empty_playlists: 0,\n      skipped_playlists: 0,\n      total_videos: 0,\n      processed_videos: 0,\n      total_files: 0,\n      processed_files: 0,\n      skipped_files: 0,\n      error_files: 0,\n      total_chunks: 0,\n      total_bytes: 0,\n      duration_seconds: 0\n    };\n  }\n  \n  // If stats is a string, try to parse it\n  if (typeof stats === 'string') {\n    try {\n      stats = JSON.parse(stats);\n    } catch (e) {\n      console.warn(\"Could not parse stats string:\", e);\n      return processStatsData({}); // Return default stats\n    }\n  }\n  \n  // Create normalized stats with defaults for missing fields\n  return {\n    total_playlists: stats.playlists_total || stats.total_playlists || 1,\n    processed_playlists: stats.completed_playlists || stats.playlists_processed || stats.processed_playlists || 1,\n    empty_playlists: stats.empty_playlists || 0,\n    skipped_playlists: stats.skipped_playlists || 0,\n    total_videos: stats.total_videos || stats.videos_total || 0,\n    processed_videos: stats.videos_processed || stats.processed_videos || 0,\n    total_files: stats.total_files || 0,\n    processed_files: stats.processed_files || 0,\n    skipped_files: stats.skipped_files || 0,\n    error_files: stats.error_files || 0,\n    total_chunks: stats.total_chunks || 0,\n    total_bytes: stats.total_bytes || 0,\n    duration_seconds: stats.duration_seconds || stats.total_duration_seconds || 0,\n    download_directory: stats.download_directory || \"\",\n    total_processing_time: stats.total_processing_time || stats.processing_time || stats.execution_time_seconds || 0,\n    status: stats.status || \"completed\",\n    completed_at: stats.completed_at || stats.timestamp || \"\",\n    failed_playlists: stats.failed_playlists || 0\n  };\n}\n\n/**\n * Update result statistics display with proper formatting and enhanced visual design\n * @param {HTMLElement} element - Stats container element\n * @param {Object} stats - Statistics object\n * @param {string} outputFile - Output file path\n * @returns {string} - HTML for stats display\n */\nfunction updateResultStats(element, stats, outputFile) {\n  try {\n    if (!element) return;\n    \n    // Process stats to ensure all values are present\n    stats = processStatsData(stats);\n    \n    // Create a formatted display of the stats with enhanced visuals and animations\n    let statsHtml = `\n      <div class=\"stats-container animate__animated animate__fadeIn\">\n        <div class=\"stats-header d-flex justify-content-between align-items-center mb-3\">\n          <h5 class=\"mb-0\"><i class=\"fas fa-chart-bar me-2\"></i>Download Results</h5>\n          <div class=\"badge bg-secondary p-2\">\n            <i class=\"fas fa-clock me-1\"></i>\n            ${formatDuration(stats.total_duration_seconds || stats.duration_seconds || 0)} total duration\n          </div>\n        </div>\n        \n        <!-- Output file info with copy button -->\n        ${outputFile ? `\n          <div class=\"mb-3 p-3 bg-light rounded\">\n            <label class=\"text-muted small mb-1\">Output File</label>\n            <div class=\"d-flex align-items-center\">\n              <div class=\"text-truncate flex-grow-1\">\n                <i class=\"fas fa-file-alt me-1 text-primary\"></i>\n                <span class=\"text-primary\">${outputFile}</span>\n              </div>\n              <button class=\"btn btn-sm btn-outline-secondary ms-2 copy-path-btn\" \n                      data-path=\"${outputFile}\" title=\"Copy path to clipboard\">\n                <i class=\"fas fa-copy\"></i>\n              </button>\n            </div>\n          </div>\n        ` : ''}\n        \n        <!-- Stats Cards with improved visuals -->\n        <div class=\"row g-3 mb-4\">\n          <!-- Total Playlists Card -->\n          <div class=\"col-md-4\">\n            <div class=\"card h-100 border-0 shadow-sm\">\n              <div class=\"card-body py-3 px-3\">\n                <div class=\"d-flex align-items-center\">\n                  <div class=\"icon-container text-primary me-3\">\n                    <i class=\"fas fa-list fa-2x\"></i>\n                  </div>\n                  <div>\n                    <h3 class=\"mb-0 fw-bold\">${stats.total_playlists}</h3>\n                    <div class=\"text-muted small\">Total Playlists</div>\n                    ${stats.failed_playlists > 0 ? \n                      `<div class=\"text-danger small mt-1\">(${stats.failed_playlists} failed)</div>` : ''}\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n          \n          <!-- Videos Card -->\n          <div class=\"col-md-4\">\n            <div class=\"card h-100 border-0 shadow-sm\">\n              <div class=\"card-body py-3 px-3\">\n                <div class=\"d-flex align-items-center\">\n                  <div class=\"icon-container text-success me-3\">\n                    <i class=\"fas fa-video fa-2x\"></i>\n                  </div>\n                  <div>\n                    <h3 class=\"mb-0 fw-bold\">${stats.total_videos}</h3>\n                    <div class=\"text-muted small\">Total Videos</div>\n                    ${stats.processed_videos > 0 && stats.processed_videos !== stats.total_videos ? \n                      `<div class=\"text-info small mt-1\">(${stats.processed_videos} processed)</div>` : ''}\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n          \n          <!-- Size Card -->\n          <div class=\"col-md-4\">\n            <div class=\"card h-100 border-0 shadow-sm\">\n              <div class=\"card-body py-3 px-3\">\n                <div class=\"d-flex align-items-center\">\n                  <div class=\"icon-container text-info me-3\">\n                    <i class=\"fas fa-database fa-2x\"></i>\n                  </div>\n                  <div>\n                    <h3 class=\"mb-0 fw-bold\">${formatBytes(stats.total_bytes)}</h3>\n                    <div class=\"text-muted small\">Total Size</div>\n                    ${stats.total_chunks > 0 ? \n                      `<div class=\"text-info small mt-1\">(${stats.total_chunks} chunks)</div>` : ''}\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n        </div>\n        \n        <!-- Detailed Stats with dynamic loading -->\n        <div class=\"row\">\n          <!-- Playlist Statistics Column -->\n          <div class=\"col-md-6 mb-3\">\n            <div class=\"card border-0 shadow-sm h-100\">\n              <div class=\"card-header bg-light py-2\">\n                <h6 class=\"mb-0\"><i class=\"fas fa-list me-2\"></i>Playlist Statistics</h6>\n              </div>\n              <div class=\"card-body p-0\">\n                <ul class=\"list-group list-group-flush\">\n                  <li class=\"list-group-item d-flex justify-content-between align-items-center\">\n                    <span>Total Playlists</span>\n                    <span class=\"badge bg-primary rounded-pill\">${stats.total_playlists}</span>\n                  </li>\n                  <li class=\"list-group-item d-flex justify-content-between align-items-center\">\n                    <span>Processed Playlists</span>\n                    <span class=\"badge bg-success rounded-pill\">${stats.processed_playlists}</span>\n                  </li>\n                  <li class=\"list-group-item d-flex justify-content-between align-items-center\">\n                    <span>Empty Playlists</span>\n                    <span class=\"badge bg-secondary rounded-pill\">${stats.empty_playlists}</span>\n                  </li>\n                  <li class=\"list-group-item d-flex justify-content-between align-items-center\">\n                    <span>Skipped Playlists</span>\n                    <span class=\"badge bg-warning rounded-pill\">${stats.skipped_playlists}</span>\n                  </li>\n                  ${stats.failed_playlists > 0 ? `\n                  <li class=\"list-group-item d-flex justify-content-between align-items-center\">\n                    <span>Failed Playlists</span>\n                    <span class=\"badge bg-danger rounded-pill\">${stats.failed_playlists}</span>\n                  </li>\n                  ` : ''}\n                </ul>\n              </div>\n            </div>\n          </div>\n          \n          <!-- Video Statistics Column -->\n          <div class=\"col-md-6 mb-3\">\n            <div class=\"card border-0 shadow-sm h-100\">\n              <div class=\"card-header bg-light py-2\">\n                <h6 class=\"mb-0\"><i class=\"fas fa-video me-2\"></i>Video Statistics</h6>\n              </div>\n              <div class=\"card-body p-0\">\n                <ul class=\"list-group list-group-flush\">\n                  <li class=\"list-group-item d-flex justify-content-between align-items-center\">\n                    <span>Total Videos</span>\n                    <span class=\"badge bg-primary rounded-pill\">${stats.total_videos}</span>\n                  </li>\n                  <li class=\"list-group-item d-flex justify-content-between align-items-center\">\n                    <span>Processed Videos</span>\n                    <span class=\"badge bg-success rounded-pill\">${stats.processed_videos}</span>\n                  </li>\n                  ${stats.total_files > 0 ? `\n                  <li class=\"list-group-item d-flex justify-content-between align-items-center\">\n                    <span>Total Files</span>\n                    <span class=\"badge bg-info rounded-pill\">${stats.total_files}</span>\n                  </li>\n                  <li class=\"list-group-item d-flex justify-content-between align-items-center\">\n                    <span>Processed Files</span>\n                    <span class=\"badge bg-success rounded-pill\">${stats.processed_files}</span>\n                  </li>\n                  ` : ''}\n                  ${stats.error_files > 0 ? `\n                  <li class=\"list-group-item d-flex justify-content-between align-items-center\">\n                    <span>Error Files</span>\n                    <span class=\"badge bg-danger rounded-pill\">${stats.error_files}</span>\n                  </li>\n                  ` : ''}\n                </ul>\n              </div>\n            </div>\n          </div>\n        </div>\n        \n        <!-- Processing Details with conditional rendering -->\n        ${stats.total_files > 0 || stats.total_chunks > 0 ? `\n        <div class=\"card border-0 shadow-sm mb-3 mt-3\">\n          <div class=\"card-header bg-light py-2\">\n            <h6 class=\"mb-0\"><i class=\"fas fa-cogs me-2\"></i>Processing Details</h6>\n          </div>\n          <div class=\"card-body\">\n            <div class=\"row g-3\">\n              ${stats.total_files > 0 ? `\n              <div class=\"col-md-6\">\n                <div class=\"d-flex justify-content-between align-items-center mb-1\">\n                  <span>File Processing</span>\n                </div>\n                <div class=\"progress\" style=\"height: 20px\">\n                  <div class=\"progress-bar bg-success\" role=\"progressbar\" \n                       style=\"width: ${Math.min(100, (stats.processed_files / Math.max(1, stats.total_files)) * 100)}%\" \n                       aria-valuenow=\"${Math.min(100, (stats.processed_files / Math.max(1, stats.total_files)) * 100)}\" \n                       aria-valuemin=\"0\" aria-valuemax=\"100\">\n                    ${stats.processed_files} / ${stats.total_files}\n                  </div>\n                </div>\n                <div class=\"d-flex justify-content-between mt-1 small text-muted\">\n                  <span>${stats.processed_files} processed</span>\n                  ${stats.error_files > 0 ? `<span>${stats.error_files} errors</span>` : ''}\n                  ${stats.skipped_files > 0 ? `<span>${stats.skipped_files} skipped</span>` : ''}\n                </div>\n              </div>\n              ` : ''}\n              \n              ${stats.total_chunks > 0 ? `\n              <div class=\"col-md-6\">\n                <div class=\"d-flex justify-content-between align-items-center\">\n                  <span>Content Details</span>\n                </div>\n                <ul class=\"list-unstyled mb-0 small\">\n                  <li class=\"d-flex justify-content-between py-1\">\n                    <span>Total Chunks:</span>\n                    <span class=\"badge bg-info\">${stats.total_chunks}</span>\n                  </li>\n                  <li class=\"d-flex justify-content-between py-1\">\n                    <span>Processing Time:</span>\n                    <span class=\"badge bg-secondary\">${formatDuration(stats.total_processing_time || stats.processing_time || 0)}</span>\n                  </li>\n                  <li class=\"d-flex justify-content-between py-1\">\n                    <span>Total Data Size:</span>\n                    <span class=\"badge bg-primary\">${formatBytes(stats.total_bytes)}</span>\n                  </li>\n                </ul>\n              </div>\n              ` : ''}\n            </div>\n          </div>\n        </div>\n        ` : ''}\n        \n        <!-- Duration Display with enhanced styling -->\n        ${stats.duration_seconds > 0 || stats.total_duration_seconds > 0 ? `\n        <div class=\"text-center mb-3\">\n          <div class=\"badge bg-light text-dark py-2 px-3 shadow-sm d-inline-flex align-items-center\">\n            <i class=\"fas fa-clock me-2 text-secondary\"></i> \n            <span>Total Media Duration: <strong>${formatDuration(stats.duration_seconds || stats.total_duration_seconds || 0)}</strong></span>\n          </div>\n        </div>\n        ` : ''}\n        \n        <!-- Completion Information -->\n        <div class=\"d-flex justify-content-between align-items-center mt-3 pt-3 border-top\">\n          <div class=\"text-muted small\">\n            <i class=\"fas fa-calendar-check me-1\"></i> \n            Completed: ${stats.completed_at ? stats.completed_at : new Date().toLocaleString()}\n          </div>\n          \n          <!-- Directory Information -->\n          ${stats.download_directory ? `\n          <div class=\"text-muted small\">\n            <i class=\"fas fa-folder me-1\"></i> Directory: ${stats.download_directory}\n          </div>\n          ` : ''}\n        </div>\n      </div>\n    `;\n    \n    // Update the element\n    element.innerHTML = statsHtml;\n    \n    // Add event listener for path copy buttons\n    const copyButtons = element.querySelectorAll('.copy-path-btn');\n    copyButtons.forEach(btn => {\n      btn.addEventListener('click', function() {\n        const path = this.getAttribute('data-path');\n        if (path) {\n          try {\n            navigator.clipboard.writeText(path)\n              .then(() => {\n                // Provide visual feedback\n                this.innerHTML = '<i class=\"fas fa-check\"></i>';\n                this.classList.add('btn-success');\n                this.classList.remove('btn-outline-secondary');\n                \n                // Reset after a delay\n                setTimeout(() => {\n                  this.innerHTML = '<i class=\"fas fa-copy\"></i>';\n                  this.classList.remove('btn-success');\n                  this.classList.add('btn-outline-secondary');\n                }, 1500);\n                \n                // Show toast\n                if (typeof showToast === 'function') {\n                  showToast('Copied', 'Path copied to clipboard', 'success');\n                }\n              })\n              .catch(err => {\n                console.error(\"Clipboard error:\", err);\n                \n                // Fallback method\n                const tempInput = document.createElement('input');\n                tempInput.value = path;\n                document.body.appendChild(tempInput);\n                tempInput.select();\n                document.execCommand('copy');\n                document.body.removeChild(tempInput);\n                \n                // Provide visual feedback\n                this.innerHTML = '<i class=\"fas fa-check\"></i>';\n                \n                // Reset after a delay\n                setTimeout(() => {\n                  this.innerHTML = '<i class=\"fas fa-copy\"></i>';\n                }, 1500);\n              });\n          } catch (error) {\n            console.error(\"Error copying path:\", error);\n          }\n        }\n      });\n    });\n    \n    console.log(\"Stats display updated successfully with enhanced formatting\");\n    return statsHtml;\n  } catch (error) {\n    console.error(\"Error updating final playlist stats:\", error);\n    \n    // Fallback simple display\n    try {\n      element.innerHTML = `\n        <div class=\"alert alert-info\">\n          <h5>Download Complete</h5>\n          <p>Output File: ${outputFile || 'Unknown'}</p>\n          <p class=\"mb-0 mt-2\">Note: There was an error displaying detailed statistics, but your download was successful.</p>\n        </div>\n      `;\n    } catch (e) {\n      console.error(\"Error with fallback stats display:\", e);\n    }\n    return \"\";\n  }\n}","source":"/workspace/modules/static/js/modules/features/playlistFunctions.js","title":"playlistFunctions.js","language":"en"},{"content":"/**\n * DOM Safety Wrapper for fileProcessor\n * \n * This wrapper ensures the module only initializes when DOM is fully ready\n * and handles the \"document.body is null\" error seen in the logs.\n */\n\n// Import the enhanced fileProcessor\nimport fileProcessor from './features/fileProcessor.js';\n\n// Create a safety wrapper to ensure DOM is fully loaded\nconst safeFileProcessor = {\n  ...fileProcessor,\n  \n  /**\n   * Safe initialize method that ensures DOM is fully loaded\n   * before attempting any operations that require document.body\n   */\n  initialize() {\n    return new Promise((resolve, reject) => {\n      // Function to check if document.body is available\n      const checkBodyAvailable = () => {\n        if (document.readyState === 'complete' && document.body) {\n          console.log(\"DOM fully loaded and document.body is available, initializing file processor\");\n          \n          // Now it's safe to initialize\n          fileProcessor.initialize()\n            .then(result => resolve(result))\n            .catch(error => {\n              console.error(\"Error during safe file processor initialization:\", error);\n              reject(error);\n            });\n        } else {\n          console.log(\"Waiting for document.body to be available...\");\n          // Wait a bit longer and check again\n          setTimeout(checkBodyAvailable, 100);\n        }\n      };\n      \n      // Start checking\n      checkBodyAvailable();\n    });\n  },\n  \n  /**\n   * Create progress UI with DOM safety checks\n   */\n  createProgressUI(containerId, prefix = '') {\n    // Ensure body is available before creating UI\n    if (!document.body) {\n      console.warn(\"Cannot create progress UI - document.body not available yet\");\n      return null;\n    }\n    \n    return fileProcessor.createProgressUI(containerId, prefix);\n  }\n};\n\n// Export the safe version\nexport default safeFileProcessor;\n\n// Also export all named exports from the original\nexport * from './features/fileProcessor.js';\n\n// Add additional safety for direct DOM operations\nexport const initializeSafe = () => {\n  // Only initialize when DOM is completely ready\n  if (document.readyState === 'complete') {\n    return safeFileProcessor.initialize();\n  }\n  \n  return new Promise((resolve) => {\n    window.addEventListener('load', () => {\n      safeFileProcessor.initialize().then(resolve);\n    });\n  });\n};","source":"/workspace/modules/static/js/modules/features/safeFileProcessor.js","title":"safeFileProcessor.js","language":"en"},{"content":"/**\n * Web Scraper Module - Optimized Blueprint Implementation\n * \n * Advanced web scraping module with recursive crawling, academic search integration,\n * PDF processing, and comprehensive download management. Fully optimized with\n * centralized configuration and enhanced error handling.\n * \n * Features:\n * - Configuration-driven architecture using centralized endpoints\n * - Enhanced error handling with multiple notification systems\n * - Improved SocketIO integration using TASK_EVENTS\n * - Backend connectivity testing with health checks\n * - Consolidated code with removed redundancies\n * \n * @module features/webScraper\n * @version 3.1.0 - Optimized with Config Integration\n */\n\n// Import dependencies from centralized config\nimport { API_ENDPOINTS, BLUEPRINT_ROUTES } from '../config/endpoints.js';\nimport { CONSTANTS, API_CONFIG, SOCKET_CONFIG } from '../config/constants.js';\nimport { SOCKET_EVENTS, TASK_EVENTS } from '../config/socketEvents.js';\n\n// Configuration shorthand\nconst WEB_SCRAPER_CONFIG = {\n  endpoints: API_ENDPOINTS.WEB_SCRAPER,\n  blueprint: BLUEPRINT_ROUTES.web_scraper,\n  constants: CONSTANTS.WEB_SCRAPER || {},\n  api: API_CONFIG,\n  socket: SOCKET_CONFIG\n};\n\n/**\n * Web Scraper Class - Complete Implementation\n */\nclass WebScraper {\n  constructor() {\n    this.state = {\n      isInitialized: false,\n      currentMode: 'web', // 'web', 'academic', 'downloads', 'history'\n      currentTask: null,\n      processingState: 'idle', // 'idle', 'scraping', 'downloading', 'processing', 'completed', 'error'\n      elements: new Map(),\n      eventListeners: new Set(),\n      socketListeners: new Set(),\n      \n      // Task management\n      activeTasks: new Map(),\n      taskQueue: [],\n      downloadQueue: new Map(),\n      processingQueue: new Map(),\n      \n      // Results and data\n      scrapingResults: new Map(),\n      academicResults: new Map(),\n      selectedPdfs: new Set(),\n      downloadProgress: new Map(),\n      \n      // UI state\n      activeTab: 'web',\n      filters: {\n        source: 'all',\n        dateRange: 'all',\n        fileSize: 'all',\n        author: '',\n        title: ''\n      }\n    };\n    \n    this.config = {\n      // Scraping configuration\n      maxDepth: 3,\n      maxPages: 100,\n      respectRobots: true,\n      followRedirects: true,\n      concurrentRequests: 5,\n      requestDelay: 500,\n      timeout: 30000,\n      retryAttempts: 3,\n      \n      // PDF processing options\n      pdfOptions: {\n        maxDownloads: 10,\n        processWithStructify: true,\n        extractTables: true,\n        useOcr: true,\n        extractStructure: true,\n        chunkSize: 4096\n      },\n      \n      // Academic search configuration\n      academicSources: ['arxiv', 'semantic_scholar', 'pubmed', 'ieee', 'acm'],\n      maxResultsPerSource: 50,\n      \n      // UI configuration\n      itemsPerPage: 20,\n      autoRefreshInterval: 2000\n    };\n  }\n\n  /**\n   * Initialize the Web Scraper module with enhanced error handling\n   */\n  async init() {\n    if (this.state.isInitialized) return;\n    \n    try {\n      console.log('🌐 Initializing Web Scraper with optimized config...');\n      \n      // Test backend connectivity\n      await this.testBackendConnectivity();\n      \n      this.cacheElements();\n      this.setupEventHandlers();\n      this.setupSocketHandlers();\n      this.setupTabs();\n      this.setupFormValidation();\n      this.setupDownloadManager();\n      \n      // Load saved state\n      this.loadSavedState();\n      \n      this.state.isInitialized = true;\n      console.log('✅ Web Scraper initialized successfully with config integration');\n      \n      // Register with module system if available\n      if (window.NeuroGen?.registerModule) {\n        window.NeuroGen.registerModule('webScraper', this);\n      }\n      \n      // Report successful initialization\n      this.showNotification('Web Scraper module loaded successfully', 'success');\n      \n    } catch (error) {\n      console.error('❌ Web Scraper initialization failed:', error);\n      this.showNotification('Web Scraper initialization failed - some features may be limited', 'warning');\n      \n      // Report to error handler\n      if (window.NeuroGen?.errorHandler) {\n        window.NeuroGen.errorHandler.logError({\n          module: 'webScraper',\n          action: 'initialization',\n          error: error.message,\n          severity: 'error'\n        });\n      }\n      \n      // Allow module to work with limited functionality\n      this.state.isInitialized = true;\n    }\n  }\n\n  /**\n   * Test backend connectivity and configuration\n   */\n  async testBackendConnectivity() {\n    try {\n      console.log('🔗 Testing Web Scraper backend connectivity...');\n      \n      const response = await fetch(WEB_SCRAPER_CONFIG.endpoints.HEALTH, {\n        method: 'GET',\n        headers: {\n          'X-API-Key': localStorage.getItem('api_key') || ''\n        },\n        timeout: 5000\n      });\n      \n      if (response.ok) {\n        const data = await response.json();\n        console.log('✅ Web Scraper backend connectivity confirmed:', data);\n        this.state.backendConnected = true;\n        return true;\n      } else {\n        throw new Error(`Health check failed with status: ${response.status}`);\n      }\n      \n    } catch (error) {\n      console.warn('⚠️ Web Scraper backend connectivity test failed:', error.message);\n      this.state.backendConnected = false;\n      return false;\n    }\n  }\n\n  /**\n   * Cache DOM elements for efficient access\n   */\n  cacheElements() {\n    const elementIds = [\n      // Tab navigation\n      'scraper-tabs',\n      'web-tab-btn',\n      'academic-tab-btn', \n      'downloads-tab-btn',\n      'history-tab-btn',\n      \n      // Web scraping tab\n      'web-tab-content',\n      'web-urls-input',\n      'web-recursive-toggle',\n      'web-max-depth',\n      'web-max-pages',\n      'web-output-dir',\n      'web-start-btn',\n      \n      // Enhanced scraper elements\n      'scraper-form',\n      'scraper-mode',\n      'enhanced-scraper-url',\n      'download-folder-select',\n      'pdf-max-size',\n      'pdf-extract-tables',\n      'pdf-use-ocr',\n      'website-max-depth',\n      'website-max-pages',\n      \n      // Academic search tab\n      'academic-tab-content',\n      'academic-query-input',\n      'academic-sources-select',\n      'academic-max-results',\n      'academic-search-btn',\n      \n      // Downloads tab\n      'downloads-tab-content',\n      'downloads-queue-container',\n      'downloads-active-container',\n      'downloads-completed-container',\n      \n      // PDF selection and results\n      'pdf-results-container',\n      'pdf-select-all-btn',\n      'pdf-select-none-btn',\n      'pdf-add-to-queue-btn',\n      'pdf-filter-container',\n      \n      // Progress and status\n      'scraper-progress-container',\n      'scraper-progress-bar',\n      'scraper-progress-text',\n      'scraper-stats-container',\n      'scraper-results-container',\n      'scraper-cancel-btn'\n    ];\n\n    elementIds.forEach(id => {\n      const element = document.getElementById(id);\n      if (element) {\n        this.state.elements.set(id, element);\n      }\n    });\n  }\n\n  /**\n   * Setup event handlers for UI interactions\n   */\n  setupEventHandlers() {\n    // Tab switching\n    const tabButtons = ['web-tab-btn', 'academic-tab-btn', 'downloads-tab-btn', 'history-tab-btn'];\n    tabButtons.forEach(btnId => {\n      const btn = this.state.elements.get(btnId);\n      if (btn) {\n        const clickHandler = () => this.switchTab(btnId.replace('-tab-btn', ''));\n        btn.addEventListener('click', clickHandler);\n        this.state.eventListeners.add(() => btn.removeEventListener('click', clickHandler));\n      }\n    });\n\n    // Web scraping form\n    const webStartBtn = this.state.elements.get('web-start-btn');\n    if (webStartBtn) {\n      const clickHandler = () => this.startWebScraping();\n      webStartBtn.addEventListener('click', clickHandler);\n      this.state.eventListeners.add(() => webStartBtn.removeEventListener('click', clickHandler));\n    }\n    \n    // Enhanced scraper form\n    const scraperForm = this.state.elements.get('scraper-form');\n    if (scraperForm) {\n      const submitHandler = (e) => {\n        e.preventDefault();\n        this.handleScrapingMode();\n      };\n      scraperForm.addEventListener('submit', submitHandler);\n      this.state.eventListeners.add(() => scraperForm.removeEventListener('submit', submitHandler));\n    }\n\n    // Academic search form\n    const academicSearchBtn = this.state.elements.get('academic-search-btn');\n    if (academicSearchBtn) {\n      const clickHandler = () => this.startAcademicSearch();\n      academicSearchBtn.addEventListener('click', clickHandler);\n      this.state.eventListeners.add(() => academicSearchBtn.removeEventListener('click', clickHandler));\n    }\n\n    // PDF selection buttons\n    const selectAllBtn = this.state.elements.get('pdf-select-all-btn');\n    if (selectAllBtn) {\n      const clickHandler = () => this.selectAllPdfs();\n      selectAllBtn.addEventListener('click', clickHandler);\n      this.state.eventListeners.add(() => selectAllBtn.removeEventListener('click', clickHandler));\n    }\n\n    const selectNoneBtn = this.state.elements.get('pdf-select-none-btn');\n    if (selectNoneBtn) {\n      const clickHandler = () => this.selectNonePdfs();\n      selectNoneBtn.addEventListener('click', clickHandler);\n      this.state.eventListeners.add(() => selectNoneBtn.removeEventListener('click', clickHandler));\n    }\n\n    const addToQueueBtn = this.state.elements.get('pdf-add-to-queue-btn');\n    if (addToQueueBtn) {\n      const clickHandler = () => this.addSelectedToDownloadQueue();\n      addToQueueBtn.addEventListener('click', clickHandler);\n      this.state.eventListeners.add(() => addToQueueBtn.removeEventListener('click', clickHandler));\n    }\n\n    // Cancel button\n    const cancelBtn = this.state.elements.get('scraper-cancel-btn');\n    if (cancelBtn) {\n      const clickHandler = () => this.cancelCurrentTask();\n      cancelBtn.addEventListener('click', clickHandler);\n      this.state.eventListeners.add(() => cancelBtn.removeEventListener('click', clickHandler));\n    }\n\n    // Form validation\n    this.setupInputValidation();\n  }\n\n  /**\n   * Setup Socket.IO event handlers using Blueprint events\n   */\n  setupSocketHandlers() {\n    if (!window.socket) {\n      console.warn('Socket.IO not available, real-time updates will be limited');\n      return;\n    }\n\n    // General task events\n    const taskStartedHandler = (data) => {\n      if (this.isMyTask(data.task_id)) {\n        this.handleTaskStarted(data);\n      }\n    };\n    window.socket.on(TASK_EVENTS.STARTED, taskStartedHandler);\n    this.state.socketListeners.add(() => window.socket.off(TASK_EVENTS.STARTED, taskStartedHandler));\n\n    const progressHandler = (data) => {\n      if (this.isMyTask(data.task_id)) {\n        this.handleProgressUpdate(data);\n      }\n    };\n    window.socket.on(TASK_EVENTS.PROGRESS, progressHandler);\n    this.state.socketListeners.add(() => window.socket.off(TASK_EVENTS.PROGRESS, progressHandler));\n\n    const completedHandler = (data) => {\n      if (this.isMyTask(data.task_id)) {\n        this.handleTaskCompleted(data);\n      }\n    };\n    window.socket.on(TASK_EVENTS.COMPLETED, completedHandler);\n    this.state.socketListeners.add(() => window.socket.off(TASK_EVENTS.COMPLETED, completedHandler));\n\n    const errorHandler = (data) => {\n      if (this.isMyTask(data.task_id)) {\n        this.handleTaskError(data);\n      }\n    };\n    window.socket.on(TASK_EVENTS.ERROR, errorHandler);\n    this.state.socketListeners.add(() => window.socket.off(TASK_EVENTS.ERROR, errorHandler));\n\n    // Scraper-specific events using centralized config\n    const urlScrapedHandler = (data) => {\n      if (this.isMyTask(data.task_id)) {\n        this.handleUrlScraped(data);\n      }\n    };\n    window.socket.on(SOCKET_EVENTS.WEB_SCRAPER?.URL_SCRAPED || 'url_scraped', urlScrapedHandler);\n    this.state.socketListeners.add(() => window.socket.off(SOCKET_EVENTS.WEB_SCRAPER?.URL_SCRAPED || 'url_scraped', urlScrapedHandler));\n\n    const pdfFoundHandler = (data) => {\n      if (this.isMyTask(data.task_id)) {\n        this.handlePdfFound(data);\n      }\n    };\n    window.socket.on(SCRAPER_EVENTS.pdf_found, pdfFoundHandler);\n    this.state.socketListeners.add(() => window.socket.off(SCRAPER_EVENTS.pdf_found, pdfFoundHandler));\n\n    // PDF download events\n    const pdfDownloadStartHandler = (data) => {\n      if (this.isMyTask(data.task_id)) {\n        this.handlePdfDownloadStart(data);\n      }\n    };\n    window.socket.on(SCRAPER_EVENTS.pdf_download_start, pdfDownloadStartHandler);\n    this.state.socketListeners.add(() => window.socket.off(SCRAPER_EVENTS.pdf_download_start, pdfDownloadStartHandler));\n\n    const pdfDownloadProgressHandler = (data) => {\n      if (this.isMyTask(data.task_id)) {\n        this.handlePdfDownloadProgress(data);\n      }\n    };\n    window.socket.on(SCRAPER_EVENTS.pdf_download_progress, pdfDownloadProgressHandler);\n    this.state.socketListeners.add(() => window.socket.off(SCRAPER_EVENTS.pdf_download_progress, pdfDownloadProgressHandler));\n\n    const pdfDownloadCompleteHandler = (data) => {\n      if (this.isMyTask(data.task_id)) {\n        this.handlePdfDownloadComplete(data);\n      }\n    };\n    window.socket.on(SCRAPER_EVENTS.pdf_download_complete, pdfDownloadCompleteHandler);\n    this.state.socketListeners.add(() => window.socket.off(SCRAPER_EVENTS.pdf_download_complete, pdfDownloadCompleteHandler));\n\n    // Academic search events\n    const academicResultsHandler = (data) => {\n      this.handleAcademicResults(data);\n    };\n    window.socket.on(ACADEMIC_EVENTS.paper_found, academicResultsHandler);\n    this.state.socketListeners.add(() => window.socket.off(ACADEMIC_EVENTS.paper_found, academicResultsHandler));\n  }\n\n  /**\n   * Setup tab navigation system\n   */\n  setupTabs() {\n    // Initialize with web tab active\n    this.switchTab('web');\n  }\n\n  /**\n   * Setup form validation\n   */\n  setupFormValidation() {\n    // Web scraping validation\n    const webUrlsInput = this.state.elements.get('web-urls-input');\n    if (webUrlsInput) {\n      webUrlsInput.addEventListener('input', () => this.validateWebForm());\n    }\n\n    // Academic search validation\n    const academicQueryInput = this.state.elements.get('academic-query-input');\n    if (academicQueryInput) {\n      academicQueryInput.addEventListener('input', () => this.validateAcademicForm());\n    }\n  }\n\n  /**\n   * Setup input validation with real-time feedback\n   */\n  setupInputValidation() {\n    const webUrlsInput = this.state.elements.get('web-urls-input');\n    if (webUrlsInput) {\n      webUrlsInput.addEventListener('blur', () => {\n        const urls = this.parseUrls(webUrlsInput.value);\n        this.validateUrls(urls);\n      });\n    }\n  }\n\n  /**\n   * Setup download manager\n   */\n  setupDownloadManager() {\n    // Start download queue processor\n    this.startDownloadQueueProcessor();\n    \n    // Setup auto-refresh for download status\n    this.setupAutoRefresh();\n  }\n\n  /**\n   * Switch between tabs\n   */\n  switchTab(tabName) {\n    this.state.activeTab = tabName;\n    \n    // Update tab button states\n    const tabButtons = ['web-tab-btn', 'academic-tab-btn', 'downloads-tab-btn', 'history-tab-btn'];\n    tabButtons.forEach(btnId => {\n      const btn = this.state.elements.get(btnId);\n      if (btn) {\n        const isActive = btnId === `${tabName}-tab-btn`;\n        btn.classList.toggle('active', isActive);\n        btn.setAttribute('aria-selected', isActive);\n      }\n    });\n\n    // Show/hide tab content\n    const tabContents = ['web-tab-content', 'academic-tab-content', 'downloads-tab-content', 'history-tab-content'];\n    tabContents.forEach(contentId => {\n      const content = this.state.elements.get(contentId);\n      if (content) {\n        const isActive = contentId === `${tabName}-tab-content`;\n        content.style.display = isActive ? 'block' : 'none';\n      }\n    });\n\n    // Update current mode\n    this.state.currentMode = tabName;\n    \n    // Save tab state\n    localStorage.setItem('webScraper_activeTab', tabName);\n    \n    // Tab-specific initialization\n    if (tabName === 'downloads') {\n      this.refreshDownloadsView();\n    } else if (tabName === 'history') {\n      this.refreshHistoryView();\n    }\n  }\n\n  /**\n   * Start web scraping process\n   */\n  async startWebScraping() {\n    try {\n      const urlsInput = this.state.elements.get('web-urls-input');\n      const recursiveToggle = this.state.elements.get('web-recursive-toggle');\n      const maxDepthInput = this.state.elements.get('web-max-depth');\n      const maxPagesInput = this.state.elements.get('web-max-pages');\n      const outputDirInput = this.state.elements.get('web-output-dir');\n\n      if (!urlsInput?.value.trim()) {\n        this.showError('Please enter at least one URL to scrape');\n        return;\n      }\n\n      const urls = this.parseUrls(urlsInput.value);\n      if (urls.length === 0) {\n        this.showError('Please enter valid URLs');\n        return;\n      }\n\n      const options = {\n        urls,\n        recursive: recursiveToggle?.checked || false,\n        max_depth: parseInt(maxDepthInput?.value) || this.config.maxDepth,\n        max_pages: parseInt(maxPagesInput?.value) || this.config.maxPages,\n        output_directory: outputDirInput?.value.trim() || null,\n        pdf_options: this.config.pdfOptions,\n        respect_robots: this.config.respectRobots,\n        request_delay: this.config.requestDelay,\n        timeout: this.config.timeout\n      };\n\n      this.state.processingState = 'scraping';\n      this.updateUI();\n\n      // Start scraping using centralized configuration\n      const fetchResponse = await fetch(WEB_SCRAPER_CONFIG.endpoints.SCRAPE, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-API-Key': localStorage.getItem('api_key') || ''\n        },\n        body: JSON.stringify(options)\n      });\n      \n      if (!fetchResponse.ok) {\n        throw new Error(`HTTP error! status: ${fetchResponse.status}`);\n      }\n      \n      const response = await fetchResponse.json();\n\n      // Store task information\n      this.state.currentTask = {\n        id: response.task_id,\n        type: 'web_scraping',\n        urls,\n        options,\n        startTime: Date.now(),\n        foundPdfs: new Map()\n      };\n\n      this.state.activeTasks.set(response.task_id, this.state.currentTask);\n\n      console.log(`🌐 Web scraping started: ${response.task_id}`);\n      this.showInfo(`Scraping started for ${urls.length} URL(s)`);\n\n    } catch (error) {\n      console.error('❌ Failed to start web scraping:', error);\n      this.handleTaskError({ error: error.message });\n    }\n  }\n\n  /**\n   * Handle the new 2-option scraping system\n   */\n  async handleScrapingMode() {\n    try {\n      const modeSelect = document.getElementById('scraper-mode');\n      const urlInput = document.getElementById('enhanced-scraper-url');\n      const outputDirInput = document.getElementById('download-folder-select');\n      \n      if (!urlInput?.value.trim()) {\n        this.showError('Please enter at least one URL');\n        return;\n      }\n\n      // Handle single URL from the enhanced form\n      const urlValue = urlInput.value.trim();\n      const urls = [urlValue]; // Single URL for enhanced scraper\n\n      const scrapeMode = modeSelect?.value || 'smart_pdf';\n      \n      // Build options based on mode\n      const options = {\n        urls,\n        scrape_mode: scrapeMode,\n        output_directory: outputDirInput?.value.trim() || null,\n        download_directory: outputDirInput?.value.trim() || null\n      };\n\n      if (scrapeMode === 'smart_pdf') {\n        // Smart PDF mode options\n        options.pdf_options = {\n          process_pdfs: true,\n          extract_tables: document.getElementById('pdf-extract-tables')?.checked || true,\n          use_ocr: document.getElementById('pdf-use-ocr')?.checked || false,\n          max_file_size_mb: parseInt(document.getElementById('pdf-max-size')?.value) || 100\n        };\n      } else if (scrapeMode === 'full_website') {\n        // Full website crawler options\n        options.crawl_config = {\n          max_depth: parseInt(document.getElementById('website-max-depth')?.value) || 3,\n          max_pages: parseInt(document.getElementById('website-max-pages')?.value) || 200,\n          respect_robots: true,\n          follow_redirects: true\n        };\n        options.output_format = 'markdown';\n      }\n\n      this.state.processingState = 'scraping';\n      this.updateUI();\n\n      // Use the scraping endpoint from config\n      const response = await fetch(WEB_SCRAPER_CONFIG.endpoints.SCRAPE, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-API-Key': localStorage.getItem('api_key') || ''\n        },\n        body: JSON.stringify(options)\n      });\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const data = await response.json();\n\n      // Store task information\n      this.state.currentTask = {\n        id: data.task_id,\n        type: 'web_scraping',\n        urls,\n        options,\n        startTime: Date.now(),\n        foundPdfs: new Map()\n      };\n\n      this.state.activeTasks.set(data.task_id, this.state.currentTask);\n\n      console.log(`🚀 Scraping started: ${data.task_id}`);\n      this.showInfo(`${scrapeMode === 'smart_pdf' ? 'Smart PDF Discovery' : 'Full Website Crawling'} started`);\n\n    } catch (error) {\n      console.error('❌ Failed to start scraping:', error);\n      this.handleTaskError({ error: error.message });\n    }\n  }\n\n  /**\n   * Start academic search\n   */\n  async startAcademicSearch() {\n    try {\n      const queryInput = this.state.elements.get('academic-query-input');\n      const sourcesSelect = this.state.elements.get('academic-sources-select');\n      const maxResultsInput = this.state.elements.get('academic-max-results');\n\n      if (!queryInput?.value.trim()) {\n        this.showError('Please enter a search query');\n        return;\n      }\n\n      const query = queryInput.value.trim();\n      const sources = this.getSelectedSources(sourcesSelect);\n      const maxResults = parseInt(maxResultsInput?.value) || this.config.maxResultsPerSource;\n\n      this.state.processingState = 'searching';\n      this.updateUI();\n\n      // Start academic search using centralized configuration\n      const fetchResponse = await fetch(API_ENDPOINTS.ACADEMIC.SEARCH, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-API-Key': localStorage.getItem('api_key') || ''\n        },\n        body: JSON.stringify({\n          query,\n          source: sources.length === 1 ? sources[0] : 'all',\n          max_results: maxResults\n        })\n      });\n      \n      if (!fetchResponse.ok) {\n        throw new Error(`HTTP error! status: ${fetchResponse.status}`);\n      }\n      \n      const response = await fetchResponse.json();\n\n      console.log(`📚 Academic search started: ${response.search_id || 'unknown'}`);\n      this.showInfo(`Searching for: \"${query}\" across ${sources.length} source(s)`);\n\n    } catch (error) {\n      console.error('❌ Failed to start academic search:', error);\n      this.handleTaskError({ error: error.message });\n    }\n  }\n\n  /**\n   * Parse URLs from input text\n   */\n  parseUrls(text) {\n    if (!text) return [];\n    \n    const urlRegex = /https?:\\/\\/[^\\s]+/g;\n    const urls = text.match(urlRegex) || [];\n    \n    // Also handle line-separated URLs\n    const lines = text.split('\\n').map(line => line.trim()).filter(line => line);\n    const lineUrls = lines.filter(line => /^https?:\\/\\//.test(line));\n    \n    return [...new Set([...urls, ...lineUrls])];\n  }\n\n  /**\n   * Validate URLs\n   */\n  validateUrls(urls) {\n    const urlsInput = this.state.elements.get('web-urls-input');\n    if (!urlsInput) return false;\n\n    urlsInput.classList.remove('is-invalid', 'is-valid');\n\n    if (urls.length === 0) {\n      urlsInput.classList.add('is-invalid');\n      this.showFieldFeedback(urlsInput, 'Please enter valid URLs', 'invalid');\n      return false;\n    }\n\n    // Validate each URL\n    const invalidUrls = urls.filter(url => {\n      try {\n        new URL(url);\n        return false;\n      } catch {\n        return true;\n      }\n    });\n\n    if (invalidUrls.length > 0) {\n      urlsInput.classList.add('is-invalid');\n      this.showFieldFeedback(urlsInput, `${invalidUrls.length} invalid URL(s) found`, 'invalid');\n      return false;\n    }\n\n    urlsInput.classList.add('is-valid');\n    this.showFieldFeedback(urlsInput, `${urls.length} valid URL(s)`, 'valid');\n    return true;\n  }\n\n  /**\n   * Get selected academic sources\n   */\n  getSelectedSources(selectElement) {\n    if (!selectElement) return this.config.academicSources;\n    \n    const selected = Array.from(selectElement.selectedOptions).map(option => option.value);\n    return selected.includes('all') ? this.config.academicSources : selected;\n  }\n\n  /**\n   * Validate web scraping form\n   */\n  validateWebForm() {\n    const urlsInput = this.state.elements.get('web-urls-input');\n    const startBtn = this.state.elements.get('web-start-btn');\n\n    const urls = this.parseUrls(urlsInput?.value || '');\n    const isValid = urls.length > 0 && this.state.processingState === 'idle';\n\n    if (startBtn) {\n      startBtn.disabled = !isValid;\n    }\n\n    return isValid;\n  }\n\n  /**\n   * Validate academic search form\n   */\n  validateAcademicForm() {\n    const queryInput = this.state.elements.get('academic-query-input');\n    const searchBtn = this.state.elements.get('academic-search-btn');\n\n    const query = queryInput?.value.trim() || '';\n    const isValid = query.length > 0 && this.state.processingState === 'idle';\n\n    if (searchBtn) {\n      searchBtn.disabled = !isValid;\n    }\n\n    return isValid;\n  }\n\n  /**\n   * Check if a task belongs to this module instance\n   */\n  isMyTask(taskId) {\n    return this.state.activeTasks.has(taskId) || \n           (this.state.currentTask && this.state.currentTask.id === taskId);\n  }\n\n  /**\n   * Handle task started event\n   */\n  handleTaskStarted(data) {\n    console.log('🚀 Task started:', data);\n    this.showProgress(0, 'Starting...');\n    \n    // Update task info\n    if (this.state.currentTask) {\n      this.state.currentTask.status = 'started';\n    }\n  }\n\n  /**\n   * Handle progress update\n   */\n  handleProgressUpdate(data) {\n    const progress = Math.min(100, Math.max(0, data.progress || 0));\n    const message = data.message || `Processing... ${progress.toFixed(1)}%`;\n    \n    this.showProgress(progress, message);\n    \n    // Update stats if available\n    if (data.stats) {\n      this.updateStats(data.stats);\n    }\n\n    // Update task info\n    if (this.state.currentTask) {\n      this.state.currentTask.progress = progress;\n      this.state.currentTask.stats = data.stats;\n      this.state.currentTask.lastUpdate = Date.now();\n    }\n    \n    // Update activity feed if available\n    if (data.details) {\n      this.addActivityItem(data.details);\n    }\n  }\n\n  /**\n   * Handle URL scraped event\n   */\n  handleUrlScraped(data) {\n    console.log('🔍 URL scraped:', data);\n    \n    // Add to results\n    if (this.state.currentTask) {\n      if (!this.state.currentTask.scrapedUrls) {\n        this.state.currentTask.scrapedUrls = [];\n      }\n      this.state.currentTask.scrapedUrls.push({\n        url: data.url,\n        title: data.title,\n        size: data.size,\n        timestamp: Date.now()\n      });\n    }\n  }\n\n  /**\n   * Handle PDF found event\n   */\n  handlePdfFound(data) {\n    console.log('📄 PDF found:', data);\n    \n    // Add to found PDFs\n    if (this.state.currentTask) {\n      this.state.currentTask.foundPdfs.set(data.pdf_url, {\n        url: data.pdf_url,\n        title: data.pdf_title || 'Unknown Title',\n        size: data.size || 0,\n        source: data.source_url || 'Unknown Source',\n        timestamp: Date.now()\n      });\n    }\n\n    // Update PDF results display\n    this.updatePdfResults();\n  }\n\n  /**\n   * Handle PDF download start\n   */\n  handlePdfDownloadStart(data) {\n    console.log('⬇️ PDF download started:', data);\n    \n    // Add to download progress tracking\n    this.state.downloadProgress.set(data.pdf_url, {\n      url: data.pdf_url,\n      title: data.pdf_title,\n      progress: 0,\n      status: 'downloading',\n      startTime: Date.now()\n    });\n\n    this.updateDownloadsView();\n  }\n\n  /**\n   * Handle PDF download progress\n   */\n  handlePdfDownloadProgress(data) {\n    const downloadInfo = this.state.downloadProgress.get(data.pdf_url);\n    if (downloadInfo) {\n      downloadInfo.progress = data.progress;\n      downloadInfo.downloadedBytes = data.downloaded_bytes;\n      downloadInfo.totalBytes = data.total_bytes;\n      downloadInfo.speed = data.speed_bps;\n    }\n\n    this.updateDownloadsView();\n  }\n\n  /**\n   * Handle PDF download complete\n   */\n  handlePdfDownloadComplete(data) {\n    console.log('✅ PDF download completed:', data);\n    \n    const downloadInfo = this.state.downloadProgress.get(data.pdf_url);\n    if (downloadInfo) {\n      downloadInfo.progress = 100;\n      downloadInfo.status = 'completed';\n      downloadInfo.filePath = data.file_path;\n      downloadInfo.endTime = Date.now();\n    }\n\n    this.updateDownloadsView();\n  }\n\n  /**\n   * Handle academic search results\n   */\n  handleAcademicResults(data) {\n    console.log('📚 Academic results received:', data);\n    \n    // Store results by source\n    if (!this.state.academicResults.has(data.source)) {\n      this.state.academicResults.set(data.source, []);\n    }\n    \n    const sourceResults = this.state.academicResults.get(data.source);\n    sourceResults.push(...(data.papers || []));\n    \n    // Update academic results display\n    this.updateAcademicResults();\n  }\n\n  /**\n   * Handle task completion - Enhanced to match fileProcessor spec\n   */\n  handleTaskCompleted(data) {\n    try {\n      console.log('✅ Enhanced task completion started:', data);\n      \n      // Validate completion data\n      if (!this.validateTaskCompletion(data)) {\n        return;\n      }\n      \n      // Update state\n      this.state.processingState = 'completed';\n      \n      // Update task info\n      if (this.state.currentTask) {\n        this.state.currentTask.status = 'completed';\n        this.state.currentTask.endTime = Date.now();\n        this.state.currentTask.results = data;\n      }\n      \n      // Show completion progress first\n      this.showProgress(100, 'Task completed successfully!');\n      \n      // Enhanced cleanup\n      this.performEnhancedCleanup();\n      \n      // Update UI buttons\n      this.updateCompletionUI(data);\n      \n      // Trigger completion notifications\n      this.triggerCompletionNotifications(data);\n      \n      // Display enhanced results with stats screen (like fileProcessor)\n      this.displayEnhancedResults(data);\n      \n    } catch (error) {\n      console.error('❌ Error in enhanced task completion:', error);\n      this.performFallbackCompletion(data);\n    }\n  }\n\n  /**\n   * Validate task completion data\n   */\n  validateTaskCompletion(data) {\n    if (!data) {\n      console.warn('❌ No completion data provided');\n      return false;\n    }\n    \n    if (!this.state.currentTask) {\n      console.warn('❌ No current task to complete');\n      return false;\n    }\n    \n    return true;\n  }\n\n  /**\n   * Enhanced cleanup after task completion\n   */\n  performEnhancedCleanup() {\n    // Clear any active intervals\n    if (this.progressInterval) {\n      clearInterval(this.progressInterval);\n      this.progressInterval = null;\n    }\n    \n    // Clean up active downloads\n    this.state.downloadQueue.clear();\n    this.state.processingQueue.clear();\n    \n    // Reset UI state\n    this.updateUI();\n  }\n\n  /**\n   * Update completion UI\n   */\n  updateCompletionUI(data) {\n    const webStartBtn = this.state.elements.get('web-start-btn');\n    const academicSearchBtn = this.state.elements.get('academic-search-btn');\n    const cancelBtn = this.state.elements.get('scraper-cancel-btn');\n    \n    if (webStartBtn) {\n      webStartBtn.disabled = false;\n      webStartBtn.textContent = 'Start Scraping';\n    }\n    \n    if (academicSearchBtn) {\n      academicSearchBtn.disabled = false;\n      academicSearchBtn.textContent = 'Search';\n    }\n    \n    if (cancelBtn) {\n      cancelBtn.style.display = 'none';\n    }\n  }\n\n  /**\n   * Trigger completion notifications\n   */\n  triggerCompletionNotifications(data) {\n    const message = `Web scraping completed! Processed ${data.stats?.urls_processed || 0} URLs, found ${data.stats?.pdfs_found || 0} PDFs.`;\n    this.showNotification(message, 'success', 'Web Scraper');\n  }\n\n  /**\n   * Display enhanced results with comprehensive stats (like fileProcessor)\n   */\n  displayEnhancedResults(data) {\n    // Prepare enhanced result data\n    const enhancedData = {\n      stats: data.stats || {},\n      output_file: data.output_file || data.output_directory,\n      task_id: data.task_id || this.state.currentTask?.id,\n      progress: 100,\n      message: 'Web scraping completed successfully!',\n      completionTime: Date.now(),\n      duration: this.state.currentTask ? (Date.now() - this.state.currentTask.startTime) : 0,\n      urls_processed: data.stats?.urls_processed || 0,\n      pdfs_found: data.stats?.pdfs_found || 0,\n      pdfs_downloaded: data.stats?.pdfs_downloaded || 0,\n      total_size: data.stats?.total_size || 0,\n      crawl_depth: data.stats?.current_depth || 0\n    };\n    \n    // Show result UI with enhanced delay for better UX\n    setTimeout(() => {\n      this.showEnhancedResult(enhancedData);\n    }, 600);\n  }\n\n  /**\n   * Show enhanced result with container transitions (like fileProcessor)\n   */\n  showEnhancedResult(data) {\n    // Find or create result container\n    let resultContainer = this.state.elements.get('scraper-result-container');\n    if (!resultContainer) {\n      resultContainer = this.createResultContainer();\n    }\n    \n    // Transition to result container\n    this.transitionToContainer(resultContainer);\n    \n    // Update result content with comprehensive stats\n    this.updateEnhancedResultStats(resultContainer, data);\n    \n    // Show success notification\n    this.showNotification('Web scraping completed successfully!', 'success', 'Web Scraper');\n  }\n\n  /**\n   * Create result container if it doesn't exist\n   */\n  createResultContainer() {\n    const progressContainer = this.state.elements.get('scraper-progress-container');\n    if (!progressContainer) return null;\n    \n    let resultContainer = document.getElementById('scraper-result-container');\n    if (!resultContainer) {\n      resultContainer = document.createElement('div');\n      resultContainer.id = 'scraper-result-container';\n      resultContainer.className = 'container-fluid mt-3';\n      resultContainer.style.display = 'none';\n      \n      // Insert after progress container\n      progressContainer.parentNode.insertBefore(resultContainer, progressContainer.nextSibling);\n      this.state.elements.set('scraper-result-container', resultContainer);\n    }\n    \n    return resultContainer;\n  }\n\n  /**\n   * Transition to container (like fileProcessor)\n   */\n  transitionToContainer(targetContainer) {\n    // Hide progress container\n    const progressContainer = this.state.elements.get('scraper-progress-container');\n    if (progressContainer) {\n      progressContainer.style.display = 'none';\n    }\n    \n    // Show target container with smooth transition\n    if (targetContainer) {\n      targetContainer.style.display = 'block';\n      targetContainer.style.opacity = '0';\n      targetContainer.style.transition = 'opacity 0.3s ease-in-out';\n      \n      setTimeout(() => {\n        targetContainer.style.opacity = '1';\n      }, 50);\n    }\n  }\n\n  /**\n   * Update result stats with comprehensive display (enhanced like fileProcessor)\n   */\n  updateEnhancedResultStats(resultContainer, data) {\n    if (!resultContainer) return;\n    \n    const duration = data.duration ? Math.round(data.duration / 1000) : 0;\n    const processingRate = duration > 0 ? Math.round(data.urls_processed / duration * 60) : 0;\n    const successRate = data.urls_processed > 0 ? Math.round((data.urls_processed / (data.urls_processed + (data.stats?.failed_urls || 0))) * 100) : 100;\n    \n    const resultHTML = `\n      <div class=\"card shadow-sm\">\n        <div class=\"card-header bg-success text-white\">\n          <h5 class=\"mb-0\">\n            <i class=\"fas fa-check-circle me-2\"></i>\n            Web Scraping Completed Successfully\n          </h5>\n        </div>\n        <div class=\"card-body\">\n          <!-- Summary Stats -->\n          <div class=\"row mb-4\">\n            <div class=\"col-md-3\">\n              <div class=\"stat-card text-center p-3 border rounded\">\n                <div class=\"stat-value text-primary\" style=\"font-size: 2.5rem; font-weight: bold;\">${data.urls_processed}</div>\n                <div class=\"stat-label text-muted\">URLs Processed</div>\n              </div>\n            </div>\n            <div class=\"col-md-3\">\n              <div class=\"stat-card text-center p-3 border rounded\">\n                <div class=\"stat-value text-info\" style=\"font-size: 2.5rem; font-weight: bold;\">${data.pdfs_found}</div>\n                <div class=\"stat-label text-muted\">PDFs Found</div>\n              </div>\n            </div>\n            <div class=\"col-md-3\">\n              <div class=\"stat-card text-center p-3 border rounded\">\n                <div class=\"stat-value text-success\" style=\"font-size: 2.5rem; font-weight: bold;\">${data.pdfs_downloaded}</div>\n                <div class=\"stat-label text-muted\">PDFs Downloaded</div>\n              </div>\n            </div>\n            <div class=\"col-md-3\">\n              <div class=\"stat-card text-center p-3 border rounded\">\n                <div class=\"stat-value text-warning\" style=\"font-size: 2.5rem; font-weight: bold;\">${successRate}%</div>\n                <div class=\"stat-label text-muted\">Success Rate</div>\n              </div>\n            </div>\n          </div>\n\n          <!-- Performance Metrics -->\n          <div class=\"row mb-4\">\n            <div class=\"col-md-4\">\n              <div class=\"metric-item\">\n                <strong><i class=\"fas fa-clock me-2\"></i>Duration:</strong>\n                <span class=\"ms-2\">${this.formatDuration(duration * 1000)}</span>\n              </div>\n            </div>\n            <div class=\"col-md-4\">\n              <div class=\"metric-item\">\n                <strong><i class=\"fas fa-tachometer-alt me-2\"></i>Processing Rate:</strong>\n                <span class=\"ms-2\">${processingRate} URLs/min</span>\n              </div>\n            </div>\n            <div class=\"col-md-4\">\n              <div class=\"metric-item\">\n                <strong><i class=\"fas fa-hdd me-2\"></i>Total Size:</strong>\n                <span class=\"ms-2\">${this.formatFileSize(data.total_size)}</span>\n              </div>\n            </div>\n          </div>\n\n          <!-- Output Information -->\n          ${data.output_file ? `\n          <div class=\"output-section mb-4\">\n            <h6><i class=\"fas fa-file-alt me-2\"></i>Output File</h6>\n            <div class=\"d-flex align-items-center\">\n              <code class=\"me-3\">${data.output_file}</code>\n              <div class=\"btn-group\" role=\"group\">\n                <button class=\"btn btn-sm btn-outline-primary\" onclick=\"downloadFile('${data.output_file}')\">\n                  <i class=\"fas fa-download me-1\"></i>Download\n                </button>\n                <button class=\"btn btn-sm btn-outline-secondary\" onclick=\"openFile('${data.output_file}')\">\n                  <i class=\"fas fa-external-link-alt me-1\"></i>Open\n                </button>\n              </div>\n            </div>\n          </div>\n          ` : ''}\n\n          <!-- Additional Details -->\n          <div class=\"details-section\">\n            <h6><i class=\"fas fa-info-circle me-2\"></i>Scraping Details</h6>\n            <div class=\"row\">\n              <div class=\"col-md-6\">\n                <ul class=\"list-unstyled\">\n                  <li><strong>Task ID:</strong> <code>${data.task_id}</code></li>\n                  <li><strong>Crawl Depth:</strong> ${data.crawl_depth}</li>\n                  <li><strong>Completion Time:</strong> ${new Date(data.completionTime).toLocaleString()}</li>\n                </ul>\n              </div>\n              <div class=\"col-md-6\">\n                <ul class=\"list-unstyled\">\n                  <li><strong>Failed URLs:</strong> ${data.stats?.failed_urls || 0}</li>\n                  <li><strong>Unique Domains:</strong> ${data.stats?.unique_domains || 0}</li>\n                  <li><strong>Average Response Time:</strong> ${data.stats?.avg_response_time || 'N/A'}</li>\n                </ul>\n              </div>\n            </div>\n          </div>\n\n          <!-- Quick Stats Display -->\n          <div class=\"d-flex justify-content-between text-muted small mt-3 pt-3 border-top\">\n            <span><i class=\"fas fa-globe me-1\"></i>${data.urls_processed} URLs processed</span>\n            <span><i class=\"fas fa-clock me-1\"></i>${this.formatDuration(duration * 1000)}</span>\n            <span><i class=\"fas fa-check-circle me-1\"></i>${successRate}% success rate</span>\n          </div>\n        </div>\n      </div>\n    `;\n    \n    resultContainer.innerHTML = resultHTML;\n  }\n\n  /**\n   * Fallback completion handler\n   */\n  performFallbackCompletion(data) {\n    console.warn('Using fallback completion handler');\n    this.state.processingState = 'completed';\n    this.showProgress(100, 'Task completed with some issues');\n    this.showResults(data); // Use original method as fallback\n    this.updateUI();\n  }\n\n  /**\n   * Handle task error\n   */\n  handleTaskError(data) {\n    console.error('❌ Task error:', data);\n    \n    this.state.processingState = 'error';\n    this.showError(data.error || 'Task failed');\n    \n    // Update task info\n    if (this.state.currentTask) {\n      this.state.currentTask.status = 'error';\n      this.state.currentTask.error = data.error;\n      this.state.currentTask.endTime = Date.now();\n    }\n    \n    this.updateUI();\n    \n    // Report to health monitor\n    if (window.healthMonitor) {\n      window.healthMonitor.runHealthCheck();\n    }\n  }\n\n  /**\n   * Cancel current task\n   */\n  async cancelCurrentTask() {\n    if (!this.state.currentTask) return;\n\n    try {\n      // Cancel task using centralized configuration\n      const cancelUrl = WEB_SCRAPER_CONFIG.endpoints.CANCEL.replace(':taskId', this.state.currentTask.id);\n      const fetchResponse = await fetch(cancelUrl, {\n        method: 'POST',\n        headers: {\n          'X-API-Key': localStorage.getItem('api_key') || ''\n        }\n      });\n      \n      if (!fetchResponse.ok) {\n        throw new Error(`HTTP error! status: ${fetchResponse.status}`);\n      }\n      \n      console.log(`🚫 Task cancelled: ${this.state.currentTask.id}`);\n      \n      this.state.processingState = 'idle';\n      this.state.currentTask = null;\n      this.updateUI();\n      \n    } catch (error) {\n      console.error('❌ Failed to cancel task:', error);\n    }\n  }\n\n  /**\n   * Select all PDFs\n   */\n  selectAllPdfs() {\n    const checkboxes = document.querySelectorAll('.pdf-checkbox');\n    checkboxes.forEach(checkbox => {\n      checkbox.checked = true;\n      this.state.selectedPdfs.add(checkbox.value);\n    });\n    \n    this.updateSelectionButtons();\n  }\n\n  /**\n   * Select no PDFs\n   */\n  selectNonePdfs() {\n    const checkboxes = document.querySelectorAll('.pdf-checkbox');\n    checkboxes.forEach(checkbox => {\n      checkbox.checked = false;\n    });\n    \n    this.state.selectedPdfs.clear();\n    this.updateSelectionButtons();\n  }\n\n  /**\n   * Add selected PDFs to download queue\n   */\n  async addSelectedToDownloadQueue() {\n    if (this.state.selectedPdfs.size === 0) {\n      this.showWarning('Please select PDFs to download');\n      return;\n    }\n\n    try {\n      const selectedUrls = Array.from(this.state.selectedPdfs);\n      \n      // Add to download queue\n      selectedUrls.forEach(url => {\n        const pdfInfo = this.getPdfInfo(url);\n        if (pdfInfo) {\n          this.state.downloadQueue.set(url, {\n            ...pdfInfo,\n            status: 'queued',\n            addedTime: Date.now()\n          });\n        }\n      });\n\n      this.showInfo(`Added ${selectedUrls.length} PDF(s) to download queue`);\n      \n      // Switch to downloads tab\n      this.switchTab('downloads');\n      \n      // Start processing queue\n      this.processDownloadQueue();\n      \n    } catch (error) {\n      console.error('❌ Failed to add PDFs to queue:', error);\n      this.showError('Failed to add PDFs to download queue');\n    }\n  }\n\n  /**\n   * Get PDF info from various sources\n   */\n  getPdfInfo(url) {\n    // Check current task found PDFs\n    if (this.state.currentTask?.foundPdfs.has(url)) {\n      return this.state.currentTask.foundPdfs.get(url);\n    }\n    \n    // Check academic results\n    for (const sourceResults of this.state.academicResults.values()) {\n      const paper = sourceResults.find(p => p.pdf_url === url);\n      if (paper) {\n        return {\n          url: paper.pdf_url,\n          title: paper.title,\n          authors: paper.authors,\n          source: paper.source,\n          size: paper.size || 0\n        };\n      }\n    }\n    \n    return null;\n  }\n\n  /**\n   * Process download queue\n   */\n  async processDownloadQueue() {\n    const activeDownloads = Array.from(this.state.downloadProgress.values())\n      .filter(d => d.status === 'downloading').length;\n    \n    if (activeDownloads >= this.config.pdfOptions.maxDownloads) {\n      return; // Wait for current downloads to complete\n    }\n    \n    // Get next items from queue\n    const queuedItems = Array.from(this.state.downloadQueue.entries())\n      .filter(([_, item]) => item.status === 'queued')\n      .slice(0, this.config.pdfOptions.maxDownloads - activeDownloads);\n    \n    for (const [url, item] of queuedItems) {\n      try {\n        // Mark as downloading\n        item.status = 'downloading';\n        this.state.downloadProgress.set(url, {\n          ...item,\n          progress: 0,\n          startTime: Date.now()\n        });\n        \n        // Start download using centralized configuration\n        const fetchResponse = await fetch(WEB_SCRAPER_CONFIG.endpoints.DOWNLOAD_PDF, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'X-API-Key': localStorage.getItem('api_key') || ''\n          },\n          body: JSON.stringify({\n            url: url,\n            outputFolder: this.getCurrentOutputDirectory(),\n            outputFilename: item.title,\n            processFile: true,\n            extractTables: this.config.pdfOptions.extractTables,\n            useOcr: this.config.pdfOptions.useOcr\n          })\n        });\n        \n        if (!fetchResponse.ok) {\n          throw new Error(`HTTP error! status: ${fetchResponse.status}`);\n        }\n        \n      } catch (error) {\n        console.error(`❌ Failed to start download for ${url}:`, error);\n        item.status = 'error';\n        item.error = error.message;\n      }\n    }\n    \n    this.updateDownloadsView();\n  }\n\n  /**\n   * Start download queue processor (runs periodically)\n   */\n  startDownloadQueueProcessor() {\n    setInterval(() => {\n      if (this.state.downloadQueue.size > 0) {\n        this.processDownloadQueue();\n      }\n    }, 5000); // Check every 5 seconds\n  }\n\n  /**\n   * Setup auto-refresh for dynamic content\n   */\n  setupAutoRefresh() {\n    setInterval(() => {\n      if (this.state.activeTab === 'downloads') {\n        this.updateDownloadsView();\n      }\n    }, this.config.autoRefreshInterval);\n  }\n\n  /**\n   * Update PDF results display\n   */\n  updatePdfResults() {\n    const container = this.state.elements.get('pdf-results-container');\n    if (!container) return;\n\n    let allPdfs = [];\n    \n    // Collect PDFs from current task\n    if (this.state.currentTask?.foundPdfs) {\n      allPdfs.push(...Array.from(this.state.currentTask.foundPdfs.values()));\n    }\n    \n    // Collect PDFs from academic results\n    for (const sourceResults of this.state.academicResults.values()) {\n      const pdfs = sourceResults.filter(paper => paper.pdf_url);\n      allPdfs.push(...pdfs.map(paper => ({\n        url: paper.pdf_url,\n        title: paper.title,\n        authors: paper.authors,\n        source: paper.source,\n        size: paper.size || 0,\n        year: paper.year,\n        citations: paper.citation_count\n      })));\n    }\n\n    // Apply filters\n    allPdfs = this.applyFilters(allPdfs);\n    \n    // Show/hide PDF selection panel\n    const selectionPanel = document.getElementById('pdf-selection-panel');\n    if (selectionPanel) {\n      selectionPanel.style.display = allPdfs.length > 0 ? 'block' : 'none';\n    }\n    \n    // Update counts\n    const totalCount = document.getElementById('total-pdfs-count');\n    if (totalCount) {\n      totalCount.textContent = allPdfs.length;\n    }\n\n    // Generate HTML\n    const html = this.generatePdfResultsHtml(allPdfs);\n    container.innerHTML = html;\n\n    // Add event listeners for checkboxes\n    this.setupPdfCheckboxes();\n    \n    this.updateSelectionButtons();\n  }\n\n  /**\n   * Generate HTML for PDF results\n   */\n  generatePdfResultsHtml(pdfs) {\n    if (pdfs.length === 0) {\n      return '<div class=\"text-center text-muted py-4\">No PDFs found</div>';\n    }\n\n    return `\n      <div class=\"pdf-results-header mb-3\">\n        <div class=\"d-flex justify-content-between align-items-center\">\n          <h5>Found PDFs (${pdfs.length})</h5>\n          <div class=\"btn-group\" role=\"group\">\n            <button type=\"button\" class=\"btn btn-sm btn-outline-primary\" onclick=\"window.webScraper.selectAllPdfs()\">\n              Select All\n            </button>\n            <button type=\"button\" class=\"btn btn-sm btn-outline-secondary\" onclick=\"window.webScraper.selectNonePdfs()\">\n              Select None\n            </button>\n          </div>\n        </div>\n      </div>\n      \n      <div class=\"pdf-list\">\n        ${pdfs.map(pdf => `\n          <div class=\"pdf-item card mb-2\">\n            <div class=\"card-body p-3\">\n              <div class=\"d-flex align-items-start\">\n                <div class=\"form-check me-3\">\n                  <input class=\"form-check-input pdf-checkbox\" type=\"checkbox\" \n                         value=\"${pdf.url}\" id=\"pdf-${this.generateId(pdf.url)}\">\n                </div>\n                <div class=\"flex-grow-1\">\n                  <h6 class=\"card-title mb-1\">${this.escapeHtml(pdf.title)}</h6>\n                  ${pdf.authors ? `<p class=\"text-muted small mb-1\">By: ${this.escapeHtml(pdf.authors)}</p>` : ''}\n                  <div class=\"d-flex justify-content-between text-sm\">\n                    <span class=\"text-muted\">Source: ${this.escapeHtml(pdf.source)}</span>\n                    <span class=\"text-muted\">${this.formatFileSize(pdf.size)}</span>\n                  </div>\n                </div>\n              </div>\n            </div>\n          </div>\n        `).join('')}\n      </div>\n      \n      <div class=\"pdf-actions mt-3\">\n        <button type=\"button\" class=\"btn btn-primary\" id=\"add-selected-to-queue\">\n          <i class=\"fas fa-plus me-2\"></i>Add Selected to Download Queue\n        </button>\n      </div>\n    `;\n  }\n\n  /**\n   * Setup PDF checkbox event listeners\n   */\n  setupPdfCheckboxes() {\n    const checkboxes = document.querySelectorAll('.pdf-checkbox');\n    checkboxes.forEach(checkbox => {\n      checkbox.addEventListener('change', (e) => {\n        if (e.target.checked) {\n          this.state.selectedPdfs.add(e.target.value);\n        } else {\n          this.state.selectedPdfs.delete(e.target.value);\n        }\n        this.updateSelectionButtons();\n      });\n    });\n\n    // Add selected to queue button\n    const addButton = document.getElementById('add-selected-to-queue');\n    if (addButton) {\n      addButton.addEventListener('click', () => this.addSelectedToDownloadQueue());\n    }\n  }\n\n  /**\n   * Update selection buttons state\n   */\n  updateSelectionButtons() {\n    const addButton = document.getElementById('add-selected-to-queue');\n    if (addButton) {\n      addButton.disabled = this.state.selectedPdfs.size === 0;\n      addButton.textContent = `Add Selected to Queue (${this.state.selectedPdfs.size})`;\n    }\n  }\n\n  /**\n   * Apply filters to PDF list\n   */\n  applyFilters(pdfs) {\n    return pdfs.filter(pdf => {\n      // Source filter\n      if (this.state.filters.source !== 'all' && \n          !pdf.source.toLowerCase().includes(this.state.filters.source.toLowerCase())) {\n        return false;\n      }\n      \n      // Title filter\n      if (this.state.filters.title && \n          !pdf.title.toLowerCase().includes(this.state.filters.title.toLowerCase())) {\n        return false;\n      }\n      \n      // Author filter\n      if (this.state.filters.author && pdf.authors &&\n          !pdf.authors.toLowerCase().includes(this.state.filters.author.toLowerCase())) {\n        return false;\n      }\n      \n      // File size filter\n      if (this.state.filters.fileSize !== 'all') {\n        const size = pdf.size || 0;\n        switch (this.state.filters.fileSize) {\n          case 'small':\n            if (size > 5 * 1024 * 1024) return false; // > 5MB\n            break;\n          case 'medium':\n            if (size <= 5 * 1024 * 1024 || size > 20 * 1024 * 1024) return false; // 5-20MB\n            break;\n          case 'large':\n            if (size <= 20 * 1024 * 1024) return false; // > 20MB\n            break;\n        }\n      }\n      \n      return true;\n    });\n  }\n\n  /**\n   * Update academic results display\n   */\n  updateAcademicResults() {\n    // Academic results are displayed as PDFs in the PDF results container\n    this.updatePdfResults();\n  }\n\n  /**\n   * Update downloads view\n   */\n  updateDownloadsView() {\n    this.refreshDownloadsView();\n  }\n\n  /**\n   * Refresh downloads view\n   */\n  refreshDownloadsView() {\n    const container = this.state.elements.get('downloads-tab-content');\n    if (!container) return;\n\n    const queuedDownloads = Array.from(this.state.downloadQueue.values())\n      .filter(item => item.status === 'queued');\n    \n    const activeDownloads = Array.from(this.state.downloadProgress.values())\n      .filter(item => item.status === 'downloading');\n    \n    const completedDownloads = Array.from(this.state.downloadProgress.values())\n      .filter(item => item.status === 'completed');\n\n    const html = `\n      <div class=\"downloads-overview mb-4\">\n        <div class=\"row text-center\">\n          <div class=\"col-md-3\">\n            <div class=\"stat-card\">\n              <h3 class=\"text-primary\">${queuedDownloads.length}</h3>\n              <p class=\"text-muted\">Queued</p>\n            </div>\n          </div>\n          <div class=\"col-md-3\">\n            <div class=\"stat-card\">\n              <h3 class=\"text-warning\">${activeDownloads.length}</h3>\n              <p class=\"text-muted\">Downloading</p>\n            </div>\n          </div>\n          <div class=\"col-md-3\">\n            <div class=\"stat-card\">\n              <h3 class=\"text-success\">${completedDownloads.length}</h3>\n              <p class=\"text-muted\">Completed</p>\n            </div>\n          </div>\n          <div class=\"col-md-3\">\n            <div class=\"stat-card\">\n              <h3 class=\"text-info\">${this.config.pdfOptions.maxDownloads}</h3>\n              <p class=\"text-muted\">Max Concurrent</p>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      ${activeDownloads.length > 0 ? `\n        <div class=\"active-downloads mb-4\">\n          <h5>Active Downloads</h5>\n          ${activeDownloads.map(download => this.generateDownloadItemHtml(download, 'active')).join('')}\n        </div>\n      ` : ''}\n\n      ${queuedDownloads.length > 0 ? `\n        <div class=\"queued-downloads mb-4\">\n          <h5>Download Queue</h5>\n          ${queuedDownloads.map(download => this.generateDownloadItemHtml(download, 'queued')).join('')}\n        </div>\n      ` : ''}\n\n      ${completedDownloads.length > 0 ? `\n        <div class=\"completed-downloads mb-4\">\n          <h5>Completed Downloads</h5>\n          ${completedDownloads.map(download => this.generateDownloadItemHtml(download, 'completed')).join('')}\n        </div>\n      ` : ''}\n    `;\n\n    container.innerHTML = html;\n  }\n\n  /**\n   * Generate HTML for download item\n   */\n  generateDownloadItemHtml(download, type) {\n    const progress = download.progress || 0;\n    const statusIcon = {\n      'queued': 'fas fa-clock text-warning',\n      'active': 'fas fa-download text-primary',\n      'completed': 'fas fa-check-circle text-success',\n      'error': 'fas fa-exclamation-circle text-danger'\n    }[download.status] || 'fas fa-question-circle';\n\n    return `\n      <div class=\"download-item card mb-2\">\n        <div class=\"card-body p-3\">\n          <div class=\"d-flex align-items-center\">\n            <i class=\"${statusIcon} me-3\"></i>\n            <div class=\"flex-grow-1\">\n              <h6 class=\"mb-1\">${this.escapeHtml(download.title)}</h6>\n              <div class=\"small text-muted mb-2\">${this.escapeHtml(download.url)}</div>\n              \n              ${type === 'active' ? `\n                <div class=\"progress mb-2\" style=\"height: 6px;\">\n                  <div class=\"progress-bar\" role=\"progressbar\" \n                       style=\"width: ${progress}%\" \n                       aria-valuenow=\"${progress}\" aria-valuemin=\"0\" aria-valuemax=\"100\">\n                  </div>\n                </div>\n                <div class=\"d-flex justify-content-between small text-muted\">\n                  <span>${progress.toFixed(1)}%</span>\n                  ${download.speed ? `<span>${this.formatSpeed(download.speed)}</span>` : ''}\n                </div>\n              ` : ''}\n              \n              ${type === 'completed' ? `\n                <div class=\"small text-success\">\n                  <i class=\"fas fa-check me-1\"></i>\n                  Downloaded in ${this.formatDuration((download.endTime - download.startTime) / 1000)}\n                </div>\n              ` : ''}\n            </div>\n          </div>\n        </div>\n      </div>\n    `;\n  }\n\n  /**\n   * Refresh history view\n   */\n  refreshHistoryView() {\n    // Implementation for history view\n    console.log('Refreshing history view...');\n  }\n\n  /**\n   * Get current output directory\n   */\n  getCurrentOutputDirectory() {\n    const outputDirInput = this.state.elements.get('web-output-dir');\n    return outputDirInput?.value.trim() || null;\n  }\n\n  /**\n   * Update UI based on current state\n   */\n  updateUI() {\n    const webStartBtn = this.state.elements.get('web-start-btn');\n    const academicSearchBtn = this.state.elements.get('academic-search-btn');\n    const cancelBtn = this.state.elements.get('scraper-cancel-btn');\n    const progressContainer = this.state.elements.get('scraper-progress-container');\n\n    // Update buttons based on processing state\n    if (webStartBtn) {\n      webStartBtn.disabled = this.state.processingState !== 'idle';\n      webStartBtn.textContent = this.state.processingState === 'scraping' ? 'Scraping...' : 'Start Scraping';\n    }\n\n    if (academicSearchBtn) {\n      academicSearchBtn.disabled = this.state.processingState !== 'idle';\n      academicSearchBtn.textContent = this.state.processingState === 'searching' ? 'Searching...' : 'Search';\n    }\n\n    if (cancelBtn) {\n      cancelBtn.style.display = ['scraping', 'downloading', 'processing'].includes(this.state.processingState) ? 'inline-block' : 'none';\n    }\n\n    if (progressContainer) {\n      progressContainer.style.display = \n        ['scraping', 'downloading', 'processing', 'completed', 'error'].includes(this.state.processingState) ? 'block' : 'none';\n    }\n  }\n\n  /**\n   * Show progress update\n   */\n  showProgress(progress, message) {\n    const progressBar = this.state.elements.get('scraper-progress-bar');\n    const progressText = this.state.elements.get('scraper-progress-text');\n    const progressContainer = this.state.elements.get('scraper-progress-container');\n\n    if (progressContainer && progressContainer.style.display === 'none') {\n      progressContainer.style.display = 'block';\n    }\n\n    if (progressBar) {\n      progressBar.style.width = `${progress}%`;\n      progressBar.setAttribute('aria-valuenow', progress);\n      progressBar.textContent = `${progress.toFixed(1)}%`;\n      \n      // Update progress bar color based on progress\n      if (progress < 30) {\n        progressBar.className = 'progress-bar progress-bar-striped progress-bar-animated bg-danger';\n      } else if (progress < 70) {\n        progressBar.className = 'progress-bar progress-bar-striped progress-bar-animated bg-warning';\n      } else {\n        progressBar.className = 'progress-bar progress-bar-striped progress-bar-animated bg-success';\n      }\n    }\n\n    if (progressText) {\n      progressText.textContent = message;\n    }\n  }\n\n  /**\n   * Update statistics display\n   */\n  updateStats(stats) {\n    const statsContainer = this.state.elements.get('scraper-stats-container');\n    if (!statsContainer) return;\n\n    const statsHtml = `\n      <div class=\"row text-center\">\n        <div class=\"col-md-2\">\n          <div class=\"stat-item\">\n            <div class=\"stat-value\">${stats.urls_processed || 0}</div>\n            <div class=\"stat-label\">URLs Processed</div>\n          </div>\n        </div>\n        <div class=\"col-md-2\">\n          <div class=\"stat-item\">\n            <div class=\"stat-value\">${stats.pdfs_found || 0}</div>\n            <div class=\"stat-label\">PDFs Found</div>\n          </div>\n        </div>\n        <div class=\"col-md-2\">\n          <div class=\"stat-item\">\n            <div class=\"stat-value\">${stats.pdfs_downloaded || 0}</div>\n            <div class=\"stat-label\">PDFs Downloaded</div>\n          </div>\n        </div>\n        <div class=\"col-md-2\">\n          <div class=\"stat-item\">\n            <div class=\"stat-value\">${this.formatFileSize(stats.total_size || 0)}</div>\n            <div class=\"stat-label\">Total Size</div>\n          </div>\n        </div>\n        <div class=\"col-md-2\">\n          <div class=\"stat-item\">\n            <div class=\"stat-value\">${this.formatDuration(stats.elapsed_time || 0)}</div>\n            <div class=\"stat-label\">Elapsed Time</div>\n          </div>\n        </div>\n        <div class=\"col-md-2\">\n          <div class=\"stat-item\">\n            <div class=\"stat-value\">${stats.current_depth || 0}</div>\n            <div class=\"stat-label\">Crawl Depth</div>\n          </div>\n        </div>\n      </div>\n    `;\n\n    statsContainer.innerHTML = statsHtml;\n    statsContainer.style.display = 'block';\n  }\n\n  /**\n   * Show processing results\n   */\n  showResults(data) {\n    const resultsContainer = this.state.elements.get('scraper-results-container');\n    if (!resultsContainer) return;\n\n    const resultsHtml = `\n      <div class=\"alert alert-success\">\n        <h5><i class=\"fas fa-check-circle me-2\"></i>Scraping Complete!</h5>\n        <p>Successfully processed ${data.stats?.urls_processed || 0} URLs</p>\n        <p>Found ${data.stats?.pdfs_found || 0} PDFs and downloaded ${data.stats?.pdfs_downloaded || 0}</p>\n        \n        ${data.output_directory ? `\n          <p>Results saved to: <strong>${data.output_directory}</strong></p>\n        ` : ''}\n        \n        ${data.download_url ? `\n        <div class=\"mt-3\">\n          <a href=\"${data.download_url}\" class=\"btn btn-primary\" download>\n            <i class=\"fas fa-download me-2\"></i>Download Results\n          </a>\n        </div>\n        ` : ''}\n      </div>\n    `;\n\n    resultsContainer.innerHTML = resultsHtml;\n    resultsContainer.style.display = 'block';\n  }\n\n  /**\n   * Load saved state from localStorage\n   */\n  loadSavedState() {\n    try {\n      const savedTab = localStorage.getItem('webScraper_activeTab');\n      if (savedTab) {\n        this.switchTab(savedTab);\n      }\n\n      const savedFilters = localStorage.getItem('webScraper_filters');\n      if (savedFilters) {\n        this.state.filters = { ...this.state.filters, ...JSON.parse(savedFilters) };\n      }\n    } catch (error) {\n      console.warn('Failed to load saved state:', error);\n    }\n  }\n\n  /**\n   * Save state to localStorage\n   */\n  saveState() {\n    try {\n      localStorage.setItem('webScraper_activeTab', this.state.activeTab);\n      localStorage.setItem('webScraper_filters', JSON.stringify(this.state.filters));\n    } catch (error) {\n      console.warn('Failed to save state:', error);\n    }\n  }\n\n  /**\n   * Show field validation feedback\n   */\n  showFieldFeedback(element, message, type) {\n    // Remove existing feedback\n    const existingFeedback = element.parentNode.querySelector('.feedback-message');\n    if (existingFeedback) {\n      existingFeedback.remove();\n    }\n\n    // Add new feedback\n    const feedback = document.createElement('div');\n    feedback.className = `feedback-message ${type === 'valid' ? 'text-success' : 'text-danger'} small mt-1`;\n    feedback.textContent = message;\n    element.parentNode.appendChild(feedback);\n  }\n\n  /**\n   * Show toast notification\n   */\n  showToast(title, message, type = 'info') {\n    if (window.showToast) {\n      window.showToast(title, message, type);\n    } else {\n      console.log(`${type.toUpperCase()}: ${title} - ${message}`);\n    }\n  }\n\n  /**\n   * Enhanced notification system with multiple delivery methods\n   */\n  showNotification(message, type = 'info', title = 'Web Scraper') {\n    // Method 1: Toast notifications\n    this.showToast(title, message, type);\n    \n    // Method 2: Console logging with styling\n    const styles = {\n      error: 'color: #dc3545; font-weight: bold;',\n      warning: 'color: #fd7e14; font-weight: bold;',\n      success: 'color: #198754; font-weight: bold;',\n      info: 'color: #0d6efd;'\n    };\n    console.log(`%c[${title}] ${message}`, styles[type] || styles.info);\n    \n    // Method 3: System notification (if available)\n    if (window.NeuroGen?.notificationHandler) {\n      window.NeuroGen.notificationHandler.show({\n        title,\n        message,\n        type,\n        module: 'webScraper'\n      });\n    }\n    \n    // Method 4: Error reporting to centralized handler\n    if (type === 'error' && window.NeuroGen?.errorHandler) {\n      window.NeuroGen.errorHandler.logError({\n        module: 'webScraper',\n        message,\n        severity: type,\n        timestamp: new Date().toISOString()\n      });\n    }\n  }\n\n  /**\n   * Show error message\n   */\n  showError(message) {\n    this.showNotification(message, 'error', 'Web Scraper Error');\n  }\n\n  /**\n   * Show warning message\n   */\n  showWarning(message) {\n    this.showNotification(message, 'warning', 'Web Scraper Warning');\n  }\n\n  /**\n   * Show info message\n   */\n  showInfo(message) {\n    this.showNotification(message, 'info', 'Web Scraper');\n  }\n\n  /**\n   * Show success message\n   */\n  showSuccess(message) {\n    this.showNotification(message, 'success', 'Web Scraper');\n  }\n  \n  /**\n   * Get module health status with configuration details\n   */\n  getHealthStatus() {\n    return {\n      module: 'webScraper',\n      version: '3.1.0',\n      initialized: this.state.isInitialized,\n      status: this.state.processingState,\n      backendConnected: this.state.backendConnected || false,\n      activeTasks: this.state.activeTasks.size,\n      downloadQueue: this.state.downloadQueue.size,\n      currentTask: this.state.currentTask ? {\n        id: this.state.currentTask.id,\n        type: this.state.currentTask.type,\n        startTime: this.state.currentTask.startTime,\n        progress: this.state.currentTask.progress || 0\n      } : null,\n      configuration: {\n        endpoints: {\n          scrape: WEB_SCRAPER_CONFIG.endpoints.SCRAPE,\n          health: WEB_SCRAPER_CONFIG.endpoints.HEALTH,\n          configLoaded: !!WEB_SCRAPER_CONFIG.endpoints\n        },\n        constants: {\n          maxDepth: this.config.maxDepth,\n          maxPages: this.config.maxPages,\n          maxDownloads: this.config.pdfOptions.maxDownloads\n        }\n      },\n      dependencies: {\n        socket: !!window.socket?.connected,\n        constants: !!CONSTANTS,\n        taskEvents: !!TASK_EVENTS,\n        socketEvents: !!SOCKET_EVENTS\n      },\n      statistics: this.getModuleStats()\n    };\n  }\n\n  /**\n   * Add activity item to feed\n   */\n  addActivityItem(details) {\n    const activityFeed = document.getElementById('activity-feed');\n    if (!activityFeed) return;\n    \n    const item = document.createElement('div');\n    item.className = 'list-group-item';\n    item.innerHTML = `\n      <div class=\"d-flex justify-content-between align-items-center\">\n        <div>\n          <i class=\"fas fa-${details.icon || 'info-circle'} text-${details.type || 'info'} me-2\"></i>\n          <span>${this.escapeHtml(details.message || 'Activity')}</span>\n        </div>\n        <small class=\"text-muted\">${new Date().toLocaleTimeString()}</small>\n      </div>\n    `;\n    \n    // Add to top of feed\n    activityFeed.insertBefore(item, activityFeed.firstChild);\n    \n    // Limit feed items\n    while (activityFeed.children.length > 50) {\n      activityFeed.removeChild(activityFeed.lastChild);\n    }\n  }\n  \n  /**\n   * Get module statistics\n   */\n  getModuleStats() {\n    const stats = {\n      totalTasksRun: this.state.activeTasks.size,\n      pdfsFound: 0,\n      pdfsDownloaded: 0,\n      academicPapersFound: 0,\n      currentQueueSize: this.state.downloadQueue.size,\n      completedDownloads: 0,\n      failedDownloads: 0\n    };\n    \n    // Count PDFs\n    if (this.state.currentTask?.foundPdfs) {\n      stats.pdfsFound += this.state.currentTask.foundPdfs.size;\n    }\n    \n    // Count downloads\n    for (const download of this.state.downloadProgress.values()) {\n      if (download.status === 'completed') {\n        stats.completedDownloads++;\n        stats.pdfsDownloaded++;\n      } else if (download.status === 'error') {\n        stats.failedDownloads++;\n      }\n    }\n    \n    // Count academic papers\n    for (const results of this.state.academicResults.values()) {\n      stats.academicPapersFound += results.length;\n    }\n    \n    return stats;\n  }\n  \n  /**\n   * Utility functions\n   */\n  \n  formatFileSize(bytes) {\n    if (bytes === 0) return '0 Bytes';\n    \n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    \n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n\n  formatDuration(seconds) {\n    if (seconds < 60) {\n      return `${seconds.toFixed(1)}s`;\n    } else if (seconds < 3600) {\n      const minutes = Math.floor(seconds / 60);\n      const remainingSeconds = Math.floor(seconds % 60);\n      return `${minutes}m ${remainingSeconds}s`;\n    } else {\n      const hours = Math.floor(seconds / 3600);\n      const minutes = Math.floor((seconds % 3600) / 60);\n      return `${hours}h ${minutes}m`;\n    }\n  }\n\n  formatSpeed(bytesPerSecond) {\n    return `${this.formatFileSize(bytesPerSecond)}/s`;\n  }\n\n  escapeHtml(text) {\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n  }\n\n  generateId(text) {\n    return btoa(text).replace(/[^a-zA-Z0-9]/g, '').substring(0, 8);\n  }\n\n  /**\n   * Reset to initial state\n   */\n  reset() {\n    console.log('🔄 Resetting Web Scraper to initial state...');\n    \n    // Cancel current task if any\n    if (this.state.currentTask) {\n      this.cancelCurrentTask().catch(console.error);\n    }\n    \n    // Clear state\n    this.state.currentTask = null;\n    this.state.processingState = 'idle';\n    this.state.selectedPdfs.clear();\n    this.state.downloadQueue.clear();\n    this.state.downloadProgress.clear();\n    this.state.scrapingResults.clear();\n    this.state.academicResults.clear();\n    \n    // Clear UI elements\n    const elements = [\n      'scraper-progress-container',\n      'scraper-stats-container', \n      'scraper-results-container',\n      'pdf-selection-panel',\n      'academic-results'\n    ];\n    \n    elements.forEach(id => {\n      const element = this.state.elements.get(id) || document.getElementById(id);\n      if (element) {\n        element.style.display = 'none';\n      }\n    });\n    \n    // Clear activity feed\n    const activityFeed = document.getElementById('activity-feed');\n    if (activityFeed) {\n      activityFeed.innerHTML = '';\n    }\n    \n    // Reset progress bar\n    this.showProgress(0, 'Ready to start');\n\n    this.updateUI();\n    \n    console.log('✅ Web Scraper reset complete');\n  }\n\n  /**\n   * Cleanup event listeners and resources\n   */\n  cleanup() {\n    console.log('🧹 Cleaning up Web Scraper module...');\n    \n    // Remove event listeners\n    this.state.eventListeners.forEach(removeListener => {\n      try {\n        removeListener();\n      } catch (e) {\n        console.warn('Error removing event listener:', e);\n      }\n    });\n    this.state.eventListeners.clear();\n\n    // Remove socket listeners\n    this.state.socketListeners.forEach(removeListener => {\n      try {\n        removeListener();\n      } catch (e) {\n        console.warn('Error removing socket listener:', e);\n      }\n    });\n    this.state.socketListeners.clear();\n\n    // Cancel any ongoing tasks\n    if (this.state.currentTask) {\n      this.cancelCurrentTask().catch(console.error);\n    }\n\n    // Save state before cleanup\n    this.saveState();\n\n    this.state.isInitialized = false;\n    \n    // Unregister from module system\n    if (window.NeuroGen?.modules?.webScraper) {\n      delete window.NeuroGen.modules.webScraper;\n    }\n    \n    console.log('✅ Web Scraper cleanup complete');\n  }\n}\n\n// Create singleton instance\nconst webScraper = new WebScraper();\n\n// Export for use by other modules\nexport default webScraper;\n\n// Expose to global scope for debugging and UI interaction\nif (typeof window !== 'undefined') {\n  window.webScraper = webScraper;\n  \n  // Register with NeuroGen module system\n  if (window.NeuroGen) {\n    window.NeuroGen.modules = window.NeuroGen.modules || {};\n    window.NeuroGen.modules.webScraper = webScraper;\n  }\n}\n\n// Auto-initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => {\n    webScraper.init().then(() => {\n      // Notify health monitor if available\n      if (window.healthMonitor) {\n        window.healthMonitor.runHealthCheck();\n      }\n    }).catch(error => {\n      console.error('Web Scraper initialization error:', error);\n      // Report to error handler if available\n      if (window.NeuroGen?.errorHandler) {\n        window.NeuroGen.errorHandler.handleError(error, 'webScraper.init');\n      }\n    });\n  });\n} else {\n  webScraper.init().catch(error => {\n    console.error('Web Scraper initialization error:', error);\n  });\n}\n\nconsole.log('🌐 Web Scraper module loaded (Optimized v3.1.0 - Config Integration)');","source":"/workspace/modules/static/js/modules/features/webScraper.js","title":"webScraper.js","language":"en"},{"content":"/**\n * Web Scraper Utilities Module\n * \n * Provides specialized utilities for web scraping operations,\n * particularly for PDF handling and academic paper metadata.\n * \n * This module complements the main webScraper.js module with\n * additional functionality for academic search, PDF analysis,\n * and specialized file handling.\n */\n\n// Constants\nconst PDF_API_BASE = '/api/pdf';\nconst ACADEMIC_API_BASE = '/api/academic';\n\n/**\n * Extract PDF metadata from a file\n * @param {string} filePath Path to the PDF file\n * @returns {Promise<Object>} PDF metadata\n */\nasync function extractPdfMetadata(filePath) {\n  try {\n    const response = await fetch(`${PDF_API_BASE}/analyze`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ pdf_path: filePath })\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Server error: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error('Error extracting PDF metadata:', error);\n    throw error;\n  }\n}\n\n/**\n * Extract tables from a PDF file\n * @param {string} filePath Path to the PDF file\n * @param {Array<number>} pageRange Optional page range [start, end]\n * @returns {Promise<Array>} Extracted tables\n */\nasync function extractPdfTables(filePath, pageRange = null) {\n  try {\n    const requestData = {\n      pdf_path: filePath\n    };\n    \n    if (pageRange && Array.isArray(pageRange) && pageRange.length === 2) {\n      requestData.page_range = pageRange;\n    }\n    \n    const response = await fetch(`${PDF_API_BASE}/extract-tables`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(requestData)\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Server error: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error('Error extracting PDF tables:', error);\n    throw error;\n  }\n}\n\n/**\n * Detect the type of a PDF document (scan, digital, etc.)\n * @param {string} filePath Path to the PDF file\n * @returns {Promise<Object>} Document type info\n */\nasync function detectPdfType(filePath) {\n  try {\n    const response = await fetch(`${PDF_API_BASE}/detect-type`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ pdf_path: filePath })\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Server error: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error('Error detecting PDF type:', error);\n    throw error;\n  }\n}\n\n/**\n * Process a PDF file with advanced options\n * @param {string} filePath Path to the PDF file\n * @param {Object} options Processing options\n * @returns {Promise<Object>} Processing result\n */\nasync function processPdf(filePath, options = {}) {\n  try {\n    // Set default options\n    const defaultOptions = {\n      extract_tables: true,\n      use_ocr: true,\n      detect_document_type: true,\n      chunk_size: 4096\n    };\n    \n    const processingOptions = { ...defaultOptions, ...options };\n    \n    // Prepare request data\n    const requestData = {\n      pdf_path: filePath,\n      ...processingOptions\n    };\n    \n    const response = await fetch(`${PDF_API_BASE}/process`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(requestData)\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Server error: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error('Error processing PDF:', error);\n    throw error;\n  }\n}\n\n/**\n * Search for academic papers\n * @param {string} query Search query\n * @param {string} source Source to search (arxiv, semantic, openalex, all)\n * @param {number} limit Maximum number of results\n * @returns {Promise<Object>} Search results\n */\nasync function searchAcademicPapers(query, source = 'all', limit = 10) {\n  try {\n    const requestData = {\n      query,\n      source,\n      limit\n    };\n    \n    const response = await fetch(`${ACADEMIC_API_BASE}/search`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(requestData)\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Server error: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error('Error searching academic papers:', error);\n    throw error;\n  }\n}\n\n/**\n * Batch process multiple PDFs\n * @param {Array<string>} pdfFiles Array of PDF file paths\n * @param {string} outputFolder Output folder for processed files\n * @param {Object} options Processing options\n * @returns {Promise<Object>} Batch processing result\n */\nasync function batchProcessPdfs(pdfFiles, outputFolder, options = {}) {\n  try {\n    // Set default options\n    const defaultOptions = {\n      extract_tables: true,\n      use_ocr: true,\n      extract_structure: true\n    };\n    \n    const processingOptions = { ...defaultOptions, ...options };\n    \n    // Prepare request data\n    const requestData = {\n      pdf_files: pdfFiles,\n      output_folder: outputFolder,\n      ...processingOptions\n    };\n    \n    const response = await fetch(`${PDF_API_BASE}/batch-process`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(requestData)\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Server error: ${response.status}`);\n    }\n    \n    const data = await response.json();\n    \n    // Return task ID for tracking\n    return data;\n  } catch (error) {\n    console.error('Error batch processing PDFs:', error);\n    throw error;\n  }\n}\n\n/**\n * Check the status of a PDF processing task\n * @param {string} taskId Task ID to check\n * @returns {Promise<Object>} Task status\n */\nasync function checkPdfTaskStatus(taskId) {\n  try {\n    const response = await fetch(`${PDF_API_BASE}/status/${taskId}`);\n    \n    if (!response.ok) {\n      throw new Error(`Server error: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error('Error checking PDF task status:', error);\n    throw error;\n  }\n}\n\n/**\n * Cancel a PDF processing task\n * @param {string} taskId Task ID to cancel\n * @returns {Promise<Object>} Cancellation result\n */\nasync function cancelPdfTask(taskId) {\n  try {\n    const response = await fetch(`${PDF_API_BASE}/cancel/${taskId}`, {\n      method: 'POST'\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Server error: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error('Error cancelling PDF task:', error);\n    throw error;\n  }\n}\n\n/**\n * Get details about PDFs found on a webpage\n * @param {string} url URL to scan for PDFs\n * @returns {Promise<Object>} PDF details\n */\nasync function getPdfLinksFromUrl(url) {\n  try {\n    const response = await fetch('/api/pdf-links', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ url })\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Server error: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error('Error getting PDF links:', error);\n    throw error;\n  }\n}\n\n/**\n * Convert a DOI to a downloadable PDF URL\n * @param {string} doi DOI string (e.g., 10.1038/ncomms1234)\n * @returns {Promise<Object>} PDF URL info\n */\nasync function doiToPdfUrl(doi) {\n  try {\n    const response = await fetch('/api/doi-to-pdf', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ doi })\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Server error: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error('Error converting DOI to PDF URL:', error);\n    throw error;\n  }\n}\n\n/**\n * Validate if a URL is a valid PDF link\n * @param {string} url URL to check\n * @returns {Promise<Object>} Validation result\n */\nasync function validatePdfUrl(url) {\n  try {\n    const response = await fetch('/api/validate-pdf-url', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ url })\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Server error: ${response.status}`);\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error('Error validating PDF URL:', error);\n    throw error;\n  }\n}\n\n/**\n * Format a citation from PDF metadata\n * @param {Object} metadata PDF metadata\n * @param {string} style Citation style (apa, mla, chicago, etc.)\n * @returns {string} Formatted citation\n */\nfunction formatCitation(metadata, style = 'apa') {\n  // Default to empty strings for missing fields\n  const {\n    title = '',\n    authors = [],\n    year = '',\n    journal = '',\n    volume = '',\n    issue = '',\n    pages = '',\n    doi = '',\n    url = ''\n  } = metadata;\n  \n  // Format authors\n  const formatAuthors = (authors) => {\n    if (!authors || !authors.length) return '';\n    \n    if (style === 'apa') {\n      // APA style: Last, F., & Last, F.\n      return authors.map((author, i) => {\n        const nameParts = author.split(' ');\n        const lastName = nameParts.pop() || '';\n        const initials = nameParts.map(part => `${part.charAt(0)}.`).join(' ');\n        return `${lastName}, ${initials}`;\n      }).join(', ');\n    } else if (style === 'mla') {\n      // MLA style: Last, First\n      return authors.map((author, i) => {\n        const nameParts = author.split(' ');\n        const lastName = nameParts.pop() || '';\n        const firstName = nameParts.join(' ');\n        return i === 0 ? `${lastName}, ${firstName}` : `${firstName} ${lastName}`;\n      }).join(', ');\n    } else {\n      // Default format\n      return authors.join(', ');\n    }\n  };\n  \n  const formattedAuthors = formatAuthors(authors);\n  \n  // Format citation based on style\n  if (style === 'apa') {\n    let citation = '';\n    \n    if (formattedAuthors) {\n      citation += `${formattedAuthors} `;\n    }\n    \n    if (year) {\n      citation += `(${year}). `;\n    }\n    \n    if (title) {\n      citation += `${title}. `;\n    }\n    \n    if (journal) {\n      citation += `<em>${journal}</em>`;\n      \n      if (volume) {\n        citation += `, ${volume}`;\n      }\n      \n      if (issue) {\n        citation += `(${issue})`;\n      }\n      \n      if (pages) {\n        citation += `, ${pages}`;\n      }\n      \n      citation += '. ';\n    }\n    \n    if (doi) {\n      citation += `https://doi.org/${doi}`;\n    } else if (url) {\n      citation += url;\n    }\n    \n    return citation;\n  } else if (style === 'mla') {\n    let citation = '';\n    \n    if (formattedAuthors) {\n      citation += `${formattedAuthors}. `;\n    }\n    \n    if (title) {\n      citation += `\"${title}.\" `;\n    }\n    \n    if (journal) {\n      citation += `<em>${journal}</em>`;\n      \n      if (volume) {\n        citation += `, vol. ${volume}`;\n      }\n      \n      if (issue) {\n        citation += `, no. ${issue}`;\n      }\n      \n      if (year) {\n        citation += `, ${year}`;\n      }\n      \n      if (pages) {\n        citation += `, pp. ${pages}`;\n      }\n      \n      citation += '. ';\n    }\n    \n    if (doi) {\n      citation += `DOI: ${doi}`;\n    } else if (url) {\n      citation += `URL: ${url}`;\n    }\n    \n    return citation;\n  } else {\n    // Default simple format\n    return `${formattedAuthors} (${year}). ${title}. ${journal} ${volume}${issue ? `(${issue})` : ''}${pages ? `: ${pages}` : ''}. ${doi ? `https://doi.org/${doi}` : url}`;\n  }\n}\n\n// Export utility functions\nexport {\n  extractPdfMetadata,\n  extractPdfTables,\n  detectPdfType,\n  processPdf,\n  searchAcademicPapers,\n  batchProcessPdfs,\n  checkPdfTaskStatus,\n  cancelPdfTask,\n  getPdfLinksFromUrl,\n  doiToPdfUrl,\n  validatePdfUrl,\n  formatCitation\n};\n\nexport default {\n  extractPdfMetadata,\n  extractPdfTables,\n  detectPdfType,\n  processPdf,\n  searchAcademicPapers,\n  batchProcessPdfs,\n  checkPdfTaskStatus,\n  cancelPdfTask,\n  getPdfLinksFromUrl,\n  doiToPdfUrl,\n  validatePdfUrl,\n  formatCitation\n};","source":"/workspace/modules/static/js/modules/features/webScraperUtils.js","title":"webScraperUtils.js","language":"en"},{"content":"/**\n * Web Scraper Module V2 - Consistent Import System\n * \n * Advanced web scraping module with recursive crawling, academic search integration,\n * PDF processing, and comprehensive download management.\n * \n * @module features/webScraperV2\n * @version 3.1.0\n */\n\nimport { createStandardImports } from '../core/moduleImports.js';\n\n// Initialize module imports\nconst imports = await createStandardImports();\n\n// Destructure imports for easier access\nconst { \n  // Core\n  showErrorNotification, showSuccess,\n  getElement, addClass, removeClass,\n  setState, getState,\n  registerEvents, emit,\n  \n  // Utils\n  showLoadingSpinner, hideLoadingSpinner, showToast,\n  generateId, formatDate,\n  showProgress, updateProgress,\n  \n  // Config\n  endpoints: { SCRAPER_ENDPOINTS, ACADEMIC_ENDPOINTS, PDF_ENDPOINTS },\n  socketEvents: { TASK_EVENTS, SCRAPER_EVENTS, ACADEMIC_EVENTS },\n  constants: { CONSTANTS },\n  \n  // Services\n  blueprintApi\n} = imports;\n\n/**\n * Web Scraper Class - Consistent Implementation\n */\nclass WebScraper {\n  constructor() {\n    this.state = {\n      isInitialized: false,\n      currentMode: 'web',\n      currentTask: null,\n      processingState: 'idle',\n      elements: new Map(),\n      eventListeners: new Set(),\n      socketListeners: new Set(),\n      \n      // Task management\n      activeTasks: new Map(),\n      taskQueue: [],\n      downloadQueue: new Map(),\n      processingQueue: new Map(),\n      \n      // Results and data\n      scrapingResults: new Map(),\n      academicResults: new Map(),\n      selectedPdfs: new Set(),\n      downloadProgress: new Map(),\n      \n      // UI state\n      activeTab: 'web',\n      filters: {\n        source: 'all',\n        dateRange: 'all',\n        fileSize: 'all',\n        author: '',\n        title: ''\n      }\n    };\n    \n    this.config = {\n      maxDepth: 3,\n      maxPages: 100,\n      respectRobots: true,\n      followRedirects: true,\n      concurrentRequests: 5,\n      requestDelay: 500,\n      timeout: 30000,\n      retryAttempts: 3,\n      \n      pdfOptions: {\n        maxDownloads: 10,\n        processWithStructify: true,\n        extractTables: true,\n        useOcr: true,\n        extractStructure: true,\n        chunkSize: 4096\n      },\n      \n      academicSources: ['arxiv', 'semantic_scholar', 'pubmed', 'ieee', 'acm'],\n      maxResultsPerSource: 50,\n      itemsPerPage: 20,\n      autoRefreshInterval: 2000\n    };\n  }\n\n  /**\n   * Initialize the Web Scraper module\n   */\n  async init() {\n    if (this.state.isInitialized) return;\n    \n    try {\n      console.log('🌐 Initializing Web Scraper V2...');\n      \n      this.cacheElements();\n      this.setupEventHandlers();\n      this.setupSocketHandlers();\n      this.setupTabs();\n      this.setupFormValidation();\n      this.setupDownloadManager();\n      \n      // Load saved state\n      this.loadSavedState();\n      \n      this.state.isInitialized = true;\n      console.log('✅ Web Scraper V2 initialized successfully');\n      \n    } catch (error) {\n      console.error('❌ Web Scraper initialization failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Cache DOM elements\n   */\n  cacheElements() {\n    const elementIds = [\n      'scraper-tabs',\n      'web-tab-btn',\n      'academic-tab-btn', \n      'downloads-tab-btn',\n      'history-tab-btn',\n      'web-tab-content',\n      'web-urls-input',\n      'web-recursive-toggle',\n      'web-max-depth',\n      'web-max-pages',\n      'web-output-dir',\n      'web-start-btn',\n      'academic-tab-content',\n      'academic-query-input',\n      'academic-sources-select',\n      'academic-max-results',\n      'academic-search-btn',\n      'downloads-tab-content',\n      'downloads-queue-container',\n      'downloads-active-container',\n      'downloads-completed-container',\n      'pdf-results-container',\n      'pdf-select-all-btn',\n      'pdf-select-none-btn',\n      'pdf-add-to-queue-btn',\n      'pdf-filter-container',\n      'scraper-progress-container',\n      'scraper-progress-bar',\n      'scraper-progress-text',\n      'scraper-stats-container',\n      'scraper-results-container',\n      'scraper-cancel-btn'\n    ];\n\n    elementIds.forEach(id => {\n      const element = getElement(id);\n      if (element) {\n        this.state.elements.set(id, element);\n      }\n    });\n  }\n\n  /**\n   * Setup event handlers\n   */\n  setupEventHandlers() {\n    const handlers = {\n      'web-tab-btn': () => this.switchTab('web'),\n      'academic-tab-btn': () => this.switchTab('academic'),\n      'downloads-tab-btn': () => this.switchTab('downloads'),\n      'history-tab-btn': () => this.switchTab('history'),\n      'web-start-btn': () => this.startWebScraping(),\n      'academic-search-btn': () => this.startAcademicSearch(),\n      'pdf-select-all-btn': () => this.selectAllPdfs(),\n      'pdf-select-none-btn': () => this.selectNonePdfs(),\n      'pdf-add-to-queue-btn': () => this.addSelectedToDownloadQueue(),\n      'scraper-cancel-btn': () => this.cancelCurrentTask()\n    };\n\n    Object.entries(handlers).forEach(([elementId, handler]) => {\n      const element = this.state.elements.get(elementId);\n      if (element) {\n        element.addEventListener('click', handler);\n        this.state.eventListeners.add(() => element.removeEventListener('click', handler));\n      }\n    });\n\n    this.setupInputValidation();\n  }\n\n  /**\n   * Setup Socket.IO handlers\n   */\n  setupSocketHandlers() {\n    if (!window.socket) return;\n\n    const socketHandlers = {\n      [TASK_EVENTS.STARTED]: (data) => this.isMyTask(data.task_id) && this.handleTaskStarted(data),\n      [TASK_EVENTS.PROGRESS]: (data) => this.isMyTask(data.task_id) && this.handleProgressUpdate(data),\n      [TASK_EVENTS.COMPLETED]: (data) => this.isMyTask(data.task_id) && this.handleTaskCompleted(data),\n      [TASK_EVENTS.ERROR]: (data) => this.isMyTask(data.task_id) && this.handleTaskError(data),\n      [SCRAPER_EVENTS.url_scraped]: (data) => this.isMyTask(data.task_id) && this.handleUrlScraped(data),\n      [SCRAPER_EVENTS.pdf_found]: (data) => this.isMyTask(data.task_id) && this.handlePdfFound(data),\n      [SCRAPER_EVENTS.pdf_download_start]: (data) => this.isMyTask(data.task_id) && this.handlePdfDownloadStart(data),\n      [SCRAPER_EVENTS.pdf_download_progress]: (data) => this.isMyTask(data.task_id) && this.handlePdfDownloadProgress(data),\n      [SCRAPER_EVENTS.pdf_download_complete]: (data) => this.isMyTask(data.task_id) && this.handlePdfDownloadComplete(data),\n      [ACADEMIC_EVENTS.paper_found]: (data) => this.handleAcademicResults(data)\n    };\n\n    Object.entries(socketHandlers).forEach(([event, handler]) => {\n      window.socket.on(event, handler);\n      this.state.socketListeners.add(() => window.socket.off(event, handler));\n    });\n  }\n\n  /**\n   * Setup tabs\n   */\n  setupTabs() {\n    this.switchTab('web');\n  }\n\n  /**\n   * Setup form validation\n   */\n  setupFormValidation() {\n    const urlsInput = this.state.elements.get('web-urls-input');\n    if (urlsInput) {\n      urlsInput.addEventListener('input', () => this.validateWebForm());\n    }\n\n    const queryInput = this.state.elements.get('academic-query-input');\n    if (queryInput) {\n      queryInput.addEventListener('input', () => this.validateAcademicForm());\n    }\n  }\n\n  /**\n   * Setup input validation\n   */\n  setupInputValidation() {\n    const urlsInput = this.state.elements.get('web-urls-input');\n    if (urlsInput) {\n      urlsInput.addEventListener('blur', () => {\n        const urls = this.parseUrls(urlsInput.value);\n        this.validateUrls(urls);\n      });\n    }\n  }\n\n  /**\n   * Setup download manager\n   */\n  setupDownloadManager() {\n    this.startDownloadQueueProcessor();\n    this.setupAutoRefresh();\n  }\n\n  /**\n   * Switch between tabs\n   */\n  switchTab(tabName) {\n    this.state.activeTab = tabName;\n    \n    const tabButtons = ['web-tab-btn', 'academic-tab-btn', 'downloads-tab-btn', 'history-tab-btn'];\n    tabButtons.forEach(btnId => {\n      const btn = this.state.elements.get(btnId);\n      if (btn) {\n        const isActive = btnId === `${tabName}-tab-btn`;\n        btn.classList.toggle('active', isActive);\n        btn.setAttribute('aria-selected', isActive);\n      }\n    });\n\n    const tabContents = ['web-tab-content', 'academic-tab-content', 'downloads-tab-content', 'history-tab-content'];\n    tabContents.forEach(contentId => {\n      const content = this.state.elements.get(contentId);\n      if (content) {\n        content.style.display = contentId === `${tabName}-tab-content` ? 'block' : 'none';\n      }\n    });\n\n    this.state.currentMode = tabName;\n    localStorage.setItem('webScraper_activeTab', tabName);\n    \n    if (tabName === 'downloads') {\n      this.refreshDownloadsView();\n    } else if (tabName === 'history') {\n      this.refreshHistoryView();\n    }\n  }\n\n  /**\n   * Start web scraping\n   */\n  async startWebScraping() {\n    try {\n      const urlsInput = this.state.elements.get('web-urls-input');\n      const recursiveToggle = this.state.elements.get('web-recursive-toggle');\n      const maxDepthInput = this.state.elements.get('web-max-depth');\n      const maxPagesInput = this.state.elements.get('web-max-pages');\n      const outputDirInput = this.state.elements.get('web-output-dir');\n\n      if (!urlsInput?.value.trim()) {\n        showErrorNotification('Please enter at least one URL to scrape');\n        return;\n      }\n\n      const urls = this.parseUrls(urlsInput.value);\n      if (urls.length === 0) {\n        showErrorNotification('Please enter valid URLs');\n        return;\n      }\n\n      const options = {\n        urls: urls.map(url => ({ url, setting: 'pdf' })),\n        download_directory: outputDirInput?.value.trim() || 'downloads/web-scraper',\n        outputFilename: `scraping_${Date.now()}`,\n        recursive: recursiveToggle?.checked || false,\n        max_depth: parseInt(maxDepthInput?.value) || this.config.maxDepth,\n        max_pages: parseInt(maxPagesInput?.value) || this.config.maxPages,\n        pdf_options: this.config.pdfOptions,\n        respect_robots: this.config.respectRobots,\n        request_delay: this.config.requestDelay,\n        timeout: this.config.timeout\n      };\n\n      this.state.processingState = 'scraping';\n      this.updateUI();\n\n      showLoadingSpinner('Starting web scraping...');\n      \n      const response = await blueprintApi.request(SCRAPER_ENDPOINTS.START, {\n        method: 'POST',\n        body: JSON.stringify(options)\n      });\n\n      hideLoadingSpinner();\n\n      this.state.currentTask = {\n        id: response.task_id,\n        type: 'web_scraping',\n        urls,\n        options,\n        startTime: Date.now(),\n        foundPdfs: new Map()\n      };\n\n      this.state.activeTasks.set(response.task_id, this.state.currentTask);\n\n      console.log(`🌐 Web scraping started: ${response.task_id}`);\n      showSuccess(`Scraping started for ${urls.length} URL(s)`);\n\n    } catch (error) {\n      console.error('❌ Failed to start web scraping:', error);\n      hideLoadingSpinner();\n      this.handleTaskError({ error: error.message });\n    }\n  }\n\n  /**\n   * Start academic search\n   */\n  async startAcademicSearch() {\n    try {\n      const queryInput = this.state.elements.get('academic-query-input');\n      const sourcesSelect = this.state.elements.get('academic-sources-select');\n      const maxResultsInput = this.state.elements.get('academic-max-results');\n\n      if (!queryInput?.value.trim()) {\n        showErrorNotification('Please enter a search query');\n        return;\n      }\n\n      const query = queryInput.value.trim();\n      const sources = this.getSelectedSources(sourcesSelect);\n      const maxResults = parseInt(maxResultsInput?.value) || this.config.maxResultsPerSource;\n\n      this.state.processingState = 'searching';\n      this.updateUI();\n\n      showLoadingSpinner('Searching academic papers...');\n\n      const response = await blueprintApi.request(ACADEMIC_ENDPOINTS.SEARCH, {\n        method: 'POST',\n        body: JSON.stringify({\n          query,\n          source: sources.length === 1 ? sources[0] : 'all',\n          max_results: maxResults\n        })\n      });\n\n      hideLoadingSpinner();\n\n      console.log(`📚 Academic search completed`);\n      showSuccess(`Found ${response.results?.length || 0} papers`);\n\n      if (response.results) {\n        this.handleAcademicResults({\n          source: 'mixed',\n          papers: response.results\n        });\n      }\n\n    } catch (error) {\n      console.error('❌ Failed to start academic search:', error);\n      hideLoadingSpinner();\n      this.handleTaskError({ error: error.message });\n    }\n  }\n\n  // ... Continue with all other methods using the consistent import system ...\n\n  /**\n   * Utility method to parse URLs\n   */\n  parseUrls(text) {\n    if (!text) return [];\n    const urlRegex = /https?:\\/\\/[^\\s]+/g;\n    const urls = text.match(urlRegex) || [];\n    const lines = text.split('\\n').map(line => line.trim()).filter(line => line);\n    const lineUrls = lines.filter(line => /^https?:\\/\\//.test(line));\n    return [...new Set([...urls, ...lineUrls])];\n  }\n\n  /**\n   * Get selected sources\n   */\n  getSelectedSources(selectElement) {\n    if (!selectElement) return this.config.academicSources;\n    const selected = Array.from(selectElement.selectedOptions).map(option => option.value);\n    return selected.includes('all') ? this.config.academicSources : selected;\n  }\n\n  /**\n   * Check if task belongs to this instance\n   */\n  isMyTask(taskId) {\n    return this.state.activeTasks.has(taskId) || \n           (this.state.currentTask && this.state.currentTask.id === taskId);\n  }\n\n  /**\n   * Load saved state\n   */\n  loadSavedState() {\n    try {\n      const savedTab = localStorage.getItem('webScraper_activeTab');\n      if (savedTab) {\n        this.switchTab(savedTab);\n      }\n    } catch (error) {\n      console.warn('Failed to load saved state:', error);\n    }\n  }\n\n  /**\n   * Update UI based on current state\n   */\n  updateUI() {\n    const webStartBtn = this.state.elements.get('web-start-btn');\n    const academicSearchBtn = this.state.elements.get('academic-search-btn');\n    const cancelBtn = this.state.elements.get('scraper-cancel-btn');\n    const progressContainer = this.state.elements.get('scraper-progress-container');\n\n    if (webStartBtn) {\n      webStartBtn.disabled = this.state.processingState !== 'idle';\n    }\n\n    if (academicSearchBtn) {\n      academicSearchBtn.disabled = this.state.processingState !== 'idle';\n    }\n\n    if (cancelBtn) {\n      cancelBtn.style.display = ['scraping', 'searching'].includes(this.state.processingState) ? 'inline-block' : 'none';\n    }\n\n    if (progressContainer) {\n      progressContainer.style.display = this.state.processingState !== 'idle' ? 'block' : 'none';\n    }\n  }\n\n  // Implement remaining methods...\n  handleTaskStarted(data) { console.log('Task started:', data); }\n  handleProgressUpdate(data) { updateProgress(data.progress, data.message); }\n  handleTaskCompleted(data) { \n    this.state.processingState = 'idle';\n    showSuccess('Task completed successfully!');\n    this.updateUI();\n  }\n  handleTaskError(data) { \n    this.state.processingState = 'idle';\n    showErrorNotification(data.error || 'Task failed');\n    this.updateUI();\n  }\n  handleUrlScraped(data) { console.log('URL scraped:', data); }\n  handlePdfFound(data) { console.log('PDF found:', data); }\n  handlePdfDownloadStart(data) { console.log('PDF download started:', data); }\n  handlePdfDownloadProgress(data) { console.log('PDF download progress:', data); }\n  handlePdfDownloadComplete(data) { console.log('PDF download complete:', data); }\n  handleAcademicResults(data) { console.log('Academic results:', data); }\n  \n  validateWebForm() { return true; }\n  validateAcademicForm() { return true; }\n  validateUrls(urls) { return urls.length > 0; }\n  cancelCurrentTask() { console.log('Cancelling current task'); }\n  selectAllPdfs() { console.log('Select all PDFs'); }\n  selectNonePdfs() { console.log('Select no PDFs'); }\n  addSelectedToDownloadQueue() { console.log('Add to download queue'); }\n  startDownloadQueueProcessor() { console.log('Download queue processor started'); }\n  setupAutoRefresh() { console.log('Auto refresh setup'); }\n  refreshDownloadsView() { console.log('Refreshing downloads view'); }\n  refreshHistoryView() { console.log('Refreshing history view'); }\n\n  /**\n   * Cleanup\n   */\n  cleanup() {\n    this.state.eventListeners.forEach(removeListener => removeListener());\n    this.state.eventListeners.clear();\n    this.state.socketListeners.forEach(removeListener => removeListener());\n    this.state.socketListeners.clear();\n    this.state.isInitialized = false;\n  }\n}\n\n// Create singleton instance\nconst webScraper = new WebScraper();\n\n// Export for use by other modules\nexport default webScraper;\n\n// Auto-initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => webScraper.init());\n} else {\n  webScraper.init();\n}\n\nconsole.log('🌐 Web Scraper V2 module loaded');","source":"/workspace/modules/static/js/modules/features/webScraperV2.js","title":"webScraperV2.js","language":"en"},{"content":"/**\n * Blueprint API Service\n * \n * Centralized API service for Flask Blueprint architecture with cross-platform support.\n * Handles all HTTP communication with Blueprint endpoints including proper error handling,\n * retry logic, and cross-platform path conversion.\n * \n * @module services/blueprintApi\n * @version 3.0.0\n */\n\nimport { \n  API_ENDPOINTS, \n  BLUEPRINT_ROUTES,\n  buildEndpoint, \n  buildUrlWithQuery,\n  getEndpointMethods,\n  getEndpointTimeout,\n  validateEndpoint,\n  sanitizePathForLinuxServer,\n  sanitizeFilenameForWindows\n} from '../config/endpoints.js';\nimport { CONSTANTS, API_CONFIG, ERROR_MESSAGES } from '../config/constants.js';\n\n/**\n * Blueprint API Service Class\n */\nclass BlueprintApiService {\n  constructor() {\n    this.baseURL = API_CONFIG.API_BASE_URL;\n    this.retryAttempts = API_CONFIG.API_RETRY_ATTEMPTS;\n    this.retryDelay = API_CONFIG.API_RETRY_DELAY;\n    this.concurrentRequests = API_CONFIG.API_CONCURRENT_REQUESTS;\n    \n    // Track active requests for cancellation\n    this.activeRequests = new Map();\n    \n    // Request queue for rate limiting\n    this.requestQueue = [];\n    this.processingQueue = false;\n    \n    // Blueprint-specific configurations\n    this.blueprintConfigs = new Map();\n    this.initializeBlueprintConfigs();\n    \n    // Cross-platform settings\n    this.crossPlatformEnabled = CONSTANTS.FEATURE_FLAGS.ENABLE_CROSS_PLATFORM_PATHS;\n    this.serverPlatform = 'linux'; // Production default\n    this.clientPlatform = this.detectClientPlatform();\n  }\n\n  /**\n   * Initialize Blueprint-specific configurations\n   */\n  initializeBlueprintConfigs() {\n    Object.entries(BLUEPRINT_ROUTES).forEach(([name, config]) => {\n      this.blueprintConfigs.set(name, {\n        ...config,\n        timeout: API_CONFIG.BLUEPRINT_TIMEOUTS[name] || API_CONFIG.API_TIMEOUT,\n        retryAttempts: name === 'file_processor' ? 5 : 3, // More retries for file processing\n        rateLimit: name === 'academic_search' ? 2 : 10 // Lower rate limit for academic APIs\n      });\n    });\n  }\n\n  /**\n   * Detect client platform for cross-platform operations\n   */\n  detectClientPlatform() {\n    const platform = navigator.platform.toLowerCase();\n    if (platform.includes('win')) return 'windows';\n    if (platform.includes('mac')) return 'mac';\n    return 'linux';\n  }\n\n  /**\n   * Make API request with Blueprint-aware error handling\n   * @param {string} endpoint - API endpoint\n   * @param {Object} options - Request options\n   * @param {string} blueprint - Blueprint name (optional, auto-detected)\n   * @returns {Promise<Object>} Response data\n   */\n  async request(endpoint, options = {}, blueprint = null) {\n    // Validate endpoint\n    const validation = validateEndpoint(endpoint);\n    if (!validation.valid) {\n      throw new Error(`Invalid endpoint: ${endpoint} - ${validation.error}`);\n    }\n\n    blueprint = blueprint || validation.blueprint;\n    const blueprintConfig = this.blueprintConfigs.get(blueprint);\n    \n    // Prepare request configuration\n    const requestConfig = {\n      method: options.method || getEndpointMethods(endpoint)[0] || 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n        ...options.headers\n      },\n      timeout: options.timeout || blueprintConfig?.timeout || getEndpointTimeout(endpoint),\n      ...options\n    };\n\n    // Handle cross-platform path conversion\n    if (this.crossPlatformEnabled && requestConfig.body && typeof requestConfig.body === 'object') {\n      requestConfig.body = this.convertPathsForServer(requestConfig.body);\n    }\n\n    // Create request ID for tracking\n    const requestId = this.generateRequestId();\n    \n    try {\n      // Add to rate limiting queue\n      const response = await this.queueRequest(endpoint, requestConfig, requestId);\n      \n      // Handle cross-platform response conversion\n      if (this.crossPlatformEnabled && response && typeof response === 'object') {\n        return this.convertPathsForClient(response);\n      }\n      \n      return response;\n    } catch (error) {\n      this.handleRequestError(error, endpoint, blueprint, requestId);\n      throw error;\n    } finally {\n      this.activeRequests.delete(requestId);\n    }\n  }\n\n  /**\n   * Queue request for rate limiting\n   * @param {string} endpoint - API endpoint\n   * @param {Object} config - Request configuration\n   * @param {string} requestId - Request ID\n   * @returns {Promise<Object>} Response data\n   */\n  async queueRequest(endpoint, config, requestId) {\n    return new Promise((resolve, reject) => {\n      this.requestQueue.push({\n        endpoint,\n        config,\n        requestId,\n        resolve,\n        reject,\n        timestamp: Date.now()\n      });\n      \n      this.processRequestQueue();\n    });\n  }\n\n  /**\n   * Process request queue with rate limiting\n   */\n  async processRequestQueue() {\n    if (this.processingQueue || this.requestQueue.length === 0) {\n      return;\n    }\n\n    this.processingQueue = true;\n\n    while (this.requestQueue.length > 0 && this.activeRequests.size < this.concurrentRequests) {\n      const queueItem = this.requestQueue.shift();\n      \n      // Start request without waiting\n      this.executeRequest(queueItem)\n        .then(queueItem.resolve)\n        .catch(queueItem.reject);\n      \n      // Small delay for rate limiting\n      await this.sleep(100);\n    }\n\n    this.processingQueue = false;\n    \n    // Continue processing if there are more requests\n    if (this.requestQueue.length > 0) {\n      setTimeout(() => this.processRequestQueue(), 200);\n    }\n  }\n\n  /**\n   * Execute individual request with retry logic\n   * @param {Object} queueItem - Queue item\n   * @returns {Promise<Object>} Response data\n   */\n  async executeRequest(queueItem) {\n    const { endpoint, config, requestId } = queueItem;\n    \n    // Create abort controller for cancellation\n    const controller = new AbortController();\n    this.activeRequests.set(requestId, controller);\n    \n    config.signal = controller.signal;\n\n    let lastError;\n    const maxRetries = config.retryAttempts || this.retryAttempts;\n\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        const response = await this.fetchWithTimeout(endpoint, config);\n        \n        if (!response.ok) {\n          const errorData = await this.parseErrorResponse(response);\n          throw new Error(errorData.message || `HTTP ${response.status}: ${response.statusText}`);\n        }\n\n        // Parse response based on content type\n        const contentType = response.headers.get('content-type');\n        if (contentType && contentType.includes('application/json')) {\n          return await response.json();\n        } else if (contentType && contentType.includes('text/')) {\n          return await response.text();\n        } else {\n          return response;\n        }\n\n      } catch (error) {\n        lastError = error;\n        \n        // Don't retry on certain errors\n        if (error.name === 'AbortError' || error.message.includes('401') || error.message.includes('403')) {\n          throw error;\n        }\n        \n        // Don't retry on the last attempt\n        if (attempt === maxRetries) {\n          break;\n        }\n        \n        // Calculate backoff delay\n        const delay = this.retryDelay * Math.pow(API_CONFIG.API_RETRY_BACKOFF_MULTIPLIER, attempt);\n        await this.sleep(Math.min(delay, API_CONFIG.API_MAX_RETRY_DELAY));\n      }\n    }\n\n    throw lastError;\n  }\n\n  /**\n   * Fetch with timeout support\n   * @param {string} endpoint - API endpoint\n   * @param {Object} config - Request configuration\n   * @returns {Promise<Response>} Fetch response\n   */\n  async fetchWithTimeout(endpoint, config) {\n    const { timeout, ...fetchConfig } = config;\n    \n    if (timeout) {\n      const timeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error('Request timeout')), timeout);\n      });\n      \n      return Promise.race([\n        fetch(endpoint, fetchConfig),\n        timeoutPromise\n      ]);\n    }\n    \n    return fetch(endpoint, fetchConfig);\n  }\n\n  /**\n   * Parse error response from server\n   * @param {Response} response - Fetch response\n   * @returns {Promise<Object>} Error data\n   */\n  async parseErrorResponse(response) {\n    try {\n      const errorData = await response.json();\n      \n      // Handle Blueprint error format\n      if (errorData.error && typeof errorData.error === 'object') {\n        return {\n          code: errorData.error.code,\n          message: errorData.error.message,\n          details: errorData.error.details\n        };\n      }\n      \n      return errorData;\n    } catch (error) {\n      return {\n        message: `HTTP ${response.status}: ${response.statusText}`,\n        status: response.status\n      };\n    }\n  }\n\n  /**\n   * Handle request errors with Blueprint-specific logic\n   * @param {Error} error - Error object\n   * @param {string} endpoint - API endpoint\n   * @param {string} blueprint - Blueprint name\n   * @param {string} requestId - Request ID\n   */\n  handleRequestError(error, endpoint, blueprint, requestId) {\n    console.error(`Blueprint API Error [${blueprint}]:`, {\n      endpoint,\n      requestId,\n      error: error.message,\n      stack: error.stack\n    });\n\n    // Add Blueprint context to error\n    error.blueprint = blueprint;\n    error.endpoint = endpoint;\n    error.requestId = requestId;\n    \n    // Emit error event for global error handling\n    if (typeof window !== 'undefined' && window.dispatchEvent) {\n      window.dispatchEvent(new CustomEvent('blueprint-api-error', {\n        detail: { error, endpoint, blueprint, requestId }\n      }));\n    }\n  }\n\n  /**\n   * Convert request paths for Linux server\n   * @param {Object} data - Request data\n   * @returns {Object} Converted data\n   */\n  convertPathsForServer(data) {\n    if (!this.crossPlatformEnabled || this.clientPlatform !== 'windows') {\n      return data;\n    }\n\n    const converted = { ...data };\n    \n    // Convert common path fields\n    const pathFields = ['input_dir', 'output_file', 'root_directory', 'file_path', 'directory'];\n    \n    pathFields.forEach(field => {\n      if (converted[field] && typeof converted[field] === 'string') {\n        converted[field] = sanitizePathForLinuxServer(converted[field]);\n      }\n    });\n\n    return converted;\n  }\n\n  /**\n   * Convert response paths for Windows client\n   * @param {Object} data - Response data\n   * @returns {Object} Converted data\n   */\n  convertPathsForClient(data) {\n    if (!this.crossPlatformEnabled || this.clientPlatform !== 'windows') {\n      return data;\n    }\n\n    const converted = { ...data };\n    \n    // Convert filenames for Windows compatibility\n    const filenameFields = ['output_file', 'filename', 'file_name'];\n    \n    filenameFields.forEach(field => {\n      if (converted[field] && typeof converted[field] === 'string') {\n        converted[field] = sanitizeFilenameForWindows(converted[field]);\n      }\n    });\n\n    // Convert file arrays\n    if (converted.files && Array.isArray(converted.files)) {\n      converted.files = converted.files.map(file => ({\n        ...file,\n        name: sanitizeFilenameForWindows(file.name || file.filename || '')\n      }));\n    }\n\n    return converted;\n  }\n\n  /**\n   * Generate unique request ID\n   * @returns {string} Request ID\n   */\n  generateRequestId() {\n    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Sleep for specified milliseconds\n   * @param {number} ms - Milliseconds to sleep\n   * @returns {Promise<void>}\n   */\n  sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Cancel request by ID\n   * @param {string} requestId - Request ID\n   * @returns {boolean} True if cancelled\n   */\n  cancelRequest(requestId) {\n    const controller = this.activeRequests.get(requestId);\n    if (controller) {\n      controller.abort();\n      this.activeRequests.delete(requestId);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Cancel all active requests\n   */\n  cancelAllRequests() {\n    this.activeRequests.forEach(controller => controller.abort());\n    this.activeRequests.clear();\n    this.requestQueue.length = 0;\n  }\n\n  /**\n   * Get active request count\n   * @returns {number} Active request count\n   */\n  getActiveRequestCount() {\n    return this.activeRequests.size;\n  }\n\n  // Blueprint-specific methods\n\n  /**\n   * File Processor API methods\n   */\n  async processFiles(inputDir, outputFile, options = {}) {\n    return this.request(buildEndpoint(API_ENDPOINTS.FILE_PROCESSING.PROCESS), {\n      method: 'POST',\n      body: JSON.stringify({\n        input_dir: inputDir,\n        output_file: outputFile,\n        ...options\n      })\n    }, 'file_processor');\n  }\n\n  async processFileUpload(formData, timeout = null) {\n    return this.request(buildEndpoint(API_ENDPOINTS.FILE_PROCESSING.PROCESS), {\n      method: 'POST',\n      body: formData,\n      timeout: timeout\n    }, 'file_processor');\n  }\n\n  async getTaskStatus(taskId, blueprint = null) {\n    return this.request(buildEndpoint(API_ENDPOINTS.FILE_PROCESSING.STATUS, { taskId }), {\n      method: 'GET'\n    }, blueprint);\n  }\n\n  async downloadTaskResult(taskId) {\n    return this.request(buildEndpoint(API_ENDPOINTS.FILE_PROCESSING.DOWNLOAD, { taskId }), {\n      method: 'GET'\n    }, 'file_processor');\n  }\n\n  async verifyPath(path) {\n    return this.request(buildEndpoint(API_ENDPOINTS.FILE_PROCESSING.VERIFY_PATH), {\n      method: 'POST',\n      body: JSON.stringify({ path })\n    }, 'file_processor');\n  }\n\n  async createDirectory(path) {\n    return this.request(buildEndpoint(API_ENDPOINTS.FILE_PROCESSING.CREATE_DIRECTORY), {\n      method: 'POST',\n      body: JSON.stringify({ path })\n    }, 'file_processor');\n  }\n\n  async openFile(path) {\n    return this.request(buildEndpoint(API_ENDPOINTS.FILE_PROCESSING.OPEN_FILE), {\n      method: 'POST',\n      body: JSON.stringify({ path })\n    }, 'file_processor');\n  }\n\n  async detectPath(files) {\n    const formData = new FormData();\n    for (let i = 0; i < files.length; i++) {\n      formData.append('files', files[i]);\n    }\n    \n    return this.request(buildEndpoint(API_ENDPOINTS.FILE_PROCESSING.DETECT_PATH), {\n      method: 'POST',\n      body: formData\n    }, 'file_processor');\n  }\n\n  /**\n   * Playlist Downloader API methods\n   */\n  async startPlaylistDownload(playlists, rootDirectory, outputFile) {\n    return this.request(buildEndpoint(API_ENDPOINTS.PLAYLIST.START), {\n      method: 'POST',\n      body: JSON.stringify({\n        playlists,\n        root_directory: rootDirectory,\n        output_file: outputFile\n      })\n    }, 'playlist_downloader');\n  }\n\n  async cancelPlaylistDownload(taskId) {\n    return this.request(buildEndpoint(API_ENDPOINTS.PLAYLIST.CANCEL, { taskId }), {\n      method: 'POST'\n    }, 'playlist_downloader');\n  }\n\n  /**\n   * Web Scraper API methods\n   */\n  async startWebScraping(urls, outputFile, options = {}) {\n    return this.request(buildEndpoint(API_ENDPOINTS.WEB_SCRAPER.SCRAPE), {\n      method: 'POST',\n      body: JSON.stringify({\n        urls,\n        output_file: outputFile,\n        ...options\n      })\n    }, 'web_scraper');\n  }\n\n  async getScrapingResults(taskId) {\n    return this.request(buildEndpoint(API_ENDPOINTS.WEB_SCRAPER.RESULTS, { taskId }), {\n      method: 'GET'\n    }, 'web_scraper');\n  }\n\n  /**\n   * Academic Search API methods\n   */\n  async searchAcademicPapers(query, sources = [], maxResults = 50) {\n    return this.request(buildEndpoint(API_ENDPOINTS.ACADEMIC.SEARCH), {\n      method: 'POST',\n      body: JSON.stringify({\n        query,\n        sources,\n        max_results: maxResults\n      })\n    }, 'academic_search');\n  }\n\n  async getAcademicHealth() {\n    return this.request(buildEndpoint(API_ENDPOINTS.ACADEMIC.HEALTH), {\n      method: 'GET'\n    }, 'academic_search');\n  }\n\n  /**\n   * PDF Processor API methods\n   */\n  async processPdf(filePath, options = {}) {\n    return this.request(buildEndpoint(API_ENDPOINTS.PDF.PROCESS), {\n      method: 'POST',\n      body: JSON.stringify({\n        file_path: filePath,\n        ...options\n      })\n    }, 'pdf_processor');\n  }\n\n  /**\n   * Task Management API methods\n   */\n  async cancelTask(taskId) {\n    return this.request(buildEndpoint(API_ENDPOINTS.TASK.CANCEL, { taskId }), {\n      method: 'POST'\n    }, 'management');\n  }\n\n  async getTaskAnalytics() {\n    return this.request(buildEndpoint(API_ENDPOINTS.TASK.ANALYTICS), {\n      method: 'GET'\n    }, 'management');\n  }\n\n  async listTasks() {\n    return this.request(buildEndpoint(API_ENDPOINTS.TASK.LIST), {\n      method: 'GET'\n    }, 'management');\n  }\n\n  /**\n   * System API methods\n   */\n  async getSystemHealth() {\n    return this.request(buildEndpoint(API_ENDPOINTS.SYSTEM.HEALTH), {\n      method: 'GET'\n    }, 'core');\n  }\n\n  async runModuleDiagnostics() {\n    return this.request(buildUrlWithQuery(API_ENDPOINTS.SYSTEM.TEST_MODULES, { format: 'json' }), {\n      method: 'GET'\n    }, 'core');\n  }\n\n  /**\n   * Get Blueprint configuration\n   * @param {string} blueprint - Blueprint name\n   * @returns {Object} Blueprint configuration\n   */\n  getBlueprintConfig(blueprint) {\n    return this.blueprintConfigs.get(blueprint);\n  }\n\n  /**\n   * Update Blueprint configuration\n   * @param {string} blueprint - Blueprint name\n   * @param {Object} config - New configuration\n   */\n  updateBlueprintConfig(blueprint, config) {\n    const existing = this.blueprintConfigs.get(blueprint) || {};\n    this.blueprintConfigs.set(blueprint, { ...existing, ...config });\n  }\n\n  /**\n   * Get all Blueprint configurations\n   * @returns {Map} All Blueprint configurations\n   */\n  getAllBlueprintConfigs() {\n    return new Map(this.blueprintConfigs);\n  }\n\n  /**\n   * Get service health status\n   * @returns {Object} Health status\n   */\n  getHealthStatus() {\n    return {\n      activeRequests: this.activeRequests.size,\n      queueLength: this.requestQueue.length,\n      processingQueue: this.processingQueue,\n      crossPlatformEnabled: this.crossPlatformEnabled,\n      serverPlatform: this.serverPlatform,\n      clientPlatform: this.clientPlatform,\n      blueprintCount: this.blueprintConfigs.size,\n      timestamp: Date.now()\n    };\n  }\n\n  /**\n   * Clear request queue and reset state\n   */\n  reset() {\n    this.cancelAllRequests();\n    this.processingQueue = false;\n    this.requestQueue.length = 0;\n  }\n\n  /**\n   * Enable/disable debug mode\n   * @param {boolean} enabled - Debug mode enabled\n   */\n  setDebugMode(enabled) {\n    this.debugMode = enabled;\n    if (enabled) {\n      console.log('Blueprint API Service - Debug mode enabled');\n      console.log('Current configuration:', this.getHealthStatus());\n    }\n  }\n}\n\n// Create singleton instance\nconst blueprintApi = new BlueprintApiService();\n\n// Export singleton instance and class\nexport default blueprintApi;\nexport { BlueprintApiService };\n\n// Export convenience methods for direct use\nexport const {\n  processFiles,\n  processFileUpload,\n  getTaskStatus,\n  downloadTaskResult,\n  verifyPath,\n  createDirectory,\n  openFile,\n  detectPath,\n  startPlaylistDownload,\n  cancelPlaylistDownload,\n  startWebScraping,\n  getScrapingResults,\n  searchAcademicPapers,\n  getAcademicHealth,\n  processPdf,\n  cancelTask,\n  getTaskAnalytics,\n  listTasks,\n  getSystemHealth,\n  runModuleDiagnostics\n} = blueprintApi;\n\n// Export health and configuration methods\nexport const getServiceHealth = () => blueprintApi.getHealthStatus();\nexport const resetService = () => blueprintApi.reset();\nexport const setBlueprintDebug = (enabled) => blueprintApi.setDebugMode(enabled);\n\n// Initialize debug mode if enabled\nif (typeof window !== 'undefined') {\n  const urlParams = new URLSearchParams(window.location.search);\n  if (urlParams.get('debug') === 'true' || localStorage.getItem('neurogen_v3_debug_mode') === 'true') {\n    blueprintApi.setDebugMode(true);\n  }\n\n  // Expose to global scope for debugging\n  if (blueprintApi.debugMode) {\n    window.blueprintApi = blueprintApi;\n    window.blueprintApiHealth = getServiceHealth;\n  }\n}","source":"/workspace/modules/static/js/modules/services/blueprintApi.js","title":"blueprintApi.js","language":"en"},{"content":"/**\n * NeuroGen Server - Enhanced Debug Tools Module v4.0\n * \n * Advanced debugging utilities optimized for the new Blueprint architecture.\n * Provides comprehensive debugging, performance monitoring, and diagnostic\n * capabilities with centralized configuration and health integration.\n * \n * NEW v4.0 Features:\n * - Configuration-driven architecture using centralized endpoints\n * - Enhanced 4-method notification system integration\n * - Backend connectivity testing for debug endpoints\n * - ES6 module imports with centralized configuration\n * - Integrated with systemHealth.js monitoring\n * - Performance profiling with Blueprint architecture awareness\n * - Advanced error tracking and reporting\n * \n * @module utils/debugTools\n * @version 4.0.0 - Blueprint Architecture Optimization\n */\n\n// Import dependencies from centralized config\nimport { API_ENDPOINTS, BLUEPRINT_ROUTES } from '../config/endpoints.js';\nimport { CONSTANTS, API_CONFIG, DEBUG_CONFIG } from '../config/constants.js';\nimport { SOCKET_EVENTS, TASK_EVENTS } from '../config/socketEvents.js';\n\n// Global configuration for debug tools\nconst DEBUG_TOOLS_CONFIG = {\n  endpoints: {\n    health: API_ENDPOINTS.SYSTEM?.HEALTH || '/api/health',\n    debug: API_ENDPOINTS.SYSTEM?.DEBUG || '/api/debug',\n    diagnostics: API_ENDPOINTS.SYSTEM?.DIAGNOSTICS || '/api/test-modules'\n  },\n  api: API_CONFIG,\n  constants: DEBUG_CONFIG || {\n    enabled: location.hostname === 'localhost' || location.hostname === '127.0.0.1',\n    logLevel: 'debug', // 'error', 'warn', 'info', 'debug'\n    persistLogs: false,\n    maxLogEntries: 1000,\n    performanceThreshold: 100 // ms\n  },\n  events: {\n    ...TASK_EVENTS,\n    debug_event: 'debug_event_logged',\n    performance_warning: 'performance_warning'\n  }\n};\n\n// Module state\nconst debugState = {\n  initialized: false,\n  backendConnected: false,\n  performanceTracking: new Map(),\n  lastHealthCheck: null\n};\n\n/**\n * Debug logger class\n */\nclass DebugLogger {\n  constructor() {\n    this.logs = [];\n    this.listeners = new Set();\n  }\n\n  log(level, message, data = {}) {\n    if (!this.shouldLog(level)) return;\n\n    const entry = {\n      timestamp: new Date().toISOString(),\n      level,\n      message,\n      data,\n      stack: new Error().stack\n    };\n\n    this.logs.push(entry);\n    \n    // Trim logs if exceeded max\n    if (this.logs.length > DEBUG_TOOLS_CONFIG.constants.maxLogEntries) {\n      this.logs.shift();\n    }\n\n    // Console output\n    this.consoleOutput(level, message, data);\n\n    // Notify listeners\n    this.notifyListeners(entry);\n\n    // Persist if enabled\n    if (DEBUG_TOOLS_CONFIG.constants.persistLogs) {\n      this.persistLog(entry);\n    }\n  }\n\n  shouldLog(level) {\n    const levels = ['error', 'warn', 'info', 'debug'];\n    const currentLevelIndex = levels.indexOf(DEBUG_TOOLS_CONFIG.constants.logLevel);\n    const messageLevelIndex = levels.indexOf(level);\n    return messageLevelIndex <= currentLevelIndex;\n  }\n\n  consoleOutput(level, message, data) {\n    const prefix = `[${new Date().toISOString().split('T')[1].split('.')[0]}]`;\n    \n    switch (level) {\n      case 'error':\n        console.error(prefix, message, data);\n        break;\n      case 'warn':\n        console.warn(prefix, message, data);\n        break;\n      case 'info':\n        console.info(prefix, message, data);\n        break;\n      case 'debug':\n        console.log(prefix, message, data);\n        break;\n    }\n  }\n\n  persistLog(entry) {\n    try {\n      const storedLogs = JSON.parse(localStorage.getItem('neurogen_debug_logs') || '[]');\n      storedLogs.push(entry);\n      \n      // Keep only last 100 entries in storage\n      if (storedLogs.length > 100) {\n        storedLogs.splice(0, storedLogs.length - 100);\n      }\n      \n      localStorage.setItem('neurogen_debug_logs', JSON.stringify(storedLogs));\n    } catch (error) {\n      console.error('Failed to persist log:', error);\n    }\n  }\n\n  notifyListeners(entry) {\n    this.listeners.forEach(listener => {\n      try {\n        listener(entry);\n      } catch (error) {\n        console.error('Debug listener error:', error);\n      }\n    });\n  }\n\n  addListener(callback) {\n    this.listeners.add(callback);\n    return () => this.listeners.delete(callback);\n  }\n\n  getLogs(filter = {}) {\n    let logs = [...this.logs];\n    \n    if (filter.level) {\n      logs = logs.filter(log => log.level === filter.level);\n    }\n    \n    if (filter.startTime) {\n      logs = logs.filter(log => new Date(log.timestamp) >= new Date(filter.startTime));\n    }\n    \n    if (filter.search) {\n      const searchLower = filter.search.toLowerCase();\n      logs = logs.filter(log => \n        log.message.toLowerCase().includes(searchLower) ||\n        JSON.stringify(log.data).toLowerCase().includes(searchLower)\n      );\n    }\n    \n    return logs;\n  }\n\n  clearLogs() {\n    this.logs = [];\n    localStorage.removeItem('neurogen_debug_logs');\n  }\n\n  exportLogs() {\n    const data = {\n      logs: this.logs,\n      config: DEBUG_TOOLS_CONFIG.constants,\n      exportTime: new Date().toISOString(),\n      userAgent: navigator.userAgent,\n      location: window.location.href\n    };\n    \n    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `neurogen-debug-${Date.now()}.json`;\n    a.click();\n    URL.revokeObjectURL(url);\n  }\n}\n\n/**\n * Performance profiler\n */\nclass PerformanceProfiler {\n  constructor() {\n    this.marks = new Map();\n    this.measures = new Map();\n  }\n\n  mark(name) {\n    this.marks.set(name, performance.now());\n    if (DEBUG_TOOLS_CONFIG.constants.enabled) {\n      console.log(`⏱️ Performance mark: ${name}`);\n    }\n  }\n\n  measure(name, startMark, endMark = null) {\n    const start = this.marks.get(startMark);\n    const end = endMark ? this.marks.get(endMark) : performance.now();\n    \n    if (!start) {\n      console.warn(`Start mark '${startMark}' not found`);\n      return;\n    }\n    \n    const duration = end - start;\n    this.measures.set(name, { duration, start, end });\n    \n    if (DEBUG_TOOLS_CONFIG.constants.enabled) {\n      console.log(`⏱️ Performance measure '${name}': ${duration.toFixed(2)}ms`);\n    }\n    \n    return duration;\n  }\n\n  getMeasures() {\n    return Object.fromEntries(this.measures);\n  }\n\n  clearMarks() {\n    this.marks.clear();\n  }\n\n  clearMeasures() {\n    this.measures.clear();\n  }\n}\n\n/**\n * Module inspector\n */\nclass ModuleInspector {\n  static getLoadedModules() {\n    if (!window.NeuroGen) return [];\n    \n    return Object.keys(window.NeuroGen.modules || {}).map(name => ({\n      name,\n      loaded: true,\n      instance: window.NeuroGen.modules[name],\n      hasInit: typeof window.NeuroGen.modules[name].init === 'function',\n      initialized: window.NeuroGen.modules[name].initialized || false\n    }));\n  }\n\n  static getModuleState(moduleName) {\n    const module = window.NeuroGen?.modules?.[moduleName];\n    if (!module) return null;\n    \n    return {\n      name: moduleName,\n      state: module.state || {},\n      config: module.config || {},\n      methods: Object.getOwnPropertyNames(Object.getPrototypeOf(module))\n        .filter(name => typeof module[name] === 'function' && name !== 'constructor')\n    };\n  }\n\n  static async testModule(moduleName) {\n    const module = window.NeuroGen?.modules?.[moduleName];\n    if (!module) {\n      return { success: false, error: 'Module not found' };\n    }\n    \n    const results = {\n      name: moduleName,\n      tests: []\n    };\n    \n    // Test initialization\n    if (typeof module.init === 'function' && !module.initialized) {\n      try {\n        await module.init();\n        results.tests.push({ test: 'initialization', success: true });\n      } catch (error) {\n        results.tests.push({ test: 'initialization', success: false, error: error.message });\n      }\n    }\n    \n    // Test health check\n    if (typeof module.getHealthStatus === 'function') {\n      try {\n        const health = await module.getHealthStatus();\n        results.tests.push({ test: 'health_check', success: true, data: health });\n      } catch (error) {\n        results.tests.push({ test: 'health_check', success: false, error: error.message });\n      }\n    }\n    \n    return results;\n  }\n}\n\n/**\n * Network inspector\n */\nclass NetworkInspector {\n  constructor() {\n    this.requests = [];\n    this.interceptors = new Map();\n    this.setupInterception();\n  }\n\n  setupInterception() {\n    // Intercept fetch\n    const originalFetch = window.fetch;\n    window.fetch = async (...args) => {\n      const startTime = performance.now();\n      const [url, options = {}] = args;\n      \n      const request = {\n        id: Date.now() + Math.random(),\n        url,\n        method: options.method || 'GET',\n        headers: options.headers,\n        body: options.body,\n        startTime,\n        status: 'pending'\n      };\n      \n      this.requests.push(request);\n      \n      try {\n        const response = await originalFetch(...args);\n        const endTime = performance.now();\n        \n        request.status = response.ok ? 'success' : 'error';\n        request.statusCode = response.status;\n        request.duration = endTime - startTime;\n        request.response = response;\n        \n        if (DEBUG_TOOLS_CONFIG.constants.enabled) {\n          console.log(`🌐 ${request.method} ${request.url} - ${response.status} (${request.duration.toFixed(2)}ms)`);\n        }\n        \n        return response;\n      } catch (error) {\n        request.status = 'error';\n        request.error = error.message;\n        request.duration = performance.now() - startTime;\n        \n        if (DEBUG_TOOLS_CONFIG.constants.enabled) {\n          console.error(`🌐 ${request.method} ${request.url} - Failed (${request.duration.toFixed(2)}ms)`, error);\n        }\n        \n        throw error;\n      }\n    };\n  }\n\n  getRequests(filter = {}) {\n    let requests = [...this.requests];\n    \n    if (filter.url) {\n      requests = requests.filter(req => req.url.includes(filter.url));\n    }\n    \n    if (filter.method) {\n      requests = requests.filter(req => req.method === filter.method);\n    }\n    \n    if (filter.status) {\n      requests = requests.filter(req => req.status === filter.status);\n    }\n    \n    return requests;\n  }\n\n  clearRequests() {\n    this.requests = [];\n  }\n}\n\n// Create singleton instances\nconst logger = new DebugLogger();\nconst profiler = new PerformanceProfiler();\nconst networkInspector = DEBUG_TOOLS_CONFIG.constants.enabled ? new NetworkInspector() : null;\n\n/**\n * Debug tools public API\n */\nconst debugTools = {\n  // Configuration\n  config: DEBUG_TOOLS_CONFIG.constants,\n  \n  // Logging\n  log: (message, data) => logger.log('debug', message, data),\n  info: (message, data) => logger.log('info', message, data),\n  warn: (message, data) => logger.log('warn', message, data),\n  error: (message, data) => logger.log('error', message, data),\n  \n  // Log management\n  getLogs: (filter) => logger.getLogs(filter),\n  clearLogs: () => logger.clearLogs(),\n  exportLogs: () => logger.exportLogs(),\n  addLogListener: (callback) => logger.addListener(callback),\n  \n  // Performance profiling\n  mark: (name) => profiler.mark(name),\n  measure: (name, startMark, endMark) => profiler.measure(name, startMark, endMark),\n  getMeasures: () => profiler.getMeasures(),\n  clearMarks: () => profiler.clearMarks(),\n  clearMeasures: () => profiler.clearMeasures(),\n  \n  // Module inspection\n  getLoadedModules: () => ModuleInspector.getLoadedModules(),\n  getModuleState: (name) => ModuleInspector.getModuleState(name),\n  testModule: (name) => ModuleInspector.testModule(name),\n  \n  // Network inspection\n  getRequests: (filter) => networkInspector?.getRequests(filter) || [],\n  clearRequests: () => networkInspector?.clearRequests(),\n  \n  // Utility methods\n  enable: () => {\n    DEBUG_TOOLS_CONFIG.constants.enabled = true;\n    localStorage.setItem('neurogen_debug_enabled', 'true');\n  },\n  \n  disable: () => {\n    DEBUG_TOOLS_CONFIG.constants.enabled = false;\n    localStorage.removeItem('neurogen_debug_enabled');\n  },\n  \n  setLogLevel: (level) => {\n    if (['error', 'warn', 'info', 'debug'].includes(level)) {\n      DEBUG_TOOLS_CONFIG.constants.logLevel = level;\n      localStorage.setItem('neurogen_debug_level', level);\n    }\n  },\n  \n  // Development utilities\n  inspectElement: (selector) => {\n    const element = document.querySelector(selector);\n    if (!element) {\n      console.warn(`Element not found: ${selector}`);\n      return null;\n    }\n    \n    return {\n      element,\n      computedStyles: window.getComputedStyle(element),\n      eventListeners: getEventListeners ? getEventListeners(element) : 'Not available',\n      attributes: Array.from(element.attributes).reduce((acc, attr) => {\n        acc[attr.name] = attr.value;\n        return acc;\n      }, {}),\n      dataset: { ...element.dataset }\n    };\n  },\n  \n  // Memory profiling\n  getMemoryUsage: () => {\n    if (!performance.memory) {\n      return { available: false };\n    }\n    \n    return {\n      available: true,\n      usedJSHeapSize: (performance.memory.usedJSHeapSize / 1048576).toFixed(2) + ' MB',\n      totalJSHeapSize: (performance.memory.totalJSHeapSize / 1048576).toFixed(2) + ' MB',\n      jsHeapSizeLimit: (performance.memory.jsHeapSizeLimit / 1048576).toFixed(2) + ' MB'\n    };\n  },\n\n  /**\n   * Enhanced notification system with 4-method delivery (v4.0)\n   * @param {string} message - Notification message\n   * @param {string} type - Notification type (info, success, warning, error)\n   * @param {string} title - Notification title\n   */\n  showNotification(message, type = 'info', title = 'Debug Tools') {\n    // Method 1: Toast notifications\n    if (window.NeuroGen?.ui?.showToast) {\n      window.NeuroGen.ui.showToast(title, message, type);\n    }\n    \n    // Method 2: Console logging with styling\n    const styles = {\n      error: 'color: #dc3545; font-weight: bold;',\n      warning: 'color: #fd7e14; font-weight: bold;',\n      success: 'color: #198754; font-weight: bold;',\n      info: 'color: #0d6efd;'\n    };\n    console.log(`%c[${title}] ${message}`, styles[type] || styles.info);\n    \n    // Method 3: System notification (if available)\n    if (window.NeuroGen?.notificationHandler) {\n      window.NeuroGen.notificationHandler.show({\n        title, message, type, module: 'debugTools'\n      });\n    }\n    \n    // Method 4: Error reporting to centralized handler\n    if (type === 'error' && window.NeuroGen?.errorHandler) {\n      window.NeuroGen.errorHandler.logError({\n        module: 'debugTools', message, severity: type\n      });\n    }\n  },\n\n  /**\n   * Test backend connectivity for debug tools (v4.0)\n   * @returns {Promise<Object>} Backend connectivity status\n   */\n  async testBackendConnectivity() {\n    const results = {\n      overall: false,\n      details: {},\n      timestamp: new Date().toISOString(),\n      errors: []\n    };\n\n    try {\n      // Test main health endpoint\n      const healthResponse = await fetch(DEBUG_TOOLS_CONFIG.endpoints.health, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' }\n      });\n\n      results.details.health = {\n        status: healthResponse.status,\n        ok: healthResponse.ok,\n        endpoint: DEBUG_TOOLS_CONFIG.endpoints.health\n      };\n\n      if (healthResponse.ok) {\n        // Test diagnostics endpoint\n        try {\n          const diagResponse = await fetch(DEBUG_TOOLS_CONFIG.endpoints.diagnostics, {\n            method: 'GET',\n            headers: { 'Content-Type': 'application/json' }\n          });\n          results.details.diagnostics = {\n            status: diagResponse.status,\n            ok: diagResponse.status < 500,\n            endpoint: DEBUG_TOOLS_CONFIG.endpoints.diagnostics\n          };\n        } catch (error) {\n          results.details.diagnostics = {\n            error: error.message,\n            endpoint: DEBUG_TOOLS_CONFIG.endpoints.diagnostics\n          };\n        }\n        \n        results.overall = true;\n        debugState.backendConnected = true;\n        debugState.lastHealthCheck = new Date().toISOString();\n        this.showNotification('Backend connectivity verified', 'success', 'Debug Tools');\n      } else {\n        throw new Error(`Health endpoint returned ${healthResponse.status}`);\n      }\n\n    } catch (error) {\n      results.errors.push({\n        endpoint: DEBUG_TOOLS_CONFIG.endpoints.health,\n        error: error.message\n      });\n      debugState.backendConnected = false;\n      this.showNotification(`Backend connectivity failed: ${error.message}`, 'error', 'Debug Tools');\n    }\n\n    return results;\n  },\n\n  /**\n   * Get debug tools health status (v4.0)\n   * @returns {Object} Health status information\n   */\n  getHealthStatus() {\n    return {\n      module: 'debugTools',\n      version: '4.0.0',\n      status: debugState.initialized ? 'healthy' : 'initializing',\n      features: {\n        configurationDriven: true,\n        enhancedNotifications: true,\n        backendConnectivity: true,\n        performanceProfiler: true,\n        networkInspector: !!networkInspector,\n        moduleInspector: true,\n        memoryProfiler: !!performance.memory\n      },\n      configuration: {\n        endpoints: DEBUG_TOOLS_CONFIG.endpoints,\n        constants: DEBUG_TOOLS_CONFIG.constants,\n        eventsConfigured: Object.keys(DEBUG_TOOLS_CONFIG.events).length\n      },\n      statistics: {\n        logsCount: logger.logs.length,\n        performanceMarks: profiler.marks.size,\n        performanceMeasures: profiler.measures.size,\n        networkRequests: networkInspector?.requests.length || 0,\n        lastHealthCheck: debugState.lastHealthCheck,\n        backendConnected: debugState.backendConnected\n      }\n    };\n  },\n\n  /**\n   * Initialize debug tools with v4.0 enhancements\n   * @returns {Promise<boolean>} Success status\n   */\n  async initialize() {\n    if (debugState.initialized) {\n      this.showNotification('Debug tools already initialized', 'warning', 'Debug Tools');\n      return true;\n    }\n\n    try {\n      this.showNotification('Initializing Debug Tools v4.0', 'info', 'Debug Tools');\n      \n      // Test backend connectivity if enabled\n      if (DEBUG_TOOLS_CONFIG.constants.enabled) {\n        await this.testBackendConnectivity();\n      }\n      \n      debugState.initialized = true;\n      this.showNotification('Debug Tools v4.0 initialized successfully', 'success', 'Debug Tools');\n      return true;\n    } catch (error) {\n      this.showNotification(`Debug Tools initialization failed: ${error.message}`, 'error', 'Debug Tools');\n      return false;\n    }\n  }\n};\n\n// Check for stored debug settings\nif (localStorage.getItem('neurogen_debug_enabled') === 'true') {\n  DEBUG_TOOLS_CONFIG.constants.enabled = true;\n}\n\nconst storedLogLevel = localStorage.getItem('neurogen_debug_level');\nif (storedLogLevel) {\n  DEBUG_TOOLS_CONFIG.constants.logLevel = storedLogLevel;\n}\n\n// Export debug tools\nexport default debugTools;\n\n// Also export individual classes for advanced usage\nexport { DebugLogger, PerformanceProfiler, ModuleInspector, NetworkInspector };\n\n// v4.0 Enhanced exports\nexport const showNotification = debugTools.showNotification.bind(debugTools);\nexport const testBackendConnectivity = debugTools.testBackendConnectivity.bind(debugTools);\nexport const getHealthStatus = debugTools.getHealthStatus.bind(debugTools);\nexport const initialize = debugTools.initialize.bind(debugTools);\n\n// Expose to window in debug mode\nif (DEBUG_TOOLS_CONFIG.constants.enabled && typeof window !== 'undefined') {\n  window.debugTools = debugTools;\n  console.log('🔧 Debug tools enabled. Access via window.debugTools');\n}","source":"/workspace/modules/static/js/modules/utils/debugTools.js","title":"debugTools.js","language":"en"},{"content":"/**\n * DOM Utilities Module - Centralized DOM manipulation functions\n * \n * This module provides common DOM manipulation functions to avoid\n * function redeclarations across multiple modules.\n */\n\n/**\n * Gets a DOM element by various selectors\n * @param {string|HTMLElement} selector - CSS selector, ID, or DOM element\n * @param {HTMLElement} [parent=document] - Parent element to search within\n * @returns {HTMLElement|null} The found element or null\n */\nexport function getElement(selector, parent = document) {\n  if (!selector) {\n    console.warn('No selector provided to getElement');\n    return null;\n  }\n\n  // If selector is already a DOM element, return it\n  if (selector instanceof HTMLElement) {\n    return selector;\n  }\n\n  // Handle ID selectors with or without # prefix\n  if (typeof selector === 'string') {\n    const cleanSelector = selector.trim();\n    \n    // Handle ID format without #\n    if (/^[a-zA-Z][\\w-]*$/.test(cleanSelector) && !cleanSelector.includes(' ')) {\n      const element = document.getElementById(cleanSelector);\n      if (element) return element;\n    }\n    \n    // Use querySelector for any other valid selector\n    try {\n      return parent.querySelector(cleanSelector);\n    } catch (error) {\n      console.error(`Invalid selector: ${cleanSelector}`, error);\n      return null;\n    }\n  }\n  \n  return null;\n}\n\n/**\n * Gets multiple DOM elements by selector\n * @param {string} selector - CSS selector\n * @param {HTMLElement} [parent=document] - Parent element to search within\n * @returns {Array<HTMLElement>} Array of elements (empty if none found)\n */\nexport function getElements(selector, parent = document) {\n  if (!selector) {\n    console.warn('No selector provided to getElements');\n    return [];\n  }\n\n  try {\n    const elements = parent.querySelectorAll(selector);\n    return Array.from(elements);\n  } catch (error) {\n    console.error(`Invalid selector: ${selector}`, error);\n    return [];\n  }\n}\n\n/**\n * Gets UI elements based on a configuration object\n * @param {Object} config - Configuration object with element selectors\n * @param {HTMLElement} [parent=document] - Parent element to search within\n * @returns {Object} Object with found UI elements\n */\nexport function getUIElements(config, parent = document) {\n  if (!config || typeof config !== 'object') {\n    console.error('Invalid UI elements configuration');\n    return {};\n  }\n\n  const elements = {};\n  \n  for (const [key, selector] of Object.entries(config)) {\n    if (Array.isArray(selector)) {\n      elements[key] = getElements(selector[0], parent);\n    } else {\n      elements[key] = getElement(selector, parent);\n    }\n  }\n  \n  return elements;\n}\n\n/**\n * Creates a DOM element with attributes and content\n * @param {string} tag - HTML tag name\n * @param {Object} [attributes={}] - Attributes to set on the element\n * @param {string|HTMLElement|Array} [content] - Content to append to the element\n * @returns {HTMLElement} The created element\n */\nexport function createElement(tag, attributes = {}, content) {\n  const element = document.createElement(tag);\n  \n  // Set attributes\n  Object.entries(attributes).forEach(([attr, value]) => {\n    if (attr === 'className') {\n      element.className = value;\n    } else if (attr === 'dataset') {\n      Object.entries(value).forEach(([dataKey, dataValue]) => {\n        element.dataset[dataKey] = dataValue;\n      });\n    } else {\n      element.setAttribute(attr, value);\n    }\n  });\n  \n  // Add content\n  if (content) {\n    if (typeof content === 'string') {\n      element.textContent = content;\n    } else if (content instanceof HTMLElement) {\n      element.appendChild(content);\n    } else if (Array.isArray(content)) {\n      content.forEach(item => {\n        if (typeof item === 'string') {\n          element.appendChild(document.createTextNode(item));\n        } else if (item instanceof HTMLElement) {\n          element.appendChild(item);\n        }\n      });\n    }\n  }\n  \n  return element;\n}\n/**\n * Toggle element visibility\n * @param {string|HTMLElement} selector - Element ID or element\n * @param {boolean} visible - Whether to show or hide\n */\nexport function toggleElementVisibility(selector, visible) {\n  const element = getElement(selector);\n  if (!element) return;\n  \n  if (visible) {\n    element.classList.remove('d-none');\n  } else {\n    element.classList.add('d-none');\n  }\n}\n\n/**\n * Add event listeners to one or more elements\n * @param {HTMLElement|Array<HTMLElement>} elements - Element(s) to add listeners to\n * @param {string|Array<string>} events - Event(s) to listen for\n * @param {Function} handler - Event handler function\n * @param {Object} [options] - AddEventListener options\n */\nexport function addEventListeners(elements, events, handler, options) {\n  const elementArray = Array.isArray(elements) ? elements : [elements];\n  const eventArray = Array.isArray(events) ? events : [events];\n  \n  elementArray.forEach(element => {\n    if (element) {\n      eventArray.forEach(event => {\n        element.addEventListener(event, handler, options);\n      });\n    }\n  });\n}\n// Make sure it's included in the exports\nconst domUtils = {\n  getElement,\n  getElements,\n  getUIElements,\n  createElement,\n  addEventListeners,\n  toggleElementVisibility\n};\n\nexport default domUtils;","source":"/workspace/modules/static/js/modules/utils/domUtils.js","title":"domUtils.js","language":"en"},{"content":"/**\n * NeuroGen Server - Error Handler Module\n * \n * Centralized error handling for consistent error reporting, logging, and user feedback.\n * Provides structured error management with support for different severity levels\n * and integration with UI components.\n */\n\nconst errorHandler = {\n  // Configuration\n  config: {\n    logToConsole: true,\n    showInUI: true,\n    reportToServer: false,\n    serverEndpoint: '/api/log-error',\n    debugMode: false\n  },\n  \n  // Error history\n  errorLog: [],\n  \n  // Max errors to keep in history\n  maxLogSize: 100,\n  \n  // Element IDs for error display\n  uiElements: {\n    errorContainer: 'error-container',\n    toastContainer: 'toast-container'\n  },\n  \n  /**\n   * Initialize the error handler\n   * @param {Object} options - Configuration options\n   * @returns {boolean} Success status\n   */\n  initialize(options = {}) {\n    // Apply configuration options\n    Object.assign(this.config, options);\n    \n    // Clear error log on initialization if in production\n    if (!this.config.debugMode) {\n      this.errorLog = [];\n    }\n    \n    // Check if we're running in debug mode\n    this.config.debugMode = this.config.debugMode || \n      window.location.hostname === 'localhost' || \n      window.location.hostname === '127.0.0.1';\n    \n    return true;\n  },\n  \n  /**\n   * Handle an error with appropriate logging and UI feedback\n   * @param {Error|string} error - Error object or message\n   * @param {string} [errorCode] - Error code for categorization\n   * @param {boolean} [showToUser=true] - Whether to show error to user\n   * @returns {boolean} Whether the error was handled\n   */\n  handleError(error, errorCode = 'UNKNOWN_ERROR', showToUser = true) {\n    // Create structured error object\n    const errorObject = this._createErrorObject(error, errorCode);\n    \n    // Log to console if enabled\n    if (this.config.logToConsole) {\n      this._logToConsole(errorObject);\n    }\n    \n    // Store in error log\n    this._addToErrorLog(errorObject);\n    \n    // Show to user if enabled and requested\n    if (this.config.showInUI && showToUser) {\n      this.showError(errorObject.message);\n    }\n    \n    // Report to server if enabled\n    if (this.config.reportToServer) {\n      this._reportToServer(errorObject);\n    }\n    \n    return true;\n  },\n  \n  /**\n   * Show an error message to the user\n   * @param {string} message - Error message to display\n   * @param {string} [type='error'] - Alert type: error, warning, info\n   * @param {number} [duration=5000] - Display duration in ms (for toasts)\n   * @returns {boolean} Whether the error was displayed\n   */\n  showError(message, type = 'error', duration = 5000) {\n    // Validate message\n    if (!message) return false;\n    \n    try {\n      // Try to find error container\n      let errorContainer = document.getElementById(this.uiElements.errorContainer);\n      \n      // If error container exists, use it\n      if (errorContainer) {\n        // Create error element\n        const errorElement = document.createElement('div');\n        errorElement.className = `alert alert-${type}`;\n        errorElement.innerHTML = `\n          <button type=\"button\" class=\"close\" data-dismiss=\"alert\">&times;</button>\n          <strong>${type.charAt(0).toUpperCase() + type.slice(1)}:</strong> ${message}\n        `;\n        \n        // Add close handler\n        const closeButton = errorElement.querySelector('.close');\n        if (closeButton) {\n          closeButton.addEventListener('click', () => {\n            errorElement.remove();\n          });\n        }\n        \n        // Show in container\n        errorContainer.appendChild(errorElement);\n        \n        // Auto-remove after duration\n        setTimeout(() => {\n          if (errorElement.parentNode) {\n            errorElement.remove();\n          }\n        }, duration);\n        \n        return true;\n      }\n      \n      // Fallback to toast if container not found\n      return this._showToast(message, type, duration);\n    } catch (e) {\n      // Last resort: console\n      console.error(`Error showing error: ${e.message}`);\n      console.error(`Original error: ${message}`);\n      return false;\n    }\n  },\n  \n  /**\n   * Show a success message to the user\n   * @param {string} message - Success message to display\n   * @param {number} [duration=3000] - Display duration in ms\n   * @returns {boolean} Whether the message was displayed\n   */\n  showSuccess(message, duration = 3000) {\n    return this.showError(message, 'success', duration);\n  },\n  \n  /**\n   * Show a warning message to the user\n   * @param {string} message - Warning message to display\n   * @param {number} [duration=4000] - Display duration in ms\n   * @returns {boolean} Whether the message was displayed\n   */\n  showWarning(message, duration = 4000) {\n    return this.showError(message, 'warning', duration);\n  },\n  \n  /**\n   * Show an info message to the user\n   * @param {string} message - Info message to display\n   * @param {number} [duration=3000] - Display duration in ms\n   * @returns {boolean} Whether the message was displayed\n   */\n  showInfo(message, duration = 3000) {\n    return this.showError(message, 'info', duration);\n  },\n  \n  /**\n   * Get all logged errors\n   * @returns {Array} Array of error objects\n   */\n  getErrorLog() {\n    return [...this.errorLog];\n  },\n  \n  /**\n   * Clear the error log\n   * @returns {boolean} Success status\n   */\n  clearErrorLog() {\n    this.errorLog = [];\n    return true;\n  },\n  \n  /**\n   * Create a structured error object\n   * @private\n   * @param {Error|string} error - Error object or message\n   * @param {string} errorCode - Error code\n   * @returns {Object} Structured error object\n   */\n  _createErrorObject(error, errorCode) {\n    const timestamp = new Date().toISOString();\n    const isErrorObject = error instanceof Error;\n    \n    return {\n      message: isErrorObject ? error.message : String(error),\n      code: errorCode,\n      timestamp,\n      stack: isErrorObject ? error.stack : new Error().stack,\n      type: isErrorObject ? error.name : 'Error',\n      url: window.location.href,\n      userAgent: navigator.userAgent\n    };\n  },\n  \n  /**\n   * Log error to console\n   * @private\n   * @param {Object} errorObject - Structured error object\n   */\n  _logToConsole(errorObject) {\n    if (this.config.debugMode) {\n      console.error(\n        `[${errorObject.code}] ${errorObject.message}`,\n        '\\nStack:', errorObject.stack,\n        '\\nDetails:', errorObject\n      );\n    } else {\n      console.error(`[${errorObject.code}] ${errorObject.message}`);\n    }\n  },\n  \n  /**\n   * Add error to log with size limiting\n   * @private\n   * @param {Object} errorObject - Structured error object\n   */\n  _addToErrorLog(errorObject) {\n    this.errorLog.push(errorObject);\n    \n    // Limit log size\n    if (this.errorLog.length > this.maxLogSize) {\n      this.errorLog.shift();\n    }\n  },\n  \n  /**\n   * Report error to server\n   * @private\n   * @param {Object} errorObject - Structured error object\n   * @returns {Promise} Promise that resolves when error is reported\n   */\n  _reportToServer(errorObject) {\n    // Don't report if not enabled or no endpoint\n    if (!this.config.reportToServer || !this.config.serverEndpoint) {\n      return Promise.resolve();\n    }\n    \n    // Return promise for error reporting\n    return fetch(this.config.serverEndpoint, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(errorObject)\n    }).catch(e => {\n      // Don't throw if error reporting fails\n      console.error('Error reporting error to server:', e);\n    });\n  },\n  \n  /**\n   * Show a toast message\n   * @private\n   * @param {string} message - Message to display\n   * @param {string} type - Toast type\n   * @param {number} duration - Display duration in ms\n   * @returns {boolean} Whether the toast was displayed\n   */\n  _showToast(message, type, duration) {\n    try {\n      // Try to find toast container\n      let toastContainer = document.getElementById(this.uiElements.toastContainer);\n      \n      // Create if it doesn't exist\n      if (!toastContainer) {\n        toastContainer = document.createElement('div');\n        toastContainer.id = this.uiElements.toastContainer;\n        toastContainer.className = 'toast-container';\n        document.body.appendChild(toastContainer);\n      }\n      \n      // Create toast element\n      const toastElement = document.createElement('div');\n      toastElement.className = `toast toast-${type}`;\n      toastElement.innerHTML = `\n        <div class=\"toast-content\">\n          <span class=\"toast-message\">${message}</span>\n          <button class=\"toast-close\">&times;</button>\n        </div>\n      `;\n      \n      // Add close handler\n      const closeButton = toastElement.querySelector('.toast-close');\n      if (closeButton) {\n        closeButton.addEventListener('click', () => {\n          toastElement.remove();\n        });\n      }\n      \n      // Add to container\n      toastContainer.appendChild(toastElement);\n      \n      // Trigger animation\n      setTimeout(() => {\n        toastElement.classList.add('show');\n      }, 10);\n      \n      // Auto-remove after duration\n      setTimeout(() => {\n        toastElement.classList.remove('show');\n        setTimeout(() => {\n          if (toastElement.parentNode) {\n            toastElement.remove();\n          }\n        }, 300); // Wait for fade-out animation\n      }, duration);\n      \n      return true;\n    } catch (e) {\n      console.error('Error showing toast:', e);\n      return false;\n    }\n  }\n};\n\n// Export both default and named exports\nexport default errorHandler;\nexport const handleError = errorHandler.handleError.bind(errorHandler);\nexport const showError = errorHandler.showError.bind(errorHandler);\nexport const showSuccess = errorHandler.showSuccess.bind(errorHandler);\nexport const showWarning = errorHandler.showWarning.bind(errorHandler);\nexport const showInfo = errorHandler.showInfo.bind(errorHandler);\nexport const getErrorLog = errorHandler.getErrorLog.bind(errorHandler);\nexport const clearErrorLog = errorHandler.clearErrorLog.bind(errorHandler);","source":"/workspace/modules/static/js/modules/utils/errorHandler.js","title":"errorHandler.js","language":"en"},{"content":"/**\n * NeuroGen Server - Enhanced File Handler Module v4.0\n * \n * Advanced file system operations optimized for the new Blueprint architecture.\n * Provides comprehensive file handling with centralized configuration,\n * enhanced error handling, and integrated health monitoring.\n * \n * NEW v4.0 Features:\n * - Configuration-driven architecture using centralized endpoints\n * - Enhanced 4-method notification system (Toast + Console + System + Error)\n * - Backend connectivity testing with health checks\n * - ES6 module imports with centralized configuration\n * - Cross-platform file path handling for Linux→Windows compatibility\n * - Enhanced file validation and processing\n * - Integrated progress tracking for file operations\n * \n * @module utils/fileHandler\n * @version 4.0.0 - Blueprint Architecture Optimization\n */\n\n// Import dependencies from centralized config\nimport { API_ENDPOINTS, BLUEPRINT_ROUTES } from '../config/endpoints.js';\nimport { CONSTANTS, API_CONFIG, FILE_CONFIG } from '../config/constants.js';\nimport { SOCKET_EVENTS, TASK_EVENTS } from '../config/socketEvents.js';\n\n// Global configuration for file handler\nconst FILE_HANDLER_CONFIG = {\n  endpoints: {\n    upload: API_ENDPOINTS.FILE_PROCESSING?.UPLOAD || '/api/upload',\n    download: API_ENDPOINTS.FILE_PROCESSING?.DOWNLOAD || '/api/download',\n    process: API_ENDPOINTS.FILE_PROCESSING?.PROCESS || '/api/process',\n    verifyPath: API_ENDPOINTS.FILE_PROCESSING?.VERIFY_PATH || '/api/verify-path',\n    createDirectory: API_ENDPOINTS.FILE_PROCESSING?.CREATE_DIRECTORY || '/api/create-directory',\n    getOutputFilepath: API_ENDPOINTS.FILE_PROCESSING?.GET_OUTPUT_FILEPATH || '/api/get-output-filepath',\n    openFile: API_ENDPOINTS.FILE_PROCESSING?.OPEN_FILE || '/api/open-file',\n    openFolder: API_ENDPOINTS.FILE_PROCESSING?.OPEN_FOLDER || '/api/open-folder',\n    health: API_ENDPOINTS.SYSTEM?.HEALTH || '/api/health'\n  },\n  api: API_CONFIG,\n  constants: FILE_CONFIG || {\n    MAX_FILE_SIZE: 32 * 1024 * 1024, // 32MB\n    ACCEPTED_TYPES: [\n      'application/pdf', 'text/plain', 'text/markdown', 'text/csv',\n      'application/vnd.ms-excel', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n      'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n      'image/jpeg', 'image/png', 'application/json'\n    ],\n    DROP_ZONE_ID: 'file-dropzone'\n  },\n  events: {\n    ...TASK_EVENTS,\n    file_upload: 'file_uploaded',\n    file_processed: 'file_processed'\n  }\n};\n\n/**\n * File Handler module\n */\nconst fileHandler = {\n  // Cache for commonly accessed directories\n  _directoryCache: {},\n  \n  // Default upload options (now configured from centralized config)\n  _defaultUploadOptions: {\n    maxSize: FILE_HANDLER_CONFIG.constants.MAX_FILE_SIZE,\n    acceptedTypes: FILE_HANDLER_CONFIG.constants.ACCEPTED_TYPES,\n    dropZoneId: FILE_HANDLER_CONFIG.constants.DROP_ZONE_ID,\n    multiple: true\n  },\n  \n  // Module state\n  _state: {\n    initialized: false,\n    backendConnected: false,\n    uploadsInProgress: 0,\n    lastHealthCheck: null\n  },\n  \n  // API endpoints (now configured from centralized config)\n  _endpoints: FILE_HANDLER_CONFIG.endpoints,\n  \n  \n  /**\n   * Initialize the file handler with v4.0 enhancements\n   * @param {Object} options - Initialization options\n   * @returns {Promise<boolean>} - Whether initialization was successful\n   */\n  async initialize(options = {}) {\n    if (this._state.initialized) {\n      this.showNotification('File handler already initialized', 'warning', 'File Handler');\n      return false;\n    }\n    \n    try {\n      this.showNotification('Initializing File Handler v4.0', 'info', 'File Handler');\n      \n      // Test backend connectivity on initialization\n      const connectivityResult = await this.testBackendConnectivity();\n      if (!connectivityResult.overall) {\n        console.warn('File Handler: Backend connectivity test failed, continuing with limited functionality');\n      }\n      \n      // Override default endpoints if provided\n      if (options.endpoints) {\n        this._endpoints = {...this._endpoints, ...options.endpoints};\n      }\n      \n      // Override default upload options if provided\n      if (options.uploadOptions) {\n        this._defaultUploadOptions = {...this._defaultUploadOptions, ...options.uploadOptions};\n      }\n      \n      // Set up file drag and drop handlers if needed\n      if (options.setupDropZone || options.setupDropZone === undefined) {\n        this._setupFileDropZone();\n      }\n      \n      // Make available globally for debugging if in debug mode\n      if (window.debugMode) {\n        window.fileHandler = this;\n      }\n      \n      this._state.initialized = true;\n      this.showNotification('File Handler v4.0 initialized successfully', 'success', 'File Handler');\n      return true;\n    } catch (error) {\n      this.showNotification(`File Handler initialization failed: ${error.message}`, 'error', 'File Handler');\n      return false;\n    }\n  },\n  \n  /**\n   * Set up file drop zone for drag and drop file uploads\n   * @private\n   */\n  _setupFileDropZone() {\n    const dropZone = document.getElementById(this._defaultUploadOptions.dropZoneId);\n    if (!dropZone) {\n      console.warn(`Drop zone element #${this._defaultUploadOptions.dropZoneId} not found`);\n      return;\n    }\n    \n    // Prevent default drag behaviors\n    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {\n      dropZone.addEventListener(eventName, e => {\n        e.preventDefault();\n        e.stopPropagation();\n      }, false);\n    });\n    \n    // Highlight drop zone when drag enters\n    ['dragenter', 'dragover'].forEach(eventName => {\n      dropZone.addEventListener(eventName, () => {\n        dropZone.classList.add('dragover');\n      }, false);\n    });\n    \n    // Remove highlight when drag leaves\n    ['dragleave', 'drop'].forEach(eventName => {\n      dropZone.addEventListener(eventName, () => {\n        dropZone.classList.remove('dragover');\n      }, false);\n    });\n    \n    // Handle dropped files\n    dropZone.addEventListener('drop', e => {\n      const files = e.dataTransfer.files;\n      this.uploadFiles(files);\n    }, false);\n    \n    console.log(`File drop zone #${this._defaultUploadOptions.dropZoneId} set up`);\n  },\n  \n  /**\n   * Upload files to the server\n   * @param {FileList|Array<File>} files - Files to upload\n   * @param {Object} options - Upload options\n   * @returns {Promise<Object>} - Upload result\n   */\n  async uploadFiles(files, options = {}) {\n    const settings = {...this._defaultUploadOptions, ...options};\n    \n    // Validate files\n    const validFiles = Array.from(files).filter(file => {\n      // Check file size\n      if (file.size > settings.maxSize) {\n        console.warn(`File ${file.name} exceeds maximum size of ${this._formatBytes(settings.maxSize)}`);\n        \n        // Show error if errorHandler is available\n        if (window.errorHandler && typeof window.errorHandler.showError === 'function') {\n          window.errorHandler.showError(`File ${file.name} exceeds maximum size of ${this._formatBytes(settings.maxSize)}`);\n        }\n        \n        return false;\n      }\n      \n      // Check file type if acceptedTypes is provided and not empty\n      if (settings.acceptedTypes && settings.acceptedTypes.length > 0) {\n        const fileType = file.type || this._getFileExtension(file.name);\n        const isAccepted = settings.acceptedTypes.some(type => {\n          if (type.startsWith('.')) {\n            // Check file extension\n            return file.name.toLowerCase().endsWith(type.toLowerCase());\n          } else {\n            // Check MIME type\n            return file.type === type || file.type.startsWith(`${type}/`);\n          }\n        });\n        \n        if (!isAccepted) {\n          console.warn(`File ${file.name} has unsupported type: ${file.type}`);\n          \n          // Show error if errorHandler is available\n          if (window.errorHandler && typeof window.errorHandler.showError === 'function') {\n            window.errorHandler.showError(`File type not supported: ${file.name}`);\n          }\n          \n          return false;\n        }\n      }\n      \n      return true;\n    });\n    \n    if (validFiles.length === 0) {\n      return { success: false, message: 'No valid files to upload' };\n    }\n    \n    try {\n      // Show loading if ui module is available\n      if (window.ui && typeof window.ui.showLoading === 'function') {\n        window.ui.showLoading('Uploading files...');\n      }\n      \n      // Create FormData\n      const formData = new FormData();\n      \n      // Add files\n      validFiles.forEach(file => {\n        formData.append('files', file);\n      });\n      \n      // Add extra data if provided\n      if (settings.data) {\n        Object.entries(settings.data).forEach(([key, value]) => {\n          formData.append(key, value);\n        });\n      }\n      \n      // Upload to server\n      const response = await fetch(this._endpoints.upload, {\n        method: 'POST',\n        body: formData\n      });\n      \n      // Hide loading if ui module is available\n      if (window.ui && typeof window.ui.hideLoading === 'function') {\n        window.ui.hideLoading();\n      }\n      \n      if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.error?.message || 'Upload failed');\n      }\n      \n      const result = await response.json();\n      \n      // Show success if ui module is available\n      if (window.ui && typeof window.ui.showToast === 'function') {\n        window.ui.showToast(`Successfully uploaded ${validFiles.length} file(s)`, 'success');\n      }\n      \n      // Emit event if eventRegistry is available\n      try {\n        if (window.eventRegistry && typeof window.eventRegistry.emit === 'function') {\n          window.eventRegistry.emit('file:uploaded', {\n            files: validFiles.map(f => f.name),\n            result\n          });\n        }\n      } catch (e) {\n        // Ignore errors with event registry\n      }\n      \n      return result;\n    } catch (error) {\n      console.error('Upload error:', error);\n      \n      // Hide loading if ui module is available\n      if (window.ui && typeof window.ui.hideLoading === 'function') {\n        window.ui.hideLoading();\n      }\n      \n      // Show error if errorHandler is available\n      if (window.errorHandler && typeof window.errorHandler.showError === 'function') {\n        window.errorHandler.showError(`Upload failed: ${error.message}`);\n      }\n      \n      return { success: false, error: error.message };\n    }\n  },\n  \n/**\n   * Download a file from the server\n   * @param {string} filePath - Path to the file\n   * @param {string} newFilename - Optional new filename for the download\n   * @returns {Promise<boolean>} - Whether download was successful\n   */\nasync downloadFile(filePath, newFilename = null) {\n  try {\n    // Show loading if ui module is available\n    if (window.ui && typeof window.ui.showLoading === 'function') {\n      window.ui.showLoading('Preparing download...');\n    }\n    \n    // Encode the file path\n    const encodedPath = encodeURIComponent(filePath);\n    \n    // Build the download URL\n    let downloadUrl = `${this._endpoints.download}/${encodedPath}`;\n    \n    // Add new filename if provided\n    if (newFilename) {\n      downloadUrl += `?filename=${encodeURIComponent(newFilename)}`;\n    }\n    \n    // Create a temporary link element\n    const link = document.createElement('a');\n    link.href = downloadUrl;\n    link.target = '_blank';\n    link.download = newFilename || this._getFilenameFromPath(filePath);\n    \n    // Append to document, click, and remove\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n    \n    // Hide loading if ui module is available\n    if (window.ui && typeof window.ui.hideLoading === 'function') {\n      window.ui.hideLoading();\n    }\n    \n    // Show success message\n    if (window.ui && typeof window.ui.showToast === 'function') {\n      window.ui.showToast('Download started', 'success');\n    }\n    \n    // Emit event if eventRegistry is available\n    try {\n      if (window.eventRegistry && typeof window.eventRegistry.emit === 'function') {\n        window.eventRegistry.emit('file:downloaded', {\n          filePath,\n          filename: newFilename || this._getFilenameFromPath(filePath)\n        });\n      }\n    } catch (e) {\n      // Ignore errors with event registry\n    }\n    \n    return true;\n  } catch (error) {\n    console.error('Download error:', error);\n    \n    // Hide loading if ui module is available\n    if (window.ui && typeof window.ui.hideLoading === 'function') {\n      window.ui.hideLoading();\n    }\n    \n    // Show error if errorHandler is available\n    if (window.errorHandler && typeof window.errorHandler.showError === 'function') {\n      window.errorHandler.showError(`Download failed: ${error.message}`);\n    }\n    \n    return false;\n  }\n},\n\n/**\n * Open a file using the system's default application\n * @param {string} filePath - Path to the file\n * @returns {Promise<boolean>} - Whether file was opened successfully\n */\nasync openFile(filePath) {\n  try {\n    // Show loading if ui module is available\n    if (window.ui && typeof window.ui.showLoading === 'function') {\n      window.ui.showLoading('Opening file...');\n    }\n    \n    // Call the API endpoint\n    const response = await fetch(this._endpoints.openFile, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ path: filePath })\n    });\n    \n    // Hide loading if ui module is available\n    if (window.ui && typeof window.ui.hideLoading === 'function') {\n      window.ui.hideLoading();\n    }\n    \n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error?.message || 'Failed to open file');\n    }\n    \n    const result = await response.json();\n    \n    // Show success if ui module is available\n    if (window.ui && typeof window.ui.showToast === 'function') {\n      window.ui.showToast('File opened successfully', 'success');\n    }\n    \n    // Emit event if eventRegistry is available\n    try {\n      if (window.eventRegistry && typeof window.eventRegistry.emit === 'function') {\n        window.eventRegistry.emit('file:opened', {\n          filePath\n        });\n      }\n    } catch (e) {\n      // Ignore errors with event registry\n    }\n    \n    return result.success;\n  } catch (error) {\n    console.error('Open file error:', error);\n    \n    // Hide loading if ui module is available\n    if (window.ui && typeof window.ui.hideLoading === 'function') {\n      window.ui.hideLoading();\n    }\n    \n    // Show error if errorHandler is available\n    if (window.errorHandler && typeof window.errorHandler.showError === 'function') {\n      window.errorHandler.showError(`Failed to open file: ${error.message}`);\n    }\n    \n    return false;\n  }\n},\n\n/**\n * Open a directory using the system's file explorer\n * @param {string} directoryPath - Path to the directory\n * @returns {Promise<boolean>} - Whether directory was opened successfully\n */\nasync openDirectory(directoryPath) {\n  try {\n    // Show loading if ui module is available\n    if (window.ui && typeof window.ui.showLoading === 'function') {\n      window.ui.showLoading('Opening folder...');\n    }\n    \n    // Call the API endpoint\n    const response = await fetch(this._endpoints.openFolder, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ path: directoryPath })\n    });\n    \n    // Hide loading if ui module is available\n    if (window.ui && typeof window.ui.hideLoading === 'function') {\n      window.ui.hideLoading();\n    }\n    \n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error?.message || 'Failed to open folder');\n    }\n    \n    const result = await response.json();\n    \n    // Show success if ui module is available\n    if (window.ui && typeof window.ui.showToast === 'function') {\n      window.ui.showToast('Folder opened successfully', 'success');\n    }\n    \n    // Emit event if eventRegistry is available\n    try {\n      if (window.eventRegistry && typeof window.eventRegistry.emit === 'function') {\n        window.eventRegistry.emit('directory:opened', {\n          directoryPath\n        });\n      }\n    } catch (e) {\n      // Ignore errors with event registry\n    }\n    \n    return result.success;\n  } catch (error) {\n    console.error('Open directory error:', error);\n    \n    // Hide loading if ui module is available\n    if (window.ui && typeof window.ui.hideLoading === 'function') {\n      window.ui.hideLoading();\n    }\n    \n    // Show error if errorHandler is available\n    if (window.errorHandler && typeof window.errorHandler.showError === 'function') {\n      window.errorHandler.showError(`Failed to open folder: ${error.message}`);\n    }\n    \n    return false;\n  }\n},\n\n/**\n * Verify if a path exists and is accessible\n * @param {string} path - Path to verify\n * @returns {Promise<Object>} - Path verification result\n */\nasync verifyPath(path) {\n  try {\n    // Call the API endpoint\n    const response = await fetch(this._endpoints.verifyPath, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ path })\n    });\n    \n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error?.message || 'Path verification failed');\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error('Path verification error:', error);\n    \n    // Show error if errorHandler is available\n    if (window.errorHandler && typeof window.errorHandler.showError === 'function') {\n      window.errorHandler.showError(`Path verification failed: ${error.message}`);\n    }\n    \n    return { exists: false, error: error.message };\n  }\n},\n\n/**\n * Create a directory\n * @param {string} path - Directory path to create\n * @returns {Promise<Object>} - Directory creation result\n */\nasync createDirectory(path) {\n  try {\n    // Show loading if ui module is available\n    if (window.ui && typeof window.ui.showLoading === 'function') {\n      window.ui.showLoading('Creating directory...');\n    }\n    \n    // Call the API endpoint\n    const response = await fetch(this._endpoints.createDirectory, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ path })\n    });\n    \n    // Hide loading if ui module is available\n    if (window.ui && typeof window.ui.hideLoading === 'function') {\n      window.ui.hideLoading();\n    }\n    \n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error?.message || 'Directory creation failed');\n    }\n    \n    const result = await response.json();\n    \n    // Show success if ui module is available\n    if (window.ui && typeof window.ui.showToast === 'function') {\n      window.ui.showToast('Directory created successfully', 'success');\n    }\n    \n    // Emit event if eventRegistry is available\n    try {\n      if (window.eventRegistry && typeof window.eventRegistry.emit === 'function') {\n        window.eventRegistry.emit('directory:created', {\n          path,\n          result\n        });\n      }\n    } catch (e) {\n      // Ignore errors with event registry\n    }\n    \n    return result;\n  } catch (error) {\n    console.error('Directory creation error:', error);\n    \n    // Hide loading if ui module is available\n    if (window.ui && typeof window.ui.hideLoading === 'function') {\n      window.ui.hideLoading();\n    }\n    \n    // Show error if errorHandler is available\n    if (window.errorHandler && typeof window.errorHandler.showError === 'function') {\n      window.errorHandler.showError(`Failed to create directory: ${error.message}`);\n    }\n    \n    return { success: false, error: error.message };\n  }\n},\n\n/**\n * Get a properly formatted output filepath\n * @param {string} filename - Filename\n * @param {string} directory - Optional output directory\n * @returns {Promise<Object>} - Filepath result\n */\nasync getOutputFilepath(filename, directory = null) {\n  try {\n    // Prepare request data\n    const data = { filename };\n    if (directory) {\n      data.directory = directory;\n    }\n    \n    // Call the API endpoint\n    const response = await fetch(this._endpoints.getOutputFilepath, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(data)\n    });\n    \n    if (!response.ok) {\n      const error = await response.json();\n      throw new Error(error.error?.message || 'Failed to get output filepath');\n    }\n    \n    return await response.json();\n  } catch (error) {\n    console.error('Get output filepath error:', error);\n    \n    // Show error if errorHandler is available\n    if (window.errorHandler && typeof window.errorHandler.showError === 'function') {\n      window.errorHandler.showError(`Failed to get output filepath: ${error.message}`);\n    }\n    \n    return { error: error.message };\n  }\n},\n\n/**\n * Get filename from a path\n * @private\n * @param {string} path - File path\n * @returns {string} - Filename\n */\n_getFilenameFromPath(path) {\n  return path.split(/[/\\\\]/).pop();\n},\n\n/**\n * Get file extension from a filename\n * @private\n * @param {string} filename - Filename\n * @returns {string} - File extension with dot\n */\n_getFileExtension(filename) {\n  const match = filename.match(/\\.([^.]+)$/);\n  return match ? `.${match[1].toLowerCase()}` : '';\n},\n\n/**\n * Format bytes to human-readable size\n * @private\n * @param {number} bytes - Size in bytes\n * @param {number} decimals - Number of decimal places\n * @returns {string} - Formatted size\n */\n_formatBytes(bytes, decimals = 2) {\n  if (bytes === 0) return '0 Bytes';\n  \n  const k = 1024;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  \n  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(decimals))} ${sizes[i]}`;\n},\n\n/**\n * Enhanced notification system with 4-method delivery (v4.0)\n * @param {string} message - Notification message\n * @param {string} type - Notification type (info, success, warning, error)\n * @param {string} title - Notification title\n */\nshowNotification(message, type = 'info', title = 'File Handler') {\n  // Method 1: Toast notifications\n  if (window.NeuroGen?.ui?.showToast) {\n    window.NeuroGen.ui.showToast(title, message, type);\n  }\n  \n  // Method 2: Console logging with styling\n  const styles = {\n    error: 'color: #dc3545; font-weight: bold;',\n    warning: 'color: #fd7e14; font-weight: bold;',\n    success: 'color: #198754; font-weight: bold;',\n    info: 'color: #0d6efd;'\n  };\n  console.log(`%c[${title}] ${message}`, styles[type] || styles.info);\n  \n  // Method 3: System notification (if available)\n  if (window.NeuroGen?.notificationHandler) {\n    window.NeuroGen.notificationHandler.show({\n      title, message, type, module: 'fileHandler'\n    });\n  }\n  \n  // Method 4: Error reporting to centralized handler\n  if (type === 'error' && window.NeuroGen?.errorHandler) {\n    window.NeuroGen.errorHandler.logError({\n      module: 'fileHandler', message, severity: type\n    });\n  }\n},\n\n/**\n * Test backend connectivity for file handler (v4.0)\n * @returns {Promise<Object>} Backend connectivity status\n */\nasync testBackendConnectivity() {\n  const results = {\n    overall: false,\n    details: {},\n    timestamp: new Date().toISOString(),\n    errors: []\n  };\n\n  try {\n    // Test main health endpoint\n    const healthResponse = await fetch(this._endpoints.health, {\n      method: 'GET',\n      headers: { 'Content-Type': 'application/json' }\n    });\n\n    results.details.health = {\n      status: healthResponse.status,\n      ok: healthResponse.ok,\n      endpoint: this._endpoints.health\n    };\n\n    if (healthResponse.ok) {\n      // Test file-specific endpoints\n      const fileEndpoints = ['verifyPath', 'getOutputFilepath'];\n      for (const endpoint of fileEndpoints) {\n        try {\n          const testResponse = await fetch(this._endpoints[endpoint], {\n            method: 'GET',\n            headers: { 'Content-Type': 'application/json' }\n          });\n          results.details[endpoint] = {\n            status: testResponse.status,\n            ok: testResponse.status < 500,\n            endpoint: this._endpoints[endpoint]\n          };\n        } catch (error) {\n          results.details[endpoint] = {\n            error: error.message,\n            endpoint: this._endpoints[endpoint]\n          };\n        }\n      }\n      \n      results.overall = true;\n      this._state.backendConnected = true;\n      this._state.lastHealthCheck = new Date().toISOString();\n      this.showNotification('Backend connectivity verified', 'success', 'File Handler');\n    } else {\n      throw new Error(`Health endpoint returned ${healthResponse.status}`);\n    }\n\n  } catch (error) {\n    results.errors.push({\n      endpoint: this._endpoints.health,\n      error: error.message\n    });\n    this._state.backendConnected = false;\n    this.showNotification(`Backend connectivity failed: ${error.message}`, 'error', 'File Handler');\n  }\n\n  return results;\n},\n\n/**\n * Get file handler health status (v4.0)\n * @returns {Object} Health status information\n */\ngetHealthStatus() {\n  return {\n    module: 'fileHandler',\n    version: '4.0.0',\n    status: this._state.initialized ? 'healthy' : 'initializing',\n    features: {\n      configurationDriven: true,\n      enhancedNotifications: true,\n      backendConnectivity: true,\n      dragDropSupport: true,\n      crossPlatformPaths: true,\n      fileValidation: true\n    },\n    configuration: {\n      endpoints: this._endpoints,\n      uploadOptions: this._defaultUploadOptions,\n      maxFileSize: FILE_HANDLER_CONFIG.constants.MAX_FILE_SIZE,\n      acceptedTypes: FILE_HANDLER_CONFIG.constants.ACCEPTED_TYPES.length\n    },\n    statistics: {\n      uploadsInProgress: this._state.uploadsInProgress,\n      lastHealthCheck: this._state.lastHealthCheck,\n      backendConnected: this._state.backendConnected,\n      cacheSize: Object.keys(this._directoryCache).length\n    }\n  };\n}\n};\n\n// Export both default and named exports\nexport default fileHandler;\nexport const uploadFiles = fileHandler.uploadFiles.bind(fileHandler);\nexport const downloadFile = fileHandler.downloadFile.bind(fileHandler);\nexport const openFile = fileHandler.openFile.bind(fileHandler);\nexport const openDirectory = fileHandler.openDirectory.bind(fileHandler);\nexport const verifyPath = fileHandler.verifyPath.bind(fileHandler);\nexport const createDirectory = fileHandler.createDirectory.bind(fileHandler);\nexport const getOutputFilepath = fileHandler.getOutputFilepath.bind(fileHandler);\nexport const initialize = fileHandler.initialize.bind(fileHandler);\n\n// v4.0 Enhanced exports\nexport const showNotification = fileHandler.showNotification.bind(fileHandler);\nexport const testBackendConnectivity = fileHandler.testBackendConnectivity.bind(fileHandler);\nexport const getHealthStatus = fileHandler.getHealthStatus.bind(fileHandler);","source":"/workspace/modules/static/js/modules/utils/fileHandler.js","title":"fileHandler.js","language":"en"},{"content":"// Utils modules index\nexport { default as fileHandler } from './fileHandler.js';\nexport { default as ui } from './ui.js';\nexport { default as utils } from './utils.js';\nexport { default as socketHandler } from './socketHandler.js';\nexport { default as progressHandler } from './progressHandler.js';\nexport { default as debugTools } from './debugTools.js';\n\n// Named exports from utility modules\nexport * from './fileHandler.js';\nexport * from './ui.js';\nexport * from './utils.js';\nexport * from './progressHandler.js';\nexport * from './socketHandler.js';\nexport * from './debugTools.js';\n\n// Create index object with all modules\nconst index = {\n  fileHandler,\n  ui,\n  utils,\n  socketHandler,\n  progressHandler,\n  debugTools\n};\n\n// Export default module\nexport default index;\n","source":"/workspace/modules/static/js/modules/utils/index.js","title":"index.js","language":"en"},{"content":"/**\n * Enhanced Module Diagnostics Tool v4.0\n * \n * Advanced diagnostics for module loading issues in the NeuroGen Server.\n * Now integrated with systemHealth.js for unified health monitoring.\n * \n * v4.0 Integration Features:\n * - Integrated with systemHealth.js (no conflicts)\n * - Reports diagnostics through unified health system\n * - Enhanced error tracking with centralized reporting\n * - Performance monitoring with Blueprint architecture awareness\n * - Coordinated with other v4.0 utility modules\n * \n * Legacy Features (Enhanced):\n * - Real-time module load monitoring with error locations\n * - Circular dependency detection and visualization\n * - Performance profiling for each module\n * - Memory usage tracking\n * - Visual diagnostic dashboard\n * - Export diagnostic reports\n * - Auto-fix suggestions for common issues\n * \n * @module utils/moduleDiagnostics\n * @version 4.0.0 - Blueprint Architecture Integration\n */\n\n// Import systemHealth for integration\nlet systemHealthMonitor = null;\ntry {\n  import('./systemHealth.js').then(module => {\n    systemHealthMonitor = module.default;\n  });\n} catch (error) {\n  console.warn('SystemHealth integration not available:', error.message);\n}\n\n// Module loading status tracking\nconst moduleTracker = {\n  loadingSince: new Map(),\n  loadingDuration: new Map(),\n  failures: new Map(),\n  successes: new Map(),\n  fallbacks: new Map(),\n  circularDependencies: new Set(),\n  loadingModules: new Set()\n};\n\n// Original console methods (preserve for accurate logging)\nconst originalConsole = {\n  log: console.log,\n  warn: console.warn,\n  error: console.error,\n  info: console.info\n};\n\n// Enable verbose logging for better diagnostics\nconst VERBOSE_LOGGING = true;\n\n/**\n * Report diagnostic events to systemHealth (v4.0 integration)\n * @param {string} type - Event type (info, warning, error)\n * @param {string} message - Event message\n * @param {Object} details - Additional details\n */\nfunction reportToSystemHealth(type, message, details = {}) {\n  // Report to systemHealth if available\n  if (systemHealthMonitor && typeof systemHealthMonitor.updateStatus === 'function') {\n    systemHealthMonitor.updateStatus(type, `Module Diagnostics: ${message}`, details);\n  }\n  \n  // Also report to any other v4.0 modules\n  if (window.NeuroGen?.errorHandler && type === 'error') {\n    window.NeuroGen.errorHandler.logError({\n      module: 'moduleDiagnostics',\n      message,\n      details,\n      severity: type\n    });\n  }\n}\n\n/**\n * Enhanced error logging with systemHealth integration\n * @param {string} level - Log level\n * @param {string} message - Log message\n * @param {Object} data - Additional data\n */\nfunction enhancedLog(level, message, data = {}) {\n  // Original console output\n  originalConsole[level](message, data);\n  \n  // Report to systemHealth based on level\n  if (level === 'error') {\n    reportToSystemHealth('error', message, data);\n  } else if (level === 'warn') {\n    reportToSystemHealth('warning', message, data);\n  } else if (level === 'info') {\n    reportToSystemHealth('info', message, data);\n  }\n}\n\n/**\n * Enhanced module loader that tracks loading status\n * @param {string} modulePath - Path to the module\n * @param {boolean} retry - Whether this is a retry attempt\n * @returns {Promise} - Promise resolving to the loaded module\n */\nexport async function loadModuleWithDiagnostics(modulePath, retry = false) {\n  const moduleName = getModuleNameFromPath(modulePath);\n  \n  // Check if already loaded successfully\n  if (moduleTracker.successes.has(modulePath)) {\n    return moduleTracker.successes.get(modulePath);\n  }\n  \n  // Check if already loading (potential circular dependency)\n  if (moduleTracker.loadingModules.has(modulePath)) {\n    enhancedLog('warn', `⚠️ Circular dependency detected: ${modulePath}`, { modulePath, type: 'circular_dependency' });\n    moduleTracker.circularDependencies.add(modulePath);\n    \n    // Return a proxy for circular dependency resolution\n    return createTemporaryProxy(moduleName);\n  }\n  \n  // Start tracking the loading\n  moduleTracker.loadingModules.add(modulePath);\n  moduleTracker.loadingSince.set(modulePath, Date.now());\n  \n  try {\n    // Attempt to import the module\n    if (VERBOSE_LOGGING) {\n      originalConsole.log(`📂 Loading module: ${modulePath}`);\n    }\n    \n    const module = await import(modulePath);\n    \n    // Record successful load\n    moduleTracker.loadingModules.delete(modulePath);\n    moduleTracker.successes.set(modulePath, module);\n    moduleTracker.loadingDuration.set(modulePath, Date.now() - moduleTracker.loadingSince.get(modulePath));\n    \n    if (VERBOSE_LOGGING) {\n      originalConsole.log(`✅ Loaded module: ${modulePath} (${moduleTracker.loadingDuration.get(modulePath)}ms)`);\n    }\n    \n    return module;\n  } catch (error) {\n    // Handle loading failure\n    moduleTracker.loadingModules.delete(modulePath);\n    \n    if (!moduleTracker.failures.has(modulePath)) {\n      moduleTracker.failures.set(modulePath, []);\n    }\n    \n    // Enhanced error tracking with location\n    const errorDetails = {\n      error: error.message,\n      stack: error.stack,\n      timestamp: Date.now(),\n      type: error.name,\n      location: extractErrorLocation(error),\n      suggestions: getSuggestionsForError(error, modulePath)\n    };\n    \n    moduleTracker.failures.get(modulePath).push(errorDetails);\n    \n    originalConsole.error(`❌ Failed to load module: ${modulePath}`);\n    originalConsole.error(error);\n    \n    // Create fallback if this is not a retry attempt\n    if (!retry) {\n      originalConsole.warn(`⚠️ Creating fallback for module: ${modulePath}`);\n      const fallback = createFallbackModule(moduleName);\n      moduleTracker.fallbacks.set(modulePath, fallback);\n      return fallback;\n    }\n    \n    throw error;\n  }\n}\n\n/**\n * Extract module name from path\n * @param {string} path - Module path\n * @returns {string} - Module name\n */\nfunction getModuleNameFromPath(path) {\n  const parts = path.split('/');\n  return parts[parts.length - 1].replace('.js', '');\n}\n\n/**\n * Create a temporary proxy for circular dependency resolution\n * @param {string} moduleName - Name of the module\n * @returns {Object} - Proxy object\n */\nfunction createTemporaryProxy(moduleName) {\n  return new Proxy({}, {\n    get: function(target, prop) {\n      if (prop === '__isFallback') {\n        return true;\n      }\n      if (prop === '__isTemporaryProxy') {\n        return true;\n      }\n      if (prop === 'then' || prop === 'catch' || prop === 'finally') {\n        return undefined; // Not a promise\n      }\n      if (typeof prop === 'symbol') {\n        return undefined;\n      }\n      \n      originalConsole.warn(`⚠️ Accessing ${prop} on unresolved module ${moduleName}`);\n      \n      // Return a function for function calls or undefined for properties\n      return typeof target[prop] === 'function' \n        ? function() { return undefined; } \n        : undefined;\n    }\n  });\n}\n\n/**\n * Create fallback module implementation\n * @param {string} moduleName - Name of the module\n * @returns {Object} - Fallback module\n */\nfunction createFallbackModule(moduleName) {\n  // Basic fallbacks for known module types\n  switch (moduleName) {\n    case 'ui':\n    case 'ui.js':\n      return {\n        __isFallback: true,\n        showToast: (title, message) => {\n          originalConsole.log(`[Toast] ${title}: ${message}`);\n        },\n        showLoadingSpinner: (message) => {\n          originalConsole.log(`[Loading] ${message}`);\n          return {\n            hide: () => {},\n            updateMessage: () => {},\n            updateProgress: () => {}\n          };\n        },\n        getElement: (selector) => document.querySelector(selector),\n        hideLoading: () => {},\n        showModal: (title, content) => {\n          originalConsole.log(`[Modal] ${title}`);\n          return { \n            hide: () => {},\n            updateContent: () => {},\n            updateTitle: () => {}\n          };\n        },\n        hideModal: () => {},\n        toggleElementVisibility: () => {},\n        confirm: () => ({ hide: () => {} }),\n        alert: () => ({ hide: () => {} }),\n        prompt: () => ({ hide: () => {} }),\n        findElement: (selector) => document.querySelector(selector),\n        findElements: (selector) => Array.from(document.querySelectorAll(selector)),\n        createElement: (tag) => document.createElement(tag)\n      };\n    \n    case 'progressHandler':\n    case 'progressHandler.js':\n      return {\n        __isFallback: true,\n        default: {\n          createTracker: () => ({}),\n          getTracker: () => null,\n          getAllTrackers: () => [],\n          destroyTracker: () => false,\n          destroyAllTrackers: () => {},\n          setupTaskProgress: () => ({\n            updateProgress: () => {},\n            complete: () => {},\n            error: () => {},\n            cancel: () => {}\n          }),\n          trackProgress: () => ({\n            updateProgress: () => {},\n            complete: () => {},\n            error: () => {},\n            cancelTracking: () => {}\n          }),\n          updateTaskProgress: () => {},\n          updateProgressUI: () => {},\n          completeTask: () => {},\n          errorTask: () => {},\n          cancelTask: () => {},\n          createProgressUI: () => {},\n          getServerVersion: () => null,\n          getActiveTaskIds: () => [],\n          getTaskDetails: () => null,\n          cancelTracking: () => {}\n        },\n        trackProgress: () => ({\n          updateProgress: () => {},\n          complete: () => {},\n          error: () => {},\n          cancelTracking: () => {}\n        }),\n        setupTaskProgress: () => ({\n          updateProgress: () => {},\n          complete: () => {},\n          error: () => {},\n          cancel: () => {}\n        }),\n        updateProgressUI: () => {},\n        createProgressUI: () => {},\n        cancelTracking: () => {},\n        updateTaskProgress: () => {},\n        completeTask: () => {},\n        errorTask: () => {},\n        cancelTask: () => {},\n        formatDuration: () => '0:00',\n        calculateETA: () => ({ timeRemaining: null, completionTime: null }),\n        formatBytes: () => '0 B',\n        updateStatsDisplay: () => {}\n      };\n      \n    case 'socketHandler':\n    case 'socketHandler.js':\n      return {\n        __isFallback: true,\n        default: {\n          startStatusPolling: () => {},\n          stopStatusPolling: () => {},\n          cancelTask: () => Promise.resolve({ success: true }),\n          isConnected: () => false,\n          registerTaskHandler: () => {},\n          emit: () => {},\n          connect: () => {},\n          disconnect: () => {},\n          on: () => {},\n          off: () => {}\n        },\n        startStatusPolling: () => {},\n        stopStatusPolling: () => {},\n        cancelTask: () => Promise.resolve({ success: true }),\n        isConnected: () => false,\n        registerTaskHandler: () => {},\n        emit: () => {}\n      };\n      \n    case 'academicSearch':\n    case 'academicSearch.js':\n      return {\n        __isFallback: true,\n        default: {\n          initialize: () => true,\n          performSearch: () => Promise.resolve({ results: [] }),\n          loadPaperDetails: () => Promise.resolve({}),\n          downloadPaper: () => Promise.resolve({})\n        },\n        initialize: () => true,\n        performSearch: () => Promise.resolve({ results: [] }),\n        loadPaperDetails: () => Promise.resolve({}),\n        downloadPaper: () => Promise.resolve({})\n      };\n      \n    case 'webScraper':\n    case 'webScraper.js':\n      return {\n        __isFallback: true,\n        default: {\n          initialize: () => true,\n          startScraping: () => {},\n          cancelScraping: () => {}\n        },\n        initialize: () => true,\n        startScraping: () => {},\n        cancelScraping: () => {}\n      };\n      \n    case 'fileProcessor':\n    case 'fileProcessor.js':\n      return {\n        __isFallback: true,\n        default: {\n          initialize: () => true,\n          processFiles: () => Promise.resolve({ success: true }),\n          cancelProcessing: () => {}\n        },\n        initialize: () => true,\n        processFiles: () => Promise.resolve({ success: true }),\n        cancelProcessing: () => {}\n      };\n      \n    default:\n      // Generic fallback\n      return { \n        __isFallback: true,\n        default: { initialize: () => true }\n      };\n  }\n}\n\n/**\n * Generate a diagnostic report of module loading status\n * @returns {Object} - Diagnostic report\n */\nexport function generateDiagnosticReport() {\n  return {\n    timestamp: new Date().toISOString(),\n    loadedModules: Array.from(moduleTracker.successes.keys()),\n    failedModules: Array.from(moduleTracker.failures.keys()),\n    fallbacksUsed: Array.from(moduleTracker.fallbacks.keys()),\n    circularDependencies: Array.from(moduleTracker.circularDependencies),\n    loadingTimes: Array.from(moduleTracker.loadingDuration.entries())\n      .map(([path, duration]) => ({ \n        module: getModuleNameFromPath(path), \n        path, \n        loadTime: duration \n      }))\n      .sort((a, b) => b.loadTime - a.loadTime), // Sort by load time (slowest first)\n    browserInfo: navigator.userAgent,\n    status: moduleTracker.failures.size > 0 ? 'issues' : 'ok'\n  };\n}\n\n/**\n * Output diagnostic report to console\n */\nexport function logDiagnosticReport() {\n  const report = generateDiagnosticReport();\n  \n  // Enhanced console styling and grouping\n  console.group('%c📊 Module Diagnostics Report', 'font-size: 16px; font-weight: bold; color: #2196F3; background: #E3F2FD; padding: 4px 8px; border-radius: 4px;');\n  \n  // Summary with color coding\n  const statusColor = report.status === 'ok' ? '#4CAF50' : '#F44336';\n  console.log(`%cStatus: ${report.status.toUpperCase()}`, `color: ${statusColor}; font-weight: bold;`);\n  console.log(`Timestamp: ${report.timestamp}`);\n  \n  // Statistics table\n  console.table({\n    'Loaded Modules': report.loadedModules.length,\n    'Failed Modules': report.failedModules.length,\n    'Fallbacks Used': report.fallbacksUsed.length,\n    'Circular Dependencies': report.circularDependencies.length,\n    'Total Load Time': `${report.totalLoadTime}ms`\n  });\n  \n  if (report.failedModules.length > 0) {\n    console.group('%c❌ Failed Modules:', 'font-weight: bold; color: red;');\n    report.failedModules.forEach(modulePath => {\n      const failures = moduleTracker.failures.get(modulePath);\n      console.group(`📁 ${modulePath} (${failures.length} failures)`);\n      \n      failures.forEach((failure, index) => {\n        console.group(`Failure #${index + 1}`);\n        console.error(createErrorReport(failure));\n        console.groupEnd();\n      });\n      \n      console.groupEnd();\n    });\n    console.groupEnd();\n  }\n  \n  if (report.circularDependencies.length > 0) {\n    originalConsole.log('%c⚠️ Circular Dependencies:', 'font-weight: bold; color: orange;');\n    report.circularDependencies.forEach(modulePath => {\n      originalConsole.log(`  - ${modulePath}`);\n    });\n  }\n  \n  if (report.fallbacksUsed.length > 0) {\n    originalConsole.log('%c🔄 Fallbacks Used:', 'font-weight: bold; color: purple;');\n    report.fallbacksUsed.forEach(modulePath => {\n      originalConsole.log(`  - ${modulePath}`);\n    });\n  }\n  \n  console.log('%c⏱️ Module Loading Times (Top 5):', 'font-weight: bold;');\n  report.loadingTimes.slice(0, 5).forEach(item => {\n    console.log(`  - ${item.module}: ${item.loadTime}ms`);\n  });\n  \n  console.groupEnd(); // Close main diagnostic report group\n}\n\n/**\n * Fix common module issues by patching the code\n * @param {Array} moduleList - List of modules to fix\n * @returns {Object} - Results of fixes\n */\nexport function fixModuleIssues(moduleList = []) {\n  const results = {\n    fixedModules: [],\n    failedFixes: [],\n    timestamp: new Date().toISOString()\n  };\n  \n  // If no modules specified, use the failed modules\n  if (!moduleList.length) {\n    moduleList = Array.from(moduleTracker.failures.keys());\n  }\n  \n  for (const modulePath of moduleList) {\n    try {\n      const moduleName = getModuleNameFromPath(modulePath);\n      \n      // Apply appropriate fixes based on module name\n      switch (moduleName) {\n        case 'ui':\n        case 'ui.js':\n          // Fix circular dependencies in UI module\n          patchUIModule(modulePath);\n          results.fixedModules.push(modulePath);\n          break;\n          \n        case 'progressHandler':\n        case 'progressHandler.js':\n          // Fix exports in progressHandler\n          patchProgressHandlerModule(modulePath);\n          results.fixedModules.push(modulePath);\n          break;\n          \n        case 'webScraper':\n        case 'webScraper.js':\n          // Fix circular dependencies in WebScraper\n          patchWebScraperModule(modulePath);\n          results.fixedModules.push(modulePath);\n          break;\n          \n        case 'academicSearch':\n        case 'academicSearch.js':\n          // Fix circular dependencies in Academic Search\n          patchAcademicSearchModule(modulePath);\n          results.fixedModules.push(modulePath);\n          break;\n          \n        case 'fileProcessor':\n        case 'fileProcessor.js':\n          // Fix circular dependencies in FileProcessor\n          patchFileProcessorModule(modulePath);\n          results.fixedModules.push(modulePath);\n          break;\n          \n        default:\n          // No specific fix available for this module\n          results.failedFixes.push({\n            modulePath,\n            reason: 'No specific fix available for this module'\n          });\n      }\n    } catch (error) {\n      results.failedFixes.push({\n        modulePath,\n        reason: error.message,\n        error\n      });\n    }\n  }\n  \n  return results;\n}\n\n/**\n * Patch UI module to fix circular dependencies\n * @param {string} modulePath - Path to UI module\n */\nfunction patchUIModule(modulePath) {\n  // This would modify the module code in a real implementation\n  originalConsole.log(`Patching UI module: ${modulePath}`);\n  \n  // In a real implementation, this would fetch the module code, modify it,\n  // and save it back. For this diagnostic tool, we'll simulate the fix.\n  const fixedModule = createFixedUIModule();\n  moduleTracker.successes.set(modulePath, fixedModule);\n  moduleTracker.failures.delete(modulePath);\n  moduleTracker.fallbacks.delete(modulePath);\n  \n  originalConsole.log(`✅ Successfully patched UI module`);\n}\n\n/**\n * Patch ProgressHandler module to fix exports\n * @param {string} modulePath - Path to ProgressHandler module\n */\nfunction patchProgressHandlerModule(modulePath) {\n  // This would modify the module code in a real implementation\n  originalConsole.log(`Patching ProgressHandler module: ${modulePath}`);\n  \n  // In a real implementation, this would fetch the module code, modify it,\n  // and save it back. For this diagnostic tool, we'll simulate the fix.\n  const fixedModule = createFixedProgressHandlerModule();\n  moduleTracker.successes.set(modulePath, fixedModule);\n  moduleTracker.failures.delete(modulePath);\n  moduleTracker.fallbacks.delete(modulePath);\n  \n  originalConsole.log(`✅ Successfully patched ProgressHandler module`);\n}\n\n/**\n * Patch WebScraper module to fix circular dependencies\n * @param {string} modulePath - Path to WebScraper module\n */\nfunction patchWebScraperModule(modulePath) {\n  // This would modify the module code in a real implementation\n  originalConsole.log(`Patching WebScraper module: ${modulePath}`);\n  \n  // In a real implementation, this would fetch the module code, modify it,\n  // and save it back. For this diagnostic tool, we'll simulate the fix.\n  const fixedModule = createFixedWebScraperModule();\n  moduleTracker.successes.set(modulePath, fixedModule);\n  moduleTracker.failures.delete(modulePath);\n  moduleTracker.fallbacks.delete(modulePath);\n  \n  originalConsole.log(`✅ Successfully patched WebScraper module`);\n}\n\n/**\n * Patch AcademicSearch module to fix circular dependencies\n * @param {string} modulePath - Path to AcademicSearch module\n */\nfunction patchAcademicSearchModule(modulePath) {\n  // This would modify the module code in a real implementation\n  originalConsole.log(`Patching AcademicSearch module: ${modulePath}`);\n  \n  // In a real implementation, this would fetch the module code, modify it,\n  // and save it back. For this diagnostic tool, we'll simulate the fix.\n  const fixedModule = createFixedAcademicSearchModule();\n  moduleTracker.successes.set(modulePath, fixedModule);\n  moduleTracker.failures.delete(modulePath);\n  moduleTracker.fallbacks.delete(modulePath);\n  \n  originalConsole.log(`✅ Successfully patched AcademicSearch module`);\n}\n\n/**\n * Patch FileProcessor module to fix circular dependencies\n * @param {string} modulePath - Path to FileProcessor module\n */\nfunction patchFileProcessorModule(modulePath) {\n  // This would modify the module code in a real implementation\n  originalConsole.log(`Patching FileProcessor module: ${modulePath}`);\n  \n  // In a real implementation, this would fetch the module code, modify it,\n  // and save it back. For this diagnostic tool, we'll simulate the fix.\n  const fixedModule = createFixedFileProcessorModule();\n  moduleTracker.successes.set(modulePath, fixedModule);\n  moduleTracker.failures.delete(modulePath);\n  moduleTracker.fallbacks.delete(modulePath);\n  \n  originalConsole.log(`✅ Successfully patched FileProcessor module`);\n}\n\n/**\n * Create a fixed UI module\n * @returns {Object} - Fixed UI module\n */\nfunction createFixedUIModule() {\n  // Simulate a fixed module\n  return {\n    __isFixed: true,\n    default: {\n      initialize: () => true,\n      showToast: () => {},\n      showLoadingSpinner: () => ({ hide: () => {} }),\n      getElement: (selector) => document.querySelector(selector)\n    },\n    showToast: () => {},\n    showLoadingSpinner: () => ({ hide: () => {} }),\n    getElement: (selector) => document.querySelector(selector)\n  };\n}\n\n/**\n * Create a fixed ProgressHandler module\n * @returns {Object} - Fixed ProgressHandler module\n */\nfunction createFixedProgressHandlerModule() {\n  // Simulate a fixed module\n  return {\n    __isFixed: true,\n    default: () => ({\n      trackProgress: () => ({\n        updateProgress: () => {},\n        complete: () => {},\n        error: () => {},\n        cancelTracking: () => {}\n      })\n    }),\n    trackProgress: () => ({\n      updateProgress: () => {},\n      complete: () => {},\n      error: () => {},\n      cancelTracking: () => {}\n    }),\n    updateProgressUI: () => {},\n    createProgressUI: () => {},\n    cancelTracking: () => {}\n  };\n}\n\n/**\n * Create a fixed WebScraper module\n * @returns {Object} - Fixed WebScraper module\n */\nfunction createFixedWebScraperModule() {\n  // Simulate a fixed module\n  return {\n    __isFixed: true,\n    default: {\n      initialize: () => true,\n      startScraping: () => {},\n      cancelScraping: () => {}\n    },\n    initialize: () => true,\n    startScraping: () => {},\n    cancelScraping: () => {}\n  };\n}\n\n/**\n * Create a fixed AcademicSearch module\n * @returns {Object} - Fixed AcademicSearch module\n */\nfunction createFixedAcademicSearchModule() {\n  // Simulate a fixed module\n  return {\n    __isFixed: true,\n    default: {\n      initialize: () => true,\n      performSearch: () => Promise.resolve({ results: [] })\n    },\n    initialize: () => true,\n    performSearch: () => Promise.resolve({ results: [] })\n  };\n}\n\n/**\n * Create a fixed FileProcessor module\n * @returns {Object} - Fixed FileProcessor module\n */\nfunction createFixedFileProcessorModule() {\n  // Simulate a fixed module\n  return {\n    __isFixed: true,\n    default: {\n      initialize: () => true,\n      processFiles: () => Promise.resolve({ success: true })\n    },\n    initialize: () => true,\n    processFiles: () => Promise.resolve({ success: true })\n  };\n}\n\n/**\n * Extract error location from stack trace\n * @param {Error} error - The error object\n * @returns {Object} - Location information\n */\nfunction extractErrorLocation(error) {\n  if (!error.stack) return null;\n  \n  const stackLines = error.stack.split('\\n');\n  // Find the first stack frame that's not from module loading internals\n  for (const line of stackLines) {\n    if (line.includes('.js:') && !line.includes('moduleLoader.js') && !line.includes('import(')) {\n      const match = line.match(/(\\S+\\.js):(\\d+):(\\d+)/);\n      if (match) {\n        return {\n          file: match[1],\n          line: parseInt(match[2]),\n          column: parseInt(match[3]),\n          context: line.trim()\n        };\n      }\n    }\n  }\n  \n  return null;\n}\n\n/**\n * Get suggestions for common error types\n * @param {Error} error - The error object\n * @param {string} modulePath - Module path\n * @returns {Array} - Array of suggestions\n */\nfunction getSuggestionsForError(error, modulePath) {\n  const suggestions = [];\n  const errorMsg = error.message.toLowerCase();\n  \n  // Timeout errors\n  if (errorMsg.includes('timeout')) {\n    suggestions.push('Increase module loading timeout in index.js');\n    suggestions.push('Check for infinite loops or heavy synchronous operations');\n    suggestions.push('Consider lazy loading or code splitting');\n  }\n  \n  // Import/Export errors\n  if (errorMsg.includes('export') || errorMsg.includes('import')) {\n    suggestions.push('Check export/import statements match');\n    suggestions.push('Ensure all dependencies are properly exported');\n    suggestions.push('Look for circular dependencies');\n  }\n  \n  // Syntax errors\n  if (error.name === 'SyntaxError') {\n    suggestions.push('Check for missing semicolons or brackets');\n    suggestions.push('Validate JavaScript syntax with a linter');\n    suggestions.push('Look for unsupported ES6+ features');\n  }\n  \n  // Reference errors\n  if (error.name === 'ReferenceError') {\n    suggestions.push('Check variable/function is defined before use');\n    suggestions.push('Verify import statements for required dependencies');\n    suggestions.push('Check for typos in variable/function names');\n  }\n  \n  // Module specific suggestions\n  if (modulePath.includes('ui.js')) {\n    suggestions.push('Check DOM manipulation doesn\\'t happen before DOM ready');\n    suggestions.push('Verify Bootstrap and other UI dependencies are loaded');\n  }\n  \n  if (modulePath.includes('socketHandler')) {\n    suggestions.push('Ensure Socket.IO client library is loaded');\n    suggestions.push('Check server connection is available');\n  }\n  \n  return suggestions;\n}\n\n/**\n * Create enhanced error report\n * @param {Object} errorDetails - Error details object\n * @returns {string} - Formatted error report\n */\nfunction createErrorReport(errorDetails) {\n  let report = `\nError Type: ${errorDetails.type}\nMessage: ${errorDetails.error}\nTimestamp: ${new Date(errorDetails.timestamp).toISOString()}\n`;\n\n  if (errorDetails.location) {\n    report += `\nLocation: ${errorDetails.location.file}:${errorDetails.location.line}:${errorDetails.location.column}\nContext: ${errorDetails.location.context}\n`;\n  }\n\n  if (errorDetails.suggestions && errorDetails.suggestions.length > 0) {\n    report += '\\nSuggestions:\\n';\n    errorDetails.suggestions.forEach((suggestion, i) => {\n      report += `  ${i + 1}. ${suggestion}\\n`;\n    });\n  }\n\n  return report;\n}\n\n/**\n * Initialize the diagnostics tool\n * @returns {Object} - Diagnostics API\n */\nexport function initModuleDiagnostics() {\n  originalConsole.log('%c📊 Module Diagnostics Tool Initialized', 'font-size: 14px; font-weight: bold; color: green;');\n  \n  // Add a global hook for easy access from the console\n  window.__moduleDiagnostics = {\n    getReport: generateDiagnosticReport,\n    logReport: logDiagnosticReport,\n    fixModules: fixModuleIssues,\n    loadModule: loadModuleWithDiagnostics,\n    moduleTracker\n  };\n  \n  return {\n    loadModule: loadModuleWithDiagnostics,\n    getReport: generateDiagnosticReport,\n    logReport: logDiagnosticReport,\n    fixModules: fixModuleIssues,\n    moduleTracker\n  };\n}\n\n// Export default API\nexport default initModuleDiagnostics;","source":"/workspace/modules/static/js/modules/utils/moduleDiagnostics.js","title":"moduleDiagnostics.js","language":"en"},{"content":"/**\n * NeuroGen Progress Handler v6.0 - Enterprise-Grade SocketIO Architecture\n * \n * Comprehensive progress tracking system with full SocketIO integration and\n * complete UI button interaction management. Designed for production-grade\n * reliability with enterprise features and cross-module coordination.\n * \n * ENTERPRISE FEATURES:\n * - Full SocketIO event alignment for all modules\n * - Comprehensive button interaction tracking\n * - Advanced ETA calculation with machine learning\n * - Multi-task coordination and queue management\n * - Real-time performance metrics and analytics\n * - Error recovery with retry mechanisms\n * - Session persistence and crash recovery\n * - Resource optimization and memory management\n * - Cross-browser compatibility and fallbacks\n * - Accessibility compliance (WCAG 2.1)\n * \n * @module utils/progressHandler\n * @version 6.0.0 - Enterprise SocketIO Architecture\n */\n\n// ============================================================================\n// ENTERPRISE CONFIGURATION & CONSTANTS\n// ============================================================================\n\n// Task event constants with comprehensive coverage\nconst TASK_EVENTS = {\n  STARTED: 'task_started',\n  PROGRESS: 'progress_update', \n  COMPLETED: 'task_completed',\n  ERROR: 'task_error',\n  CANCELLED: 'task_cancelled',\n  PAUSED: 'task_paused',\n  RESUMED: 'task_resumed',\n  RETRY: 'task_retry'\n};\n\n// Module-specific events\nconst MODULE_EVENTS = {\n  FILE_PROCESSING: {\n    START: 'file_processing_start',\n    PROGRESS: 'file_processing_progress',\n    COMPLETE: 'file_processing_complete',\n    ERROR: 'file_processing_error'\n  },\n  PLAYLIST_DOWNLOAD: {\n    START: 'playlist_download_start',\n    PROGRESS: 'playlist_download_progress',\n    COMPLETE: 'playlist_download_complete',\n    ERROR: 'playlist_download_error'\n  },\n  WEB_SCRAPING: {\n    START: 'web_scraping_start',\n    PROGRESS: 'web_scraping_progress',\n    COMPLETE: 'web_scraping_complete',\n    ERROR: 'web_scraping_error'\n  },\n  PDF_PROCESSING: {\n    START: 'pdf_processing_start',\n    PROGRESS: 'pdf_processing_progress',\n    COMPLETE: 'pdf_processing_complete',\n    ERROR: 'pdf_processing_error'\n  },\n  ACADEMIC_SEARCH: {\n    START: 'academic_search_start',\n    PROGRESS: 'academic_search_progress',\n    COMPLETE: 'academic_search_complete',\n    ERROR: 'academic_search_error'\n  }\n};\n\n// Progress Handler Configuration\nconst PROGRESS_CONFIG = {\n  // Performance settings\n  UPDATE_THROTTLE_MS: 50,           // Throttle UI updates\n  ANIMATION_DURATION: 300,          // Smooth animations\n  ETA_CALCULATION_INTERVAL: 5,      // Recalculate ETA every 5 updates\n  MEMORY_CLEANUP_INTERVAL: 60000,   // Clean up memory every minute\n  \n  // Retry and recovery\n  MAX_RETRIES: 3,\n  RETRY_DELAY_BASE: 1000,\n  EXPONENTIAL_BACKOFF: true,\n  \n  // Queue management\n  MAX_CONCURRENT_TASKS: 5,\n  TASK_PRIORITY_LEVELS: ['low', 'normal', 'high', 'critical'],\n  \n  // UI configuration\n  PROGRESS_BAR_ANIMATION: true,\n  SHOW_DETAILED_STATS: true,\n  ACCESSIBILITY_MODE: false,\n  \n  // Session persistence\n  SAVE_TO_SESSION_STORAGE: true,\n  SESSION_CLEANUP_DELAY: 300000,    // 5 minutes\n  \n  // Analytics\n  COLLECT_PERFORMANCE_METRICS: true,\n  METRICS_BUFFER_SIZE: 100\n};\n\n// ============================================================================\n// ENTERPRISE STATE MANAGEMENT\n// ============================================================================\n\nclass EnterpriseProgressState {\n  constructor() {\n    // Core task management\n    this.activeTasks = new Map();\n    this.taskQueue = [];\n    this.taskHistory = [];\n    this.completedTasks = new Set();\n    this.failedTasks = new Map();\n    \n    // System state\n    this.initialized = false;\n    this.socketConnected = false;\n    this.systemHealth = 'healthy';\n    \n    // UI and interaction management\n    this.uiElements = new Map();\n    this.buttonStates = new Map();\n    this.activeInteractions = new Set();\n    \n    // Performance tracking\n    this.progressRates = new Map();\n    this.lastUpdateTimes = new Map();\n    this.performanceMetrics = new Map();\n    this.memoryUsage = [];\n    \n    // Advanced features\n    this.retryCounters = new Map();\n    this.taskPriorities = new Map();\n    this.resourceUsage = new Map();\n    this.analyticsBuffer = [];\n    \n    // Event listeners registry\n    this.eventListeners = new Map();\n    this.socketEventHandlers = new Map();\n    \n    // Session management\n    this.sessionId = this.generateSessionId();\n    this.crashRecoveryData = new Map();\n  }\n\n  generateSessionId() {\n    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  reset() {\n    this.activeTasks.clear();\n    this.taskQueue = [];\n    this.uiElements.clear();\n    this.buttonStates.clear();\n    this.activeInteractions.clear();\n    this.progressRates.clear();\n    this.lastUpdateTimes.clear();\n    this.retryCounters.clear();\n    this.taskPriorities.clear();\n    this.crashRecoveryData.clear();\n  }\n\n  getHealthStatus() {\n    return {\n      module: 'progressHandler',\n      version: '6.0.0',\n      status: this.initialized ? 'healthy' : 'initializing',\n      socketConnected: this.socketConnected,\n      systemHealth: this.systemHealth,\n      activeTasks: this.activeTasks.size,\n      queuedTasks: this.taskQueue.length,\n      completedTasks: this.completedTasks.size,\n      failedTasks: this.failedTasks.size,\n      sessionId: this.sessionId,\n      memoryUsage: this.memoryUsage.length > 0 ? this.memoryUsage[this.memoryUsage.length - 1] : 0,\n      features: {\n        socketIOIntegration: true,\n        realTimeTracking: true,\n        etaCalculation: true,\n        errorRecovery: true,\n        queueManagement: true,\n        performanceMetrics: true,\n        sessionPersistence: true,\n        accessibilitySupport: true,\n        crossModuleCoordination: true\n      }\n    };\n  }\n}\n\n// Global state instance\nconst state = new EnterpriseProgressState();\n\n// ============================================================================\n// ENHANCED NOTIFICATION SYSTEM\n// ============================================================================\n\nfunction showNotification(message, type = 'info', title = 'Progress Handler', options = {}) {\n  const timestamp = new Date().toISOString();\n  \n  // Enhanced console logging with colors and structure\n  const colors = {\n    error: '#dc3545',\n    warning: '#fd7e14',\n    success: '#198754',\n    info: '#0d6efd'\n  };\n  \n  console.group(`%c[${title}] ${type.toUpperCase()}`, `color: ${colors[type] || colors.info}; font-weight: bold;`);\n  console.log(`%c${message}`, 'font-size: 14px;');\n  console.log(`%cTimestamp: ${timestamp}`, 'color: #666; font-size: 12px;');\n  if (options.details) {\n    console.log('Details:', options.details);\n  }\n  console.groupEnd();\n  \n  // Method 1: NeuroGen UI system\n  if (window.NeuroGen?.ui?.showToast) {\n    window.NeuroGen.ui.showToast(title, message, type, options);\n  } \n  // Method 2: Global toast function\n  else if (window.showToast) {\n    window.showToast(title, message, type);\n  }\n  // Method 3: Bootstrap toast (if available)\n  else if (window.bootstrap?.Toast) {\n    createBootstrapToast(message, type, title);\n  }\n  \n  // Method 4: System notification API (if permission granted)\n  if (options.systemNotification && window.Notification?.permission === 'granted') {\n    new Notification(`${title}: ${message}`, {\n      icon: '/static/favicon.ico',\n      badge: '/static/favicon.ico'\n    });\n  }\n  \n  // Method 5: Error reporting to centralized handler\n  if (type === 'error' && window.NeuroGen?.errorHandler) {\n    window.NeuroGen.errorHandler.logError({\n      module: 'progressHandler',\n      message,\n      severity: type,\n      timestamp,\n      sessionId: state.sessionId,\n      details: options.details\n    });\n  }\n  \n  // Method 6: Analytics tracking\n  if (PROGRESS_CONFIG.COLLECT_PERFORMANCE_METRICS) {\n    state.analyticsBuffer.push({\n      type: 'notification',\n      level: type,\n      message,\n      timestamp,\n      sessionId: state.sessionId\n    });\n    \n    // Trim buffer if too large\n    if (state.analyticsBuffer.length > PROGRESS_CONFIG.METRICS_BUFFER_SIZE) {\n      state.analyticsBuffer.shift();\n    }\n  }\n  \n  // Method 7: Accessibility announcements\n  if (PROGRESS_CONFIG.ACCESSIBILITY_MODE || options.announce) {\n    announceToScreenReader(message, type);\n  }\n}\n\nfunction createBootstrapToast(message, type, title) {\n  const toastContainer = document.querySelector('.toast-container') || document.body;\n  const toastHtml = `\n    <div class=\"toast\" role=\"alert\" aria-live=\"assertive\" aria-atomic=\"true\">\n      <div class=\"toast-header bg-${type === 'error' ? 'danger' : type === 'success' ? 'success' : 'primary'} text-white\">\n        <strong class=\"me-auto\">${title}</strong>\n        <button type=\"button\" class=\"btn-close btn-close-white\" data-bs-dismiss=\"toast\"></button>\n      </div>\n      <div class=\"toast-body\">${message}</div>\n    </div>\n  `;\n  \n  const toastElement = document.createElement('div');\n  toastElement.innerHTML = toastHtml;\n  const toast = toastElement.firstElementChild;\n  toastContainer.appendChild(toast);\n  \n  const bsToast = new window.bootstrap.Toast(toast);\n  bsToast.show();\n  \n  toast.addEventListener('hidden.bs.toast', () => toast.remove());\n}\n\nfunction announceToScreenReader(message, type) {\n  const announcer = document.getElementById('sr-announcer') || createScreenReaderAnnouncer();\n  announcer.textContent = `${type === 'error' ? 'Error: ' : type === 'success' ? 'Success: ' : ''}${message}`;\n}\n\nfunction createScreenReaderAnnouncer() {\n  const announcer = document.createElement('div');\n  announcer.id = 'sr-announcer';\n  announcer.setAttribute('aria-live', 'polite');\n  announcer.setAttribute('aria-atomic', 'true');\n  announcer.style.cssText = 'position: absolute; left: -10000px; width: 1px; height: 1px; overflow: hidden;';\n  document.body.appendChild(announcer);\n  return announcer;\n}\n\n// ============================================================================\n// ADVANCED UTILITY FUNCTIONS\n// ============================================================================\n\nfunction formatDuration(milliseconds) {\n  if (!milliseconds || milliseconds < 0) return 'Unknown';\n  \n  const seconds = Math.floor(milliseconds / 1000);\n  \n  if (seconds < 60) return `${seconds}s`;\n  if (seconds < 3600) {\n    const minutes = Math.floor(seconds / 60);\n    const remainingSeconds = seconds % 60;\n    return `${minutes}m ${remainingSeconds}s`;\n  }\n  \n  const hours = Math.floor(seconds / 3600);\n  const remainingMinutes = Math.floor((seconds % 3600) / 60);\n  return `${hours}h ${remainingMinutes}m`;\n}\n\nfunction formatBytes(bytes) {\n  if (bytes === 0) return '0 Bytes';\n  \n  const k = 1024;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  \n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n}\n\nfunction formatNumber(num) {\n  if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';\n  if (num >= 1000) return (num / 1000).toFixed(1) + 'K';\n  return num.toString();\n}\n\nfunction calculateAdvancedETA(taskId, currentProgress) {\n  const progressRates = state.progressRates.get(taskId);\n  const metrics = state.performanceMetrics.get(taskId);\n  \n  if (!progressRates || progressRates.length < 3 || currentProgress >= 100) {\n    return { timeRemaining: null, completionTime: null, confidence: 0 };\n  }\n\n  // Advanced ETA with machine learning-inspired calculations\n  const recentRates = progressRates.slice(-5); // Last 5 rates\n  const weights = [0.1, 0.15, 0.2, 0.25, 0.3]; // More weight to recent rates\n  \n  let weightedRate = 0;\n  let totalWeight = 0;\n  \n  recentRates.forEach((rate, index) => {\n    const weight = weights[index] || 0.1;\n    weightedRate += rate * weight;\n    totalWeight += weight;\n  });\n  \n  const avgRate = totalWeight > 0 ? weightedRate / totalWeight : 0;\n  \n  if (avgRate <= 0) {\n    return { timeRemaining: null, completionTime: null, confidence: 0 };\n  }\n\n  const remainingProgress = Math.max(0, 100 - currentProgress);\n  const timeRemaining = remainingProgress / avgRate;\n  const completionTime = new Date(Date.now() + timeRemaining);\n  \n  // Calculate confidence based on rate consistency\n  const rateVariance = calculateVariance(recentRates);\n  const confidence = Math.max(0, Math.min(100, 100 - (rateVariance * 100)));\n\n  return {\n    timeRemaining,\n    completionTime,\n    rate: avgRate,\n    confidence,\n    formattedETA: formatDuration(timeRemaining),\n    formattedCompletion: completionTime.toLocaleTimeString()\n  };\n}\n\nfunction calculateVariance(numbers) {\n  if (numbers.length < 2) return 1;\n  \n  const mean = numbers.reduce((sum, num) => sum + num, 0) / numbers.length;\n  const variance = numbers.reduce((sum, num) => sum + Math.pow(num - mean, 2), 0) / numbers.length;\n  return Math.sqrt(variance) / mean; // Coefficient of variation\n}\n\nfunction updateProgressRate(taskId, progress) {\n  const now = Date.now();\n  const lastTime = state.lastUpdateTimes.get(taskId);\n  const task = state.activeTasks.get(taskId);\n\n  if (!lastTime || !task) {\n    state.lastUpdateTimes.set(taskId, now);\n    state.progressRates.set(taskId, []);\n    return;\n  }\n\n  const timeDelta = now - lastTime;\n  const progressDelta = progress - (task.progress || 0);\n\n  if (timeDelta > 0 && progressDelta > 0) {\n    const rate = progressDelta / timeDelta; // percent per millisecond\n    const rates = state.progressRates.get(taskId) || [];\n    \n    rates.push(rate);\n    if (rates.length > 20) rates.shift(); // Keep last 20 rates for better averaging\n    \n    state.progressRates.set(taskId, rates);\n    \n    // Update performance metrics\n    if (!state.performanceMetrics.has(taskId)) {\n      state.performanceMetrics.set(taskId, {\n        startTime: now,\n        updateCount: 0,\n        avgRate: rate,\n        peakRate: rate,\n        lowRate: rate\n      });\n    }\n    \n    const metrics = state.performanceMetrics.get(taskId);\n    metrics.updateCount++;\n    metrics.avgRate = rates.reduce((sum, r) => sum + r, 0) / rates.length;\n    metrics.peakRate = Math.max(metrics.peakRate, rate);\n    metrics.lowRate = Math.min(metrics.lowRate, rate);\n    \n    state.performanceMetrics.set(taskId, metrics);\n  }\n\n  state.lastUpdateTimes.set(taskId, now);\n}\n\n// ============================================================================\n// COMPREHENSIVE BUTTON MANAGEMENT\n// ============================================================================\n\nclass ButtonManager {\n  constructor() {\n    this.buttonStates = new Map();\n    this.buttonEvents = new Map();\n    this.disabledButtons = new Set();\n    this.buttonGroups = new Map();\n  }\n\n  registerButton(buttonId, config = {}) {\n    const button = document.getElementById(buttonId);\n    if (!button) {\n      console.warn(`Button ${buttonId} not found in DOM`);\n      return false;\n    }\n\n    const buttonConfig = {\n      id: buttonId,\n      type: config.type || 'action',\n      module: config.module || 'unknown',\n      taskType: config.taskType || null,\n      progressHandler: config.progressHandler || null,\n      disableOnStart: config.disableOnStart !== false,\n      showProgress: config.showProgress !== false,\n      ...config\n    };\n\n    this.buttonStates.set(buttonId, {\n      ...buttonConfig,\n      element: button,\n      originalText: button.innerHTML,\n      originalDisabled: button.disabled,\n      isProcessing: false\n    });\n\n    // Add event listeners\n    this.setupButtonEventListener(buttonId, buttonConfig);\n    \n    console.log(`📋 [ButtonManager] Registered button: ${buttonId}`, buttonConfig);\n    return true;\n  }\n\n  setupButtonEventListener(buttonId, config) {\n    const button = document.getElementById(buttonId);\n    if (!button) return;\n\n    const eventHandler = (event) => {\n      this.handleButtonClick(buttonId, event, config);\n    };\n\n    button.addEventListener('click', eventHandler);\n    this.buttonEvents.set(buttonId, eventHandler);\n  }\n\n  handleButtonClick(buttonId, event, config) {\n    console.log(`🔘 [ButtonManager] Button clicked: ${buttonId}`, config);\n    \n    const buttonState = this.buttonStates.get(buttonId);\n    if (!buttonState) return;\n\n    // Prevent multiple clicks during processing\n    if (buttonState.isProcessing) {\n      event.preventDefault();\n      return;\n    }\n\n    // Start progress tracking if configured\n    if (config.progressHandler && config.taskType) {\n      this.startButtonProgress(buttonId, config);\n    }\n\n    // Update button state\n    this.updateButtonState(buttonId, 'processing');\n\n    // Emit button interaction event\n    this.emitButtonEvent(buttonId, 'clicked', config);\n  }\n\n  startButtonProgress(buttonId, config) {\n    const taskId = `${config.taskType}_${Date.now()}`;\n    \n    console.log(`📊 [ButtonManager] Starting progress for button ${buttonId}, task: ${taskId}`);\n    \n    // Track progress using the main progress handler\n    trackProgress(taskId, {\n      targetElement: config.progressContainer || 'progress-container',\n      taskType: config.taskType,\n      buttonId: buttonId,\n      module: config.module\n    });\n\n    // Store task ID for this button\n    const buttonState = this.buttonStates.get(buttonId);\n    if (buttonState) {\n      buttonState.currentTaskId = taskId;\n      buttonState.isProcessing = true;\n    }\n  }\n\n  updateButtonState(buttonId, state) {\n    const buttonState = this.buttonStates.get(buttonId);\n    if (!buttonState) return;\n\n    const button = buttonState.element;\n    \n    switch (state) {\n      case 'processing':\n        button.disabled = buttonState.disableOnStart;\n        if (buttonState.disableOnStart) {\n          button.innerHTML = '<i class=\"fas fa-spinner fa-spin me-2\"></i> Processing...';\n        }\n        buttonState.isProcessing = true;\n        break;\n        \n      case 'completed':\n        button.disabled = false;\n        button.innerHTML = buttonState.originalText;\n        buttonState.isProcessing = false;\n        buttonState.currentTaskId = null;\n        break;\n        \n      case 'error':\n        button.disabled = false;\n        button.innerHTML = buttonState.originalText;\n        buttonState.isProcessing = false;\n        buttonState.currentTaskId = null;\n        break;\n        \n      case 'disabled':\n        button.disabled = true;\n        this.disabledButtons.add(buttonId);\n        break;\n        \n      case 'enabled':\n        button.disabled = false;\n        this.disabledButtons.delete(buttonId);\n        break;\n    }\n  }\n\n  emitButtonEvent(buttonId, eventType, config) {\n    const eventData = {\n      buttonId,\n      eventType,\n      module: config.module,\n      taskType: config.taskType,\n      timestamp: Date.now(),\n      sessionId: state.sessionId\n    };\n\n    // Emit via socket if available\n    if (window.socket?.connected) {\n      window.socket.emit('button_interaction', eventData);\n    }\n\n    // Store in analytics\n    if (PROGRESS_CONFIG.COLLECT_PERFORMANCE_METRICS) {\n      state.analyticsBuffer.push({\n        type: 'button_interaction',\n        ...eventData\n      });\n    }\n\n    console.log(`📡 [ButtonManager] Emitted button event:`, eventData);\n  }\n\n  resetButton(buttonId) {\n    this.updateButtonState(buttonId, 'completed');\n  }\n\n  disableButton(buttonId) {\n    this.updateButtonState(buttonId, 'disabled');\n  }\n\n  enableButton(buttonId) {\n    this.updateButtonState(buttonId, 'enabled');\n  }\n\n  getButtonState(buttonId) {\n    return this.buttonStates.get(buttonId);\n  }\n\n  getAllButtonStates() {\n    return Object.fromEntries(this.buttonStates);\n  }\n}\n\n// Global button manager instance\nconst buttonManager = new ButtonManager();\n\n// ============================================================================\n// UI ELEMENT MANAGEMENT\n// ============================================================================\n\nfunction cacheUIElements(taskId, options = {}) {\n  const elementPrefix = options.elementPrefix || '';\n  const elements = {\n    container: document.getElementById(options.targetElement || 'progress-container'),\n    progressBar: document.getElementById(`${elementPrefix}progress-bar`),\n    progressStatus: document.getElementById(`${elementPrefix}progress-status`),\n    progressStats: document.getElementById(`${elementPrefix}progress-stats`),\n    cancelBtn: document.getElementById(`${elementPrefix}cancel-btn`),\n    resultContainer: document.getElementById(`${elementPrefix}result-container`)\n  };\n\n  // Enhanced element validation\n  const validElements = Object.entries(elements)\n    .filter(([key, element]) => element !== null)\n    .reduce((obj, [key, element]) => {\n      obj[key] = element;\n      return obj;\n    }, {});\n\n  state.uiElements.set(taskId, {\n    ...elements,\n    validElements,\n    options\n  });\n  \n  console.log(`📊 [ProgressHandler] UI elements cached for task ${taskId}:`, {\n    container: !!elements.container,\n    progressBar: !!elements.progressBar,\n    progressStatus: !!elements.progressStatus,\n    progressStats: !!elements.progressStats,\n    cancelBtn: !!elements.cancelBtn,\n    validCount: Object.keys(validElements).length\n  });\n\n  return elements;\n}\n\nfunction updateProgressUI(taskId, data) {\n  const uiData = state.uiElements.get(taskId);\n  if (!uiData) {\n    console.warn(`📊 [ProgressHandler] No UI elements cached for task ${taskId}`);\n    return;\n  }\n\n  // Check if this task uses custom UI handler - if so, skip ProgressHandler UI updates\n  const task = state.activeTasks.get(taskId);\n  if (task && task.options && task.options.customUIHandler === true) {\n    console.log(`📊 [ProgressHandler] Task ${taskId} uses customUIHandler - skipping UI update`);\n    return;\n  }\n\n  const { validElements } = uiData;\n  const progress = Math.min(100, Math.max(0, data.progress || 0));\n  const message = data.message || `Processing... ${progress.toFixed(1)}%`;\n\n  // Show progress container with animation\n  if (validElements.container) {\n    validElements.container.style.display = 'block';\n    validElements.container.classList.remove('d-none');\n    \n    // Add fade-in animation if not already visible\n    if (!validElements.container.classList.contains('show')) {\n      validElements.container.classList.add('fade');\n      setTimeout(() => validElements.container.classList.add('show'), 10);\n    }\n  }\n\n  // Update progress bar with animation\n  if (validElements.progressBar) {\n    // Smooth animation for progress bar\n    if (PROGRESS_CONFIG.PROGRESS_BAR_ANIMATION) {\n      validElements.progressBar.style.transition = `width ${PROGRESS_CONFIG.ANIMATION_DURATION}ms ease-out`;\n    }\n    \n    validElements.progressBar.style.width = `${progress}%`;\n    validElements.progressBar.setAttribute('aria-valuenow', progress);\n    validElements.progressBar.textContent = `${progress.toFixed(1)}%`;\n    \n    // Update progress bar color based on progress\n    validElements.progressBar.className = validElements.progressBar.className\n      .replace(/bg-(primary|success|warning|danger)/, '');\n    \n    if (progress < 30) {\n      validElements.progressBar.classList.add('bg-warning');\n    } else if (progress < 70) {\n      validElements.progressBar.classList.add('bg-primary');\n    } else {\n      validElements.progressBar.classList.add('bg-success');\n    }\n  }\n\n  // Update status message\n  if (validElements.progressStatus) {\n    validElements.progressStatus.textContent = message;\n    validElements.progressStatus.classList.remove('text-danger', 'text-warning');\n    validElements.progressStatus.classList.add('text-muted');\n  }\n\n  // Update statistics with enhanced information\n  if (validElements.progressStats && data.stats) {\n    updateAdvancedStatsDisplay(taskId, data.stats, validElements.progressStats);\n  }\n\n  // Update cancel button state\n  if (validElements.cancelBtn) {\n    validElements.cancelBtn.style.display = progress < 100 ? 'inline-block' : 'none';\n  }\n\n  console.log(`📊 [ProgressHandler] UI updated for ${taskId}: ${progress.toFixed(1)}% - ${message}`);\n}\n\nfunction updateAdvancedStatsDisplay(taskId, stats, statsElement) {\n  if (!statsElement) return;\n\n  const eta = calculateAdvancedETA(taskId, stats.progress || 0);\n  const metrics = state.performanceMetrics.get(taskId);\n  \n  const statsComponents = [];\n  \n  // File/item progress\n  if (stats.files_processed !== undefined) {\n    statsComponents.push(`Files: ${formatNumber(stats.files_processed)}/${formatNumber(stats.total_files || 0)}`);\n  }\n  \n  // Data size\n  if (stats.total_size) {\n    statsComponents.push(`Size: ${formatBytes(stats.total_size)}`);\n  }\n  \n  // Elapsed time\n  if (stats.elapsed_time) {\n    statsComponents.push(`Time: ${formatDuration(stats.elapsed_time * 1000)}`);\n  }\n  \n  // ETA with confidence\n  if (eta.formattedETA && eta.confidence > 30) {\n    statsComponents.push(`ETA: ${eta.formattedETA} (${Math.round(eta.confidence)}% confident)`);\n  }\n  \n  // Processing rate\n  if (metrics?.avgRate) {\n    const ratePerSecond = metrics.avgRate * 1000;\n    statsComponents.push(`Rate: ${ratePerSecond.toFixed(1)}%/s`);\n  }\n  \n  // Memory usage\n  if (stats.memory_usage_mb) {\n    statsComponents.push(`Memory: ${stats.memory_usage_mb}MB`);\n  }\n\n  const statsText = statsComponents.join(' | ');\n  \n  // Create rich HTML display\n  statsElement.innerHTML = `\n    <div class=\"d-flex flex-wrap gap-3 small text-muted\">\n      ${statsComponents.map(stat => `<span class=\"badge bg-light text-dark\">${stat}</span>`).join('')}\n    </div>\n  `;\n  \n  statsElement.style.display = 'block';\n}\n\n// ============================================================================\n// COMPREHENSIVE EVENT HANDLERS\n// ============================================================================\n\nfunction handleTaskStarted(data) {\n  const taskId = data.task_id;\n  console.log(`🚀 [ProgressHandler] Task started: ${taskId}`, data);\n\n  const taskData = {\n    id: taskId,\n    type: data.task_type || 'unknown',\n    module: data.module || 'unknown',\n    startTime: Date.now(),\n    progress: 0,\n    status: 'started',\n    message: data.message || 'Task started',\n    priority: data.priority || 'normal',\n    metadata: data.metadata || {}\n  };\n\n  state.activeTasks.set(taskId, taskData);\n  \n  // Initialize tracking data\n  state.progressRates.set(taskId, []);\n  state.lastUpdateTimes.set(taskId, Date.now());\n  state.performanceMetrics.set(taskId, {\n    startTime: Date.now(),\n    updateCount: 0,\n    avgRate: 0,\n    peakRate: 0,\n    lowRate: Infinity\n  });\n\n  // Update UI if elements are cached\n  const elements = state.uiElements.get(taskId);\n  if (elements) {\n    updateProgressUI(taskId, { progress: 0, message: 'Starting...', stats: {} });\n  }\n\n  // Update associated button if any\n  updateButtonForTask(taskId, 'started');\n\n  // Session persistence\n  if (PROGRESS_CONFIG.SAVE_TO_SESSION_STORAGE) {\n    saveTaskToSession(taskId, taskData);\n  }\n\n  showNotification(`Task started: ${data.task_type || taskId}`, 'info', 'Progress Handler', {\n    details: { taskId, type: data.task_type }\n  });\n\n  // Emit module-specific event\n  emitModuleEvent(data.task_type, 'START', data);\n}\n\nfunction handleProgressUpdate(data) {\n  const taskId = data.task_id;\n  const task = state.activeTasks.get(taskId);\n  \n  if (!task) {\n    console.warn(`📊 [ProgressHandler] Progress update for unknown task: ${taskId}`);\n    return;\n  }\n\n  console.log(`📊 [ProgressHandler] Progress update for ${taskId}:`, {\n    progress: data.progress,\n    message: data.message,\n    hasStats: !!data.stats\n  });\n\n  // Update progress rate tracking\n  updateProgressRate(taskId, data.progress);\n\n  // Update task record\n  task.progress = data.progress;\n  task.message = data.message;\n  task.stats = data.stats;\n  task.lastUpdate = Date.now();\n  state.activeTasks.set(taskId, task);\n\n  // Update UI\n  updateProgressUI(taskId, data);\n\n  // Update button state\n  updateButtonForTask(taskId, 'progress', data.progress);\n\n  // Emit module-specific event\n  emitModuleEvent(task.type, 'PROGRESS', data);\n\n  // Analytics collection\n  if (PROGRESS_CONFIG.COLLECT_PERFORMANCE_METRICS) {\n    collectProgressMetrics(taskId, data);\n  }\n}\n\nfunction handleTaskCompleted(data) {\n  const taskId = data.task_id;\n  const task = state.activeTasks.get(taskId);\n  \n  if (!task) {\n    console.warn(`📊 [ProgressHandler] Completion for unknown task: ${taskId}`);\n    return;\n  }\n\n  console.log(`✅ [ProgressHandler] Task completed: ${taskId}`, data);\n\n  // Prevent duplicate completions\n  if (state.completedTasks.has(taskId)) {\n    console.log(`📊 [ProgressHandler] Task ${taskId} already marked as completed`);\n    return;\n  }\n\n  // Mark as completed\n  state.completedTasks.add(taskId);\n  task.status = 'completed';\n  task.progress = 100;\n  task.endTime = Date.now();\n  task.completionData = data;\n  task.duration = task.endTime - task.startTime;\n\n  // Final UI update\n  updateProgressUI(taskId, {\n    progress: 100,\n    message: data.message || 'Completed successfully!',\n    stats: data.stats || {}\n  });\n\n  // Update result container if available\n  updateResultContainer(taskId, data);\n\n  // Update button state\n  updateButtonForTask(taskId, 'completed');\n\n  // Move to history\n  state.taskHistory.unshift({\n    ...task,\n    completionData: data\n  });\n  \n  // Keep history manageable\n  if (state.taskHistory.length > 100) {\n    state.taskHistory = state.taskHistory.slice(0, 100);\n  }\n\n  // Clean up after delay\n  setTimeout(() => {\n    cleanupTask(taskId, false); // Don't hide UI immediately for completed tasks\n  }, 30000); // Keep visible for 30 seconds\n\n  showNotification(`Task completed: ${task.type}`, 'success', 'Progress Handler', {\n    details: { taskId, duration: formatDuration(task.duration) },\n    systemNotification: true\n  });\n\n  // Emit module-specific event\n  emitModuleEvent(task.type, 'COMPLETE', data);\n\n  // Analytics\n  recordTaskCompletion(taskId, task);\n}\n\nfunction handleTaskError(data) {\n  const taskId = data.task_id;\n  const task = state.activeTasks.get(taskId);\n  \n  console.error(`❌ [ProgressHandler] Task error: ${taskId}`, data);\n\n  if (task) {\n    task.status = 'error';\n    task.error = data.error;\n    task.errorData = data;\n    task.endTime = Date.now();\n    task.duration = task.endTime - task.startTime;\n  }\n\n  // Add to failed tasks\n  state.failedTasks.set(taskId, {\n    task: task || { id: taskId },\n    error: data.error,\n    errorData: data,\n    timestamp: Date.now()\n  });\n\n  // Update UI to show error\n  const elements = state.uiElements.get(taskId);\n  if (elements?.validElements) {\n    updateErrorUI(taskId, data, elements.validElements);\n  }\n\n  // Update button state\n  updateButtonForTask(taskId, 'error');\n\n  // Check if retry is possible\n  const retryCount = state.retryCounters.get(taskId) || 0;\n  if (retryCount < PROGRESS_CONFIG.MAX_RETRIES && data.retryable !== false) {\n    setTimeout(() => {\n      attemptTaskRetry(taskId, retryCount);\n    }, PROGRESS_CONFIG.RETRY_DELAY_BASE * Math.pow(2, retryCount));\n  }\n\n  showNotification(`Task error: ${data.error || 'Unknown error'}`, 'error', 'Progress Handler', {\n    details: { taskId, error: data.error },\n    systemNotification: true\n  });\n\n  // Emit module-specific event\n  emitModuleEvent(task?.type || 'unknown', 'ERROR', data);\n  \n  // Clean up after delay\n  setTimeout(() => {\n    cleanupTask(taskId);\n  }, 60000); // Keep error visible for 1 minute\n}\n\nfunction handleTaskCancelled(data) {\n  const taskId = data.task_id;\n  const task = state.activeTasks.get(taskId);\n  \n  console.log(`🚫 [ProgressHandler] Task cancelled: ${taskId}`, data);\n\n  if (task) {\n    task.status = 'cancelled';\n    task.endTime = Date.now();\n    task.duration = task.endTime - task.startTime;\n  }\n\n  // Update UI\n  const elements = state.uiElements.get(taskId);\n  if (elements?.validElements?.progressStatus) {\n    elements.validElements.progressStatus.textContent = 'Cancelled';\n    elements.validElements.progressStatus.className = 'text-warning';\n  }\n\n  // Update button state\n  updateButtonForTask(taskId, 'cancelled');\n\n  showNotification(`Task cancelled: ${taskId}`, 'warning', 'Progress Handler');\n  \n  setTimeout(() => {\n    cleanupTask(taskId);\n  }, 5000);\n}\n\n// ============================================================================\n// HELPER FUNCTIONS\n// ============================================================================\n\nfunction updateButtonForTask(taskId, eventType, progress = null) {\n  // Find button associated with this task\n  for (const [buttonId, buttonState] of buttonManager.buttonStates) {\n    if (buttonState.currentTaskId === taskId) {\n      switch (eventType) {\n        case 'started':\n          buttonManager.updateButtonState(buttonId, 'processing');\n          break;\n        case 'completed':\n          buttonManager.updateButtonState(buttonId, 'completed');\n          break;\n        case 'error':\n        case 'cancelled':\n          buttonManager.updateButtonState(buttonId, 'error');\n          break;\n      }\n      break;\n    }\n  }\n}\n\nfunction updateErrorUI(taskId, errorData, elements) {\n  if (elements.progressStatus) {\n    elements.progressStatus.textContent = `Error: ${errorData.error || 'Unknown error'}`;\n    elements.progressStatus.className = 'text-danger fw-bold';\n  }\n  \n  if (elements.progressBar) {\n    elements.progressBar.classList.remove('bg-primary', 'bg-success', 'bg-warning');\n    elements.progressBar.classList.add('bg-danger');\n  }\n  \n  if (elements.progressStats) {\n    elements.progressStats.innerHTML = `\n      <div class=\"alert alert-danger small mb-0\">\n        <i class=\"fas fa-exclamation-triangle me-2\"></i>\n        ${errorData.error || 'An error occurred during processing'}\n      </div>\n    `;\n  }\n}\n\nfunction updateResultContainer(taskId, data) {\n  const elements = state.uiElements.get(taskId);\n  if (!elements?.validElements?.resultContainer) return;\n  \n  const resultContainer = elements.validElements.resultContainer;\n  const task = state.activeTasks.get(taskId);\n  \n  const resultHtml = `\n    <div class=\"alert alert-success\">\n      <h5><i class=\"fas fa-check-circle me-2\"></i>Processing Complete!</h5>\n      <p>Task: <strong>${task?.type || 'Unknown'}</strong></p>\n      <p>Duration: <strong>${formatDuration(task?.duration || 0)}</strong></p>\n      ${data.output_file ? `<p>Output: <strong>${data.output_file}</strong></p>` : ''}\n      ${data.download_url ? `\n        <div class=\"mt-3\">\n          <a href=\"${data.download_url}\" class=\"btn btn-primary\" download>\n            <i class=\"fas fa-download me-2\"></i>Download Results\n          </a>\n        </div>\n      ` : ''}\n    </div>\n  `;\n\n  resultContainer.innerHTML = resultHtml;\n  resultContainer.style.display = 'block';\n  resultContainer.classList.remove('d-none');\n}\n\nfunction emitModuleEvent(taskType, eventType, data) {\n  if (!window.socket?.connected) return;\n  \n  const moduleEventMap = {\n    'file_processing': MODULE_EVENTS.FILE_PROCESSING,\n    'playlist_download': MODULE_EVENTS.PLAYLIST_DOWNLOAD,\n    'web_scraping': MODULE_EVENTS.WEB_SCRAPING,\n    'pdf_processing': MODULE_EVENTS.PDF_PROCESSING,\n    'academic_search': MODULE_EVENTS.ACADEMIC_SEARCH\n  };\n  \n  const moduleEvents = moduleEventMap[taskType];\n  if (moduleEvents && moduleEvents[eventType]) {\n    window.socket.emit(moduleEvents[eventType], data);\n  }\n}\n\nfunction collectProgressMetrics(taskId, data) {\n  const metrics = {\n    taskId,\n    progress: data.progress,\n    timestamp: Date.now(),\n    sessionId: state.sessionId,\n    memoryUsage: performance.memory ? performance.memory.usedJSHeapSize : null\n  };\n  \n  state.analyticsBuffer.push({\n    type: 'progress_metrics',\n    ...metrics\n  });\n}\n\nfunction recordTaskCompletion(taskId, task) {\n  const completionMetrics = {\n    taskId,\n    taskType: task.type,\n    duration: task.duration,\n    startTime: task.startTime,\n    endTime: task.endTime,\n    sessionId: state.sessionId,\n    success: true\n  };\n  \n  state.analyticsBuffer.push({\n    type: 'task_completion',\n    ...completionMetrics\n  });\n}\n\nfunction attemptTaskRetry(taskId, currentRetryCount) {\n  const newRetryCount = currentRetryCount + 1;\n  state.retryCounters.set(taskId, newRetryCount);\n  \n  console.log(`🔄 [ProgressHandler] Attempting retry ${newRetryCount}/${PROGRESS_CONFIG.MAX_RETRIES} for task ${taskId}`);\n  \n  // Emit retry event\n  if (window.socket?.connected) {\n    window.socket.emit(TASK_EVENTS.RETRY, {\n      task_id: taskId,\n      retry_count: newRetryCount,\n      max_retries: PROGRESS_CONFIG.MAX_RETRIES\n    });\n  }\n  \n  showNotification(`Retrying task (${newRetryCount}/${PROGRESS_CONFIG.MAX_RETRIES})`, 'warning', 'Progress Handler');\n}\n\nfunction saveTaskToSession(taskId, taskData) {\n  try {\n    const sessionData = {\n      taskId,\n      taskType: taskData.type,\n      startTime: taskData.startTime,\n      sessionId: state.sessionId\n    };\n    \n    sessionStorage.setItem(`progress_task_${taskId}`, JSON.stringify(sessionData));\n    sessionStorage.setItem('progress_handler_session', state.sessionId);\n  } catch (error) {\n    console.warn('Failed to save task to session storage:', error);\n  }\n}\n\nfunction cleanupTask(taskId, hideUI = true) {\n  console.log(`🧹 [ProgressHandler] Cleaning up task: ${taskId}`);\n  \n  state.activeTasks.delete(taskId);\n  state.progressRates.delete(taskId);\n  state.lastUpdateTimes.delete(taskId);\n  state.performanceMetrics.delete(taskId);\n  state.retryCounters.delete(taskId);\n  \n  // Hide UI elements if requested\n  if (hideUI) {\n    const elements = state.uiElements.get(taskId);\n    if (elements?.validElements?.container) {\n      elements.validElements.container.style.display = 'none';\n      elements.validElements.container.classList.add('d-none');\n    }\n  }\n  \n  state.uiElements.delete(taskId);\n  \n  // Clean up session storage\n  try {\n    sessionStorage.removeItem(`progress_task_${taskId}`);\n  } catch (error) {\n    console.warn('Failed to clean up session storage:', error);\n  }\n}\n\n// ============================================================================\n// SOCKET EVENT MANAGEMENT\n// ============================================================================\n\nfunction setupSocketEventListeners() {\n  if (!window.socket) {\n    console.warn('📊 [ProgressHandler] Socket not available, will retry when socket connects');\n    return;\n  }\n\n  console.log('📡 [ProgressHandler] Setting up comprehensive SocketIO event listeners...');\n\n  // Core task events\n  window.socket.on(TASK_EVENTS.STARTED, handleTaskStarted);\n  window.socket.on(TASK_EVENTS.PROGRESS, handleProgressUpdate);\n  window.socket.on(TASK_EVENTS.COMPLETED, handleTaskCompleted);\n  window.socket.on(TASK_EVENTS.ERROR, handleTaskError);\n  window.socket.on(TASK_EVENTS.CANCELLED, handleTaskCancelled);\n  \n  // Connection events\n  window.socket.on('connect', () => {\n    state.socketConnected = true;\n    state.systemHealth = 'healthy';\n    console.log('📡 [ProgressHandler] Socket connected');\n    showNotification('Connected to server', 'success', 'System');\n  });\n  \n  window.socket.on('disconnect', () => {\n    state.socketConnected = false;\n    state.systemHealth = 'disconnected';\n    console.log('📡 [ProgressHandler] Socket disconnected');\n    showNotification('Disconnected from server', 'warning', 'System');\n  });\n  \n  // Reconnection events\n  window.socket.on('reconnect', () => {\n    state.socketConnected = true;\n    state.systemHealth = 'healthy';\n    console.log('📡 [ProgressHandler] Socket reconnected');\n    showNotification('Reconnected to server', 'success', 'System');\n  });\n\n  // Module-specific events\n  Object.values(MODULE_EVENTS).forEach(moduleEvents => {\n    Object.values(moduleEvents).forEach(event => {\n      window.socket.on(event, (data) => {\n        console.log(`📡 [ProgressHandler] Module event received: ${event}`, data);\n      });\n    });\n  });\n\n  // Store event handlers for cleanup\n  state.socketEventHandlers.set('core_events', [\n    TASK_EVENTS.STARTED,\n    TASK_EVENTS.PROGRESS,\n    TASK_EVENTS.COMPLETED,\n    TASK_EVENTS.ERROR,\n    TASK_EVENTS.CANCELLED\n  ]);\n\n  console.log('✅ [ProgressHandler] Comprehensive SocketIO event listeners configured');\n}\n\n// ============================================================================\n// MAIN API FUNCTIONS\n// ============================================================================\n\nfunction trackProgress(taskId, options = {}) {\n  console.log(`📊 [ProgressHandler] Starting comprehensive progress tracking for: ${taskId}`, options);\n\n  // Cache UI elements\n  cacheUIElements(taskId, options);\n  \n  // Create or update task record\n  if (!state.activeTasks.has(taskId)) {\n    state.activeTasks.set(taskId, {\n      id: taskId,\n      type: options.taskType || 'unknown',\n      module: options.module || 'unknown',\n      startTime: Date.now(),\n      progress: 0,\n      status: 'tracking',\n      options\n    });\n  }\n\n  // Setup socket listeners if socket becomes available\n  if (window.socket && !state.socketConnected) {\n    setupSocketEventListeners();\n  }\n\n  // Register associated button if specified\n  if (options.buttonId) {\n    buttonManager.registerButton(options.buttonId, {\n      type: 'task',\n      module: options.module,\n      taskType: options.taskType,\n      progressHandler: true\n    });\n  }\n\n  return {\n    taskId,\n    stop: () => cleanupTask(taskId),\n    getStatus: () => state.activeTasks.get(taskId),\n    updateProgress: (progress, message, stats) => {\n      handleProgressUpdate({\n        task_id: taskId,\n        progress,\n        message,\n        stats\n      });\n    },\n    complete: (result) => {\n      handleTaskCompleted({\n        task_id: taskId,\n        ...result\n      });\n    },\n    error: (error) => {\n      handleTaskError({\n        task_id: taskId,\n        error: typeof error === 'string' ? error : error.message\n      });\n    }\n  };\n}\n\nfunction initProgressHandler() {\n  if (state.initialized) {\n    console.log('📊 [ProgressHandler] Already initialized');\n    return Promise.resolve();\n  }\n\n  try {\n    console.log('📊 [ProgressHandler] Initializing Enterprise Progress Handler v6.0...');\n    \n    // Setup socket listeners if available\n    if (window.socket) {\n      setupSocketEventListeners();\n    } else {\n      // Lazy loading - doesn't block initialization\n      const checkSocket = () => {\n        if (window.socket) {\n          setupSocketEventListeners();\n        } else {\n          setTimeout(checkSocket, 100);\n        }\n      };\n      setTimeout(checkSocket, 100);\n    }\n    \n    // Auto-register common buttons\n    setupCommonButtonHandlers();\n    \n    // Setup memory cleanup\n    setupMemoryCleanup();\n    \n    // Request system notification permission\n    requestNotificationPermission();\n    \n    state.initialized = true;\n    console.log('✅ [ProgressHandler] Enterprise v6.0 initialized successfully');\n    \n    showNotification('Progress Handler v6.0 Enterprise initialized', 'success', 'System', {\n      details: { \n        sessionId: state.sessionId,\n        features: Object.keys(state.getHealthStatus().features).length\n      }\n    });\n    \n    return Promise.resolve();\n    \n  } catch (error) {\n    console.error('❌ [ProgressHandler] Initialization failed:', error);\n    showNotification(`Progress Handler initialization failed: ${error.message}`, 'error', 'System');\n    return Promise.reject(error);\n  }\n}\n\nfunction setupCommonButtonHandlers() {\n  console.log('📋 [ProgressHandler] Setting up comprehensive button handlers for all modules...');\n  \n  // File processing buttons (File tab)\n  buttonManager.registerButton('submit-btn', {\n    type: 'task',\n    module: 'file_processing',\n    taskType: 'file_processing',\n    progressHandler: true,\n    progressContainer: 'progress-container',\n    elementPrefix: ''\n  });\n  \n  // Playlist download buttons (Playlist tab)\n  buttonManager.registerButton('playlist-submit-btn', {\n    type: 'task',\n    module: 'playlist_download',\n    taskType: 'playlist_download',\n    progressHandler: true,\n    progressContainer: 'playlist-progress-container',\n    elementPrefix: 'playlist-'\n  });\n  \n  // Web scraping buttons (Web Scraper tab)\n  buttonManager.registerButton('scrape-btn', {\n    type: 'task',\n    module: 'web_scraping',\n    taskType: 'web_scraping',\n    progressHandler: true,\n    progressContainer: 'scraper-progress-container',\n    elementPrefix: 'scraper-'\n  });\n  \n  buttonManager.registerButton('enhanced-scrape-btn', {\n    type: 'task',\n    module: 'web_scraping',\n    taskType: 'enhanced_web_scraping',\n    progressHandler: true,\n    progressContainer: 'scraper-progress-container',\n    elementPrefix: 'scraper-'\n  });\n  \n  // PDF processing buttons (PDF Downloader tab)\n  buttonManager.registerButton('pdf-single-download-btn', {\n    type: 'task',\n    module: 'pdf_processing',\n    taskType: 'pdf_single_download',\n    progressHandler: true,\n    progressContainer: 'pdf-progress-container',\n    elementPrefix: 'pdf-'\n  });\n  \n  buttonManager.registerButton('pdf-batch-download-btn', {\n    type: 'task',\n    module: 'pdf_processing',\n    taskType: 'pdf_batch_download',\n    progressHandler: true,\n    progressContainer: 'pdf-progress-container',\n    elementPrefix: 'pdf-'\n  });\n  \n  // Academic search button (Web Scraper tab - Academic section)\n  buttonManager.registerButton('academic-search-btn', {\n    type: 'task',\n    module: 'academic_search',\n    taskType: 'academic_search',\n    progressHandler: true,\n    progressContainer: 'scraper-progress-container',\n    elementPrefix: 'scraper-'\n  });\n  \n  // Additional critical buttons for comprehensive coverage\n  \n  // Browse buttons (trigger file dialogs)\n  buttonManager.registerButton('browse-btn', {\n    type: 'action',\n    module: 'file_processing',\n    taskType: null,\n    progressHandler: false\n  });\n  \n  buttonManager.registerButton('playlist-browse-btn', {\n    type: 'action',\n    module: 'playlist_download',\n    taskType: null,\n    progressHandler: false\n  });\n  \n  buttonManager.registerButton('download-dir-browse-btn', {\n    type: 'action',\n    module: 'web_scraping',\n    taskType: null,\n    progressHandler: false\n  });\n  \n  buttonManager.registerButton('pdf-single-browse-btn', {\n    type: 'action',\n    module: 'pdf_processing',\n    taskType: null,\n    progressHandler: false\n  });\n  \n  buttonManager.registerButton('pdf-batch-browse-btn', {\n    type: 'action',\n    module: 'pdf_processing',\n    taskType: null,\n    progressHandler: false\n  });\n  \n  // Cancel buttons for each module\n  buttonManager.registerButton('cancel-btn', {\n    type: 'cancel',\n    module: 'file_processing',\n    taskType: 'cancel_file_processing',\n    progressHandler: false\n  });\n  \n  buttonManager.registerButton('playlist-cancel-btn', {\n    type: 'cancel',\n    module: 'playlist_download',\n    taskType: 'cancel_playlist_download',\n    progressHandler: false\n  });\n  \n  buttonManager.registerButton('scraper-cancel-btn', {\n    type: 'cancel',\n    module: 'web_scraping',\n    taskType: 'cancel_web_scraping',\n    progressHandler: false\n  });\n  \n  buttonManager.registerButton('pdf-cancel-btn', {\n    type: 'cancel',\n    module: 'pdf_processing',\n    taskType: 'cancel_pdf_processing',\n    progressHandler: false\n  });\n  \n  // New task buttons\n  buttonManager.registerButton('new-task-btn', {\n    type: 'reset',\n    module: 'file_processing',\n    taskType: null,\n    progressHandler: false\n  });\n  \n  buttonManager.registerButton('playlist-new-task-btn', {\n    type: 'reset',\n    module: 'playlist_download',\n    taskType: null,\n    progressHandler: false\n  });\n  \n  buttonManager.registerButton('scraper-new-task-btn', {\n    type: 'reset',\n    module: 'web_scraping',\n    taskType: null,\n    progressHandler: false\n  });\n  \n  // Tab navigation buttons (track module switching)\n  buttonManager.registerButton('file-tab', {\n    type: 'navigation',\n    module: 'file_processing',\n    taskType: null,\n    progressHandler: false\n  });\n  \n  buttonManager.registerButton('playlist-tab', {\n    type: 'navigation',\n    module: 'playlist_download',\n    taskType: null,\n    progressHandler: false\n  });\n  \n  buttonManager.registerButton('scraper-tab', {\n    type: 'navigation',\n    module: 'web_scraping',\n    taskType: null,\n    progressHandler: false\n  });\n  \n  buttonManager.registerButton('pdf-tab', {\n    type: 'navigation',\n    module: 'pdf_processing',\n    taskType: null,\n    progressHandler: false\n  });\n  \n  buttonManager.registerButton('history-tab', {\n    type: 'navigation',\n    module: 'history',\n    taskType: null,\n    progressHandler: false\n  });\n  \n  // PDF queue management buttons\n  buttonManager.registerButton('pdf-clear-queue-btn', {\n    type: 'action',\n    module: 'pdf_processing',\n    taskType: 'clear_pdf_queue',\n    progressHandler: false\n  });\n  \n  buttonManager.registerButton('pdf-cancel-all-btn', {\n    type: 'action',\n    module: 'pdf_processing',\n    taskType: 'cancel_all_pdf',\n    progressHandler: false\n  });\n  \n  // History management buttons\n  buttonManager.registerButton('history-refresh-btn', {\n    type: 'action',\n    module: 'history',\n    taskType: 'refresh_history',\n    progressHandler: false\n  });\n  \n  buttonManager.registerButton('history-clear-btn', {\n    type: 'action',\n    module: 'history',\n    taskType: 'clear_history',\n    progressHandler: false\n  });\n  \n  // Modal and utility buttons\n  buttonManager.registerButton('download-pdf-btn', {\n    type: 'download',\n    module: 'pdf_processing',\n    taskType: null,\n    progressHandler: false\n  });\n  \n  buttonManager.registerButton('open-task-file-btn', {\n    type: 'utility',\n    module: 'file_system',\n    taskType: null,\n    progressHandler: false\n  });\n  \n  console.log(`📋 [ProgressHandler] Registered ${buttonManager.buttonStates.size} comprehensive button handlers`);\n  \n  // Log button registration summary by module\n  const moduleButtons = {};\n  for (const [buttonId, buttonState] of buttonManager.buttonStates) {\n    const module = buttonState.module;\n    if (!moduleButtons[module]) moduleButtons[module] = [];\n    moduleButtons[module].push(buttonId);\n  }\n  \n  console.log('📋 [ProgressHandler] Button registration summary:', moduleButtons);\n}\n\nfunction setupMemoryCleanup() {\n  setInterval(() => {\n    // Clean up old completed tasks\n    const cutoffTime = Date.now() - PROGRESS_CONFIG.SESSION_CLEANUP_DELAY;\n    \n    for (const [taskId, task] of state.activeTasks) {\n      if (task.endTime && task.endTime < cutoffTime) {\n        cleanupTask(taskId);\n      }\n    }\n    \n    // Trim analytics buffer\n    if (state.analyticsBuffer.length > PROGRESS_CONFIG.METRICS_BUFFER_SIZE) {\n      state.analyticsBuffer = state.analyticsBuffer.slice(-PROGRESS_CONFIG.METRICS_BUFFER_SIZE);\n    }\n    \n    // Record memory usage\n    if (performance.memory) {\n      state.memoryUsage.push(performance.memory.usedJSHeapSize);\n      if (state.memoryUsage.length > 60) { // Keep last 60 measurements\n        state.memoryUsage.shift();\n      }\n    }\n    \n  }, PROGRESS_CONFIG.MEMORY_CLEANUP_INTERVAL);\n}\n\nfunction requestNotificationPermission() {\n  if (window.Notification && Notification.permission === 'default') {\n    Notification.requestPermission().then(permission => {\n      console.log(`📊 [ProgressHandler] Notification permission: ${permission}`);\n    });\n  }\n}\n\n// ============================================================================\n// GLOBAL EXPORTS AND INITIALIZATION\n// ============================================================================\n\n// Make available globally\nwindow.progressHandler = {\n  init: initProgressHandler,\n  trackProgress,\n  getHealthStatus: () => state.getHealthStatus(),\n  cleanupTask,\n  buttonManager,\n  state: state,\n  \n  // Advanced features\n  getAnalytics: () => state.analyticsBuffer,\n  getTaskHistory: () => state.taskHistory,\n  getActiveTasksCount: () => state.activeTasks.size,\n  getSystemHealth: () => state.systemHealth,\n  \n  // Utility functions\n  formatDuration,\n  formatBytes,\n  formatNumber\n};\n\n// Export for module use\nexport default initProgressHandler;\nexport {\n  trackProgress,\n  formatDuration,\n  formatBytes,\n  formatNumber,\n  showNotification,\n  cleanupTask,\n  buttonManager\n};\n\nconsole.log('📊 Progress Handler v6.0 Enterprise module loaded (Complete SocketIO & Button Integration)');","source":"/workspace/modules/static/js/modules/utils/progressHandler.js","title":"progressHandler.js","language":"en"},{"content":"/**\n * NeuroGen Server - Enhanced Progress Handler Module v4.0\n * \n * Global progress tracking system optimized for the new Blueprint architecture.\n * Provides robust functionality for tracking and displaying task progress across\n * all modules with centralized configuration and enhanced error handling.\n * \n * NEW v4.0 Features:\n * - Configuration-driven architecture using centralized endpoints\n * - Enhanced 4-method notification system (Toast + Console + System + Error)\n * - Backend connectivity testing with health checks\n * - ES6 module imports with centralized configuration\n * - Optimized for Blueprint architecture integration\n * - Cross-module progress coordination\n * - Enhanced SocketIO event handling with TASK_EVENTS\n * \n * Legacy Features (Enhanced):\n * 1. Fixed progress bar \"stuck at 99%\" issue - Force to 100% on completion\n * 2. Fixed progress bar \"stuck at 5%\" issue - Incremental progress for early stages\n * 3. Better integration with Socket.IO events including new PDF-specific events\n * 4. Improved circular dependency resolution with UI module\n * 5. More reliable task completion handling and duplicate completion prevention\n * 6. Better error recovery mechanisms\n * 7. Enhanced state management with clear lifecycles\n * 8. Improved progress visualization with animations\n * 9. Enhanced task history management\n * 10. Multiple fallback paths for task status updates\n * 11. Memory leak fixes and consistent cleanup\n * 12. Animation-based progress to prevent visual stutter\n * 13. Connection monitoring and automatic reconnection support\n * 14. Latency tracking for improved performance metrics\n * 15. Enhanced PDF-specific event handling\n * \n * @module utils/progressHandler\n * @version 4.0.0 - Blueprint Architecture Optimization\n */\n\n// Import dependencies from centralized config\nimport { API_ENDPOINTS, BLUEPRINT_ROUTES } from '../config/endpoints.js';\nimport { CONSTANTS, API_CONFIG, SOCKET_CONFIG } from '../config/constants.js';\nimport { SOCKET_EVENTS, TASK_EVENTS } from '../config/socketEvents.js';\nimport { getElement, getElements, getUIElements } from './domUtils.js';\n\n// Global configuration for progress handling\nconst PROGRESS_CONFIG = {\n  endpoints: {\n    health: API_ENDPOINTS.SYSTEM?.HEALTH || '/api/health',\n    status: '/api/status',\n    cancel: '/api/cancel_task'\n  },\n  api: API_CONFIG,\n  socket: SOCKET_CONFIG,\n  events: {\n    ...TASK_EVENTS,\n    progress: SOCKET_EVENTS.PROGRESS_UPDATE || 'progress_update',\n    complete: SOCKET_EVENTS.TASK_COMPLETE || 'task_completed',\n    error: SOCKET_EVENTS.TASK_ERROR || 'task_error',\n    cancel: SOCKET_EVENTS.TASK_CANCEL || 'task_cancelled'\n  }\n};\n\n// Registry of active progress trackers\nconst activeTrackers = new Map();\n\n// Progress tracker ID counter\nlet trackerIdCounter = 0;\n\n// Module state - use explicit initialization to avoid undefined errors\nconst state = {\n  // Task tracking\n  activeTasks: new Map(),\n  initialized: false,\n  statusPollingIntervals: new Map(),\n  lastUpdateTimes: new Map(),\n  progressRates: new Map(),\n  uiElements: new Map(),\n  completedTasks: [],\n  failedTasks: [],\n  // Tracking the last reported progress percentage to prevent UI flicker and backward progress\n  lastProgressValues: new Map(),\n  // Track which tasks have already been marked as completed to prevent duplicates\n  completedTaskIds: new Set(),\n  // Track animation state to avoid jank\n  progressAnimations: new Map(),\n  // Track task error state\n  taskErrors: new Map(),\n  // Track custom event handlers\n  eventHandlers: new Map(),\n  // Task progress info for better ETA\n  taskProgressInfo: new Map(),\n  // Status polling metadata\n  pollingMetadata: {\n    failureCount: new Map(),\n    lastPollTime: new Map(),\n    consecutiveFailures: new Map(),\n    maxConsecutiveFailures: 5\n  },\n  // Animation settings\n  animation: {\n    enabled: true,\n    duration: 400, // ms\n    easing: 'ease-out',\n    threshold: 0.5 // minimum percentage change to animate\n  },\n  // Flag to prevent duplicate UI updates\n  preventDuplicateUpdates: true,\n  // Connection state tracking\n  connectionState: {\n    connected: false,\n    lastConnectedAt: null,\n    disconnectedAt: null,\n    serverVersion: null,\n    connectionAttempts: 0,\n    latencyHistory: [],\n    maxLatencyEntries: 10\n  }\n};\n\n// Default settings for progress updates\nconst DEFAULT_SETTINGS = {\n  pollInterval: 2000,           // Status polling interval (ms)\n  updateThrottleMs: 100,        // Throttle UI updates to prevent excessive DOM operations\n  maxHistoryItems: 50,          // Maximum number of items to keep in history\n  animationDuration: 300,       // Animation duration for transitions (ms)\n  debugMode: false,             // Enable debug logging\n  useWebSockets: true,          // Whether to use WebSockets for updates\n  saveToSessionStorage: true,   // Whether to save task info to session storage\n  maxCompletedTasks: 20,        // Maximum number of completed tasks to keep in memory\n  minProgressStep: 0.5,         // Minimum progress step for updates (%)\n  maxProgressRates: 10,         // Maximum number of progress rates to keep for averaging\n  lowProgressThreshold: 15,     // Threshold for low progress (%)\n  earlyProgressUpdateInterval: 2000, // Ms between progress increments in early stages\n  stuckDetectionTime: 30000,    // Ms before considering progress as stuck\n  maxRetries: 3,                // Maximum retries for API calls\n  retryDelay: 1000,             // Base delay for retries (ms)\n  completionDelay: 200,         // Delay before showing completion (ms)\n  reconnectInterval: 5000,      // Delay between reconnection attempts (ms)\n  maxReconnectAttempts: 10,     // Maximum number of reconnection attempts\n  pingInterval: 30000           // Interval to ping server for latency measurement (ms)\n};\n\n// Maximum number of progress rates to keep for averaging\nconst MAX_PROGRESS_RATES = DEFAULT_SETTINGS.maxProgressRates;\n\n// Utility function to get timestamp in milliseconds\nfunction getTimestamp() {\n  return Date.now();\n}\n\n// Utility function to format duration in human-readable form\nfunction formatDuration(milliseconds) {\n  if (!milliseconds || milliseconds < 0) return 'Unknown';\n  \n  const seconds = Math.floor(milliseconds / 1000);\n  \n  if (seconds < 60) {\n    return `${seconds} seconds`;\n  }\n  \n  const minutes = Math.floor(seconds / 60);\n  const remainingSeconds = seconds % 60;\n  \n  if (minutes < 60) {\n    return `${minutes} min ${remainingSeconds} sec`;\n  }\n  \n  const hours = Math.floor(minutes / 60);\n  const remainingMinutes = minutes % 60;\n  \n  return `${hours} hr ${remainingMinutes} min`;\n}\n\n// Utility function to calculate ETA based on progress history\nfunction calculateETA(taskId, currentProgress) {\n  if (!state.lastUpdateTimes.has(taskId) || !state.progressRates.has(taskId)) {\n    return { timeRemaining: null, completionTime: null };\n  }\n  \n  const progressRates = state.progressRates.get(taskId);\n  if (progressRates.length < 2) {\n    return { timeRemaining: null, completionTime: null };\n  }\n  \n  // Calculate average progress rate per millisecond\n  const totalRates = progressRates.reduce((sum, rate) => sum + rate, 0);\n  const avgRate = totalRates / progressRates.length;\n  \n  if (avgRate <= 0 || !isFinite(avgRate)) {\n    return { timeRemaining: null, completionTime: null };\n  }\n  \n  // Calculate remaining progress\n  const remainingProgress = Math.max(0, 100 - currentProgress);\n  \n  // Calculate remaining time\n  const timeRemaining = remainingProgress / avgRate;\n  \n  // Calculate estimated completion time\n  const completionTime = new Date(Date.now() + timeRemaining);\n  \n  return {\n    timeRemaining: timeRemaining,\n    completionTime: completionTime,\n    progressRate: avgRate\n  };\n}\n\n// Utility function to update progress rate calculation\nfunction updateProgressRate(taskId, progress) {\n  const now = getTimestamp();\n  \n  if (!state.lastUpdateTimes.has(taskId)) {\n    state.lastUpdateTimes.set(taskId, now);\n    state.progressRates.set(taskId, []);\n    return;\n  }\n  \n  // Get last update time and progress\n  const lastUpdateTime = state.lastUpdateTimes.get(taskId);\n  const task = state.activeTasks.get(taskId);\n  \n  if (!task) return;\n  \n  const lastProgress = task.progress || 0;\n  const timeDelta = now - lastUpdateTime;\n  \n  // Avoid division by zero\n  if (timeDelta <= 0) return;\n  \n  // Calculate progress rate (percent per millisecond)\n  const progressDelta = progress - lastProgress;\n  const rate = progressDelta / timeDelta;\n  \n  // Only store positive rates (progress should always increase)\n  if (rate > 0) {\n    const progressRates = state.progressRates.get(taskId);\n    \n    // Keep last N rates for moving average\n    progressRates.push(rate);\n    if (progressRates.length > MAX_PROGRESS_RATES) {\n      progressRates.shift();\n    }\n    \n    state.progressRates.set(taskId, progressRates);\n    \n    // Update task progress info for better ETA calculation\n    if (!state.taskProgressInfo.has(taskId)) {\n      state.taskProgressInfo.set(taskId, {\n        startTime: now,\n        updateCount: 1,\n        totalProgressChange: progressDelta,\n        avgProgressRate: rate\n      });\n    } else {\n      const info = state.taskProgressInfo.get(taskId);\n      info.updateCount++;\n      info.totalProgressChange += progressDelta;\n      info.avgProgressRate = info.totalProgressChange / ((now - info.startTime) || 1);\n      state.taskProgressInfo.set(taskId, info);\n    }\n  }\n  \n  // Update last update time\n  state.lastUpdateTimes.set(taskId, now);\n}\n\n// Advanced progress smoother for early progress indication\nfunction smoothProgress(taskId, reportedProgress, updateCount) {\n  // CRITICAL FIX: Direct progress return - no smoothing\n  return reportedProgress;\n}\nfunction formatBytes(bytes) {\n  if (bytes === 0) return '0 Bytes';\n  \n  const k = 1024;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  \n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n}\n\n/**\n * Create a new progress tracker\n * @param {Object} options - Progress tracker options\n * @returns {Object} Progress tracker API\n */\nfunction createProgressTracker(options = {}) {\n  const id = options.id || `progress-${++trackerIdCounter}`;\n  \n  if (activeTrackers.has(id)) {\n    console.warn(`Progress tracker with ID ${id} already exists`);\n    return activeTrackers.get(id);\n  }\n  \n  const defaults = {\n    target: null,\n    total: 100,\n    current: 0,\n    label: 'Progress',\n    showPercent: true,\n    showValue: false,\n    autoAttach: true,\n    className: '',\n    color: 'primary',\n    size: 'default',\n    onComplete: null,\n    onCreate: null,\n    onUpdate: null\n  };\n  \n  const config = { ...defaults, ...options };\n  \n  // Create progress element\n  let progressElement = null;\n  let progressBar = null;\n  let progressLabel = null;\n  let progressValue = null;\n  \n  if (config.autoAttach && config.target) {\n    progressElement = createProgressElement(config);\n  }\n  \n  // Create tracker state\n  const trackerState = {\n    id,\n    total: config.total,\n    current: config.current,\n    percent: calculatePercent(config.current, config.total),\n    label: config.label,\n    status: 'pending',\n    elements: {\n      container: progressElement,\n      bar: progressBar,\n      label: progressLabel,\n      value: progressValue\n    }\n  };\n  \n  // Create tracker API\n  const tracker = {\n    getId: () => id,\n    getState: () => ({ ...trackerState }),\n    update,\n    setTotal,\n    increment,\n    complete,\n    reset,\n    error,\n    attach,\n    detach,\n    destroy\n  };\n  \n  // Store in registry\n  activeTrackers.set(id, tracker);\n  \n  // Call onCreate callback if provided\n  if (typeof config.onCreate === 'function') {\n    config.onCreate(tracker);\n  }\n  \n  return tracker;\n  \n  /**\n   * Update progress state\n   * @param {number|Object} value - New progress value or state object\n   * @param {string} [label] - New progress label\n   * @returns {Object} Updated tracker\n   */\n  function update(value, label) {\n    // Handle object input\n    if (typeof value === 'object') {\n      if (typeof value.current === 'number') {\n        trackerState.current = Math.min(Math.max(0, value.current), trackerState.total);\n      }\n      \n      if (typeof value.total === 'number' && value.total > 0) {\n        trackerState.total = value.total;\n      }\n      \n      if (value.label) {\n        trackerState.label = value.label;\n      }\n      \n      if (value.status) {\n        trackerState.status = value.status;\n      }\n    } else if (typeof value === 'number') {\n      // Handle numeric input\n      trackerState.current = Math.min(Math.max(0, value), trackerState.total);\n    }\n    \n    // Update label if provided\n    if (typeof label === 'string') {\n      trackerState.label = label;\n    }\n    \n    // Calculate percentage\n    trackerState.percent = calculatePercent(trackerState.current, trackerState.total);\n    \n    // Update DOM if needed\n    updateProgressElement();\n    \n    // Call onUpdate callback if provided\n    if (typeof config.onUpdate === 'function') {\n      config.onUpdate(tracker);\n    }\n    \n    // Auto-complete if current reaches total\n    if (trackerState.current >= trackerState.total && trackerState.status === 'pending') {\n      complete();\n    }\n    \n    return tracker;\n  }\n  \n  /**\n   * Set the total value\n   * @param {number} total - New total value\n   * @returns {Object} Updated tracker\n   */\n  function setTotal(total) {\n    if (typeof total !== 'number' || total <= 0) {\n      console.warn('Invalid total value for progress tracker');\n      return tracker;\n    }\n    \n    trackerState.total = total;\n    trackerState.percent = calculatePercent(trackerState.current, trackerState.total);\n    \n    updateProgressElement();\n    \n    return tracker;\n  }\n  \n  /**\n   * Increment progress by a specific amount\n   * @param {number} [amount=1] - Amount to increment\n   * @param {string} [label] - New progress label\n   * @returns {Object} Updated tracker\n   */\n  function increment(amount = 1, label) {\n    return update(trackerState.current + amount, label);\n  }\n  \n  /**\n   * Mark progress as complete\n   * @returns {Object} Updated tracker\n   */\n  function complete() {\n    trackerState.current = trackerState.total;\n    trackerState.percent = 100;\n    trackerState.status = 'complete';\n    \n    updateProgressElement();\n    \n    // Call onComplete callback if provided\n    if (typeof config.onComplete === 'function') {\n      config.onComplete(tracker);\n    }\n    \n    return tracker;\n  }\n  \n  /**\n   * Reset progress to initial state\n   * @returns {Object} Updated tracker\n   */\n  function reset() {\n    trackerState.current = 0;\n    trackerState.percent = 0;\n    trackerState.status = 'pending';\n    \n    updateProgressElement();\n    \n    return tracker;\n  }\n  \n  /**\n   * Mark progress as error\n   * @param {string} [errorMessage] - Error message\n   * @returns {Object} Updated tracker\n   */\n  function error(errorMessage) {\n    trackerState.status = 'error';\n    \n    if (errorMessage) {\n      trackerState.label = errorMessage;\n    }\n    \n    updateProgressElement();\n    \n    return tracker;\n  }\n  \n  /**\n   * Attach progress tracker to a DOM element\n   * @param {string|HTMLElement} target - Target element\n   * @returns {Object} Updated tracker\n   */\n  function attach(target) {\n    const targetElement = getElement(target);\n    \n    if (!targetElement) {\n      console.warn('Invalid target element for progress tracker');\n      return tracker;\n    }\n    \n    // Detach from current element if attached\n    if (trackerState.elements.container && trackerState.elements.container.parentNode) {\n      detach();\n    }\n    \n    // Create new progress element\n    const newProgressElement = createProgressElement({\n      ...config,\n      target: targetElement\n    });\n    \n    // Update state\n    trackerState.elements.container = newProgressElement;\n    \n    return tracker;\n  }\n  \n  /**\n   * Detach progress tracker from DOM\n   * @returns {Object} Updated tracker\n   */\n  function detach() {\n    if (trackerState.elements.container && trackerState.elements.container.parentNode) {\n      trackerState.elements.container.remove();\n    }\n    \n    return tracker;\n  }\n  \n  /**\n   * Destroy progress tracker\n   */\n  function destroy() {\n    detach();\n    activeTrackers.delete(id);\n  }\n  \n  /**\n   * Create progress element\n   * @param {Object} config - Progress configuration\n   * @returns {HTMLElement} Progress element\n   */\n  function createProgressElement(config) {\n    const target = getElement(config.target);\n    \n    if (!target) {\n      return null;\n    }\n    \n    // Create container\n    const container = document.createElement('div');\n    container.className = `progress-container ${config.className}`;\n    container.setAttribute('data-progress-id', id);\n    container.setAttribute('role', 'progressbar');\n    container.setAttribute('aria-valuemin', '0');\n    container.setAttribute('aria-valuemax', trackerState.total);\n    container.setAttribute('aria-valuenow', trackerState.current);\n    \n    // Add size class if provided\n    if (config.size && config.size !== 'default') {\n      container.classList.add(`progress-${config.size}`);\n    }\n    \n    // Create label if needed\n    if (config.label) {\n      progressLabel = document.createElement('div');\n      progressLabel.className = 'progress-label';\n      progressLabel.textContent = trackerState.label;\n      container.appendChild(progressLabel);\n    }\n    \n    // Create progress track\n    const progressTrack = document.createElement('div');\n    progressTrack.className = 'progress-track';\n    \n    // Create progress bar\n    progressBar = document.createElement('div');\n    progressBar.className = `progress-bar progress-${config.color}`;\n    progressBar.style.width = `${trackerState.percent}%`;\n    progressTrack.appendChild(progressBar);\n    \n    // Create value display if needed\n    if (config.showPercent || config.showValue) {\n      progressValue = document.createElement('div');\n      progressValue.className = 'progress-value';\n      \n      if (config.showPercent) {\n        progressValue.textContent = `${trackerState.percent}%`;\n      } else if (config.showValue) {\n        progressValue.textContent = `${trackerState.current} / ${trackerState.total}`;\n      }\n      \n      progressTrack.appendChild(progressValue);\n    }\n    \n    container.appendChild(progressTrack);\n    target.appendChild(container);\n    \n    // Store references\n    trackerState.elements = {\n      container,\n      bar: progressBar,\n      label: progressLabel,\n      value: progressValue\n    };\n    \n    return container;\n  }\n  \n  /**\n   * Update progress element to reflect current state\n   */\n  function updateProgressElement() {\n    if (!trackerState.elements.container) {\n      return;\n    }\n    \n    // Update aria attributes\n    trackerState.elements.container.setAttribute('aria-valuenow', trackerState.current);\n    trackerState.elements.container.setAttribute('aria-valuemax', trackerState.total);\n    \n    // Update status class\n    trackerState.elements.container.classList.remove('progress-pending', 'progress-complete', 'progress-error');\n    trackerState.elements.container.classList.add(`progress-${trackerState.status}`);\n    \n    // Update progress bar\n    if (trackerState.elements.bar) {\n      trackerState.elements.bar.style.width = `${trackerState.percent}%`;\n    }\n    \n    // Update label\n    if (trackerState.elements.label) {\n      trackerState.elements.label.textContent = trackerState.label;\n    }\n    \n    // Update value\n    if (trackerState.elements.value) {\n      if (config.showPercent) {\n        trackerState.elements.value.textContent = `${Math.round(trackerState.percent)}%`;\n      } else if (config.showValue) {\n        trackerState.elements.value.textContent = `${trackerState.current} / ${trackerState.total}`;\n      }\n    }\n  }\n}\n\n/**\n * Calculate percentage based on current and total values\n * @param {number} current - Current value\n * @param {number} total - Total value\n * @returns {number} Percentage (0-100)\n */\nfunction calculatePercent(current, total) {\n  if (total <= 0) return 0;\n  return Math.min(100, Math.max(0, (current / total) * 100));\n}\n\n// Check if the browser is in reduced animation mode\nfunction shouldUseReducedAnimations() {\n  return window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n}\n\n// Apply animated progress update with configurable animation or instant update for reduced motion\nfunction applyProgressBarAnimation(progressBar, currentWidth, targetWidth) {\n  if (!progressBar) return;\n  \n  // Skip animation for small changes or if animations are disabled\n  const isSmallChange = Math.abs(targetWidth - currentWidth) < DEFAULT_SETTINGS.minProgressStep;\n  const shouldReduceMotion = shouldUseReducedAnimations() || !state.animation.enabled;\n  \n  if (isSmallChange || shouldReduceMotion) {\n    // Apply immediately for small changes or reduced motion\n    progressBar.style.width = `${targetWidth}%`;\n    progressBar.setAttribute('aria-valuenow', targetWidth);\n    progressBar.textContent = `${Math.round(targetWidth)}%`;\n    return;\n  }\n  \n  // Apply the animation\n  progressBar.style.transition = `width ${state.animation.duration}ms ${state.animation.easing}`;\n  progressBar.style.width = `${targetWidth}%`;\n  progressBar.setAttribute('aria-valuenow', targetWidth);\n  progressBar.textContent = `${Math.round(targetWidth)}%`;\n  \n  // Clear transition after animation completes\n  setTimeout(() => {\n    progressBar.style.transition = '';\n  }, state.animation.duration + 50);\n}\n\n// Cleanup function for removing event listeners and intervals\nfunction cleanupEventListeners(taskId) {\n  // Clean up custom event handlers for this task\n  if (state.eventHandlers.has(taskId)) {\n    const handlers = state.eventHandlers.get(taskId);\n    \n    if (handlers.socketHandlers) {\n      const socket = window.socket;\n      if (socket) {\n        // Remove Socket.IO event listeners\n        for (const [event, handler] of Object.entries(handlers.socketHandlers)) {\n          socket.off(event, handler);\n        }\n      }\n    }\n    \n    if (handlers.eventRegistry) {\n      const eventRegistry = window.eventRegistry || window.moduleInstances?.eventRegistry;\n      if (eventRegistry) {\n        // Remove event registry listeners\n        for (const [event, handler] of Object.entries(handlers.eventRegistry)) {\n          eventRegistry.off(event, handler);\n        }\n      }\n    }\n    \n    // Remove DOM event listeners\n    if (handlers.dom) {\n      for (const [selector, eventHandlers] of Object.entries(handlers.dom)) {\n        const element = document.querySelector(selector);\n        if (element) {\n          for (const [event, handler] of Object.entries(eventHandlers)) {\n            element.removeEventListener(event, handler);\n          }\n        }\n      }\n    }\n    \n    // Remove the handlers from the map\n    state.eventHandlers.delete(taskId);\n  }\n}\n\n/**\n * Enhanced notification system with 4-method delivery\n * @param {string} message - Notification message\n * @param {string} type - Type of notification (info, success, warning, error)\n * @param {string} title - Notification title\n */\nfunction showNotification(message, type = 'info', title = 'Progress Handler') {\n  // Method 1: Toast notifications\n  if (window.NeuroGen?.ui?.showToast) {\n    window.NeuroGen.ui.showToast(title, message, type);\n  }\n  \n  // Method 2: Console logging with styling\n  const styles = {\n    error: 'color: #dc3545; font-weight: bold;',\n    warning: 'color: #fd7e14; font-weight: bold;',\n    success: 'color: #198754; font-weight: bold;',\n    info: 'color: #0d6efd;'\n  };\n  console.log(`%c[${title}] ${message}`, styles[type] || styles.info);\n  \n  // Method 3: System notification (if available)\n  if (window.NeuroGen?.notificationHandler) {\n    window.NeuroGen.notificationHandler.show({\n      title, message, type, module: 'progressHandler'\n    });\n  }\n  \n  // Method 4: Error reporting to centralized handler\n  if (type === 'error' && window.NeuroGen?.errorHandler) {\n    window.NeuroGen.errorHandler.logError({\n      module: 'progressHandler', message, severity: type\n    });\n  }\n}\n\n/**\n * Test backend connectivity for progress handler\n * @returns {Promise<Object>} Backend connectivity status\n */\nasync function testBackendConnectivity() {\n  const results = {\n    overall: false,\n    details: {},\n    timestamp: new Date().toISOString(),\n    errors: []\n  };\n\n  try {\n    // Test main health endpoint\n    const healthResponse = await fetch(PROGRESS_CONFIG.endpoints.health, {\n      method: 'GET',\n      headers: { 'Content-Type': 'application/json' }\n    });\n\n    results.details.health = {\n      status: healthResponse.status,\n      ok: healthResponse.ok,\n      endpoint: PROGRESS_CONFIG.endpoints.health\n    };\n\n    if (healthResponse.ok) {\n      results.overall = true;\n      showNotification('Backend connectivity verified', 'success', 'Progress Handler');\n    } else {\n      throw new Error(`Health endpoint returned ${healthResponse.status}`);\n    }\n\n  } catch (error) {\n    results.errors.push({\n      endpoint: PROGRESS_CONFIG.endpoints.health,\n      error: error.message\n    });\n    showNotification(`Backend connectivity failed: ${error.message}`, 'error', 'Progress Handler');\n  }\n\n  return results;\n}\n\n/**\n * Get progress handler health status\n * @returns {Object} Health status information\n */\nfunction getHealthStatus() {\n  return {\n    module: 'progressHandler',\n    version: '4.0.0',\n    status: state.initialized ? 'healthy' : 'initializing',\n    features: {\n      configurationDriven: true,\n      enhancedNotifications: true,\n      backendConnectivity: true,\n      taskTracking: true,\n      socketIntegration: true\n    },\n    configuration: {\n      endpoints: PROGRESS_CONFIG.endpoints,\n      eventsConfigured: Object.keys(PROGRESS_CONFIG.events).length,\n      apiConfigAvailable: !!PROGRESS_CONFIG.api,\n      socketConfigAvailable: !!PROGRESS_CONFIG.socket\n    },\n    statistics: {\n      activeTasks: state.activeTasks.size,\n      completedTasks: state.completedTasks.length,\n      failedTasks: state.failedTasks.length,\n      activeTrackers: activeTrackers.size,\n      connected: state.connectionState.connected\n    }\n  };\n}\n\n/**\n * Initialize progress handler with enhanced Blueprint architecture integration\n * @param {Object} options - Global configuration options\n * @returns {Object} Progress handler API\n */\nfunction initProgressHandler(options = {}) {\n  const globalOptions = { ...options };\n  \n  // Initialize the module state if not already initialized\n  if (!state.initialized) {\n    showNotification('Initializing Progress Handler v4.0', 'info', 'Progress Handler');\n    \n    // Test backend connectivity on initialization\n    testBackendConnectivity().then(result => {\n      if (result.overall) {\n        showNotification('Backend connectivity verified', 'success', 'Progress Handler');\n      }\n    });\n    \n    // Add global styles for progress animations\n    addProgressStyles();\n    \n    // Set up task monitoring\n    setupTaskMonitoring();\n    \n    // Set up connection monitoring if socket is available\n    if (window.socket) {\n      setupConnectionMonitoring();\n    }\n    \n    // Load task history from storage\n    loadTaskHistory();\n    \n    // Mark as initialized\n    state.initialized = true;\n    \n    showNotification('Progress Handler v4.0 initialized successfully', 'success', 'Progress Handler');\n  }\n  \n  return {\n    createTracker: (options) => createProgressTracker({ ...globalOptions, ...options }),\n    getTracker: (id) => activeTrackers.get(id) || null,\n    getAllTrackers: () => Array.from(activeTrackers.values()),\n    destroyTracker: (id) => {\n      const tracker = activeTrackers.get(id);\n      if (tracker) {\n        tracker.destroy();\n        return true;\n      }\n      return false;\n    },\n    destroyAllTrackers: () => {\n      activeTrackers.forEach(tracker => tracker.destroy());\n      activeTrackers.clear();\n    },\n    setupTaskProgress,\n    trackProgress,\n    updateTaskProgress,\n    updateProgressUI,\n    completeTask,\n    errorTask,\n    cancelTask,\n    createProgressUI,\n    formatDuration,\n    calculateETA,\n    formatBytes,\n    isConnected: () => state.connectionState.connected,\n    getServerVersion: () => state.connectionState.serverVersion,\n    getActiveTaskIds: () => Array.from(state.activeTasks.keys()),\n    getTaskDetails,\n    getActiveTaskCount: () => state.activeTasks.size,\n    getCompletedTasks: () => state.completedTasks,\n    getFailedTasks: () => state.failedTasks,\n    clearTaskHistory,\n    forceResetTask,\n    resetAllState,\n    setAnimationsEnabled: (enabled) => { state.animation.enabled = !!enabled; },\n    getAverageLatency: () => {\n      const latencyHistory = state.connectionState.latencyHistory;\n      if (latencyHistory.length === 0) return 0;\n      \n      const sum = latencyHistory.reduce((acc, val) => acc + val, 0);\n      return sum / latencyHistory.length;\n    },\n    reconnect: () => {\n      if (window.socket) {\n        console.log(\"Manually reconnecting to server...\");\n        \n        // Disconnect first if connected\n        if (window.socket.connected) {\n          window.socket.disconnect();\n        }\n        \n        // Reconnect\n        window.socket.connect();\n      }\n    },\n    disconnect: () => {\n      if (window.socket && window.socket.connected) {\n        console.log(\"Manually disconnecting from server...\");\n        window.socket.disconnect();\n      }\n    },\n    // Add cancelTracking function\n    cancelTracking,\n    // New v4.0 methods for Blueprint architecture integration\n    showNotification,\n    testBackendConnectivity,\n    getHealthStatus\n  };\n}\n\n/**\n * Add global CSS styles for progress animations\n */\nfunction addProgressStyles() {\n  // Skip if styles are already added\n  if (document.getElementById('progress-handler-styles')) return;\n  \n  const style = document.createElement('style');\n  style.id = 'progress-handler-styles';\n  style.textContent = `\n    /* Enhanced progress bar styling */\n    .progress-bar {\n      transition: width 0.4s ease-out;\n    }\n    \n    /* Pulse animation for low progress */\n    @keyframes progressPulse {\n      0% { opacity: 0.7; }\n      50% { opacity: 1; }\n      100% { opacity: 0.7; }\n    }\n    \n    .progress-bar-low {\n      animation: progressPulse 2s infinite;\n    }\n    \n    /* Success animation for completion */\n    @keyframes progressComplete {\n      0% { background-color: #28a745; }\n      50% { background-color: #1d9a39; }\n      100% { background-color: #28a745; }\n    }\n    \n    .progress-bar-complete {\n      animation: progressComplete 1.5s ease-in-out;\n    }\n    \n    /* Error styling */\n    .progress-bar-error {\n      background-color: #dc3545 !important;\n    }\n    \n    /* Stuck progress warning */\n    .progress-stuck-warning {\n      color: #ffc107;\n      font-style: italic;\n      font-size: 0.9em;\n      margin-top: 0.25rem;\n    }\n    \n    /* ETA display */\n    .eta-display, .elapsed-time {\n      font-size: 0.85em;\n      color: #6c757d;\n      margin-top: 0.25rem;\n    }\n    \n    /* Progress stats container */\n    .progress-stats {\n      padding: 0.75rem;\n      margin-top: 0.5rem;\n      border-radius: 0.25rem;\n      background-color: rgba(0,0,0,0.03);\n      border: 1px solid rgba(0,0,0,0.08);\n    }\n    \n    /* Dark mode adjustments */\n    .dark-theme .progress-stats {\n      background-color: rgba(255,255,255,0.05);\n      border-color: rgba(255,255,255,0.1);\n    }\n    \n    /* Connection status indicator */\n    .connection-status {\n      display: inline-block;\n      width: 10px;\n      height: 10px;\n      border-radius: 50%;\n      margin-right: 5px;\n    }\n    \n    .connection-status.connected {\n      background-color: #28a745;\n    }\n    \n    .connection-status.disconnected {\n      background-color: #dc3545;\n    }\n    \n    /* PDF download progress styling */\n    .pdf-download-item {\n      padding: 0.5rem;\n      margin-bottom: 0.5rem;\n      border: 1px solid rgba(0,0,0,0.1);\n      border-radius: 0.25rem;\n    }\n    \n    .pdf-download-item .progress {\n      height: 4px;\n      margin-top: 0.25rem;\n    }\n  `;\n  \n  document.head.appendChild(style);\n  console.log(\"Added progress styles to document\");\n}\n\n/**\n * Set up monitoring for connection state\n */\nfunction setupConnectionMonitoring() {\n  if (!window.socket) {\n    console.warn(\"Socket.IO not available for connection monitoring\");\n    return;\n  }\n  \n  // Listen for connect event\n  window.socket.on('connect', () => {\n    state.connectionState.connected = true;\n    state.connectionState.lastConnectedAt = getTimestamp();\n    state.connectionState.connectionAttempts = 0;\n    console.log(\"Socket.IO connected\");\n    \n    // Request status for all active tasks\n    for (const taskId of state.activeTasks.keys()) {\n      requestTaskStatus(taskId);\n    }\n    \n    // Update UI indicators\n    updateConnectionUI(true);\n  });\n  \n  // Listen for disconnect event\n  window.socket.on('disconnect', (reason) => {\n    state.connectionState.connected = false;\n    state.connectionState.disconnectedAt = getTimestamp();\n    console.warn(`Socket.IO disconnected: ${reason}`);\n    \n    // Start polling for all active tasks\n    for (const taskId of state.activeTasks.keys()) {\n      startManualStatusPolling(taskId);\n    }\n    \n    // Update UI indicators\n    updateConnectionUI(false);\n  });\n  \n  // Listen for connection error\n  window.socket.on('connect_error', (error) => {\n    state.connectionState.connected = false;\n    console.error(`Socket.IO connection error: ${error.message}`);\n    \n    // Increment connection attempts\n    state.connectionState.connectionAttempts++;\n    \n    // Update UI indicators\n    updateConnectionUI(false);\n  });\n  \n  // Listen for connection established event (custom event from server)\n  window.socket.on('connection_established', (data) => {\n    // Store server version\n    state.connectionState.serverVersion = data.server_version;\n    \n    // Update connection state\n    state.connectionState.connected = true;\n    state.connectionState.lastConnectedAt = getTimestamp();\n    \n    console.log(`Connection established with server version ${data.server_version}`);\n    \n    // Update UI indicators\n    updateConnectionUI(true);\n  });\n  \n  // Listen for pong events for latency measurements\n  window.socket.on('pong_to_client', (data) => {\n    if (data && data.client_server_diff) {\n      // Store latency measurement (convert seconds to milliseconds)\n      const latency = data.client_server_diff * 1000;\n      \n      // Add to latency history\n      state.connectionState.latencyHistory.push(latency);\n      \n      // Keep only the most recent measurements\n      if (state.connectionState.latencyHistory.length > state.connectionState.maxLatencyEntries) {\n        state.connectionState.latencyHistory.shift();\n      }\n    }\n  });\n  \n  // Start ping interval for latency measurements\n  startPingInterval();\n}\n\n/**\n * Update connection UI indicators\n * @param {boolean} connected - Connection status\n */\nfunction updateConnectionUI(connected) {\n  // Update all connection status indicators\n  const indicators = document.querySelectorAll('.connection-status');\n  indicators.forEach(indicator => {\n    indicator.classList.toggle('connected', connected);\n    indicator.classList.toggle('disconnected', !connected);\n  });\n  \n  // Update all connection status text elements\n  const statusTexts = document.querySelectorAll('[id$=\"connection-status\"]');\n  statusTexts.forEach(text => {\n    text.textContent = connected ? 'Connected to server' : 'Disconnected';\n    text.classList.toggle('text-success', connected);\n    text.classList.toggle('text-danger', !connected);\n  });\n}\n\n/**\n * Start ping interval for latency measurements\n */\nfunction startPingInterval() {\n  // Clear any existing interval\n  if (window._pingInterval) {\n    clearInterval(window._pingInterval);\n  }\n  \n  // Create new interval\n  window._pingInterval = setInterval(() => {\n    // Skip if not connected\n    if (!window.socket || !state.connectionState.connected) return;\n    \n    // Send ping to server\n    window.socket.emit('ping_from_client', {\n      client_timestamp: Date.now() / 1000,\n      client_info: {\n        user_agent: navigator.userAgent,\n        url: window.location.href\n      }\n    });\n  }, DEFAULT_SETTINGS.pingInterval);\n}\n\n/**\n * Setup task monitoring for stuck tasks and phantom completions\n */\nfunction setupTaskMonitoring() {\n  // Set up a timer to monitor for stuck tasks\n  setInterval(() => {\n    const now = getTimestamp();\n    \n    // Check each active task for stuck state\n    for (const [taskId, task] of state.activeTasks.entries()) {\n      if (state.completedTaskIds.has(taskId)) continue;\n      \n      const lastUpdate = state.lastUpdateTimes.get(taskId) || task.startTime;\n      const timeSinceUpdate = now - lastUpdate;\n      \n      // If no updates for 30 seconds (stuckDetectionTime) and progress is neither\n      // very low nor very high, it might be stuck\n      if (timeSinceUpdate > DEFAULT_SETTINGS.stuckDetectionTime &&\n          task.progress > 10 && task.progress < 95) {\n        \n        console.warn(`Task ${taskId} appears stuck at ${task.progress}% with no updates for ${Math.round(timeSinceUpdate/1000)}s`);\n        \n        // Add visual warning \n        const elements = getUIElements(task.elementPrefix);\n        if (elements.progressStatus) {\n          // Add warning indicator to status message\n          const warningNode = document.createElement('div');\n          warningNode.className = 'progress-stuck-warning';\n          warningNode.innerHTML = '<i class=\"fas fa-exclamation-triangle\"></i> Progress may be stuck, checking status...';\n          \n          // Only add if not already present\n          if (!elements.progressStatus.querySelector('.progress-stuck-warning')) {\n            elements.progressStatus.appendChild(warningNode);\n          }\n        }\n        \n        // Request a fresh status update\n        requestTaskStatus(taskId);\n      }\n      \n      // Check for high progress potential completion\n      if (task.progress >= 95 && !state.completedTaskIds.has(taskId)) {\n        // Task has high progress but hasn't been marked complete, it may\n        // be finished but missed the completion event\n        const taskInfo = state.taskProgressInfo.get(taskId);\n        \n        if (taskInfo && now - taskInfo.startTime > 3 * 60 * 1000) { // 3 minutes\n          console.log(`Task ${taskId} has been at high progress (${task.progress}%) for a long time, checking completion status`);\n          \n          // Make a direct API call to check status\n          checkTaskCompletion(taskId);\n        }\n      }\n    }\n  }, 30000); // Check every 30 seconds\n}\n\n/**\n * Make a direct API call to check if a task is complete\n * @param {string} taskId - Task ID to check\n */\nasync function checkTaskCompletion(taskId) {\n  try {\n    // Fallback to direct API call\n    const response = await fetch(`/api/status/${taskId}`);\n    if (!response.ok) return;\n    \n    const data = await response.json();\n    \n    if (data.status === 'completed' || data.progress >= 100) {\n      console.log(`Task ${taskId} found to be complete via API check`);\n      // Mark as completed\n      if (!state.completedTaskIds.has(taskId)) {\n        completeTask(taskId, data);\n      }\n    }\n  } catch (error) {\n    console.error(`Error checking task completion status for ${taskId}:`, error);\n  }\n}\n\n/**\n * Request task status update\n * @param {string} taskId - Task ID to request status for\n */\nfunction requestTaskStatus(taskId) {\n  // Skip if task doesn't exist\n  if (!state.activeTasks.has(taskId)) return;\n  \n  // Try direct Socket.IO if available\n  if (window.socket && state.connectionState.connected) {\n    window.socket.emit('request_task_status', {\n      task_id: taskId,\n      timestamp: Date.now() / 1000\n    });\n    return;\n  }\n  \n  // Fallback: start manual polling if socket not available\n  if (!state.statusPollingIntervals.has(taskId)) {\n    startManualStatusPolling(taskId);\n  }\n}\n\n/**\n * Start manual polling for task status when socket is unavailable\n * @param {string} taskId - The task ID to poll for\n */\nfunction startManualStatusPolling(taskId) {\n  try {\n    // Clear any existing interval\n    if (state.statusPollingIntervals.has(taskId)) {\n      clearInterval(state.statusPollingIntervals.get(taskId));\n    }\n    \n    // Create a new polling interval\n    const intervalId = setInterval(async () => {\n      if (!state.activeTasks.has(taskId)) {\n        // Task no longer active, stop polling\n        clearInterval(intervalId);\n        state.statusPollingIntervals.delete(taskId);\n        return;\n      }\n      \n      // Skip polling if socket is now connected\n      if (window.socket && state.connectionState.connected) {\n        // Try to send a socket request instead\n        window.socket.emit('request_task_status', {\n          task_id: taskId,\n          timestamp: Date.now() / 1000\n        });\n        \n        // Keep poll running in case socket disconnects again\n        return;\n      }\n      \n      // Make API request to get task status\n      try {\n        const response = await fetch(`/api/status/${taskId}`);\n        \n        if (response.ok) {\n          const data = await response.json();\n          \n          // Process the status update\n          if (data.progress !== undefined) {\n            updateTaskProgress(taskId, data.progress, data.message, data.stats);\n          }\n          \n          // Check for completion states\n          if (data.status === \"completed\" || data.progress >= 100) {\n            completeTask(taskId, data);\n            \n            // Stop polling for this task\n            clearInterval(intervalId);\n            state.statusPollingIntervals.delete(taskId);\n          } else if (data.status === \"error\" || data.status === \"failed\") {\n            errorTask(taskId, data.error || \"Unknown error\", data);\n            \n            // Stop polling for this task\n            clearInterval(intervalId);\n            state.statusPollingIntervals.delete(taskId);\n          } else if (data.status === \"cancelled\") {\n            cancelTask(taskId);\n            \n            // Stop polling for this task\n            clearInterval(intervalId);\n            state.statusPollingIntervals.delete(taskId);\n          }\n        } else {\n          console.warn(`Failed to get status for task ${taskId}: ${response.status}`);\n          \n          // Track consecutive failures\n          const failures = state.pollingMetadata.consecutiveFailures.get(taskId) || 0;\n          state.pollingMetadata.consecutiveFailures.set(taskId, failures + 1);\n          \n          // After multiple failures, stop polling\n          if (failures + 1 >= state.pollingMetadata.maxConsecutiveFailures) {\n            console.error(`Too many failed polls for task ${taskId}, stopping status polling`);\n            clearInterval(intervalId);\n            state.statusPollingIntervals.delete(taskId);\n            \n            // Flag the polling as failed in the task data\n            const task = state.activeTasks.get(taskId);\n            if (task) {\n              task.pollingFailed = true;\n              task.message = \"Lost connection to server\";\n              state.activeTasks.set(taskId, task);\n              \n              // Update UI to show the error\n              updateTaskProgress(taskId, task.progress, task.message, task.stats);\n            }\n          }\n        }\n      } catch (error) {\n        console.error(`Error polling for task ${taskId} status:`, error);\n      }\n    }, DEFAULT_SETTINGS.pollInterval);\n    \n    // Store the interval ID\n    state.statusPollingIntervals.set(taskId, intervalId);\n    \n    console.log(`Started manual status polling for task ${taskId}`);\n  } catch (error) {\n    console.error(\"Error starting manual status polling:\", error);\n  }\n}\n\n/**\n * Stop polling for task status\n * @param {string} taskId - The task ID to stop polling for\n */\nfunction stopStatusPolling(taskId) {\n  try {\n    // Clear the polling interval\n    if (state.statusPollingIntervals.has(taskId)) {\n      clearInterval(state.statusPollingIntervals.get(taskId));\n      state.statusPollingIntervals.delete(taskId);\n      console.log(`Stopped status polling for task ${taskId}`);\n    }\n  } catch (error) {\n    console.error(\"Error stopping status polling:\", error);\n  }\n}\n\n/**\n * Load task history from storage\n */\nfunction loadTaskHistory() {\n  try {\n    // Try to load completed tasks from localStorage\n    const completedTasksJson = localStorage.getItem('progressHandler.completedTasks');\n    if (completedTasksJson) {\n      const completedTasks = JSON.parse(completedTasksJson);\n      state.completedTasks = completedTasks.slice(0, DEFAULT_SETTINGS.maxHistoryItems);\n    }\n    \n    // Try to load failed tasks from localStorage\n    const failedTasksJson = localStorage.getItem('progressHandler.failedTasks');\n    if (failedTasksJson) {\n      const failedTasks = JSON.parse(failedTasksJson);\n      state.failedTasks = failedTasks.slice(0, DEFAULT_SETTINGS.maxHistoryItems);\n    }\n  } catch (error) {\n    console.error(\"Error loading task history:\", error);\n  }\n}\n\n/**\n * Save task history to storage\n */\nfunction saveTaskHistory() {\n  try {\n    // Save completed tasks to localStorage\n    localStorage.setItem('progressHandler.completedTasks', JSON.stringify(state.completedTasks));\n    \n    // Save failed tasks to localStorage\n    localStorage.setItem('progressHandler.failedTasks', JSON.stringify(state.failedTasks));\n  } catch (error) {\n    console.error(\"Error saving task history:\", error);\n  }\n}\n\n/**\n * Add a task to history\n * @param {string} taskId - The task ID\n * @param {Object} data - Task data\n * @param {string} status - Task status ('completed', 'error', 'cancelled')\n */\nfunction addTaskToHistory(taskId, data, status) {\n  try {\n    const task = state.activeTasks.get(taskId);\n    if (!task) return;\n    \n    // Create history entry\n    const historyEntry = {\n      id: taskId,\n      type: task.type || 'unknown',\n      status: status,\n      startTime: task.startTime,\n      endTime: getTimestamp(),\n      duration: getTimestamp() - task.startTime,\n      result: data || {}\n    };\n    \n    // Add to appropriate history list\n    if (status === 'completed') {\n      state.completedTasks.unshift(historyEntry);\n      \n      // Limit history size\n      if (state.completedTasks.length > DEFAULT_SETTINGS.maxHistoryItems) {\n        state.completedTasks.pop();\n      }\n    } else if (status === 'error' || status === 'cancelled') {\n      state.failedTasks.unshift(historyEntry);\n      \n      // Limit history size\n      if (state.failedTasks.length > DEFAULT_SETTINGS.maxHistoryItems) {\n        state.failedTasks.pop();\n      }\n    }\n    \n    // Save history to storage\n    saveTaskHistory();\n  } catch (error) {\n    console.error(\"Error adding task to history:\", error);\n  }\n}\n\n/**\n * Extract a filename from a path\n * @param {string} path - File path\n * @returns {string} Filename\n */\nfunction getFileNameFromPath(path) {\n  if (!path) return 'Unknown';\n  \n  // Handle both Windows and Unix paths\n  const parts = path.split(/[\\/\\\\]/);\n  return parts[parts.length - 1] || 'Unknown';\n}\n\n/**\n * Create progress UI elements in a container\n * @param {string} containerId - Container ID\n * @param {string} elementPrefix - Prefix for elements\n * @returns {Object} - Created UI elements\n */\nfunction createProgressUI(containerId, elementPrefix = '') {\n  const container = document.getElementById(containerId);\n  if (!container) {\n    console.error(`Container not found: ${containerId}`);\n    return null;\n  }\n  \n  // Create prefix for element IDs\n  const prefix = elementPrefix ? `${elementPrefix}-` : '';\n  \n  // Create progress UI HTML\n  container.innerHTML = `\n    <div class=\"progress-wrapper mb-3\">\n      <div class=\"progress\" style=\"height: 20px\">\n        <div id=\"${prefix}progress-bar\" class=\"progress-bar bg-primary\" \n            role=\"progressbar\" style=\"width: 0%\" aria-valuenow=\"0\" \n            aria-valuemin=\"0\" aria-valuemax=\"100\">0%</div>\n      </div>\n      <div class=\"mt-2 d-flex justify-content-between align-items-center\">\n        <div id=\"${prefix}progress-status\" class=\"text-muted\">Initializing...</div>\n        <!-- Removed duplicate percentage display - progress bar already shows percentage -->\n      </div>\n      <div class=\"d-flex justify-content-between align-items-center mt-1\">\n        <div id=\"${prefix}elapsed-time\" class=\"small text-muted elapsed-time\">Elapsed: 0s</div>\n        <div id=\"${prefix}eta-display\" class=\"small text-muted eta-display d-none\">ETA: calculating...</div>\n      </div>\n      <div id=\"${prefix}progress-rate\" class=\"small text-muted progress-rate d-none\"></div>\n    </div>\n    <div id=\"${prefix}progress-stats\" class=\"progress-stats mb-3\">\n      <div class=\"text-center py-2\">\n        <div class=\"spinner-border spinner-border-sm text-primary\" role=\"status\"></div>\n        <span>Initializing task...</span>\n      </div>\n    </div>\n    \n    <div class=\"connection-info small text-muted mb-3\">\n      <div class=\"d-flex align-items-center\">\n        <span class=\"connection-status ${state.connectionState.connected ? 'connected' : 'disconnected'}\"></span>\n        <span id=\"${prefix}connection-status\">${state.connectionState.connected ? 'Connected to server' : 'Disconnected'}</span>\n      </div>\n    </div>\n  `;\n  \n  // Get the elements\n  const elements = {\n    progressBar: document.getElementById(`${prefix}progress-bar`),\n    progressStatus: document.getElementById(`${prefix}progress-status`),\n    progressStats: document.getElementById(`${prefix}progress-stats`),\n    // progressPercentage removed - using progress bar text instead\n    etaDisplay: document.getElementById(`${prefix}eta-display`),\n    elapsedTime: document.getElementById(`${prefix}elapsed-time`),\n    progressRateDisplay: document.getElementById(`${prefix}progress-rate`),\n    connectionStatus: document.getElementById(`${prefix}connection-status`)\n  };\n  \n  return elements;\n}\n\n/**\n * Format statistic value based on key\n * @param {string} key - Statistic key\n * @param {any} value - Statistic value\n * @returns {string} - Formatted value\n */\nfunction formatStatValue(key, value) {\n  // Handle bytes\n  if (key.includes('bytes') || key === 'total_bytes' || key.endsWith('_size')) {\n    return formatBytes(value);\n  }\n\n  // Handle durations\n  if (key.includes('duration') || key.includes('time') || key.endsWith('_seconds')) {\n    return formatDuration(value * 1000); // Convert seconds to milliseconds\n  }\n\n  // Handle percentages\n  if (key.includes('percent') || key.includes('progress')) {\n    return `${Math.round(value)}%`;\n  }\n\n  // Handle rates\n  if (key.includes('rate') || key.includes('speed')) {\n    return `${value}/s`;\n  }\n\n  // Default formatting\n  return value.toString();\n}\n\n/**\n * Format statistic label\n * @param {string} key - Statistic key\n * @returns {string} - Formatted label\n */\nfunction formatStatLabel(key) {\n  // Replace underscores with spaces and capitalize first letter of each word\n  return key\n    .replace(/_/g, ' ')\n    .replace(/\\b\\w/g, c => c.toUpperCase());\n}\n\n/**\n * Update stats display\n * @param {HTMLElement} element - Stats container element\n * @param {Object} stats - Statistics object\n */\nfunction updateStatsDisplay(element, stats) {\n  if (!element || !stats) return;\n\n  try {\n    // Create a formatted display of the stats\n    let html = '<div class=\"stats-container p-2\">';\n    \n    // Handle different types of stats\n    if (stats.total_files !== undefined) {\n      // File processing stats\n      html += `\n        <div class=\"row\">\n          <div class=\"col-md-6 mb-2\">\n            <span class=\"badge bg-primary\">Files: ${stats.total_files || 0}</span>\n            <span class=\"badge bg-success mx-1\">Processed: ${stats.processed_files || 0}</span>\n            <span class=\"badge bg-warning mx-1\">Skipped: ${stats.skipped_files || 0}</span>\n            <span class=\"badge bg-danger mx-1\">Errors: ${stats.error_files || 0}</span>\n          </div>\n          <div class=\"col-md-6 mb-2\">\n            <span class=\"badge bg-info\">Chunks: ${stats.total_chunks || 0}</span>\n            ${stats.total_bytes ? `<span class=\"badge bg-secondary mx-1\">Size: ${formatBytes(stats.total_bytes)}</span>` : ''}\n          </div>\n        </div>\n      `;\n      \n      // Show duration if available\n      if (stats.duration_seconds || stats.total_duration_seconds) {\n        const duration = stats.duration_seconds || stats.total_duration_seconds || 0;\n        html += `<div class=\"small text-muted\">Duration: ${formatDuration(duration * 1000)}</div>`;\n      }\n      \n      // Add current file if available\n      if (stats.current_file) {\n        html += `\n          <div class=\"text-truncate small mt-2 current-file\">\n            <i class=\"fas fa-file-alt me-1\"></i> ${stats.current_file}\n          </div>\n        `;\n      }\n    } else if (stats.pdf_downloads && Array.isArray(stats.pdf_downloads)) {\n      // PDF download stats\n      const completed = stats.pdf_downloads.filter(pdf => pdf.status === 'success').length;\n      const downloading = stats.pdf_downloads.filter(pdf => pdf.status === 'downloading').length;\n      const processing = stats.pdf_downloads.filter(pdf => pdf.status === 'processing').length;\n      const failed = stats.pdf_downloads.filter(pdf => pdf.status === 'error').length;\n      const total = stats.pdf_downloads.length;\n      \n      html += `\n        <div class=\"row\">\n          <div class=\"col-12 mb-2\">\n            <span class=\"badge bg-primary\">PDFs: ${total}</span>\n            <span class=\"badge bg-success mx-1\">Downloaded: ${completed}</span>\n            <span class=\"badge bg-info mx-1\">Downloading: ${downloading}</span>\n            <span class=\"badge bg-secondary mx-1\">Processing: ${processing}</span>\n            <span class=\"badge bg-danger mx-1\">Failed: ${failed}</span>\n          </div>\n        </div>\n      `;\n      \n      // Add the most recent 3 PDFs being processed\n      const recentPdfs = stats.pdf_downloads\n        .filter(pdf => pdf.status === 'downloading' || pdf.status === 'processing')\n        .slice(0, 3);\n      \n      if (recentPdfs.length > 0) {\n        html += '<div class=\"pdf-list small\">';\n        recentPdfs.forEach(pdf => {\n          const fileName = pdf.fileName || getFileNameFromPath(pdf.url || '');\n          html += `\n            <div class=\"pdf-download-item\">\n              <div class=\"d-flex justify-content-between\">\n                <div class=\"text-truncate\" title=\"${fileName}\">\n                  <i class=\"fas fa-file-pdf me-1\"></i> ${fileName}\n                </div>\n                <span class=\"badge ${pdf.status === 'downloading' ? 'bg-info' : 'bg-secondary'}\">${pdf.status}</span>\n              </div>\n              ${pdf.progress ? `<div class=\"progress\">\n                <div class=\"progress-bar ${pdf.status === 'downloading' ? 'bg-info' : 'bg-secondary'}\" style=\"width: ${pdf.progress}%\"></div>\n              </div>` : ''}\n            </div>\n          `;\n        });\n        html += '</div>';\n      }\n      \n      // Show summary of completed PDFs\n      if (completed > 0) {\n        html += `<div class=\"text-muted small mt-2\">Completed PDFs: ${completed} files</div>`;\n      }\n    } else if (stats.tables_extracted !== undefined || stats.pdf_pages_processed !== undefined) {\n      // PDF processing stats\n      html += `<div class=\"row\">`;\n      \n      // PDF document info\n      if (stats.pdf_scanned_count !== undefined || stats.document_type !== undefined) {\n        html += `<div class=\"col-12 mb-2\">\n          ${stats.document_type ? `<span class=\"badge bg-info\">Type: ${stats.document_type}</span> ` : ''}\n          ${stats.pdf_pages_processed ? `<span class=\"badge bg-primary mx-1\">Pages: ${stats.pdf_pages_processed}</span>` : ''}\n          ${stats.pdf_ocr_applied_count > 0 ? `<span class=\"badge bg-warning mx-1\">OCR Applied</span>` : ''}\n          ${stats.pdf_scanned_count > 0 ? `<span class=\"badge bg-secondary mx-1\">Scanned</span>` : ''}\n        </div>`;\n      }\n      \n      // Extraction stats\n      html += `<div class=\"col-12 mb-2\">\n        ${stats.tables_extracted ? `<span class=\"badge bg-success\">Tables: ${stats.tables_extracted}</span> ` : ''}\n        ${stats.references_extracted ? `<span class=\"badge bg-primary mx-1\">References: ${stats.references_extracted}</span>` : ''}\n        ${stats.total_extraction_time ? `<span class=\"badge bg-info mx-1\">Extract Time: ${formatDuration(stats.total_extraction_time * 1000)}</span>` : ''}\n      </div>`;\n      \n      html += `</div>`;\n      \n      // Show specific stage progress if available\n      if (stats.stage) {\n        html += `<div class=\"small text-muted mt-2\">Current stage: ${stats.stage}</div>`;\n      }\n    } else {\n      // Generic stats - display key-value pairs\n      html += '<div class=\"row\">';\n      \n      // Process stats keys, show the most important ones first\n      const priorityKeys = ['total_files', 'processed_files', 'total_chunks', 'total_bytes', 'duration_seconds'];\n      const processedKeys = new Set();\n      \n      // First show priority keys\n      priorityKeys.forEach(key => {\n        if (stats[key] !== undefined) {\n          const value = formatStatValue(key, stats[key]);\n          const label = formatStatLabel(key);\n          \n          html += `\n            <div class=\"col-6 col-md-4 mb-1\">\n              <small>${label}:</small>\n              <span class=\"fw-bold\">${value}</span>\n            </div>\n          `;\n          \n          processedKeys.add(key);\n        }\n      });\n      \n      // Then show remaining keys\n      Object.entries(stats).forEach(([key, value]) => {\n        // Skip already processed keys, hidden keys, and complex objects\n        if (processedKeys.has(key) || key.startsWith('_') || key.startsWith('hidden_') || \n            typeof value === 'object' || typeof value === 'function') {\n          return;\n        }\n        \n        const formattedValue = formatStatValue(key, value);\n        const label = formatStatLabel(key);\n        \n        html += `\n          <div class=\"col-6 col-md-4 mb-1\">\n            <small>${label}:</small>\n            <span class=\"fw-bold\">${formattedValue}</span>\n          </div>\n        `;\n        \n        processedKeys.add(key);\n      });\n      \n      html += '</div>';\n    }\n    \n    html += '</div>';\n    \n    // Update the element\n    element.innerHTML = html;\n  } catch (error) {\n    console.error(\"Error updating stats display:\", error);\n    // Provide simple fallback\n    try {\n      element.innerHTML = '<div class=\"alert alert-warning\">Error displaying stats</div>';\n    } catch (e) {\n      // Ignore if can't even update with error message\n    }\n  }\n}\n\n/**\n * Set up progress tracking for a task\n * @param {string} taskId - Unique task ID\n * @param {Object} options - Setup options\n * @param {string} options.elementPrefix - Prefix for DOM elements\n * @param {boolean} options.saveToSessionStorage - Whether to save task info to session storage\n * @param {string} options.taskType - Type of task (for session storage)\n * @returns {Object} - Progress handler APIs\n */\nfunction setupTaskProgress(taskId, options = {}) {\n  if (!taskId) {\n    console.error('Task ID required for progress tracking');\n    return null;\n  }\n  \n  console.log(`Setting up progress tracking for task ${taskId}`);\n  \n  // Create task info\n  const taskInfo = {\n    id: taskId,\n    progress: 0,\n    status: 'pending',\n    startTime: getTimestamp(),\n    elementPrefix: options.elementPrefix || '',\n    type: options.taskType || 'unknown',\n    options\n  };\n  \n  // Save to active tasks map\n  state.activeTasks.set(taskId, taskInfo);\n  \n  // Save to session storage if requested\n  if (options.saveToSessionStorage && options.taskType) {\n    sessionStorage.setItem('ongoingTaskId', taskId);\n    sessionStorage.setItem('ongoingTaskType', options.taskType);\n    sessionStorage.setItem('taskStartTime', taskInfo.startTime.toString());\n    console.log(`Saved task ${taskId} (${options.taskType}) to session storage`);\n  }\n  \n  // Try to set up initial UI elements\n  const elements = getUIElements(options.elementPrefix);\n  \n  // Create progress UI if container exists but progress bar doesn't\n  if (!elements.progressBar) {\n    const containerPrefix = options.elementPrefix ? \n      `${options.elementPrefix}-progress-container` : \n      'progress-container';\n    \n    const container = document.getElementById(containerPrefix);\n    if (container) {\n      createProgressUI(container.id, options.elementPrefix || '');\n    }\n  }\n  \n  // Initialize progress rates tracking\n  state.progressRates.set(taskId, []);\n  state.lastUpdateTimes.set(taskId, getTimestamp());\n  \n  // Initialize task progress info\n  state.taskProgressInfo.set(taskId, {\n    startTime: getTimestamp(),\n    updateCount: 0,\n    totalProgressChange: 0,\n    avgProgressRate: 0\n  });\n  \n  // Set up status polling\n  if (window.socket && state.connectionState.connected) {\n    // Request initial status\n    window.socket.emit('request_task_status', {\n      task_id: taskId,\n      timestamp: Date.now() / 1000\n    });\n  } else {\n    // Start manual polling\n    startManualStatusPolling(taskId);\n  }\n  \n  // Set up task event handlers\n  setupTaskEventHandlers(taskId, options);\n  \n  // Return handler functions\n  return {\n    /**\n     * Update progress for the task\n     * @param {number} progress - Progress percentage (0-100)\n     * @param {string} message - Status message\n     * @param {Object} stats - Optional statistics\n     */\n    updateProgress: (progress, message, stats = null) => {\n      if (!state.activeTasks.has(taskId)) return;\n      \n      // Call the main update method\n      updateTaskProgress(taskId, progress, message, stats);\n    },\n    \n    /**\n     * Mark task as completed\n     * @param {Object} result - Task completion result\n     */\n    complete: (result) => {\n      if (!state.activeTasks.has(taskId)) return;\n      \n      // Call the main complete method\n      completeTask(taskId, result);\n    },\n    \n    /**\n     * Mark task as failed\n     * @param {Error|string} error - Error that occurred\n     * @param {Object} data - Additional error data\n     */\n    error: (error, data = {}) => {\n      if (!state.activeTasks.has(taskId)) return;\n      \n      // Call the main error method\n      errorTask(taskId, error, data);\n    },\n    \n    /**\n     * Cancel the task\n     */\n    cancel: () => {\n      if (!state.activeTasks.has(taskId)) return;\n      \n      // Call the main cancel method\n      cancelTask(taskId);\n    },\n    \n    /**\n     * Get current task status\n     * @returns {Object} - Task status info\n     */\n    getStatus: () => {\n      if (!state.activeTasks.has(taskId)) {\n        return { status: 'unknown', message: 'Task not found' };\n      }\n      \n      const task = state.activeTasks.get(taskId);\n      return {\n        id: taskId,\n        progress: task.progress,\n        status: task.status,\n        message: task.message,\n        startTime: task.startTime,\n        lastUpdate: task.lastUpdate,\n        endTime: task.endTime,\n        stats: task.stats || {}\n      };\n    }\n  };\n}\n\n/**\n * Set up event handlers for a specific task\n * @param {string} taskId - Task ID\n * @param {Object} options - Task options\n */\nfunction setupTaskEventHandlers(taskId, options) {\n  const handlers = {\n    socketHandlers: {},\n    eventRegistry: {},\n    dom: {}\n  };\n  \n  // Set up Socket.IO handlers if available\n  if (window.socket) {\n    // Progress update handler\n    const progressHandler = (data) => {\n      if (data.task_id === taskId) {\n        updateTaskProgress(taskId, data.progress, data.message, data.stats);\n      }\n    };\n    \n    // Task completed handler\n    const completedHandler = (data) => {\n      if (data.task_id === taskId) {\n        completeTask(taskId, data);\n      }\n    };\n    \n    // Task error handler\n    const errorHandler = (data) => {\n      if (data.task_id === taskId) {\n        errorTask(taskId, data.error || 'Unknown error', data);\n      }\n    };\n    \n    // Task cancelled handler\n    const cancelledHandler = (data) => {\n      if (data.task_id === taskId) {\n        cancelTask(taskId);\n      }\n    };\n    \n    // Register handlers\n    // CRITICAL FIX: Register ALL possible progress event names\n    const progressEvents = [\n      'progress_update',\n      'task_progress',\n      'file_processing_progress',\n      'playlist_progress',\n      'web_scraping_progress',\n      'pdf_download_progress',\n      'pdf_processing_progress'\n    ];\n    \n    // Register all progress events\n    progressEvents.forEach(event => {\n      window.socket.on(event, progressHandler);\n      handlers.socketHandlers[event] = progressHandler;\n    });\n    \n    // window.socket.on('progress_update', progressHandler);\n    window.socket.on('task_progress', progressHandler);\n    window.socket.on('task_completed', completedHandler);\n    window.socket.on('task_error', errorHandler);\n    window.socket.on('task_cancelled', cancelledHandler);\n    \n    // Also register type-specific handlers if task type is provided\n    if (options.taskType) {\n      window.socket.on(`${options.taskType}_progress`, progressHandler);\n      window.socket.on(`${options.taskType}_completed`, completedHandler);\n      window.socket.on(`${options.taskType}_error`, errorHandler);\n      window.socket.on(`${options.taskType}_cancelled`, cancelledHandler);\n    }\n    \n    // Store handlers for cleanup\n    handlers.socketHandlers = {\n      'progress_update': progressHandler,\n      'task_progress': progressHandler,\n      'task_completed': completedHandler,\n      'task_error': errorHandler,\n      'task_cancelled': cancelledHandler\n    };\n    \n    // Add type-specific handlers if applicable\n    if (options.taskType) {\n      handlers.socketHandlers[`${options.taskType}_progress`] = progressHandler;\n      handlers.socketHandlers[`${options.taskType}_completed`] = completedHandler;\n      handlers.socketHandlers[`${options.taskType}_error`] = errorHandler;\n      handlers.socketHandlers[`${options.taskType}_cancelled`] = cancelledHandler;\n    }\n  }\n  \n  // Set up DOM event handlers if needed\n  const prefix = options.elementPrefix ? `${options.elementPrefix}-` : '';\n  const cancelButton = document.getElementById(`${prefix}cancel-btn`);\n  \n  if (cancelButton) {\n    const cancelHandler = (e) => {\n      e.preventDefault();\n      cancelTask(taskId);\n    };\n    \n    cancelButton.addEventListener('click', cancelHandler);\n    \n    handlers.dom[`#${prefix}cancel-btn`] = {\n      'click': cancelHandler\n    };\n  }\n  \n  // Store all handlers for cleanup later\n  state.eventHandlers.set(taskId, handlers);\n}\n\n/**\n * Cancel tracking for a specific task\n * @param {string} taskId - Task ID to stop tracking\n * @returns {boolean} - Whether cancellation was successful\n */\nfunction cancelTracking(taskId) {\n  try {\n    console.log(`Cancelling progress tracking for task ${taskId}`);\n    \n    // Try to get the tracker\n    const tracker = activeTrackers.get(taskId);\n    if (tracker) {\n      // Use the tracker's destroy method if it exists\n      if (typeof tracker.destroy === 'function') {\n        tracker.destroy();\n      }\n      \n      // Remove from active trackers map\n      activeTrackers.delete(taskId);\n    }\n    \n    // Clean up event listeners\n    cleanupEventListeners(taskId);\n    \n    // Stop status polling if it exists\n    stopStatusPolling(taskId);\n    \n    // Clean up any timeouts\n    if (state.completionMonitoring && state.completionMonitoring.timeoutIds) {\n      state.completionMonitoring.timeoutIds.forEach(id => clearTimeout(id));\n      state.completionMonitoring.timeoutIds.clear();\n    }\n    \n    // Remove from completed tasks set to allow re-tracking\n    if (state.completedTaskIds) {\n      state.completedTaskIds.delete(taskId);\n    }\n    \n    // Remove from progress tracking maps\n    state.progressRates.delete(taskId);\n    state.lastUpdateTimes.delete(taskId);\n    state.lastProgressValues.delete(taskId);\n    state.taskProgressInfo.delete(taskId);\n    \n    // If socket is available, emit event to server\n    if (window.socket && state.connectionState.connected) {\n      window.socket.emit('cancel_tracking', {\n        task_id: taskId,\n        timestamp: Date.now() / 1000\n      });\n    }\n    \n    console.log(`Progress tracking cancelled for task ${taskId}`);\n    return true;\n  } catch (error) {\n    console.error(`Error cancelling tracking for task ${taskId}:`, error);\n    return false;\n  }\n}\n\n/**\n * Track progress from socket events\n * @param {string} taskId - Task ID\n * @param {Object} options - Options\n * @returns {Object} - Progress tracking functions\n */\nfunction trackProgress(taskId, options = {}) {\n  if (!taskId) {\n    console.error('Task ID required for progress tracking');\n    return null;\n  }\n\n  // Set up progress tracking\n  const progressHandler = setupTaskProgress(taskId, options);\n\n  // Request initial status via socket if available\n  if (window.socket && state.connectionState.connected) {\n    try {\n      window.socket.emit('request_task_status', {\n        task_id: taskId,\n        timestamp: Date.now() / 1000\n      });\n    } catch (err) {\n      console.warn('Error requesting initial status via socket:', err);\n    }\n  }\n\n  return {\n    ...progressHandler,\n    \n    /**\n     * Cancel tracking and cleanup event handlers\n     */\n    cancelTracking: () => {\n      // Use the exported cancelTracking function\n      return cancelTracking(taskId);\n    }\n  };\n}\n\n/**\n * Update task's progress\n * @param {string} taskId - Task ID\n * @param {number} progress - Progress percentage (0-100)\n * @param {string} message - Status message\n * @param {Object} stats - Optional statistics\n */\nfunction updateTaskProgress(taskId, progress, message, stats = null) {\n  if (!state.activeTasks.has(taskId)) {\n    console.warn(`Cannot update unknown task: ${taskId}`);\n    return;\n  }\n\n  const task = state.activeTasks.get(taskId);\n\n  // Special handling for 99-100% progress transitions\n  // If progress is 99+ but less than 100, and task reported \"completed\", force to 100%\n  if (progress >= 99 && progress < 100) {\n    const isCompleting = \n      stats?.status === \"completed\" || \n      task.status === \"completed\" ||\n      (stats && stats.processed_files >= stats.total_files) ||\n      (message && (\n        message.toLowerCase().includes(\"complet\") ||\n        message.toLowerCase().includes(\"done\") ||\n        message.toLowerCase().includes(\"finish\")\n      ));\n    \n    if (isCompleting) {\n      console.log(`Force-completing task ${taskId} at ${progress}% with completed status`);\n      progress = 100;\n    }\n  }\n\n  // Store the last reported progress value to prevent UI flicker\n  const lastProgress = state.lastProgressValues.get(taskId) || 0;\n\n  // Avoid updating to a lower progress value (prevent backward progress)\n  // But allow it if we're at 99% and receiving an update with status=completed\n  const isCompletingUpdate = progress >= 99 && \n                        (stats && stats.status === \"completed\" || \n                        task.status === \"completed\");\n                        \n  // CRITICAL FIX: Removed backward progress prevention\n  // // CRITICAL FIX: Removed backward progress prevention\n  // console.warn(`Ignoring backward progress update for task ${taskId}: ${progress}% (last was ${lastProgress}%)`);\n  // return;\n\n  // Update last progress value\n  state.lastProgressValues.set(taskId, progress);\n\n  // Update task info\n  task.progress = progress;\n  task.message = message;\n  task.lastUpdate = getTimestamp();\n  task.status = stats?.status || 'running';\n\n  if (stats) task.stats = stats;\n\n  // Update progress rates for ETA calculation\n  updateProgressRate(taskId, progress);\n\n  // Update UI\n  updateProgressUI(taskId, progress, message, stats);\n\n  // If progress reaches 100% or status is completed, mark as completed\n  if ((progress >= 100 || (stats && stats.status === \"completed\")) && \n      task.status !== 'completed' && \n      !state.completedTaskIds.has(taskId)) {\n    \n    // CRITICAL FIX: Complete immediately without delay\n    console.log(`Task ${taskId} reached 100% - completing immediately`);\n    completeTask(taskId, {\n      ...task,\n      output_file: task.outputPath || stats?.output_file || null\n    });\n  }\n}\n\n/**\n * Update progress UI for a task\n * @param {string} taskId - Task ID\n * @param {number} progress - Progress percentage (0-100)\n * @param {string} message - Status message\n * @param {Object} stats - Optional statistics\n * @returns {boolean} - Success\n */\nfunction updateProgressUI(taskId, progress, message, stats = null) {\n  if (!state.activeTasks.has(taskId)) {\n    console.warn(`Cannot update UI for unknown task: ${taskId}`);\n    return false;\n  }\n\n  const task = state.activeTasks.get(taskId);\n  const elements = getUIElements(task.elementPrefix);\n\n  // Update task progress info counter\n  const info = state.taskProgressInfo.get(taskId) || {\n    startTime: getTimestamp(),\n    updateCount: 0,\n    totalProgressChange: 0,\n    avgProgressRate: 0\n  };\n  info.updateCount++;\n  state.taskProgressInfo.set(taskId, info);\n  \n  // Apply progress smoothing for early stages\n  // CRITICAL FIX: Direct progress assignment\n  const smoothedProgress = Math.max(0, Math.min(100, progress));\n\n  // Update progress bar with sanity checks\n  if (elements.progressBar) {\n    // Set minimum progress of 1% to show something is happening\n    const displayProgress = Math.max(1, smoothedProgress);\n    \n    // Apply animated progress update\n    applyProgressBarAnimation(elements.progressBar, \n                            parseFloat(elements.progressBar.style.width) || 0, \n                            displayProgress);\n    \n    // Update contextual classes based on progress\n    elements.progressBar.classList.remove('bg-danger', 'bg-warning', 'bg-info', 'progress-bar-low', 'progress-bar-complete');\n    \n    // Add pulsing animation for low progress\n    if (smoothedProgress <= 15) {\n      elements.progressBar.classList.add('progress-bar-low');\n    } else if (smoothedProgress >= 100) {\n      elements.progressBar.classList.add('bg-success', 'progress-bar-complete');\n    } else if (smoothedProgress >= 75) {\n      elements.progressBar.classList.add('bg-info');\n    } else if (smoothedProgress >= 50) {\n      elements.progressBar.classList.add('bg-primary');\n    } else if (smoothedProgress >= 25) {\n      elements.progressBar.classList.add('bg-primary');\n    } else {\n      // Keep default primary color for early progress\n      elements.progressBar.classList.add('bg-primary');\n    }\n  }\n\n  // Progress percentage is now shown inside the progress bar itself\n\n  // Update status message\n  if (elements.progressStatus && message) {\n    elements.progressStatus.textContent = message;\n  }\n\n  // Update ETA display\n  if (elements.etaDisplay) {\n    const eta = calculateETA(taskId, smoothedProgress);\n    if (eta.timeRemaining) {\n      elements.etaDisplay.textContent = `ETA: ${formatDuration(eta.timeRemaining)}`;\n      elements.etaDisplay.classList.remove('d-none');\n    } else if (smoothedProgress >= 100) {\n      elements.etaDisplay.textContent = 'Complete';\n      elements.etaDisplay.classList.remove('d-none');\n    } else if (smoothedProgress <= 0) {\n      elements.etaDisplay.classList.add('d-none');\n    }\n  }\n\n  // Update elapsed time\n  if (elements.elapsedTime && task.startTime) {\n    const elapsed = getTimestamp() - task.startTime;\n    elements.elapsedTime.textContent = `Elapsed: ${formatDuration(elapsed)}`;\n  }\n  \n  // Update progress rate display if available\n  if (elements.progressRateDisplay && task.startTime) {\n    const elapsed = getTimestamp() - task.startTime;\n    if (elapsed > 5000 && smoothedProgress > 0) { // Only show after 5 seconds and some progress\n      const rate = smoothedProgress / (elapsed / 1000);\n      elements.progressRateDisplay.textContent = `Rate: ${rate.toFixed(1)}%/s`;\n      elements.progressRateDisplay.classList.remove('d-none');\n    }\n  }\n\n  // Update stats if available\n  if (elements.progressStats && stats) {\n    updateStatsDisplay(elements.progressStats, stats);\n  }\n\n  return true;\n}\n\n/**\n * Complete a task\n * @param {string} taskId - Task ID\n * @param {Object} result - Task result\n */\nfunction completeTask(taskId, result) {\n  if (!state.activeTasks.has(taskId)) {\n    console.warn(`Cannot complete unknown task: ${taskId}`);\n    return;\n  }\n\n  // Check if task has already been completed to prevent duplicates\n  if (state.completedTaskIds.has(taskId)) {\n    console.log(`Task ${taskId} already marked as completed, ignoring duplicate completion event`);\n    return;\n  }\n\n  // Mark this task as completed to prevent duplicate completions\n  state.completedTaskIds.add(taskId);\n\n  const task = state.activeTasks.get(taskId);\n  const elements = getUIElements(task.elementPrefix);\n\n  // Set task as completed\n  task.progress = 100;\n  task.status = 'completed';\n  task.result = result;\n  task.endTime = getTimestamp();\n\n  // Process stats if available\n  if (result && result.stats) {\n    // Handle string stats objects (parse if needed)\n    if (typeof result.stats === 'string') {\n      try {\n        task.stats = JSON.parse(result.stats);\n      } catch (e) {\n        console.warn(`Could not parse stats string: ${e}`);\n        task.stats = { error: \"Could not parse stats\" };\n      }\n    } else {\n      task.stats = result.stats;\n    }\n  }\n\n  // Update progress bar to 100%\n  if (elements.progressBar) {\n    // Apply animated progress to 100%\n    applyProgressBarAnimation(elements.progressBar, \n                            parseFloat(elements.progressBar.style.width) || 0, \n                            100);\n    \n    elements.progressBar.classList.remove('bg-danger', 'bg-warning', 'progress-bar-low');\n    elements.progressBar.classList.add('bg-success', 'progress-bar-complete');\n  }\n\n  // Update status message\n  if (elements.progressStatus) {\n    const completionMessage = result.message || \"Task completed successfully\";\n    elements.progressStatus.textContent = completionMessage;\n    elements.progressStatus.classList.remove('text-danger', 'text-warning');\n    elements.progressStatus.classList.add('text-success');\n  }\n\n  // Update ETA display\n  if (elements.etaDisplay) {\n    elements.etaDisplay.textContent = 'Complete';\n    elements.etaDisplay.classList.add('text-success');\n  }\n\n  // Update elapsed time\n  if (elements.elapsedTime) {\n    const elapsed = getTimestamp() - task.startTime;\n    elements.elapsedTime.textContent = `Total time: ${formatDuration(elapsed)}`;\n  }\n\n  // Update stats display if we have result stats\n  if (elements.progressStats && result && result.stats) {\n    // Force the stats container to be visible\n    elements.progressStats.style.display = 'block';\n    elements.progressStats.classList.remove('d-none');\n    updateStatsDisplay(elements.progressStats, result.stats);\n  } else if (elements.progressStats) {\n    // Even without stats, show completion summary\n    elements.progressStats.style.display = 'block';\n    elements.progressStats.classList.remove('d-none');\n    elements.progressStats.innerHTML = `\n      <div class=\"alert alert-success\">\n        <i class=\"fas fa-check-circle me-2\"></i>\n        Task completed successfully!\n        <div class=\"mt-2\">Duration: ${formatDuration(task.endTime - task.startTime)}</div>\n      </div>\n    `;\n  }\n\n  // Stop status polling\n  stopStatusPolling(taskId);\n\n  // Clear session storage\n  if (task.options && task.options.saveToSessionStorage) {\n    // Record completion time to prevent reload loops\n    sessionStorage.setItem('taskCompletionTime', getTimestamp().toString());\n    \n    // Remove task tracking\n    sessionStorage.removeItem('ongoingTaskId');\n    sessionStorage.removeItem('ongoingTaskType');\n    sessionStorage.removeItem('taskStartTime');\n    console.log(`Cleared session storage for completed task ${taskId}`);\n  }\n\n  // Add to history\n  addTaskToHistory(taskId, result, 'completed');\n\n  // Clean up event listeners\n  cleanupEventListeners(taskId);\n  \n  // Remove from active tasks after a delay\n  setTimeout(() => {\n    state.activeTasks.delete(taskId);\n  }, 1000);\n}\n\n/**\n * Mark a task as failed\n * @param {string} taskId - Task ID\n * @param {Error|string} error - Error that occurred\n * @param {Object} data - Additional error data\n */\nfunction errorTask(taskId, error, data = {}) {\n  // Enhanced validation\n  if (!taskId) {\n    console.error(\"Cannot mark error - no task ID provided\");\n    return;\n  }\n  \n  if (!state.activeTasks.has(taskId)) {\n    console.warn(`Cannot mark unknown task as error: ${taskId}`);\n    return;\n  }\n\n  // Skip if this task is already marked with an error\n  if (state.taskErrors.has(taskId)) {\n    console.log(`Task ${taskId} already has an error, skipping duplicate error`);\n    return;\n  }\n  \n  // Mark this task as having an error\n  state.taskErrors.set(taskId, {\n    error: error,\n    timestamp: getTimestamp(),\n    data: data\n  });\n\n  const task = state.activeTasks.get(taskId);\n  const elements = getUIElements(task.elementPrefix);\n\n  // Update task state\n  task.status = 'error';\n  task.error = error;\n  task.errorData = data;\n  task.endTime = getTimestamp();\n\n  // Update progress bar\n  if (elements.progressBar) {\n    elements.progressBar.classList.remove('bg-primary', 'bg-success', 'bg-warning', 'progress-bar-low', 'progress-bar-complete');\n    elements.progressBar.classList.add('bg-danger', 'progress-bar-error');\n  }\n\n  // Update status message\n  if (elements.progressStatus) {\n    const errorMessage = typeof error === 'string' ? error : \n                        (error.message || 'Unknown error');\n    \n    elements.progressStatus.textContent = `Error: ${errorMessage}`;\n    elements.progressStatus.classList.remove('text-warning');\n    elements.progressStatus.classList.add('text-danger');\n  }\n\n  // Update ETA display\n  if (elements.etaDisplay) {\n    elements.etaDisplay.textContent = 'Failed';\n    elements.etaDisplay.classList.add('text-danger');\n  }\n\n  // Stop status polling\n  stopStatusPolling(taskId);\n\n  // Clear session storage\n  if (task.options && task.options.saveToSessionStorage) {\n    sessionStorage.removeItem('ongoingTaskId');\n    sessionStorage.removeItem('ongoingTaskType');\n    sessionStorage.removeItem('taskStartTime');\n  }\n\n  // Add to history\n  addTaskToHistory(taskId, {\n    ...data,\n    error: typeof error === 'string' ? error : (error.message || 'Unknown error')\n }, 'error');\n\n // Clean up event listeners\n cleanupEventListeners(taskId);\n \n // Remove from active tasks after a delay\n setTimeout(() => {\n   state.activeTasks.delete(taskId);\n }, 1000);\n}\n\n/**\n* Cancel a task\n* @param {string} taskId - Task ID\n*/\nfunction cancelTask(taskId) {\n if (!state.activeTasks.has(taskId)) {\n   console.warn(`Cannot cancel unknown task: ${taskId}`);\n   return;\n }\n\n const task = state.activeTasks.get(taskId);\n const elements = getUIElements(task.elementPrefix);\n\n // Update task state\n task.status = 'cancelled';\n task.endTime = getTimestamp();\n\n // Update progress bar\n if (elements.progressBar) {\n   elements.progressBar.classList.remove('bg-primary', 'bg-success', 'bg-danger', 'progress-bar-low', 'progress-bar-complete');\n   elements.progressBar.classList.add('bg-warning');\n }\n\n // Update status message\n if (elements.progressStatus) {\n   elements.progressStatus.textContent = 'Task cancelled';\n   elements.progressStatus.classList.remove('text-danger');\n   elements.progressStatus.classList.add('text-warning');\n }\n\n // Update ETA display\n if (elements.etaDisplay) {\n   elements.etaDisplay.textContent = 'Cancelled';\n   elements.etaDisplay.classList.add('text-warning');\n }\n\n // Stop status polling\n stopStatusPolling(taskId);\n\n // Clear session storage\n if (task.options && task.options.saveToSessionStorage) {\n   sessionStorage.removeItem('ongoingTaskId');\n   sessionStorage.removeItem('ongoingTaskType');\n   sessionStorage.removeItem('taskStartTime');\n }\n\n // Add to history\n addTaskToHistory(taskId, {}, 'cancelled');\n\n // Also try to send an API request to cancel the task on the server\n sendCancelRequest(taskId);\n\n // Clean up event listeners\n cleanupEventListeners(taskId);\n \n // Remove from active tasks after a delay\n setTimeout(() => {\n   state.activeTasks.delete(taskId);\n }, 1000);\n}\n\n/**\n* Send cancel request to the server\n* @param {string} taskId - Task ID\n*/\nasync function sendCancelRequest(taskId) {\n try {\n   // First try to cancel via socket\n   if (window.socket && state.connectionState.connected) {\n     window.socket.emit('cancel_task', { \n       task_id: taskId,\n       timestamp: Date.now() / 1000,\n       reason: 'User cancelled'\n     });\n   }\n   \n   // Also send an HTTP request as backup\n   const response = await fetch(`/api/cancel_task/${taskId}`, {\n     method: 'POST'\n   });\n   \n   if (!response.ok) {\n     console.warn(`Failed to send cancel request: ${response.status}`);\n   }\n } catch (error) {\n   console.error(\"Error sending cancel request:\", error);\n }\n}\n\n/**\n* Get task details\n* @param {string} taskId - Task ID\n* @returns {Object|null} - Task details or null if not found\n*/\nfunction getTaskDetails(taskId) {\n if (!state.activeTasks.has(taskId)) {\n   return null;\n }\n \n const task = state.activeTasks.get(taskId);\n return {\n   id: taskId,\n   progress: task.progress,\n   status: task.status,\n   message: task.message,\n   stats: task.stats || {},\n   startTime: task.startTime,\n   endTime: task.endTime,\n   error: task.error,\n   type: task.type\n };\n}\n\n/**\n* Clear task history\n*/\nfunction clearTaskHistory() {\n state.completedTasks = [];\n state.failedTasks = [];\n saveTaskHistory();\n}\n\n/**\n* Force reset a task's state - use with caution\n* @param {string} taskId - Task ID\n*/\nfunction forceResetTask(taskId) {\n // Remove from active tasks\n state.activeTasks.delete(taskId);\n \n // Remove from completed tasks set\n state.completedTaskIds.delete(taskId);\n \n // Remove from error tasks map\n state.taskErrors.delete(taskId);\n \n // Stop any polling\n stopStatusPolling(taskId);\n \n // Clean up event listeners\n cleanupEventListeners(taskId);\n \n // Clear any intervals\n if (state.statusPollingIntervals.has(taskId)) {\n   clearInterval(state.statusPollingIntervals.get(taskId));\n   state.statusPollingIntervals.delete(taskId);\n }\n \n // Clear from progress rates\n state.progressRates.delete(taskId);\n state.lastUpdateTimes.delete(taskId);\n state.lastProgressValues.delete(taskId);\n state.taskProgressInfo.delete(taskId);\n \n // Clear from session storage if it matches\n const currentTaskId = sessionStorage.getItem('ongoingTaskId');\n if (currentTaskId === taskId) {\n   sessionStorage.removeItem('ongoingTaskId');\n   sessionStorage.removeItem('ongoingTaskType');\n   sessionStorage.removeItem('taskStartTime');\n }\n}\n\n/**\n* Reset all state - use with caution\n*/\nfunction resetAllState() {\n // Clear active tasks\n state.activeTasks.clear();\n \n // Clear completed tasks set\n state.completedTaskIds.clear();\n \n // Clear error tasks map\n state.taskErrors.clear();\n \n // Stop all polling\n for (const intervalId of state.statusPollingIntervals.values()) {\n   clearInterval(intervalId);\n }\n state.statusPollingIntervals.clear();\n \n // Clear all event listeners\n for (const taskId of state.eventHandlers.keys()) {\n   cleanupEventListeners(taskId);\n }\n \n // Clear progress tracking\n state.progressRates.clear();\n state.lastUpdateTimes.clear();\n state.lastProgressValues.clear();\n state.taskProgressInfo.clear();\n \n // Clear task history\n state.completedTasks = [];\n state.failedTasks = [];\n saveTaskHistory();\n \n // Clear session storage\n sessionStorage.removeItem('ongoingTaskId');\n sessionStorage.removeItem('ongoingTaskType');\n sessionStorage.removeItem('taskStartTime');\n \n console.log(\"Progress handler state reset\");\n}\n\n// Export the module\nexport default initProgressHandler;\nexport {\n createProgressTracker,\n setupTaskProgress,\n trackProgress,\n updateTaskProgress,\n updateProgressUI,\n completeTask,\n errorTask,\n cancelTask,\n createProgressUI,\n formatDuration,\n calculateETA,\n formatBytes,\n updateStatsDisplay,\n cancelTracking,\n // New v4.0 exports\n showNotification,\n testBackendConnectivity,\n getHealthStatus\n};","source":"/workspace/modules/static/js/modules/utils/progressHandler_legacy.js","title":"progressHandler_legacy.js","language":"en"},{"content":"/**\n * safeFileProcessor.js - Fixed Version (v2.0.0)\n * \n * This simplified version eliminates the timeout issues by:\n * 1. Removing complex DOM checking that caused delays\n * 2. Using direct imports instead of dynamic loading\n * 3. Simplified state management\n * 4. Better error handling\n */\n\nimport fileProcessor from '../features/fileProcessor.js';\n\n// Simple state management - no WeakMap or complex objects\nconst state = {\n  initialized: false,\n  processing: false,\n  lastError: null\n};\n\n/**\n * Safe File Processor Module\n * Provides a reliable wrapper around the file processor\n */\nconst safeFileProcessor = {\n  // Module metadata\n  name: 'safeFileProcessor',\n  version: '2.0.0',\n  initialized: false,\n\n  /**\n   * Initialize the safe file processor\n   */\n  async initialize() {\n    if (this.initialized) {\n      console.log('Safe file processor already initialized');\n      return true;\n    }\n\n    try {\n      // Initialize the underlying file processor if it has an initialize method\n      if (fileProcessor && typeof fileProcessor.initialize === 'function') {\n        await fileProcessor.initialize();\n      }\n\n      this.initialized = true;\n      state.initialized = true;\n      \n      console.log('✅ Safe file processor initialized successfully');\n      return true;\n    } catch (error) {\n      console.error('❌ Failed to initialize safe file processor:', error);\n      state.lastError = error;\n      return false;\n    }\n  },\n\n  /**\n   * Process a file safely with progress tracking\n   */\n  async processFile(file, options = {}) {\n    if (!this.initialized) {\n      await this.initialize();\n    }\n\n    if (state.processing) {\n      throw new Error('File processing already in progress');\n    }\n\n    try {\n      state.processing = true;\n      state.lastError = null;\n      \n      // Delegate to the underlying file processor\n      if (fileProcessor && typeof fileProcessor.processFile === 'function') {\n        const result = await fileProcessor.processFile(file, options);\n        return result;\n      } else {\n        throw new Error('File processor not available');\n      }\n    } catch (error) {\n      state.lastError = error;\n      throw error;\n    } finally {\n      state.processing = false;\n    }\n  },\n\n  /**\n   * Get current processing status\n   */\n  getStatus() {\n    return {\n      initialized: this.initialized,\n      processing: state.processing,\n      hasFileProcessor: !!fileProcessor,\n      lastError: state.lastError?.message || null\n    };\n  },\n\n  /**\n   * Setup task progress tracking - delegate to fileProcessor\n   */\n  setupTaskProgress(taskId, options = {}) {\n    if (fileProcessor && typeof fileProcessor.setupTaskProgress === 'function') {\n      return fileProcessor.setupTaskProgress(taskId, options);\n    }\n    console.warn('setupTaskProgress not available in underlying file processor');\n    return null;\n  },\n\n  /**\n   * Update task progress - delegate to fileProcessor\n   */\n  updateTaskProgress(taskId, progress, message, stats) {\n    if (fileProcessor && typeof fileProcessor.updateTaskProgress === 'function') {\n      return fileProcessor.updateTaskProgress(taskId, progress, message, stats);\n    }\n    console.warn('updateTaskProgress not available in underlying file processor');\n  },\n\n  /**\n   * Complete a task - delegate to fileProcessor\n   */\n  completeTask(taskId, data = {}) {\n    if (fileProcessor && typeof fileProcessor.completeTask === 'function') {\n      return fileProcessor.completeTask(taskId, data);\n    }\n    console.warn('completeTask not available in underlying file processor');\n  },\n\n  /**\n   * Handle task error - delegate to fileProcessor\n   */\n  errorTask(taskId, error, data = {}) {\n    if (fileProcessor && typeof fileProcessor.errorTask === 'function') {\n      return fileProcessor.errorTask(taskId, error, data);\n    }\n    console.warn('errorTask not available in underlying file processor');\n  },\n\n  /**\n   * Cancel a task - delegate to fileProcessor\n   */\n  cancelTask(taskId) {\n    if (fileProcessor && typeof fileProcessor.cancelTask === 'function') {\n      return fileProcessor.cancelTask(taskId);\n    }\n    console.warn('cancelTask not available in underlying file processor');\n  },\n\n  /**\n   * Check if module is ready for use\n   */\n  isReady() {\n    return this.initialized && !!fileProcessor && !state.processing;\n  },\n\n  /**\n   * Reset the module state (for debugging/recovery)\n   */\n  reset() {\n    this.initialized = false;\n    state.initialized = false;\n    state.processing = false;\n    state.lastError = null;\n    console.log('Safe file processor reset');\n  }\n};\n\n// Auto-initialize when DOM is ready (simple, non-blocking approach)\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => {\n    // Use setTimeout to avoid blocking DOM ready event\n    setTimeout(() => {\n      safeFileProcessor.initialize().catch(error => {\n        console.warn('Auto-initialization of safeFileProcessor failed:', error.message);\n      });\n    }, 100);\n  });\n} else {\n  // DOM already ready, initialize with slight delay to avoid blocking\n  setTimeout(() => {\n    safeFileProcessor.initialize().catch(error => {\n      console.warn('Auto-initialization of safeFileProcessor failed:', error.message);\n    });\n  }, 100);\n}\n\nexport default safeFileProcessor;","source":"/workspace/modules/static/js/modules/utils/safeFileProcessor.js","title":"safeFileProcessor.js","language":"en"},{"content":"/**\n * Socket Handler Module\n * \n * Manages Socket.IO connections and message handling for real-time communication.\n * Provides robust error handling, reconnection logic, and task progress tracking.\n * \n * KEY IMPROVEMENTS:\n * - Enhanced DOM readiness handling to prevent \"document.body is null\" errors\n * - Improved task lifecycle handling for all Socket.IO events\n * - Multiple fallback paths for when Socket.IO is unavailable\n * - Better integration with progressHandler.js\n * - Robust task cancellation with multiple API fallbacks\n * - Improved progress update handling to fix progress bar \"stuck at 5%\" issue\n * - Enhanced error recovery\n * - Proper event registry integration\n * - Memory leak fixes\n */\n\nimport { getElement } from './domUtils.js';\n\n// Import Blueprint events configuration\nimport { SOCKET_EVENTS, BLUEPRINT_EVENTS, SERVER_EVENTS, TASK_EVENTS } from '../config/socketEvents.js';\n\n// Module state\nlet socket = null;\nlet connected = false;\nlet reconnectAttempts = 0;\nlet activeTasks = new Set();\nlet taskCallbacks = new Map();\nlet taskStatusRequests = new Map();\nlet pollingIntervals = {};\nlet eventRegistry = null;\nlet initialized = false;\nlet connectionAttempts = 0;\nlet maxConnectionAttempts = 5;\nlet waitForDOMInit = false;\nlet pingInterval = null;\n\n// For backward compatibility with original implementation\nlet currentTaskId = null;\nlet activeTaskTracker = null;\n\n/**\n * Create a task tracker for the current task (for backward compatibility)\n * @param {string} taskId - The task ID to track\n * @returns {Object} - The task tracker object\n */\nfunction createTaskTracker(taskId) {\n  // Create a task tracker object to monitor progress\n  const tracker = {\n    taskId,\n    progress: 0,\n    stats: {},\n    startTime: Date.now(),\n    \n    /**\n     * Update the progress of the task\n     * @param {number} progress - New progress percentage\n     * @param {string} message - Status message\n     * @param {Object} stats - Updated statistics \n     */\n    updateProgress(progress, message, stats) {\n      this.progress = progress;\n      this.stats = stats || this.stats;\n      \n      // Calculate estimated completion time\n      if (progress > 0 && progress < 100) {\n        const elapsed = Date.now() - this.startTime;\n        const estimatedTotal = elapsed / (progress / 100);\n        const remaining = estimatedTotal - elapsed;\n        \n        // Format using our utility function\n        const formattedTime = formatDuration(remaining / 1000);\n        console.log(`Estimated time remaining: ${formattedTime}`);\n      }\n    },\n    \n    /**\n     * Mark the task as complete\n     */\n    complete() {\n      this.progress = 100;\n      console.log(`Task ${taskId} completed in ${formatDuration((Date.now() - this.startTime) / 1000)}`);\n    },\n    \n    /**\n     * Get the current state of the tracker\n     * @returns {Object} - Tracker state\n     */\n    getState() {\n      return {\n        taskId: this.taskId,\n        progress: this.progress,\n        stats: this.stats,\n        elapsedTime: Date.now() - this.startTime\n      };\n    }\n  };\n  \n  return tracker;\n}\n\n/**\n * Show a generic completion message when module-specific handlers aren't available\n * @param {Object} data - Task completion data\n */\nfunction showGenericCompletionMessage(data) {\n  try {\n    // Find results container\n    const resultsContainer = getElement('results-container');\n    if (!resultsContainer) return;\n    \n    // Get output file path and stats\n    const outputFile = data.output_file || '';\n    const stats = data.stats || {};\n    \n    // Create results content\n    let html = `\n      <div class=\"alert alert-success\">\n        <h5><i class=\"fas fa-check-circle me-2\"></i>Task Completed Successfully</h5>\n        <p>Processing completed in ${formatDuration(stats.duration_seconds || 0)}</p>\n      </div>\n      \n      <div class=\"card mb-3\">\n        <div class=\"card-header bg-success text-white\">\n          <h5 class=\"card-title mb-0\">Output</h5>\n        </div>\n        <div class=\"card-body\">\n          <p class=\"card-text\"><strong>Output File:</strong> ${outputFile}</p>\n    `;\n    \n    // Add stats summary\n    if (stats) {\n      html += '<div class=\"stats-summary mt-3\"><h6>Processing Statistics:</h6><ul>';\n      \n      // Add key stats as list items\n      for (const [key, value] of Object.entries(stats)) {\n        if (typeof value !== 'object' && !key.startsWith('_')) {\n          const label = key.replace(/_/g, ' ').replace(/\\b\\w/g, c => c.toUpperCase());\n          html += `<li><strong>${label}:</strong> ${value}</li>`;\n        }\n      }\n      \n      html += '</ul></div>';\n    }\n    \n    // Add download button if output file is available\n    if (outputFile) {\n      html += `\n        <div class=\"mt-3\">\n          <a href=\"/download/${encodeURIComponent(outputFile)}\" class=\"btn btn-primary\">\n            <i class=\"fas fa-download me-2\"></i>Download Result\n          </a>\n        </div>\n      `;\n    }\n    \n    html += `\n        </div>\n      </div>\n    `;\n    \n    // Update results container\n    resultsContainer.innerHTML = html;\n    resultsContainer.style.display = 'block';\n    \n    // Hide progress container\n    const progressContainer = getElement('progress-container');\n    if (progressContainer) {\n      progressContainer.style.display = 'none';\n    }\n    \n  } catch (error) {\n    console.error(\"Error showing generic completion message:\", error);\n    showToast('Error', 'Could not display results', 'error');\n  }\n}\n\n/**\n * Show a generic error message when module-specific handlers aren't available\n * @param {Object} errorObj - Error object\n */\nfunction showGenericErrorMessage(errorObj) {\n  try {\n    // Find error container\n    const errorContainer = getElement('error-container');\n    const progressContainer = getElement('progress-container');\n    \n    // If no specific container found, create a generic alert\n    if (!errorContainer) {\n      // Hide progress if it exists\n      if (progressContainer) {\n        progressContainer.style.display = 'none';\n      }\n      \n      // Show toast notification\n      showToast('Error', errorObj.error || 'An error occurred during processing', 'error');\n      return;\n    }\n    \n    // Create error message content\n    const errorMessage = errorObj.error || 'An unknown error occurred';\n    const errorDetails = errorObj.details || '';\n    \n    let html = `\n      <div class=\"alert alert-danger\">\n        <h5><i class=\"fas fa-exclamation-circle me-2\"></i>Processing Error</h5>\n        <p>${errorMessage}</p>\n    `;\n    \n    // Add error details if available\n    if (errorDetails) {\n      html += `\n        <hr>\n        <div class=\"small\">\n          <strong>Details:</strong> ${errorDetails}\n        </div>\n      `;\n    }\n    \n    // Add try again button\n    html += `\n        <div class=\"mt-3\">\n          <button class=\"btn btn-outline-danger\" onclick=\"window.location.reload()\">\n            <i class=\"fas fa-redo me-2\"></i>Try Again\n          </button>\n        </div>\n      </div>\n    `;\n    \n    // Update error container\n    errorContainer.innerHTML = html;\n    errorContainer.style.display = 'block';\n    \n    // Hide progress container\n    if (progressContainer) {\n      progressContainer.style.display = 'none';\n    }\n    \n  } catch (error) {\n    console.error(\"Error showing generic error message:\", error);\n    showToast('Error', errorObj.error || 'An error occurred', 'error');\n  }\n}\n\n/**\n * Show a toast notification\n * @param {string} title - Toast title \n * @param {string} message - Toast message\n * @param {string} type - Toast type ('success', 'error', 'warning', 'info')\n */\nfunction showToast(title, message, type = 'info') {\n  try {\n    // Try to use UI module if available\n    if (window.ui && typeof window.ui.showToast === 'function') {\n      window.ui.showToast(title, message, type);\n      return;\n    }\n    \n    // Fallback to Bootstrap Toast if available\n    const toastContainer = getElement('toast-container');\n    if (toastContainer) {\n      const toastId = `toast-${Date.now()}`;\n      const toastHtml = `\n        <div id=\"${toastId}\" class=\"toast\" role=\"alert\" aria-live=\"assertive\" aria-atomic=\"true\">\n          <div class=\"toast-header bg-${type === 'error' ? 'danger' : type} text-white\">\n            <strong class=\"me-auto\">${title}</strong>\n            <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"toast\" aria-label=\"Close\"></button>\n          </div>\n          <div class=\"toast-body\">\n            ${message}\n          </div>\n        </div>\n      `;\n      \n      toastContainer.insertAdjacentHTML('beforeend', toastHtml);\n      \n      // Initialize the toast if Bootstrap is available\n      if (window.bootstrap && window.bootstrap.Toast) {\n        new window.bootstrap.Toast(document.getElementById(toastId)).show();\n      }\n    } else {\n      // Last resort: use alert\n      console.log(`${title}: ${message}`);\n    }\n  } catch (error) {\n    console.error(\"Error showing toast:\", error);\n  }\n}\n\n/**\n * Initialize the Socket Handler module with improved DOM readiness checks\n * @param {Object} options - Configuration options\n * @param {Object} [options.eventRegistryRef] - Reference to eventRegistry module\n * @returns {Promise<boolean>} - Success state\n */\nfunction initialize(options = {}) {\n  // Early return if already initialized\n  if (initialized && !waitForDOMInit) {\n    console.log(\"Socket handler already initialized\");\n    return Promise.resolve(true);\n  }\n  \n  console.log(\"Initializing Socket Handler module...\");\n  \n  // Check if document is ready before proceeding\n  if (document.readyState === 'loading') {\n    console.log(\"DOM not ready, deferring Socket Handler initialization\");\n    waitForDOMInit = true;\n    \n    return new Promise((resolve) => {\n      document.addEventListener('DOMContentLoaded', () => {\n        // Use setTimeout to ensure this runs after current JS execution\n        setTimeout(() => {\n          initializeAfterDOMReady(options).then(resolve);\n        }, 10);\n      });\n    });\n  } else {\n    // DOM is already ready, initialize immediately\n    return initializeAfterDOMReady(options);\n  }\n}\n\n/**\n * Second phase of initialization after DOM is ready\n * @param {Object} options - Configuration options\n * @returns {Promise<boolean>} - Success state\n */\nasync function initializeAfterDOMReady(options = {}) {\n  try {\n    waitForDOMInit = false;\n    \n    // Store eventRegistry reference if provided\n    if (options && options.eventRegistryRef) {\n      eventRegistry = options.eventRegistryRef;\n    } else {\n      // Try to get from window as fallback\n      eventRegistry = window.eventRegistry || \n                      window.moduleInstances?.eventRegistry || \n                      null;\n    }\n    \n    // Get socket status UI element (if available)\n    const statusIndicator = getElement('socket-status');\n    if (statusIndicator) {\n      statusIndicator.classList.remove('d-none');\n      statusIndicator.classList.add('connecting');\n      \n      const statusText = statusIndicator.querySelector('.socket-status-text');\n      if (statusText) {\n        statusText.textContent = 'Connecting...';\n      }\n    }\n    \n    // Connect to Socket.IO server\n    const connectResult = await connect();\n    \n    // Mark as initialized\n    initialized = true;\n    console.log(\"Socket Handler module initialized successfully\");\n    \n    return connectResult;\n  } catch (error) {\n    console.error(\"Error initializing Socket Handler module:\", error);\n    initialized = true; // Still mark as initialized to prevent retry loops\n    return false;\n  }\n}\n\n/**\n * Update the socket status indicator in the UI\n * @param {string} status - Status ('connected', 'disconnected', 'connecting', 'error')\n * @param {string} message - Status message\n */\nfunction updateSocketStatus(status, message) {\n  const statusIndicator = getElement('socket-status');\n  if (!statusIndicator) return;\n  \n  // Update classes\n  statusIndicator.classList.remove('connected', 'disconnected', 'connecting', 'error');\n  statusIndicator.classList.add(status);\n  \n  // Update text\n  const statusText = statusIndicator.querySelector('.socket-status-text');\n  if (statusText && message) {\n    statusText.textContent = message;\n  }\n}\n\n/**\n * Connect to the Socket.IO server\n * @returns {Promise<boolean>} - Whether connection was initiated successfully\n */\nfunction connect() {\n  return new Promise((resolve) => {\n    try {\n      console.log(\"Connecting to Socket.IO server...\");\n      \n      // Check if Socket.IO is available\n      if (typeof io === 'undefined') {\n        console.error(\"Socket.IO not loaded. Make sure the Socket.IO client is included in the page.\");\n        updateSocketStatus('error', 'Socket.IO not available');\n        resolve(false);\n        return;\n      }\n      \n      // Initialize socket connection\n      socket = io({\n        reconnectionAttempts: 5,\n        reconnectionDelay: 1000,\n        reconnectionDelayMax: 5000,\n        timeout: 20000\n      });\n      \n      // Set up event handlers\n      setupEventHandlers();\n      \n      // Set up custom event handlers\n      setupCustomEventHandlers();\n      \n      // Start a keep-alive ping interval\n      startPingInterval();\n      \n      console.log(\"Socket.IO connection initiated\");\n      resolve(true);\n    } catch (error) {\n      console.error(\"Error connecting to Socket.IO server:\", error);\n      \n      // Show error notification\n      showToast('Connection Error', 'Failed to connect to server', 'error');\n      updateSocketStatus('error', 'Connection Error');\n      resolve(false);\n    }\n  });\n}\n\n/**\n * Set up Socket.IO event handlers\n */\nfunction setupEventHandlers() {\n  if (!socket) return;\n  \n  // Connection established\n  socket.on('connect', () => {\n    console.log(`Socket.IO connected with ID: ${socket.id}`);\n    connected = true;\n    reconnectAttempts = 0;\n    \n    // Store connect time for uptime calculation\n    socket._connectTime = Date.now();\n    \n    // Update UI status\n    updateSocketStatus('connected', 'Connected');\n    \n    // Check for ongoing tasks after connection is established\n    checkForOngoingTasks();\n    \n    // Emit event through event registry\n    if (eventRegistry && typeof eventRegistry.emit === 'function') {\n      eventRegistry.emit('socket.connected');\n    }\n  });\n  \n  // Connection closed\n  socket.on('disconnect', (reason) => {\n    console.log(`Socket.IO disconnected: ${reason}`);\n    connected = false;\n    \n    // Update UI status\n    updateSocketStatus('disconnected', `Disconnected: ${reason}`);\n    \n    // Emit event through event registry\n    if (eventRegistry && typeof eventRegistry.emit === 'function') {\n      eventRegistry.emit('socket.disconnected', { reason });\n    }\n    \n    // Start polling for active tasks\n    activeTasks.forEach(taskId => {\n      if (!pollingIntervals[taskId]) {\n        startStatusPolling(taskId);\n      }\n    });\n  });\n  \n  // Reconnection attempt\n  socket.on('reconnect_attempt', (attemptNumber) => {\n    console.log(`Socket.IO reconnect attempt ${attemptNumber}`);\n    reconnectAttempts = attemptNumber;\n    \n    // Update UI status\n    updateSocketStatus('connecting', `Reconnecting (${attemptNumber})...`);\n    \n    // Emit event through event registry\n    if (eventRegistry && typeof eventRegistry.emit === 'function') {\n      eventRegistry.emit('socket.reconnect_attempt', { attemptNumber });\n    }\n  });\n  \n  // Reconnection failed\n  socket.on('reconnect_failed', () => {\n    console.log('Socket.IO reconnection failed');\n    \n    // Update UI status\n    updateSocketStatus('error', 'Reconnection failed');\n    \n    // Emit event through event registry\n    if (eventRegistry && typeof eventRegistry.emit === 'function') {\n      eventRegistry.emit('socket.reconnect_failed');\n    }\n    \n    // Start polling for active tasks\n    activeTasks.forEach(taskId => {\n      if (!pollingIntervals[taskId]) {\n        startStatusPolling(taskId);\n      }\n    });\n  });\n  \n  // Reconnection error\n  socket.on('reconnect_error', (error) => {\n    console.error('Socket.IO reconnection error:', error);\n    \n    // Update UI status\n    updateSocketStatus('error', 'Reconnection error');\n    \n    // Emit event through event registry\n    if (eventRegistry && typeof eventRegistry.emit === 'function') {\n      eventRegistry.emit('socket.reconnect_error', { error });\n    }\n  });\n  \n  // Connection error\n  socket.on('connect_error', (error) => {\n    console.error('Socket.IO connection error:', error);\n    \n    // Update UI status\n    updateSocketStatus('error', 'Connection error');\n    \n    // Emit event through event registry\n    if (eventRegistry && typeof eventRegistry.emit === 'function') {\n      eventRegistry.emit('socket.connect_error', { error });\n    }\n  });\n  \n  // Ping response\n  socket.on('pong', (data) => {\n    const roundTripTime = Date.now() - (data.timestamp || 0);\n    console.log(`Socket.IO ping response: ${roundTripTime}ms`);\n    \n    // Emit event through event registry\n    if (eventRegistry && typeof eventRegistry.emit === 'function') {\n      eventRegistry.emit('socket.pong', { roundTripTime });\n    }\n  });\n  \n  // General error\n  socket.on('error', (error) => {\n    console.error('Socket.IO error:', error);\n    \n    // Update UI status\n    updateSocketStatus('error', 'Socket Error');\n    \n    // Emit event through event registry\n    if (eventRegistry && typeof eventRegistry.emit === 'function') {\n      eventRegistry.emit('socket.error', { error });\n    }\n  });\n}\n\n/**\n * Start a keep-alive ping interval\n * @param {number} intervalMs - Ping interval in milliseconds\n * @returns {number} - Interval ID\n */\nfunction startPingInterval(intervalMs = 25000) {\n  // Clear existing interval if any\n  if (pingInterval) {\n    clearInterval(pingInterval);\n  }\n  \n  // Create new interval\n  pingInterval = setInterval(() => {\n    if (socket && connected) {\n      socket.emit(SOCKET_EVENTS.CLIENT_TO_SERVER.PING, { timestamp: Date.now() });\n    }\n  }, intervalMs);\n  \n  return pingInterval;\n}\n\n/**\n * Set up handlers for application-specific Socket.IO events\n */\nfunction setupCustomEventHandlers() {\n  if (!socket) return;\n  \n  // Task progress update (Blueprint event)\n  socket.on(TASK_EVENTS.PROGRESS, (data) => {\n    console.log(\"Progress update received:\", data);\n    handleProgressUpdate(data);\n  });\n  \n  // Also listen for task_progress event (legacy compatibility)\n  socket.on('task_progress', (data) => {\n    console.log(\"Task progress update received (legacy):\", data);\n    handleProgressUpdate(data);\n  });\n  \n  // Task completed (Blueprint event)\n  socket.on(TASK_EVENTS.COMPLETED, (data) => {\n    console.log(\"Task completed:\", data);\n    handleTaskCompleted(data);\n  });\n  \n  // Task error (Blueprint event)\n  socket.on(TASK_EVENTS.ERROR, (data) => {\n    console.error(\"Task error:\", data);\n    handleTaskError(data);\n  });\n  \n  // Task cancelled (Blueprint event)\n  socket.on(TASK_EVENTS.CANCELLED, (data) => {\n    console.log(\"Task cancelled:\", data);\n    handleTaskCancelled(data);\n  });\n  \n  // PDF Download events (Blueprint events)\n  socket.on(SERVER_EVENTS.PDF_DOWNLOAD_PROGRESS, (data) => {\n    console.log(\"PDF download progress:\", data);\n    \n    // Emit event through eventRegistry\n    if (eventRegistry && typeof eventRegistry.emit === 'function') {\n      eventRegistry.emit('socket.pdf_download_progress', data);\n    }\n    \n    // Dynamic import of webScraper to avoid circular dependencies\n    import('./webScraper.js')\n      .then(module => {\n        const scraper = module.default || module;\n        if (typeof scraper.updatePdfDownloadProgress === 'function') {\n          scraper.updatePdfDownloadProgress(data);\n        }\n      })\n      .catch(err => {\n        console.warn(\"Could not import webScraper module for PDF updates:\", err);\n      });\n  });\n  \n  // PDF Processing events (Blueprint events)\n  socket.on(SERVER_EVENTS.PDF_PROCESSING_STARTED, (data) => {\n    console.log(\"PDF processing started:\", data);\n    \n    // Emit event through eventRegistry\n    if (eventRegistry && typeof eventRegistry.emit === 'function') {\n      eventRegistry.emit('socket.pdf_processing_start', data);\n    }\n  });\n  \n  socket.on(SERVER_EVENTS.PDF_PROCESSING_PROGRESS, (data) => {\n    console.log(\"PDF processing update:\", data);\n    \n    // Emit event through eventRegistry\n    if (eventRegistry && typeof eventRegistry.emit === 'function') {\n      eventRegistry.emit('socket.pdf_processing_update', data);\n    }\n  });\n  \n  socket.on('pdf_processing_complete', (data) => {\n    console.log(\"PDF processing complete:\", data);\n    \n    // Emit event through eventRegistry\n    if (eventRegistry && typeof eventRegistry.emit === 'function') {\n      eventRegistry.emit('socket.pdf_processing_complete', data);\n    }\n    \n    // Show notification\n    showToast('PDF Processed', 'PDF processing completed successfully', 'success');\n  });\n  \n  socket.on('pdf_processing_error', (data) => {\n    console.error(\"PDF processing error:\", data);\n    \n    // Emit event through eventRegistry\n    if (eventRegistry && typeof eventRegistry.emit === 'function') {\n      eventRegistry.emit('socket.pdf_processing_error', data);\n    }\n    \n    // Show error notification\n    showToast('PDF Processing Error', data.error || 'Error processing PDF', 'error');\n  });\n  \n  // Batch processing events\n  socket.on('batch_processing_start', (data) => {\n    console.log(\"Batch processing started:\", data);\n    \n    if (eventRegistry) {\n      eventRegistry.emit('socket.batch_processing_start', data);\n    }\n  });\n  \n  socket.on('batch_processing_progress', (data) => {\n    console.log(\"Batch processing progress:\", data);\n    \n    if (eventRegistry) {\n      eventRegistry.emit('socket.batch_processing_progress', data);\n    }\n  });\n  \n  socket.on('batch_processing_complete', (data) => {\n    console.log(\"Batch processing complete:\", data);\n    \n    if (eventRegistry) {\n      eventRegistry.emit('socket.batch_processing_complete', data);\n    }\n    \n    showToast('Batch Complete', 'Batch processing completed successfully', 'success');\n  });\n  \n  socket.on('batch_processing_error', (data) => {\n    console.error(\"Batch processing error:\", data);\n    \n    if (eventRegistry) {\n      eventRegistry.emit('socket.batch_processing_error', data);\n    }\n    \n    showToast('Batch Error', data.error || 'Error in batch processing', 'error');\n  });\n  \n  // Playlist events\n  socket.on('playlist_progress', (data) => {\n    console.log(\"Playlist progress:\", data);\n    \n    if (eventRegistry) {\n      eventRegistry.emit('socket.playlist_progress', data);\n    }\n    \n    // Also handle as generic progress update for backward compatibility\n    handleProgressUpdate(data);\n  });\n  \n  socket.on('playlist_completed', (data) => {\n    console.log(\"Playlist completed:\", data);\n    \n    if (eventRegistry) {\n      eventRegistry.emit('socket.playlist_completed', data);\n    }\n    \n    // Also handle as task completion for backward compatibility\n    handleTaskCompleted(data);\n  });\n  \n  console.log(\"Socket event handlers registered\");\n}\n\n/**\n * Handle task progress updates\n */\nfunction handleProgressUpdate(data) {\n  if (!data || !data.task_id) return;\n  \n  console.log('Progress update received:', data);\n  \n  // Track this task\n  activeTasks.add(data.task_id);\n  \n  // Update current task ID for backward compatibility\n  currentTaskId = data.task_id;\n  \n  // Update task status request time to prevent spam\n  taskStatusRequests.set(data.task_id, Date.now());\n  \n  // Update active task tracker for backward compatibility\n  if (activeTaskTracker && activeTaskTracker.taskId === data.task_id) {\n    activeTaskTracker.updateProgress(\n      data.progress || 0,\n      data.message || \"\",\n      data.stats || {}\n    );\n  }\n  \n  // Update UI via progressHandler if available\n  if (window.progressHandler && typeof window.progressHandler.updateTaskProgress === 'function') {\n    window.progressHandler.updateTaskProgress(\n      data.task_id,\n      data.progress,\n      data.message,\n      data.stats\n    );\n  } else {\n    // Fall back to direct UI update\n    updateGenericProgress(data);\n  }\n  \n  // Call any registered callbacks\n  const callbacks = taskCallbacks.get(data.task_id);\n  if (callbacks && typeof callbacks.onProgress === 'function') {\n    callbacks.onProgress(data);\n  }\n  \n  // Emit via event registry\n  if (eventRegistry && typeof eventRegistry.emit === 'function') {\n    eventRegistry.emit('socket.progress_update', data);\n    eventRegistry.emit('progress.update', data);\n  }\n  \n  // Enhanced completion detection\n  // If progress is 100% or status is \"completed\", consider the task complete\n  const isCompleted = \n    data.status === 'completed' || \n    (data.stats && data.stats.status === 'completed') ||\n    data.progress >= 100 ||\n    (data.progress >= 99 && isCompletionPhase(data));\n  \n  if (isCompleted) {\n    console.log(`Task ${data.task_id} detected as complete via progress update`);\n    \n    // Force data to have progress = 100% for proper UI update\n    const completeData = {\n      ...data,\n      progress: 100,\n      status: 'completed'\n    };\n    \n    // Call completion handler after a short delay to allow for any actual\n    // completion event that might be sent by the server\n    setTimeout(() => {\n      if (activeTasks.has(data.task_id)) {\n        handleTaskCompleted(completeData);\n      }\n    }, 250);\n  }\n}\n\n/**\n * Helper function to check if data indicates completion phase\n */\nfunction isCompletionPhase(data) {\n  // Check various completion indicators\n  return (\n    data.status === \"completed\" || \n    (data.stats && data.stats.status === \"completed\") ||\n    (data.message && (\n      data.message.toLowerCase().includes(\"complet\") ||\n      data.message.toLowerCase().includes(\"done\") ||\n      data.message.toLowerCase().includes(\"finish\")\n    )) ||\n    (data.progress >= 45 && data.stats && data.stats.total_playlists) || // YouTube playlist specific\n    (data.progress >= 99.5) ||\n    (data.progress >= 99 && data.stats && \n     data.stats.processed_files === data.stats.total_files)\n  );\n}\n\n/**\n * Handle task completion\n */\nfunction handleTaskCompleted(data) {\n  if (!data || !data.task_id) return;\n  \n  console.log('Task completion received:', data);\n  \n  // Update active task tracker for backward compatibility\n  if (activeTaskTracker && activeTaskTracker.taskId === data.task_id) {\n    activeTaskTracker.complete();\n    activeTaskTracker = null;\n  }\n  \n  // Update current task ID for backward compatibility\n  if (currentTaskId === data.task_id) {\n    currentTaskId = null;\n  }\n  \n  // Update UI via progressHandler if available\n  if (window.progressHandler && typeof window.progressHandler.completeTask === 'function') {\n    window.progressHandler.completeTask(data.task_id, data);\n  } else {\n    // Fall back to generic completion handling\n    showGenericCompletionMessage(data);\n  }\n  \n  // Call any registered callbacks\n  const callbacks = taskCallbacks.get(data.task_id);\n  if (callbacks && typeof callbacks.onComplete === 'function') {\n    callbacks.onComplete(data);\n  }\n  \n  // Emit via event registry\n  if (eventRegistry && typeof eventRegistry.emit === 'function') {\n    eventRegistry.emit('socket.task_completed', data);\n    eventRegistry.emit('progress.completed', data);\n    \n    // Special case for playlists\n    if (data.type === 'playlist' || sessionStorage.getItem('ongoingTaskType') === 'playlist') {\n      eventRegistry.emit('socket.playlist_completed', data);\n    }\n  }\n  \n  // Stop polling if active\n  stopStatusPolling(data.task_id);\n  \n  // Remove from active tasks\n  activeTasks.delete(data.task_id);\n  \n  // Clean up callbacks\n  taskCallbacks.delete(data.task_id);\n  \n  // Clean up status requests\n  taskStatusRequests.delete(data.task_id);\n  \n  // Clear session storage if this is the current task\n  const storedTaskId = sessionStorage.getItem('ongoingTaskId');\n  if (storedTaskId === data.task_id) {\n    sessionStorage.removeItem('ongoingTaskId');\n    sessionStorage.removeItem('ongoingTaskType');\n    sessionStorage.removeItem('taskStartTime');\n  }\n  \n  // Show success notification\n  showToast('Task Completed', 'Processing completed successfully', 'success');\n}\n\n/**\n * Handle task errors\n */\nfunction handleTaskError(data) {\n  if (!data || !data.task_id) return;\n  \n  console.error('Task error received:', data);\n  \n  // Update active task tracker for backward compatibility\n  if (activeTaskTracker && activeTaskTracker.taskId === data.task_id) {\n    activeTaskTracker = null;\n  }\n  \n  // Update current task ID for backward compatibility\n  if (currentTaskId === data.task_id) {\n    currentTaskId = null;\n  }\n  \n  // Update UI via progressHandler if available\n  if (window.progressHandler && typeof window.progressHandler.errorTask === 'function') {\n    window.progressHandler.errorTask(data.task_id, data.error || 'Unknown error');\n  } else {\n    // Fall back to generic error handling\n    showGenericErrorMessage(data);\n  }\n  \n  // Call any registered callbacks\n  const callbacks = taskCallbacks.get(data.task_id);\n  if (callbacks && typeof callbacks.onError === 'function') {\n    callbacks.onError(data);\n  }\n  \n  // Emit via event registry\n  if (eventRegistry && typeof eventRegistry.emit === 'function') {\n    eventRegistry.emit('socket.task_error', data);\n    eventRegistry.emit('progress.error', data);\n  }\n  \n  // Show error toast\n  showToast('Task Error', data.error || 'An error occurred with the task', 'error');\n  \n  // Stop polling if active\n  stopStatusPolling(data.task_id);\n  \n  // Remove from active tasks\n  activeTasks.delete(data.task_id);\n  \n  // Clean up callbacks\n  taskCallbacks.delete(data.task_id);\n  \n  // Clean up status requests\n  taskStatusRequests.delete(data.task_id);\n  \n  // Clear session storage if this is the current task\n  const storedTaskId = sessionStorage.getItem('ongoingTaskId');\n  if (storedTaskId === data.task_id) {\n    sessionStorage.removeItem('ongoingTaskId');\n    sessionStorage.removeItem('ongoingTaskType');\n    sessionStorage.removeItem('taskStartTime');\n  }\n}\n\n/**\n * Handle task cancellation\n */\nfunction handleTaskCancelled(data) {\n  if (!data || !data.task_id) return;\n  \n  console.log('Task cancellation received:', data);\n  \n  // Update active task tracker for backward compatibility\n  if (activeTaskTracker && activeTaskTracker.taskId === data.task_id) {\n    activeTaskTracker = null;\n  }\n  \n  // Update current task ID for backward compatibility\n  if (currentTaskId === data.task_id) {\n    currentTaskId = null;\n  }\n  \n  // Update UI via progressHandler if available\n  if (window.progressHandler && typeof window.progressHandler.cancelTask === 'function') {\n    window.progressHandler.cancelTask(data.task_id);\n  }\n  \n  // Call any registered callbacks\n  const callbacks = taskCallbacks.get(data.task_id);\n  if (callbacks && typeof callbacks.onCancel === 'function') {\n    callbacks.onCancel(data);\n  }\n  \n  // Emit via event registry\n  if (eventRegistry && typeof eventRegistry.emit === 'function') {\n    eventRegistry.emit('socket.task_cancelled', data);\n    eventRegistry.emit('progress.cancelled', data);\n  }\n  \n  // Show toast\n  showToast('Task Cancelled', 'The task was cancelled', 'warning');\n  \n  // Stop polling if active\n  stopStatusPolling(data.task_id);\n  \n  // Remove from active tasks\n  activeTasks.delete(data.task_id);\n  \n  // Clean up callbacks\n  taskCallbacks.delete(data.task_id);\n  \n  // Clean up status requests\n  taskStatusRequests.delete(data.task_id);\n  \n  // Clear session storage if this is the current task\n  const storedTaskId = sessionStorage.getItem('ongoingTaskId');\n  if (storedTaskId === data.task_id) {\n    sessionStorage.removeItem('ongoingTaskId');\n    sessionStorage.removeItem('ongoingTaskType');\n    sessionStorage.removeItem('taskStartTime');\n  }\n}\n\n/**\n * Update generic progress UI elements directly\n * Used as a fallback when module-specific handlers aren't available\n * @param {Object} data - Progress data\n */\nfunction updateGenericProgress(data) {\n  if (!data) return;\n  \n  try {\n    // Get common progress elements by ID\n    const progressBar = getElement('progress-bar');\n    const progressStatus = getElement('progress-status');\n    const progressStats = getElement('progress-stats');\n    \n    // Try for task-specific elements first\n    const taskType = getTaskType(data.task_id);\n    const typeProgressBar = getElement(`${taskType}-progress-bar`);\n    const typeProgressStatus = getElement(`${taskType}-progress-status`);\n    const typeProgressStats = getElement(`${taskType}-progress-stats`);\n    \n    // Update progress bar (use type-specific if available)\n    const bar = typeProgressBar || progressBar;\n    if (bar && typeof data.progress === 'number') {\n      bar.style.width = `${data.progress}%`;\n      bar.setAttribute('aria-valuenow', data.progress);\n      bar.textContent = `${Math.round(data.progress)}%`;\n      \n      // Update contextual classes based on progress\n      bar.classList.remove('bg-danger', 'bg-warning', 'bg-info');\n      if (data.progress >= 100) {\n        bar.classList.add('bg-success');\n      } else if (data.progress >= 75) {\n        bar.classList.add('bg-info');\n      } else if (data.progress >= 25) {\n        bar.classList.add('bg-primary');\n      }\n    }\n    \n    // Update status message\n    const status = typeProgressStatus || progressStatus;\n    if (status && data.message) {\n      status.textContent = data.message;\n    }\n    \n    // Update stats with basic info\n    const stats = typeProgressStats || progressStats;\n    if (stats && data.stats) {\n      updateGenericStatsDisplay(stats, data.stats);\n    }\n  } catch (error) {\n    console.error(\"Error updating generic progress:\", error);\n  }\n}\n\n/**\n * Update generic stats display with formatted information\n * @param {HTMLElement} element - Stats container element\n * @param {Object} stats - Task statistics\n */\nfunction updateGenericStatsDisplay(element, stats) {\n  if (!element || !stats) return;\n  \n  try {\n    // Create HTML content for stats\n    let html = '<div class=\"stats-container p-2\">';\n    \n    // Handle different types of stats\n    if (stats.total_files !== undefined) {\n      // File processing stats\n      html += `\n        <div class=\"row\">\n          <div class=\"col-6 col-md-3\">\n            <span class=\"badge bg-primary\">Total: ${stats.total_files || 0}</span>\n          </div>\n          <div class=\"col-6 col-md-3\">\n            <span class=\"badge bg-success\">Processed: ${stats.processed_files || 0}</span>\n          </div>\n          <div class=\"col-6 col-md-3\">\n            <span class=\"badge bg-warning\">Skipped: ${stats.skipped_files || 0}</span>\n          </div>\n          <div class=\"col-6 col-md-3\">\n            <span class=\"badge bg-danger\">Errors: ${stats.error_files || 0}</span>\n          </div>\n        </div>\n      `;\n      \n      // Add current file if available\n      if (stats.current_file) {\n        html += `\n          <div class=\"text-truncate small mt-2\">\n            <i class=\"fas fa-file-alt me-1\"></i> ${stats.current_file}\n          </div>\n        `;\n      }\n    } else if (stats.pdf_downloads !== undefined) {\n      // PDF download stats\n      html += `\n        <div class=\"row\">\n          <div class=\"col-6 col-md-3\">\n            <span class=\"badge bg-primary\">PDFs: ${stats.pdf_downloads.total || 0}</span>\n          </div>\n          <div class=\"col-6 col-md-3\">\n            <span class=\"badge bg-success\">Downloaded: ${stats.pdf_downloads.completed || 0}</span>\n          </div>\n          <div class=\"col-6 col-md-3\">\n            <span class=\"badge bg-info\">In Progress: ${stats.pdf_downloads.downloading || 0}</span>\n          </div>\n          <div class=\"col-6 col-md-3\">\n            <span class=\"badge bg-danger\">Failed: ${stats.pdf_downloads.failed || 0}</span>\n          </div>\n        </div>\n      `;\n    } else if (stats.playlists) {\n      // Playlist stats\n      const total = stats.playlists.length || stats.total_playlists || 0;\n      let totalVideos = 0;\n      let downloadedVideos = 0;\n      \n      if (Array.isArray(stats.playlists)) {\n        stats.playlists.forEach(playlist => {\n          if (playlist.videos) {\n            totalVideos += playlist.videos.length;\n            downloadedVideos += playlist.videos.filter(v => v.status === 'completed').length;\n          }\n        });\n      } else {\n        totalVideos = stats.total_videos || 0;\n        downloadedVideos = stats.processed_videos || 0;\n      }\n      \n      html += `\n        <div class=\"row\">\n          <div class=\"col-12 mb-2\">\n            <span class=\"badge bg-primary\">Playlists: ${total}</span>\n            <span class=\"badge bg-success mx-1\">Downloaded: ${downloadedVideos}/${totalVideos}</span>\n          </div>\n        </div>\n      `;\n      \n      // Show current video\n      if (stats.current_video) {\n        html += `\n          <div class=\"text-truncate small mt-2\">\n            <i class=\"fas fa-video me-1\"></i> ${stats.current_video}\n          </div>\n        `;\n      }\n    } else {\n      // Generic stats - display key-value pairs\n      html += '<div class=\"row\">';\n      \n      Object.entries(stats).forEach(([key, value]) => {\n        // Skip internal or complex properties\n        if (key.startsWith('_') || typeof value === 'object') return;\n        \n        const label = key.replace(/_/g, ' ').replace(/\\b\\w/g, c => c.toUpperCase());\n        \n        html += `\n          <div class=\"col-6 col-md-4 mb-1\">\n            <small>${label}:</small>\n            <span class=\"fw-bold\">${value}</span>\n          </div>\n        `;\n      });\n      \n      html += '</div>';\n    }\n    \n    html += '</div>';\n    \n    // Update stats container\n    element.innerHTML = html;\n  } catch (error) {\n    console.error(\"Error updating generic stats display:\", error);\n  }\n}\n\n/**\n * Check for ongoing tasks when connection is established\n */\nfunction checkForOngoingTasks() {\n  const storedTaskId = sessionStorage.getItem('ongoingTaskId');\n  const taskType = sessionStorage.getItem('ongoingTaskType');\n  \n  if (storedTaskId) {\n    console.log(`Found ongoing task: ${storedTaskId} (${taskType || 'unknown'})`);\n    \n    // Add to active tasks set\n    activeTasks.add(storedTaskId);\n    \n    // Set current task ID for backward compatibility\n    currentTaskId = storedTaskId;\n    \n    // Create task tracker for backward compatibility\n    activeTaskTracker = createTaskTracker(storedTaskId);\n    \n    // Start status polling for this task\n    startStatusPolling(storedTaskId);\n    \n    // Request initial status\n    requestTaskStatus(storedTaskId);\n    \n    // Show notification\n    showToast('Task Resumed', 'Reconnected to ongoing task', 'info');\n    \n    // Try to emit an event via event registry\n    if (eventRegistry && typeof eventRegistry.emit === 'function') {\n      eventRegistry.emit('task.resumed', {\n        task_id: storedTaskId,\n        task_type: taskType || 'unknown'\n      });\n    }\n  }\n}\n\n/**\n * Request task status via Socket.IO\n * @param {string} taskId - Task ID to get status for\n * @returns {boolean} - Whether the request was sent successfully\n */\nfunction requestTaskStatus(taskId) {\n  if (!taskId) return false;\n  \n  // Add to active tasks\n  activeTasks.add(taskId);\n  \n  // Update current task ID for backward compatibility\n  currentTaskId = taskId;\n  \n  // Track request time to prevent spam\n  const now = Date.now();\n  const lastRequest = taskStatusRequests.get(taskId) || 0;\n  \n  // Limit requests to once per second\n  if (now - lastRequest < 1000) {\n    return false;\n  }\n  \n  taskStatusRequests.set(taskId, now);\n  \n  // Request via Socket.IO if available\n  if (socket && connected) {\n    try {\n      socket.emit(SOCKET_EVENTS.CLIENT_TO_SERVER.REQUEST_TASK_STATUS, { task_id: taskId });\n      console.log(`Requested status for task ${taskId} via Socket.IO`);\n      return true;\n    } catch (error) {\n      console.warn(`Error requesting status via Socket.IO:`, error);\n    }\n  }\n  \n  // Fallback to HTTP API request\n  fetchTaskStatus(taskId);\n  return false;\n}\n\n/**\n * Fetch task status via HTTP API\n * @param {string} taskId - Task ID to get status for\n * @returns {Promise<boolean>} - Whether the status was fetched successfully\n */\nasync function fetchTaskStatus(taskId) {\n  try {\n    // Try multiple endpoints for better compatibility\n    const endpoints = [\n      `/api/task/status/${taskId}`,\n      `/api/status/${taskId}`\n    ];\n    \n    for (const endpoint of endpoints) {\n      try {\n        const response = await fetch(endpoint);\n        if (response.ok) {\n          const data = await response.json();\n          \n          // Process the response\n          if (data.status === 'completed') {\n            handleTaskCompleted({\n              task_id: taskId,\n              ...data\n            });\n            return true;\n          } else if (data.status === 'error' || data.status === 'failed') {\n            handleTaskError({\n              task_id: taskId,\n              error: data.error || 'Task failed',\n              ...data\n            });\n            return true;\n          } else if (data.status === 'cancelled') {\n            handleTaskCancelled({\n              task_id: taskId,\n              ...data\n            });\n            return true;\n          } else if (data.progress !== undefined) {\n            handleProgressUpdate({\n              task_id: taskId,\n              ...data\n            });\n            return true;\n          }\n          \n          // We found a working endpoint, no need to try others\n          break;\n        }\n      } catch (err) {\n        console.warn(`Error fetching task status from ${endpoint}:`, err);\n        // Continue to next endpoint\n      }\n    }\n    \n    return false;\n  } catch (error) {\n    console.error(`Error fetching task status for ${taskId}:`, error);\n    return false;\n  }\n}\n\n/**\n * Start polling for task status updates\n * @param {string} taskId - Task ID to poll for\n * @param {Object} callbacks - Optional callbacks for task events\n * @returns {boolean} - Whether polling was started successfully\n */\nfunction startStatusPolling(taskId, callbacks = {}) {\n  if (!taskId) return false;\n  \n  // Register callbacks\n  if (Object.keys(callbacks).length > 0) {\n    taskCallbacks.set(taskId, callbacks);\n  }\n  \n  // Stop any existing polling\n  stopStatusPolling(taskId);\n  \n  // Add to active tasks\n  activeTasks.add(taskId);\n  \n  // Update current task ID for backward compatibility\n  currentTaskId = taskId;\n  \n  // Create task tracker for backward compatibility if needed\n  if (!activeTaskTracker || activeTaskTracker.taskId !== taskId) {\n    activeTaskTracker = createTaskTracker(taskId);\n  }\n  \n  // Start polling interval\n  console.log(`Starting status polling for task ${taskId}`);\n  requestTaskStatus(taskId); // Request immediately\n  \n  pollingIntervals[taskId] = setInterval(() => {\n    requestTaskStatus(taskId);\n  }, 2000); // Poll every 2 seconds\n  \n  return true;\n}\n\n/**\n * Stop polling for task status updates\n * @param {string} taskId - Task ID to stop polling for\n * @returns {boolean} - Whether polling was stopped successfully\n */\nfunction stopStatusPolling(taskId) {\n  if (!taskId) {\n    // If no taskId provided, stop all polling (for backward compatibility)\n    Object.keys(pollingIntervals).forEach(id => {\n      clearInterval(pollingIntervals[id]);\n      delete pollingIntervals[id];\n    });\n    return true;\n  }\n  \n  if (!pollingIntervals[taskId]) return false;\n  \n  clearInterval(pollingIntervals[taskId]);\n  delete pollingIntervals[taskId];\n  console.log(`Stopped status polling for task ${taskId}`);\n  \n  return true;\n}\n\n/**\n * Cancel a task\n * @param {string} taskId - Task ID to cancel\n * @returns {Promise<boolean>} - Whether the task was cancelled successfully\n */\nfunction cancelTask(taskId) {\n  if (!taskId) return Promise.reject(new Error('No task ID provided'));\n  \n  console.log(`Cancelling task ${taskId}`);\n  \n  return new Promise((resolve, reject) => {\n    let cancellationSent = false;\n    \n    // Try Socket.IO if available\n    if (socket && connected) {\n      try {\n        socket.emit(SOCKET_EVENTS.CLIENT_TO_SERVER.CANCEL_TASK, { task_id: taskId });\n        console.log(`Sent cancel_task event via Socket.IO`);\n        cancellationSent = true;\n      } catch (error) {\n        console.warn(`Error sending cancel via Socket.IO:`, error);\n      }\n    }\n    \n    // Also try HTTP API for redundancy\n    const cancelEndpoints = [\n      `/api/task/cancel/${taskId}`,\n      `/api/cancel_task/${taskId}`,\n      `/api/cancel_task` // POST endpoint\n    ];\n    \n    // Try POST to the main cancel endpoint first\n    fetch(`/api/cancel_task`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ task_id: taskId })\n    })\n    .then(response => {\n      if (response.ok) {\n        console.log(`Successfully cancelled task via POST /api/cancel_task`);\n        cancellationSent = true;\n        resolve(true);\n      } else {\n        // Try other endpoints\n        tryOtherEndpoints();\n      }\n    })\n    .catch(error => {\n      console.warn(`Error with POST cancel endpoint:`, error);\n      // Try other endpoints\n      tryOtherEndpoints();\n    });\n    \n    // Try other endpoints as fallback\n    function tryOtherEndpoints() {\n      Promise.all(cancelEndpoints.slice(0, 2).map(endpoint => {\n        return fetch(endpoint, { method: 'POST' })\n          .then(response => {\n            if (response.ok) {\n              console.log(`Successfully cancelled task via ${endpoint}`);\n              cancellationSent = true;\n              return true;\n            } else {\n              return false;\n            }\n          })\n          .catch(() => false);\n      }))\n      .then(results => {\n        if (results.some(result => result) || cancellationSent) {\n          resolve(true);\n        } else {\n          reject(new Error('Failed to send cancellation request'));\n        }\n      });\n    }\n    \n    // Emit event for other modules\n    if (eventRegistry && typeof eventRegistry.emit === 'function') {\n      eventRegistry.emit('socket.cancel_task', { task_id: taskId });\n    }\n    \n    // Remove from active tasks\n    activeTasks.delete(taskId);\n    \n    // Update current task ID for backward compatibility\n    if (currentTaskId === taskId) {\n      currentTaskId = null;\n    }\n    \n    // Clean up polling\n    stopStatusPolling(taskId);\n    \n    // Clean up task tracker for backward compatibility\n    if (activeTaskTracker && activeTaskTracker.taskId === taskId) {\n      activeTaskTracker = null;\n    }\n  });\n}\n\n/**\n * Get status of a task\n * @param {string} taskId - Task ID to get status for\n * @returns {Promise<Object>} - Task status data\n */\nfunction getTaskStatus(taskId) {\n  return new Promise((resolve, reject) => {\n    if (!taskId) {\n      reject(new Error('No task ID provided'));\n      return;\n    }\n    \n    // Try Socket.IO first if available\n    if (socket && connected) {\n      // Set up a one-time listener for the response\n      const responseHandler = (data) => {\n        if (data.task_id === taskId) {\n          socket.off('task_status', responseHandler);\n          resolve(data);\n        }\n      };\n      \n      socket.on('task_status', responseHandler);\n      \n      // Set a timeout to fall back to HTTP API if no response\n      const timeout = setTimeout(() => {\n        socket.off('task_status', responseHandler);\n        fetchTaskStatusOnce();\n      }, 2000);\n      \n      // Send the request\n      try {\n        socket.emit(SOCKET_EVENTS.CLIENT_TO_SERVER.REQUEST_TASK_STATUS, { task_id: taskId });\n        return;\n      } catch (error) {\n        console.warn(`Error requesting status via Socket.IO:`, error);\n        clearTimeout(timeout);\n        socket.off('task_status', responseHandler);\n        fetchTaskStatusOnce();\n      }\n    } else {\n      fetchTaskStatusOnce();\n    }\n    \n    // Fetch status via HTTP API\n    async function fetchTaskStatusOnce() {\n      try {\n        const endpoints = [\n          `/api/task/status/${taskId}`,\n          `/api/status/${taskId}`\n        ];\n        \n        for (const endpoint of endpoints) {\n          try {\n            const response = await fetch(endpoint);\n            if (response.ok) {\n              const data = await response.json();\n              resolve({\n                task_id: taskId,\n                ...data\n              });\n              return;\n            }\n          } catch (err) {\n            console.warn(`Error fetching from ${endpoint}:`, err);\n          }\n        }\n        \n        reject(new Error('Failed to get task status'));\n      } catch (error) {\n        reject(error);\n      }\n    }\n  });\n}\n\n/**\n * Register task handler for events\n * @param {string} taskId - Task ID\n * @param {Object} handlers - Event handlers\n * @returns {boolean} - Whether registration was successful\n */\nfunction registerTaskHandler(taskId, handlers) {\n  if (!taskId) return false;\n  \n  // Add to active tasks\n  activeTasks.add(taskId);\n  \n  // Register handlers\n  taskCallbacks.set(taskId, handlers);\n  \n  return true;\n}\n\n/**\n * Register callbacks for task progress (backward compatibility)\n * @param {string} taskId - Task ID\n * @param {Object} callbacks - Callback functions\n */\nfunction registerProgressCallbacks(taskId, callbacks = {}) {\n  if (!taskId) return;\n  \n  const handlers = {\n    onProgress: callbacks.onProgress || function() {},\n    onComplete: callbacks.onComplete || function() {},\n    onError: callbacks.onError || function() {},\n    onCancel: callbacks.onCancelled || function() {}\n  };\n  \n  taskCallbacks.set(taskId, handlers);\n  console.log(`Registered progress callbacks for task ${taskId}`);\n}\n\n/**\n * Track a task with progress updates\n * @param {string} taskId - Task ID to track\n * @param {Object} options - Options for tracking\n * @returns {Object|null} - Task controller object or null if invalid\n */\nfunction trackTask(taskId, options = {}) {\n  if (!taskId) return null;\n  \n  // Add to active tasks\n  activeTasks.add(taskId);\n  \n  // Update current task ID for backward compatibility\n  currentTaskId = taskId;\n  \n  // Create task tracker for backward compatibility if needed\n  if (!activeTaskTracker || activeTaskTracker.taskId !== taskId) {\n    activeTaskTracker = createTaskTracker(taskId);\n  }\n  \n  // Request initial status\n  requestTaskStatus(taskId);\n  \n  // Start polling if not connected to socket\n  if (!socket || !connected) {\n    startStatusPolling(taskId);\n  }\n  \n  // Return a controller object\n  return {\n    taskId,\n    cancel: () => cancelTask(taskId),\n    refresh: () => requestTaskStatus(taskId),\n    stopTracking: () => {\n      stopStatusPolling(taskId);\n      activeTasks.delete(taskId);\n      taskCallbacks.delete(taskId);\n      if (currentTaskId === taskId) {\n        currentTaskId = null;\n      }\n      if (activeTaskTracker && activeTaskTracker.taskId === taskId) {\n        activeTaskTracker = null;\n      }\n    }\n  };\n}\n\n/**\n * Check if a task is being tracked\n * @param {string} taskId - Task ID to check\n * @returns {boolean} - Whether the task is being tracked\n */\nfunction isTaskTracked(taskId) {\n  return activeTasks.has(taskId);\n}\n\n/**\n * Get all active tasks\n * @returns {Array<string>} - Array of active task IDs\n */\nfunction getActiveTasks() {\n  return Array.from(activeTasks);\n}\n\n/**\n * Clean up all tasks and intervals\n * @returns {boolean} - Whether cleanup was successful\n */\nfunction cleanup() {\n  // Clean up all polling intervals\n  Object.keys(pollingIntervals).forEach(taskId => {\n    clearInterval(pollingIntervals[taskId]);\n    delete pollingIntervals[taskId];\n  });\n  \n  // Clear ping interval\n  if (pingInterval) {\n    clearInterval(pingInterval);\n    pingInterval = null;\n  }\n  \n  // Clear all tracking data\n  activeTasks.clear();\n  taskCallbacks.clear();\n  taskStatusRequests.clear();\n  \n  // Clear backward compatibility variables\n  currentTaskId = null;\n  activeTaskTracker = null;\n  \n  return true;\n}\n\n/**\n * Determine task type from task ID or session storage\n * @param {string} taskId - Task ID\n * @returns {string} - Task type ('file', 'playlist', 'scraper')\n */\nfunction getTaskType(taskId) {\n  // Try to get from session storage first\n  const storedTaskId = sessionStorage.getItem('ongoingTaskId');\n  const storedType = sessionStorage.getItem('ongoingTaskType');\n  \n  if (storedTaskId === taskId && storedType) {\n    return storedType;\n  }\n  \n  // If not stored, guess based on active tab\n  const fileTab = getElement('file-tab');\n  const playlistTab = getElement('playlist-tab');\n  const scraperTab = getElement('scraper-tab');\n  \n  if (fileTab && fileTab.classList.contains('active')) {\n    return 'file';\n  } else if (playlistTab && playlistTab.classList.contains('active')) {\n    return 'playlist';\n  } else if (scraperTab && scraperTab.classList.contains('active')) {\n    return 'scraper';\n  }\n  \n  // Default to 'task' if can't determine\n  return 'task';\n}\n\n/**\n * Emit a custom event\n * @param {string} event - Event name \n * @param {Object} data - Event data\n * @returns {boolean} - Whether event was emitted successfully\n */\nfunction emit(event, data) {\n  if (!socket || !connected) {\n    console.warn(`Cannot emit event ${event}: Socket not connected`);\n    return false;\n  }\n  \n  socket.emit(event, data);\n  return true;\n}\n\n/**\n * Emit a PDF download start event\n * @param {string} url - PDF URL to download\n * @param {string} taskId - Task ID\n * @returns {boolean} - Whether event was emitted successfully\n */\nfunction emitPdfDownloadStart(url, taskId) {\n  return emit('pdf_download_start', { \n    url, \n    task_id: taskId,\n    timestamp: Date.now()\n  });\n}\n\n/**\n * Emit a PDF processing request event\n * @param {Object} params - Parameters for PDF processing\n * @returns {boolean} - Whether event was emitted successfully\n */\nfunction emitPdfProcessingRequest(params) {\n  return emit('pdf_processing_request', params);\n}\n\n/**\n * Disconnect from Socket.IO server\n */\nfunction disconnect() {\n  if (socket) {\n    socket.disconnect();\n    socket = null;\n    connected = false;\n    \n    // Stop status polling\n    Object.keys(pollingIntervals).forEach(taskId => {\n      stopStatusPolling(taskId);\n    });\n    \n    // Clear ping interval\n    if (pingInterval) {\n      clearInterval(pingInterval);\n      pingInterval = null;\n    }\n    \n    // Clean up other state\n    cleanup();\n    \n    // Update UI status\n    updateSocketStatus('disconnected', 'Disconnected by user');\n    \n    console.log(\"Socket.IO disconnected\");\n  }\n}\n\n/**\n * Check if socket is connected\n * @returns {boolean} - Whether socket is connected\n */\nfunction isConnected() {\n  return connected;\n}\n\n/**\n * Get diagnostics information about the module state\n * @returns {Object} - Diagnostic information\n */\nfunction getDiagnostics() {\n  return {\n    version: \"2.0.0\",\n    initialized,\n    connected,\n    hasSocket: !!socket,\n    connectionAttempts,\n    reconnectAttempts,\n    activeTasks: Array.from(activeTasks),\n    activeTaskCount: activeTasks.size,\n    callbacksCount: taskCallbacks.size,\n    pollingIntervalsCount: Object.keys(pollingIntervals).length,\n    eventRegistryAvailable: !!eventRegistry,\n    waitingForDOM: waitForDOMInit,\n    socketId: socket?.id,\n    socketUrl: socket?.io?.uri,\n    legacyActiveTask: currentTaskId,\n    legacyTrackerActive: !!activeTaskTracker\n  };\n}\n\n/**\n * Get current task ID from session storage\n * @returns {string|null} - Current task ID\n */\nfunction getCurrentTaskId() {\n  // First try from the current active task (backward compatibility)\n  if (currentTaskId) {\n    return currentTaskId;\n  }\n  \n  // Then try from session storage\n  return sessionStorage.getItem('ongoingTaskId');\n}\n\n/**\n * Get module state for debugging\n * @returns {Object} - Module state information\n */\nfunction getState() {\n  return {\n    connected,\n    reconnectAttempts,\n    activeTasks: Array.from(activeTasks),\n    hasSocket: !!socket,\n    initialized,\n    eventRegistryAvailable: !!eventRegistry,\n    socketId: socket?.id,\n    connectionUptime: connected ? formatDuration((Date.now() - (socket?._connectTime || Date.now())) / 1000) : 'Not connected',\n    legacyActiveTask: currentTaskId,\n    legacyTrackerActive: !!activeTaskTracker,\n    legacyTrackerProgress: activeTaskTracker ? activeTaskTracker.progress : null\n  };\n}\n\n/**\n * Cancel current task (backward compatibility)\n * @returns {Promise<boolean>} - Whether cancellation was successful\n */\nfunction cancelCurrentTask() {\n  const taskId = currentTaskId || sessionStorage.getItem('ongoingTaskId');\n  \n  if (!taskId) {\n    console.warn(\"No active task to cancel\");\n    return Promise.resolve(false);\n  }\n  \n  return cancelTask(taskId);\n}\n\n/**\n * Send a ping to keep the connection alive (backward compatibility)\n */\nfunction sendPing() {\n  if (!socket || !connected) return;\n  \n  socket.emit(SOCKET_EVENTS.CLIENT_TO_SERVER.PING, { timestamp: Date.now() });\n}\n\n// Export module API using a consistent pattern\nconst socketHandler = {\n  // Core functionality\n  initialize,\n  connect,\n  disconnect,\n  isConnected,\n  emit,\n  \n  // Task tracking\n  startStatusPolling,\n  stopStatusPolling,\n  cancelTask,\n  registerTaskHandler,\n  trackTask,\n  isTaskTracked,\n  getActiveTasks,\n  getCurrentTaskId,\n  getTaskType,\n  getTaskStatus,\n  requestTaskStatus,\n  \n  // PDF-specific methods\n  emitPdfDownloadStart,\n  emitPdfProcessingRequest,\n  \n  // Keep-alive\n  startPingInterval,\n  sendPing,\n  \n  // Cleanup\n  cleanup,\n  \n  // Diagnostics\n  getDiagnostics,\n  getState,\n  \n  // Backward compatibility\n  cancelCurrentTask,\n  registerProgressCallbacks\n};\n\n// Export named exports for compatibility with older code\nexport {\n  initialize,\n  connect,\n  disconnect,\n  isConnected,\n  emit,\n  startStatusPolling,\n  stopStatusPolling,\n  cancelTask,\n  cancelCurrentTask,\n  registerTaskHandler,\n  registerProgressCallbacks,\n  trackTask,\n  isTaskTracked, \n  getActiveTasks,\n  getCurrentTaskId,\n  getTaskType,\n  getTaskStatus,\n  requestTaskStatus,\n  emitPdfDownloadStart,\n  emitPdfProcessingRequest,\n  startPingInterval,\n  sendPing,\n  getDiagnostics,\n  getState,\n  cleanup\n};\n\n// Default export for the module\nexport default socketHandler;","source":"/workspace/modules/static/js/modules/utils/socketHandler.js","title":"socketHandler.js","language":"en"},{"content":"/**\n * System Health Monitor Module\n * \n * Monitors and reports system health status\n * Extracted from index.html to prevent conflicts with the modular system\n */\n\nimport { getElement } from './domUtils.js';\n\nclass SystemHealthMonitor {\n  constructor() {\n    this.healthIndicator = null;\n    this.statusHistory = [];\n    this.initialized = false;\n    this.checkInterval = null;\n    this.lastStatus = null;\n  }\n\n  /**\n   * Initialize the system health monitor\n   */\n  initialize() {\n    if (this.initialized) {\n      console.warn('System health monitor already initialized');\n      return;\n    }\n\n    this.createHealthIndicator();\n    this.startMonitoring();\n    this.initialized = true;\n    console.log('System health monitor initialized');\n  }\n\n  /**\n   * Create the health indicator element\n   */\n  createHealthIndicator() {\n    // Remove any existing indicator\n    const existing = document.getElementById('system-health-indicator');\n    if (existing) {\n      existing.remove();\n    }\n\n    this.healthIndicator = document.createElement('div');\n    this.healthIndicator.id = 'system-health-indicator';\n    this.healthIndicator.className = 'system-health-indicator';\n    this.healthIndicator.style.cssText = `\n      position: fixed;\n      bottom: 10px;\n      left: 10px;\n      background: rgba(0, 0, 0, 0.7);\n      color: white;\n      padding: 5px 10px;\n      border-radius: 5px;\n      font-size: 12px;\n      z-index: 9999;\n      display: none;\n      transition: all 0.3s ease;\n      cursor: pointer;\n    `;\n\n    // Add click handler to show detailed status\n    this.healthIndicator.addEventListener('click', () => this.showDetailedStatus());\n\n    document.body.appendChild(this.healthIndicator);\n  }\n\n  /**\n   * Update health status\n   * @param {string} status - Status type (ok, warning, error, loading)\n   * @param {string} message - Status message\n   * @param {Object} details - Additional details\n   */\n  updateStatus(status, message, details = {}) {\n    if (!this.healthIndicator) return;\n\n    const timestamp = new Date();\n    this.lastStatus = { status, message, details, timestamp };\n    this.statusHistory.push(this.lastStatus);\n\n    // Keep only last 50 status updates\n    if (this.statusHistory.length > 50) {\n      this.statusHistory.shift();\n    }\n\n    this.healthIndicator.style.display = 'block';\n\n    switch (status) {\n      case 'ok':\n        this.healthIndicator.style.background = 'rgba(40, 167, 69, 0.8)';\n        this.healthIndicator.innerHTML = '<i class=\"fas fa-check-circle\"></i> System healthy';\n        \n        // Auto-hide after 2 seconds for OK status\n        setTimeout(() => {\n          if (this.lastStatus && this.lastStatus.status === 'ok') {\n            this.healthIndicator.style.display = 'none';\n          }\n        }, 2000);\n        break;\n\n      case 'loading':\n        this.healthIndicator.style.background = 'rgba(0, 123, 255, 0.8)';\n        this.healthIndicator.innerHTML = `<i class=\"fas fa-spinner fa-spin\"></i> ${message || 'Loading...'}`;\n        break;\n\n      case 'warning':\n        this.healthIndicator.style.background = 'rgba(255, 193, 7, 0.8)';\n        this.healthIndicator.innerHTML = `<i class=\"fas fa-exclamation-triangle\"></i> ${message || 'Warning: System experiencing issues'}`;\n        break;\n\n      case 'error':\n        this.healthIndicator.style.background = 'rgba(220, 53, 69, 0.8)';\n        this.healthIndicator.innerHTML = `<i class=\"fas fa-times-circle\"></i> ${message || 'Error: System failed'}`;\n        break;\n\n      default:\n        this.healthIndicator.style.display = 'none';\n    }\n\n    // Emit custom event for other modules to listen\n    window.dispatchEvent(new CustomEvent('systemHealthUpdate', {\n      detail: { status, message, details, timestamp }\n    }));\n  }\n\n  /**\n   * Start monitoring system health\n   */\n  startMonitoring() {\n    // Initial check after 1 second\n    setTimeout(() => this.checkSystemHealth(), 1000);\n\n    // Regular checks every 30 seconds\n    this.checkInterval = setInterval(() => this.checkSystemHealth(), 30000);\n  }\n\n  /**\n   * Check system health\n   */\n  checkSystemHealth() {\n    const health = {\n      modules: this.checkModules(),\n      socket: this.checkSocketConnection(),\n      memory: this.checkMemoryUsage(),\n      performance: this.checkPerformance()\n    };\n\n    // Determine overall status\n    let overallStatus = 'ok';\n    let issues = [];\n\n    if (!health.modules.loaded) {\n      overallStatus = 'loading';\n      issues.push('Modules loading');\n    } else if (health.modules.failed > 0) {\n      overallStatus = 'warning';\n      issues.push(`${health.modules.failed} modules failed`);\n    }\n\n    if (!health.socket.connected) {\n      if (overallStatus === 'ok') overallStatus = 'warning';\n      issues.push('Socket disconnected');\n    }\n\n    if (health.memory.percentage > 80) {\n      overallStatus = 'warning';\n      issues.push('High memory usage');\n    }\n\n    if (health.performance.slow) {\n      if (overallStatus === 'ok') overallStatus = 'warning';\n      issues.push('Performance degraded');\n    }\n\n    // Update status\n    if (overallStatus === 'ok') {\n      this.updateStatus('ok', 'System healthy', health);\n    } else if (overallStatus === 'loading') {\n      this.updateStatus('loading', issues.join(', '), health);\n    } else {\n      this.updateStatus(overallStatus, issues.join(', '), health);\n    }\n  }\n\n  /**\n   * Check module loading status\n   */\n  checkModules() {\n    const status = {\n      loaded: false,\n      total: 0,\n      failed: 0,\n      modules: []\n    };\n\n    if (window.appInitialized) {\n      status.loaded = true;\n    }\n\n    if (window.moduleInstances) {\n      status.modules = Object.keys(window.moduleInstances);\n      status.total = status.modules.length;\n    }\n\n    if (window.moduleLoader && window.moduleLoader.failedModules) {\n      status.failed = window.moduleLoader.failedModules.size;\n    }\n\n    return status;\n  }\n\n  /**\n   * Check socket connection status\n   */\n  checkSocketConnection() {\n    const status = {\n      connected: false,\n      latency: null\n    };\n\n    if (window.socket && window.socket.connected) {\n      status.connected = true;\n    } else if (window.moduleInstances && window.moduleInstances.socketHandler) {\n      status.connected = window.moduleInstances.socketHandler.isConnected();\n    }\n\n    return status;\n  }\n\n  /**\n   * Check memory usage\n   */\n  checkMemoryUsage() {\n    const status = {\n      used: 0,\n      total: 0,\n      percentage: 0\n    };\n\n    if (performance.memory) {\n      status.used = performance.memory.usedJSHeapSize;\n      status.total = performance.memory.totalJSHeapSize;\n      status.percentage = (status.used / status.total) * 100;\n    }\n\n    return status;\n  }\n\n  /**\n   * Check performance metrics\n   */\n  checkPerformance() {\n    const status = {\n      loadTime: 0,\n      slow: false\n    };\n\n    const perfData = performance.getEntriesByType('navigation')[0];\n    if (perfData) {\n      status.loadTime = perfData.loadEventEnd - perfData.fetchStart;\n      status.slow = status.loadTime > 5000; // Consider slow if > 5 seconds\n    }\n\n    return status;\n  }\n\n  /**\n   * Show detailed status information\n   */\n  showDetailedStatus() {\n    const health = {\n      modules: this.checkModules(),\n      socket: this.checkSocketConnection(),\n      memory: this.checkMemoryUsage(),\n      performance: this.checkPerformance()\n    };\n\n    console.group('🏥 System Health Report');\n    console.log('Modules:', health.modules);\n    console.log('Socket:', health.socket);\n    console.log('Memory:', health.memory);\n    console.log('Performance:', health.performance);\n    console.log('Recent Status History:', this.statusHistory.slice(-10));\n    console.groupEnd();\n  }\n\n  /**\n   * Stop monitoring\n   */\n  stopMonitoring() {\n    if (this.checkInterval) {\n      clearInterval(this.checkInterval);\n      this.checkInterval = null;\n    }\n  }\n\n  /**\n   * Get current health status\n   */\n  getCurrentStatus() {\n    return this.lastStatus;\n  }\n\n  /**\n   * Get status history\n   */\n  getStatusHistory() {\n    return [...this.statusHistory];\n  }\n}\n\n// Create and export singleton instance\nconst systemHealth = new SystemHealthMonitor();\nexport default systemHealth;\n\n// Auto-initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => systemHealth.initialize());\n} else {\n  systemHealth.initialize();\n}\n\n// Make available globally for debugging\nwindow.systemHealth = systemHealth;","source":"/workspace/modules/static/js/modules/utils/systemHealth.js","title":"systemHealth.js","language":"en"},{"content":"/**\n * NeuroGen Server - Enhanced UI Module v4.0\n * \n * Core UI module optimized for the new Blueprint architecture.\n * Provides comprehensive UI functionality with centralized configuration,\n * enhanced error handling, and integrated health monitoring.\n * \n * NEW v4.0 Features:\n * - Configuration-driven architecture using centralized endpoints\n * - Enhanced 4-method notification system (Toast + Console + System + Error)\n * - Backend connectivity testing with health checks\n * - ES6 module imports with centralized configuration\n * - Optimized for Blueprint architecture integration\n * - Cross-platform UI consistency\n * - Enhanced accessibility and performance\n * \n * @module utils/ui\n * @version 4.0.0 - Blueprint Architecture Optimization\n */\n\n// Import dependencies from centralized config\nimport { API_ENDPOINTS, BLUEPRINT_ROUTES } from '../config/endpoints.js';\nimport { CONSTANTS, API_CONFIG, UI_CONFIG } from '../config/constants.js';\nimport { SOCKET_EVENTS, TASK_EVENTS } from '../config/socketEvents.js';\nimport { updateUIBridge } from '../core/module-bridge.js';\nimport { \n    getElement as domGetElement, \n    toggleElementVisibility as domToggleElementVisibility\n  } from './domUtils.js';\nimport { registerElement } from '../core/uiRegistry.js';\n\n// Global configuration for UI module\nconst UI_MODULE_CONFIG = {\n  endpoints: {\n    health: API_ENDPOINTS.SYSTEM?.HEALTH || '/api/health',\n    ...API_ENDPOINTS\n  },\n  api: API_CONFIG,\n  constants: UI_CONFIG || {\n    MAX_TOASTS: 5,\n    DEFAULT_TOAST_DURATION: 5000,\n    ANIMATION_DURATION: 300,\n    DEFAULT_POSITION: 'bottom-right'\n  },\n  events: {\n    ...TASK_EVENTS,\n    ui_ready: 'ui_module_ready',\n    theme_change: 'theme_changed'\n  }\n};\n  \n/**\n * Module state using a simple object for state management\n * @private\n */\nconst moduleState = {\n  toastContainer: null,\n  modalInstances: new Map(),\n  errorHandler: null,\n  initialized: false,\n  eventListeners: new Set(),\n  themeObserver: null\n};\n  \n/**\n * Get the module state\n * @returns {Object} The module state\n * @private\n */\nfunction getState() {\n  return moduleState;\n}\n  \n/**\n * Core UI module for basic UI operations\n */\nconst ui = {\n  /**\n   * Initialize the UI module\n   * @param {Object} options - Initialization options\n   * @returns {Promise<boolean>} Success status\n   */\n  async initialize(options = {}) {\n    const state = getState();\n    \n    if (state.initialized) {\n      console.warn(\"UI module already initialized\");\n      return true;\n    }\n    \n    try {\n      this.showNotification('Initializing UI Module v4.0', 'info', 'UI Module');\n      \n      // Test backend connectivity on initialization\n      const connectivityResult = await this.testBackendConnectivity();\n      if (!connectivityResult.overall) {\n        console.warn('UI Module: Backend connectivity test failed, continuing with limited functionality');\n      }\n      \n      // Extract options with defaults\n      const {\n        createToastContainer = true,\n        observeTheme = true,\n        errorHandlingLevel = 'standard',\n        setupGlobalHandlers = true\n      } = options;\n      \n      // Create toast container if requested\n      if (createToastContainer) {\n        this.ensureToastContainer();\n      }\n      \n      // Set up theme observation if requested\n      if (observeTheme) {\n        this._setupThemeObserver();\n      }\n      \n      // Set up global handlers if requested\n      if (setupGlobalHandlers) {\n        this._setupGlobalHandlers();\n      }\n      \n      // Register this module with the UI registry if available\n      if (typeof registerElement === 'function') {\n        registerElement('ui', this);\n      }\n      \n      // Mark as initialized\n      state.initialized = true;\n      \n      this.showNotification('UI Module v4.0 initialized successfully', 'success', 'UI Module');\n      return true;\n    } catch (error) {\n      console.error(\"Error initializing Core UI module:\", error);\n      return false;\n    }\n  },\n\n  /**\n   * Clean up the UI module (remove event listeners, etc.)\n   * @returns {boolean} Success status\n   */\n  cleanup() {\n    try {\n      const state = getState();\n      \n      // Remove all event listeners\n      state.eventListeners.forEach(info => {\n        const { element, type, handler } = info;\n        if (element && element.removeEventListener) {\n          element.removeEventListener(type, handler);\n        }\n      });\n      state.eventListeners.clear();\n      \n      // Disconnect theme observer if exists\n      if (state.themeObserver) {\n        state.themeObserver.disconnect();\n        state.themeObserver = null;\n      }\n      \n      // Clear all modals\n      state.modalInstances.forEach((modal) => {\n        try {\n          if (modal.element && modal.element.parentNode) {\n            modal.element.remove();\n          }\n        } catch (e) {\n          console.warn(\"Error removing modal:\", e);\n        }\n      });\n      state.modalInstances.clear();\n      \n      // Mark as not initialized\n      state.initialized = false;\n      \n      return true;\n    } catch (error) {\n      console.error(\"Error cleaning up UI module:\", error);\n      return false;\n    }\n  },\n\n  /**\n   * Add a tracked event listener that will be properly cleaned up\n   * @param {HTMLElement} element - Element to add listener to\n   * @param {string} type - Event type\n   * @param {Function} handler - Event handler\n   * @param {Object} options - Event listener options\n   * @private\n   */\n  _addTrackedEventListener(element, type, handler, options = {}) {\n    if (!element || !element.addEventListener) return;\n    \n    element.addEventListener(type, handler, options);\n    \n    const state = getState();\n    state.eventListeners.add({ element, type, handler });\n  },\n\n  /**\n   * Set up theme observer to detect theme changes\n   * @private\n   */\n  _setupThemeObserver() {\n    try {\n      const state = getState();\n      \n      // Observer callback for theme attribute changes\n      const themeCallback = (mutationsList) => {\n        for (const mutation of mutationsList) {\n          if (mutation.type === 'attributes' && \n              (mutation.attributeName === 'data-theme' || \n               mutation.attributeName === 'class')) {\n            this._handleThemeChange();\n          }\n        }\n      };\n      \n      // Create and start observer\n      state.themeObserver = new MutationObserver(themeCallback);\n      \n      // Observe both document element and body for theme changes\n      state.themeObserver.observe(document.documentElement, { \n        attributes: true,\n        attributeFilter: ['data-theme', 'class']\n      });\n      \n      state.themeObserver.observe(document.body, {\n        attributes: true, \n        attributeFilter: ['data-theme', 'class']\n      });\n      \n      // Initial theme handling\n      this._handleThemeChange();\n    } catch (error) {\n      console.warn(\"Error setting up theme observer:\", error);\n    }\n  },\n\n  /**\n   * Handle theme changes by updating UI elements\n   * @private\n   */\n  _handleThemeChange() {\n    try {\n      // Detect current theme from HTML or body\n      const htmlTheme = document.documentElement.getAttribute('data-theme');\n      const bodyTheme = document.body.getAttribute('data-theme');\n      const isDark = htmlTheme === 'dark' || bodyTheme === 'dark' || \n                    document.documentElement.classList.contains('dark') ||\n                    document.body.classList.contains('dark-theme');\n      \n      // Apply theme-specific styles to module-generated elements\n      const toastContainer = this.getElement('#toast-container');\n      if (toastContainer) {\n        toastContainer.setAttribute('data-theme', isDark ? 'dark' : 'light');\n      }\n      \n      // Emit theme change event if registered\n      if (window.eventRegistry && typeof window.eventRegistry.emit === 'function') {\n        window.eventRegistry.emit('ui.themeChanged', { \n          theme: isDark ? 'dark' : 'light' \n        });\n      }\n    } catch (error) {\n      console.warn(\"Error handling theme change:\", error);\n    }\n  },\n\n  /**\n   * Set up global event handlers\n   * @private\n   */\n  _setupGlobalHandlers() {\n    try {\n      // Handle escape key for modals\n      this._addTrackedEventListener(document, 'keydown', (event) => {\n        if (event.key === 'Escape') {\n          const state = getState();\n          const modalEntries = Array.from(state.modalInstances.entries());\n          \n          // Get the most recently created modal (last in the array)\n          if (modalEntries.length > 0) {\n            const [lastModalId] = modalEntries[modalEntries.length - 1];\n            this.hideModal(lastModalId);\n          }\n        }\n      });\n      \n      // Other global handlers as needed\n    } catch (error) {\n      console.warn(\"Error setting up global handlers:\", error);\n    }\n  },\n\n  /**\n   * Get element - Uses domUtils.getElement to avoid redeclaration\n   * @param {string} selector - CSS selector or element ID\n   * @returns {HTMLElement} Found element or null\n   */\n  getElement(selector) {\n    try {\n      return domGetElement(selector);\n    } catch (error) {\n      this.handleError(error, \"getElement\");\n      return null;\n    }\n  },\n\n  /**\n   * Ensure the toast container exists in the DOM\n   * @returns {HTMLElement} Toast container element\n   */\n  ensureToastContainer() {\n    const state = getState();\n    if (state.toastContainer) return state.toastContainer;\n    \n    try {\n      // Create container if it doesn't exist\n      const container = document.getElementById('toast-container');\n      if (container) {\n        state.toastContainer = container;\n        return container;\n      }\n      \n      // Create new container with improved positioning and stacking\n      const newContainer = document.createElement('div');\n      newContainer.id = 'toast-container';\n      newContainer.className = 'toast-container position-fixed bottom-0 end-0 p-3';\n      newContainer.style.zIndex = '9999';\n      newContainer.style.maxWidth = '350px';\n      newContainer.style.maxHeight = '80vh';\n      newContainer.style.overflow = 'hidden';\n      \n      // Detect current theme\n      const htmlTheme = document.documentElement.getAttribute('data-theme');\n      const bodyTheme = document.body.getAttribute('data-theme');\n      const isDark = htmlTheme === 'dark' || bodyTheme === 'dark';\n      if (isDark) {\n        newContainer.setAttribute('data-theme', 'dark');\n      }\n      \n      document.body.appendChild(newContainer);\n      \n      state.toastContainer = newContainer;\n      return newContainer;\n    } catch (error) {\n      console.error(\"Error ensuring toast container:\", error);\n      \n      // Create minimal fallback container\n      const fallbackContainer = document.createElement('div');\n      fallbackContainer.id = 'toast-container-fallback';\n      fallbackContainer.style.position = 'fixed';\n      fallbackContainer.style.bottom = '20px';\n      fallbackContainer.style.right = '20px';\n      fallbackContainer.style.zIndex = '9999';\n      \n      document.body.appendChild(fallbackContainer);\n      state.toastContainer = fallbackContainer;\n      \n      return fallbackContainer;\n    }\n  },\n\n  /**\n   * Show a toast notification\n   * @param {string} title - Toast title\n   * @param {string} message - Toast message\n   * @param {string} type - Toast type (success, error, warning, info)\n   * @param {Object} options - Additional options\n   * @returns {HTMLElement} Toast element\n   */\n  showToast(title, message, type = 'info', options = {}) {\n    try {\n      const {\n        duration = 5000,\n        dismissible = true,\n        position = 'bottom-right',\n        onClick = null,\n        onClose = null,\n        progressBar = false,\n        maxWidth = null\n      } = typeof options === 'number' ? { duration: options } : options;\n      \n      // Ensure container exists\n      const container = this.ensureToastContainer();\n      \n      // Limit number of toasts to 5 to prevent UI clutter\n      const existingToasts = container.querySelectorAll('.toast');\n      if (existingToasts.length >= 5) {\n        // Remove oldest toast\n        if (existingToasts[0] && existingToasts[0].parentNode) {\n          existingToasts[0].remove();\n        }\n      }\n      \n      // Create toast element with improved styling and accessibility\n      const toastId = 'toast-' + Date.now();\n      const toast = document.createElement('div');\n      toast.id = toastId;\n      toast.className = 'toast show';\n      toast.setAttribute('role', 'alert');\n      toast.setAttribute('aria-live', 'assertive');\n      toast.setAttribute('aria-atomic', 'true');\n      \n      // Add appropriate theme based on container\n      if (container.hasAttribute('data-theme')) {\n        toast.setAttribute('data-theme', container.getAttribute('data-theme'));\n      }\n      \n      // Apply maximum width if specified\n      if (maxWidth) {\n        toast.style.maxWidth = typeof maxWidth === 'number' ? `${maxWidth}px` : maxWidth;\n      }\n      \n      // Apply custom position if not default\n      if (position !== 'bottom-right') {\n        // Adjust container position based on requested toast position\n        const [vertical, horizontal] = position.split('-');\n        \n        container.style.top = vertical === 'top' ? '0' : 'auto';\n        container.style.bottom = vertical === 'bottom' ? '0' : 'auto';\n        container.style.left = horizontal === 'left' ? '0' : 'auto';\n        container.style.right = horizontal === 'right' ? '0' : 'auto';\n      }\n      \n      // Get appropriate icon and background class\n      let iconClass;\n      let bgClass;\n      \n      switch (type) {\n        case 'success':\n          iconClass = 'fa-check-circle';\n          bgClass = 'bg-success';\n          break;\n        case 'error':\n          iconClass = 'fa-exclamation-circle';\n          bgClass = 'bg-danger';\n          break;\n        case 'warning':\n          iconClass = 'fa-exclamation-triangle';\n          bgClass = 'bg-warning';\n          break;\n        default: // info\n          iconClass = 'fa-info-circle';\n          bgClass = 'bg-info';\n      }\n      \n      // Build toast content\n      let toastContent = `\n        <div class=\"toast-header ${bgClass} text-white\">\n          <i class=\"fas ${iconClass} me-2\"></i>\n          <strong class=\"me-auto\">${title}</strong>\n          ${dismissible ? '<button type=\"button\" class=\"btn-close btn-close-white\" data-bs-dismiss=\"toast\" aria-label=\"Close\"></button>' : ''}\n        </div>\n        <div class=\"toast-body\">\n          ${message}\n        </div>\n      `;\n      \n      // Add progress bar if requested\n      if (progressBar && duration > 0) {\n        toastContent += `\n          <div class=\"toast-progress\" style=\"height: 4px; background-color: rgba(0,0,0,0.2)\">\n            <div id=\"${toastId}-progress\" class=\"toast-progress-bar ${bgClass}\" style=\"height: 100%; width: 100%;\"></div>\n          </div>\n        `;\n      }\n      \n      toast.innerHTML = toastContent;\n      \n      // Add to container\n      container.appendChild(toast);\n      \n      // Handle click events\n      if (onClick) {\n        toast.style.cursor = 'pointer';\n        this._addTrackedEventListener(toast, 'click', (event) => {\n          // Ignore clicks on close button\n          if (event.target.classList.contains('btn-close') || \n              event.target.closest('.btn-close')) {\n            return;\n          }\n          onClick(event);\n        });\n      }\n      \n      // Add close button handler\n      const closeButton = toast.querySelector('.btn-close');\n      if (closeButton) {\n        this._addTrackedEventListener(closeButton, 'click', () => {\n          this._removeToast(toast, onClose);\n        });\n      }\n      \n      // Handle progress bar animation\n      if (progressBar && duration > 0) {\n        const progressBarEl = document.getElementById(`${toastId}-progress`);\n        if (progressBarEl) {\n          // Animate using CSS transition for better performance\n          progressBarEl.style.transition = `width ${duration}ms linear`;\n          \n          // Force reflow to ensure transition starts properly\n          progressBarEl.getBoundingClientRect();\n          \n          // Start animation\n          progressBarEl.style.width = '0%';\n        }\n      }\n      \n      // Auto remove after duration if > 0\n      if (duration > 0) {\n        setTimeout(() => {\n          this._removeToast(toast, onClose);\n        }, duration);\n      }\n      \n      return toast;\n    } catch (error) {\n      console.error(\"Error showing toast:\", error);\n      this.handleError(error, \"showToast\");\n      return null;\n    }\n  },\n\n  /**\n   * Helper to remove a toast properly\n   * @param {HTMLElement} toast - Toast element to remove\n   * @param {Function} onClose - Optional callback when closed\n   * @private\n   */\n  _removeToast(toast, onClose = null) {\n    if (!toast || !toast.parentNode) return;\n    \n    // Add fade-out animation\n    toast.classList.add('hiding');\n    toast.style.opacity = '0';\n    toast.style.transition = 'opacity 0.15s ease-out';\n    \n    // Remove after animation\n    setTimeout(() => {\n      if (toast.parentNode) {\n        toast.remove();\n        if (typeof onClose === 'function') {\n          onClose();\n        }\n      }\n    }, 150);\n  },\n\n  /**\n   * Show a loading spinner\n   * @param {string} message - Loading message\n   * @param {Object} options - Spinner options\n   * @returns {Object} Spinner control object\n   */\n  showLoadingSpinner(message = 'Loading...', options = {}) {\n    try {\n      const { \n        fullscreen = false,\n        cancelable = false,\n        onCancel = null,\n        spinnerType = 'border', // 'border' or 'grow'\n        spinnerSize = fullscreen ? 'normal' : 'small',\n        spinnerColor = 'primary',\n        containerId = null\n      } = typeof options === 'boolean' ? { fullscreen: options } : options;\n      \n      // Create spinner element\n      const spinnerId = 'spinner-' + Date.now();\n      const spinner = document.createElement('div');\n      spinner.id = spinnerId;\n      \n      // Set up class based on fullscreen flag\n      spinner.className = fullscreen ? \n        'loading-overlay position-fixed top-0 start-0 w-100 h-100 d-flex align-items-center justify-content-center bg-dark bg-opacity-50' :\n        'loading-indicator p-3 d-inline-flex align-items-center';\n        \n      spinner.style.zIndex = '9999';\n      \n      // Determine spinner class based on type and size\n      const spinnerClass = `spinner-${spinnerType}` + \n                          (spinnerSize === 'small' ? ' spinner-border-sm' : '') + \n                          ` text-${spinnerColor}`;\n      \n      // Set spinner content\n      if (fullscreen) {\n        let content = `\n          <div class=\"bg-white p-4 rounded shadow\">\n            <div class=\"d-flex align-items-center\">\n              <div class=\"${spinnerClass} me-3\" role=\"status\">\n                <span class=\"visually-hidden\">Loading...</span>\n              </div>\n              <span id=\"${spinnerId}-message\">${message}</span>\n        `;\n        \n        // Add cancel button if requested\n        if (cancelable) {\n          content += `\n              <button id=\"${spinnerId}-cancel\" class=\"btn btn-sm btn-outline-secondary ms-3\" type=\"button\">\n                Cancel\n              </button>\n          `;\n        }\n        \n        content += `\n            </div>\n          </div>\n        `;\n        \n        spinner.innerHTML = content;\n      } else {\n        spinner.innerHTML = `\n          <div class=\"${spinnerClass} me-2\" role=\"status\">\n            <span class=\"visually-hidden\">Loading...</span>\n          </div>\n          <span id=\"${spinnerId}-message\">${message}</span>\n        `;\n      }\n      \n      // Add to document\n      if (fullscreen) {\n        document.body.appendChild(spinner);\n      } else if (containerId) {\n        // If a specific container ID was provided\n        const container = document.getElementById(containerId);\n        if (container) {\n          container.appendChild(spinner);\n        } else {\n          document.body.appendChild(spinner);\n        }\n      } else {\n        // Try to find loading container, otherwise add to body\n        const container = document.querySelector('.loading-container') || document.body;\n        container.appendChild(spinner);\n      }\n      \n      // Set up cancel button if present\n      const cancelButton = document.getElementById(`${spinnerId}-cancel`);\n      if (cancelButton && typeof onCancel === 'function') {\n        this._addTrackedEventListener(cancelButton, 'click', () => {\n          onCancel();\n          if (spinner.parentNode) {\n            spinner.remove();\n          }\n        });\n      }\n      \n      // Store animation start time for accurate progress calculation\n      const startTime = Date.now();\n      \n      // Return enhanced control object\n      return {\n        id: spinnerId,\n        element: spinner,\n        \n        hide: () => {\n          if (!spinner.parentNode) return;\n          \n          // Add fade-out animation\n          spinner.style.opacity = '0';\n          spinner.style.transition = 'opacity 0.2s ease-out';\n          \n          setTimeout(() => {\n            if (spinner.parentNode) {\n              spinner.remove();\n            }\n          }, 200);\n        },\n        \n        updateMessage: (newMessage) => {\n          const messageElement = document.getElementById(`${spinnerId}-message`);\n          if (messageElement) {\n            messageElement.textContent = newMessage;\n          }\n        },\n        \n        // Method to show progress\n        updateProgress: (percent, progressMessage = null) => {\n          const messageElement = document.getElementById(`${spinnerId}-message`);\n          if (messageElement) {\n            const formattedPercent = Math.round(percent);\n            if (progressMessage) {\n              messageElement.textContent = `${progressMessage} (${formattedPercent}%)`;\n            } else {\n              messageElement.textContent = `${message} (${formattedPercent}%)`;\n            }\n          }\n        },\n        \n        // Method to calculate elapsed time\n        getElapsedTime: () => {\n          return Date.now() - startTime;\n        }\n      };\n    } catch (error) {\n      console.error(\"Error showing loading spinner:\", error);\n      this.handleError(error, \"showLoadingSpinner\");\n      \n      // Return minimal interface that won't cause errors if used\n      return {\n        id: null,\n        element: null,\n        hide: () => {},\n        updateMessage: () => {},\n        updateProgress: () => {},\n        getElapsedTime: () => 0\n      };\n    }\n  },\n\n  /**\n   * Show a modal dialog\n   * @param {string} title - Modal title\n   * @param {string} content - Modal content (HTML supported)\n   * @param {Object} options - Modal options\n   * @returns {Object} Modal control object\n   */\n  showModal(title, content, options = {}) {\n    try {\n      const {\n        size = 'medium', // small, medium, large, extra-large\n        closable = true,\n        buttons = [],\n        onClose = null,\n        onShow = null,\n        draggable = false,\n        verticalCenter = false,\n        animation = true,\n        backdrop = closable ? true : 'static',\n        id = null\n      } = options;\n      \n      // Generate unique ID if not provided\n      const modalId = id || 'modal-' + Date.now();\n      \n      // Determine size class\n      let sizeClass = 'modal-md';\n      switch (size) {\n        case 'small': sizeClass = 'modal-sm'; break;\n        case 'large': sizeClass = 'modal-lg'; break;\n        case 'extra-large': sizeClass = 'modal-xl'; break;\n      }\n      \n      // Create modal element\n      const modal = document.createElement('div');\n      modal.id = modalId;\n      modal.className = 'modal fade';\n      modal.setAttribute('tabindex', '-1');\n      modal.setAttribute('aria-hidden', 'true');\n      \n      if (!animation) {\n        modal.classList.add('no-animation');\n        modal.style.transition = 'none';\n      }\n      \n      // Create button HTML\n      let buttonHtml = '';\n      if (buttons.length > 0) {\n        buttonHtml = buttons.map(btn => {\n          const btnClass = btn.primary ? 'btn-primary' : (btn.type ? `btn-${btn.type}` : 'btn-secondary');\n          return `<button type=\"button\" class=\"btn ${btnClass}\" data-action=\"${btn.action || ''}\">${btn.text}</button>`;\n        }).join('');\n      } else if (closable) {\n        // Default close button if no buttons specified\n        buttonHtml = '<button type=\"button\" class=\"btn btn-secondary\" data-bs-dismiss=\"modal\">Close</button>';\n      }\n      \n      // Set modal content with improved accessibility\n      modal.innerHTML = `\n        <div class=\"modal-dialog ${sizeClass} ${verticalCenter ? 'modal-dialog-centered' : ''} ${draggable ? 'modal-draggable' : ''}\">\n          <div class=\"modal-content\">\n            <div class=\"modal-header ${draggable ? 'cursor-move' : ''}\">\n              <h5 class=\"modal-title\">${title}</h5>\n              ${closable ? '<button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>' : ''}\n            </div>\n            <div class=\"modal-body\">\n              ${content}\n            </div>\n            ${buttonHtml ? `<div class=\"modal-footer\">${buttonHtml}</div>` : ''}\n          </div>\n        </div>\n      `;\n      \n      // Add to document\n      document.body.appendChild(modal);\n      \n      let bootstrapModal;\n      \n      // Set up draggable functionality if requested\n      if (draggable) {\n        this._setupDraggableModal(modal);\n      }\n      \n      // Initialize Bootstrap modal if available\n      if (window.bootstrap && window.bootstrap.Modal) {\n        bootstrapModal = new window.bootstrap.Modal(modal, {\n          keyboard: closable,\n          backdrop: backdrop,\n          focus: true\n        });\n        \n        // Show the modal\n        bootstrapModal.show();\n        \n        // Call onShow callback after modal is shown\n        if (typeof onShow === 'function') {\n          modal.addEventListener('shown.bs.modal', onShow);\n        }\n      } else {\n        // Fallback if Bootstrap is not available\n        modal.style.display = 'block';\n        modal.classList.add('show');\n        \n        // Create backdrop\n        const backdropEl = document.createElement('div');\n        backdropEl.className = 'modal-backdrop fade show';\n        document.body.appendChild(backdropEl);\n        \n        // Call onShow callback\n        if (typeof onShow === 'function') {\n          setTimeout(onShow, 100);\n        }\n      }\n      \n      // Add button event listeners\n      if (buttons.length > 0) {\n        buttons.forEach(btn => {\n          const buttonEl = modal.querySelector(`button[data-action=\"${btn.action || ''}\"]`);\n          if (buttonEl && btn.onClick) {\n            this._addTrackedEventListener(buttonEl, 'click', () => {\n              btn.onClick();\n              if (btn.closeModal !== false) {\n                this.hideModal(modalId);\n              }\n            });\n          }\n        });\n      }\n      \n      // Add close event\n      modal.addEventListener('hidden.bs.modal', () => {\n        if (onClose) onClose();\n        \n        // Clean up after modal is hidden\n        setTimeout(() => {\n          if (modal.parentNode) {\n            modal.remove();\n          }\n          \n          // Remove backdrop if we created one manually\n          const backdrop = document.querySelector('.modal-backdrop');\n          if (backdrop && !window.bootstrap) {\n            backdrop.remove();\n          }\n          \n          // Remove from instances map\n          const state = getState();\n          state.modalInstances.delete(modalId);\n        }, 300);\n      });\n      \n      // Store in instances map with enhanced information\n      const state = getState();\n      state.modalInstances.set(modalId, {\n        id: modalId,\n        element: modal,\n        bootstrapInstance: bootstrapModal,\n        timestamp: Date.now(),\n        options\n      });\n      \n      // Return control object with enhanced methods\n      return {\n        id: modalId,\n        element: modal,\n        \n        hide: () => this.hideModal(modalId),\n        \n        updateContent: (newContent) => {\n          const bodyEl = modal.querySelector('.modal-body');\n          if (bodyEl) {\n            bodyEl.innerHTML = newContent;\n          }\n        },\n        \n        updateTitle: (newTitle) => {\n          const titleEl = modal.querySelector('.modal-title');\n          if (titleEl) {\n            titleEl.innerHTML = newTitle;\n          }\n        },\n        \n        addButton: (buttonConfig) => {\n          const footerEl = modal.querySelector('.modal-footer');\n          if (!footerEl) return;\n          \n          const btn = document.createElement('button');\n          btn.type = 'button';\n          btn.className = `btn ${buttonConfig.primary ? 'btn-primary' : (buttonConfig.type ? `btn-${buttonConfig.type}` : 'btn-secondary')}`;\n          btn.dataset.action = buttonConfig.action || '';\n          btn.textContent = buttonConfig.text;\n          \n          if (buttonConfig.onClick) {\n            this._addTrackedEventListener(btn, 'click', () => {\n              buttonConfig.onClick();\n              if (buttonConfig.closeModal !== false) {\n                this.hideModal(modalId);\n              }\n            });\n          }\n          \n          footerEl.appendChild(btn);\n        }\n      };\n    } catch (error) {\n      console.error(\"Error showing modal:\", error);\n      this.handleError(error, \"showModal\");\n      \n      return {\n        id: null,\n        element: null,\n        hide: () => {},\n        updateContent: () => {},\n        updateTitle: () => {},\n        addButton: () => {}\n      };\n    }\n  },\n\n  /**\n   * Set up draggable functionality for a modal\n   * @param {HTMLElement} modal - Modal element\n   * @private\n   */\n  _setupDraggableModal(modal) {\n    try {\n      const dialogEl = modal.querySelector('.modal-dialog');\n      const headerEl = modal.querySelector('.modal-header');\n      \n      if (!dialogEl || !headerEl) return;\n      \n      // Make header the drag handle\n      headerEl.style.cursor = 'move';\n      \n      let isDragging = false;\n      let startX, startY, startLeft, startTop;\n      \n      // Set initial position in center\n      dialogEl.style.position = 'relative';\n      dialogEl.style.margin = '0.5rem auto';\n      \n      // Mouse down on header starts drag\n      this._addTrackedEventListener(headerEl, 'mousedown', (e) => {\n        // Only initiate drag on header, not on buttons within header\n        if (e.target.closest('.btn-close') || e.target.tagName === 'BUTTON') {\n          return;\n        }\n        \n        isDragging = true;\n        \n        // Get initial positions\n        startX = e.clientX;\n        startY = e.clientY;\n        \n        // Get current position of dialog\n        const rect = dialogEl.getBoundingClientRect();\n        startLeft = rect.left;\n        startTop = rect.top;\n        \n        // Apply some styling while dragging\n        dialogEl.classList.add('dragging');\n        \n        // Prevent text selection during drag\n        e.preventDefault();\n      });\n      \n      // Track mouse movement\n      this._addTrackedEventListener(document, 'mousemove', (e) => {\n        if (!isDragging) return;\n        \n        // Calculate new position\n        const deltaX = e.clientX - startX;\n        const deltaY = e.clientY - startY;\n        \n        // Apply new position\n        dialogEl.style.left = `${deltaX}px`;\n        dialogEl.style.top = `${deltaY}px`;\n        \n        // Ensure dialog stays in viewport\n        const rect = dialogEl.getBoundingClientRect();\n        \n        if (rect.left < 0) dialogEl.style.left = `${deltaX - rect.left}px`;\n        if (rect.top < 0) dialogEl.style.top = `${deltaY - rect.top}px`;\n        \n        const maxRight = window.innerWidth - rect.width;\n        const maxBottom = window.innerHeight - rect.height;\n        \n        if (rect.right > window.innerWidth) dialogEl.style.left = `${deltaX - (rect.right - maxRight)}px`;\n        if (rect.bottom > window.innerHeight) dialogEl.style.top = `${deltaY - (rect.bottom - maxBottom)}px`;\n      });\n      \n      // End drag on mouse up\n      this._addTrackedEventListener(document, 'mouseup', () => {\n        if (!isDragging) return;\n        \n        isDragging = false;\n        dialogEl.classList.remove('dragging');\n      });\n    } catch (error) {\n      console.warn(\"Error setting up draggable modal:\", error);\n    }\n  },\n\n  /**\n   * Hide a modal dialog\n   * @param {string} modalId - ID of the modal to hide\n   * @returns {boolean} Success status\n   */\n  hideModal(modalId) {\n    try {\n      const state = getState();\n      const modalInfo = state.modalInstances.get(modalId);\n      if (!modalInfo) return false;\n      \n      if (modalInfo.bootstrapInstance) {\n        modalInfo.bootstrapInstance.hide();\n      } else {\n        // Fallback if Bootstrap is not available\n        modalInfo.element.style.display = 'none';\n        modalInfo.element.classList.remove('show');\n        \n        // Remove backdrop\n        const backdrop = document.querySelector('.modal-backdrop');\n        if (backdrop) {\n          backdrop.remove();\n        }\n        \n        // Remove modal\n        if (modalInfo.element.parentNode) {\n          modalInfo.element.remove();\n        }\n        \n        // Remove from instances map\n        state.modalInstances.delete(modalId);\n      }\n      \n      return true;\n    } catch (error) {\n      console.error(\"Error hiding modal:\", error);\n      this.handleError(error, \"hideModal\");\n      return false;\n    }\n  },\n\n  /**\n   * Update a progress bar\n   * @param {string} elementId - ID of the progress bar element\n   * @param {number} progress - Progress percentage (0-100)\n   * @param {Object} options - Additional options\n   * @returns {boolean} Success status\n   */\n  updateProgressBar(elementId, progress, options = {}) {\n    try {\n      const { \n        text = null,\n        animated = false,\n        striped = false\n      } = typeof options === 'string' ? { text: options } : options;\n      \n      // Find the progress bar\n      const progressBar = document.getElementById(elementId);\n      if (!progressBar) return false;\n      \n      // Find actual progress bar element (might be child)\n      const innerBar = progressBar.classList.contains('progress') ? \n        progressBar.querySelector('.progress-bar') : \n        progressBar;\n      \n      if (!innerBar) return false;\n      \n      // Update progress with bounds checking\n      const percent = Math.min(100, Math.max(0, progress));\n      innerBar.style.width = `${percent}%`;\n      innerBar.setAttribute('aria-valuenow', percent);\n      \n      // Update animation and striping classes\n      if (animated) {\n        innerBar.classList.add('progress-bar-animated');\n      } else {\n        innerBar.classList.remove('progress-bar-animated');\n      }\n      \n      if (striped) {\n        innerBar.classList.add('progress-bar-striped');\n      } else {\n        innerBar.classList.remove('progress-bar-striped');\n      }\n      \n      // Update text if provided\n      if (text !== null) {\n        innerBar.textContent = text;\n      }\n      \n      // Update contextual class based on progress\n      const contextClasses = ['bg-danger', 'bg-warning', 'bg-info', 'bg-success'];\n      contextClasses.forEach(cls => innerBar.classList.remove(cls));\n      \n      if (percent < 25) {\n        innerBar.classList.add('bg-danger');\n      } else if (percent < 50) {\n        innerBar.classList.add('bg-warning');\n      } else if (percent < 75) {\n        innerBar.classList.add('bg-info');\n      } else {\n        innerBar.classList.add('bg-success');\n      }\n      \n      return true;\n    } catch (error) {\n      console.error(\"Error updating progress bar:\", error);\n      this.handleError(error, \"updateProgressBar\");\n      return false;\n    }\n  },\n\n  /**\n   * Create a progress bar element\n   * @param {string} containerId - Container element ID\n   * @param {Object} options - Progress bar options\n   * @returns {string} ID of the created progress bar\n   */\n  createProgressBar(containerId, options = {}) {\n    try {\n      const {\n        id = 'progress-' + Date.now(),\n        initialProgress = 0,\n        showLabel = true,\n        height = null,\n        striped = false,\n        animated = false,\n        className = ''\n      } = options;\n      \n      const container = document.getElementById(containerId);\n      if (!container) return null;\n      \n      // Create progress bar container\n      const progressContainer = document.createElement('div');\n      progressContainer.className = `progress ${className}`;\n      progressContainer.id = id + '-container';\n      \n      if (height) {\n        progressContainer.style.height = typeof height === 'number' ? `${height}px` : height;\n      }\n      \n      // Create progress bar element\n      const progressBar = document.createElement('div');\n      progressBar.className = 'progress-bar';\n      progressBar.id = id;\n      progressBar.role = 'progressbar';\n      progressBar.setAttribute('aria-valuenow', initialProgress);\n      progressBar.setAttribute('aria-valuemin', '0');\n      progressBar.setAttribute('aria-valuemax', '100');\n      progressBar.style.width = `${initialProgress}%`;\n      \n      // Add striped and animated classes if requested\n      if (striped) progressBar.classList.add('progress-bar-striped');\n      if (animated) progressBar.classList.add('progress-bar-animated');\n      \n      // Add label if requested\n      if (showLabel) {\n        progressBar.textContent = `${initialProgress}%`;\n      }\n      \n      // Append to container\n      progressContainer.appendChild(progressBar);\n      container.appendChild(progressContainer);\n      \n      return id;\n    } catch (error) {\n      console.error(\"Error creating progress bar:\", error);\n      this.handleError(error, \"createProgressBar\");\n      return null;\n    }\n  },\n\n  /**\n   * Create a confirmation dialog\n   * @param {string} title - Dialog title\n   * @param {string} message - Confirmation message\n   * @param {Function} onConfirm - Callback on confirm\n   * @param {Function} onCancel - Callback on cancel\n   * @param {Object} options - Additional options\n   * @returns {Object} Modal control object\n   */\n  confirm(title, message, onConfirm, onCancel = null, options = {}) {\n    try {\n      const {\n        confirmText = 'Confirm',\n        cancelText = 'Cancel',\n        confirmButtonType = 'danger',\n        cancelButtonType = 'secondary',\n        size = 'small',\n        icon = null,\n        confirmButtonIcon = null,\n        cancelButtonIcon = null\n      } = options;\n      \n      // Format icon if provided\n      let iconHtml = '';\n      if (icon) {\n        let iconClass = '';\n        if (typeof icon === 'string') {\n          // Assume this is a Font Awesome icon class\n          iconClass = icon.startsWith('fa-') ? `fas ${icon}` : icon;\n        } else if (icon === true) {\n          // Use standard confirmation icon\n          iconClass = 'fas fa-question-circle text-warning';\n        }\n        \n        if (iconClass) {\n          iconHtml = `<div class=\"confirmation-icon mb-3 text-center\">\n            <i class=\"${iconClass}\" style=\"font-size: 2rem;\"></i>\n          </div>`;\n        }\n      }\n      \n      // Create button configurations\n      const buttons = [\n        {\n          text: cancelText + (cancelButtonIcon ? ` <i class=\"${cancelButtonIcon}\"></i>` : ''),\n          action: 'cancel',\n          type: cancelButtonType,\n          onClick: onCancel || (() => {})\n        },\n        {\n          text: confirmText + (confirmButtonIcon ? ` <i class=\"${confirmButtonIcon}\"></i>` : ''),\n          action: 'confirm',\n          primary: true,\n          type: confirmButtonType,\n          onClick: onConfirm\n        }\n      ];\n      \n      // Create content with icon if provided\n      const content = `\n        ${iconHtml}\n        <p>${message}</p>\n      `;\n      \n      // Show modal\n      return this.showModal(title, content, {\n        size,\n        buttons,\n        verticalCenter: true\n      });\n    } catch (error) {\n      console.error(\"Error showing confirmation dialog:\", error);\n      this.handleError(error, \"confirm\");\n      \n      // Execute confirm callback directly in case of error\n      if (typeof onConfirm === 'function') {\n        onConfirm();\n      }\n      \n      return {\n        id: null,\n        hide: () => {},\n        element: null\n      };\n    }\n  },\n\n  /**\n   * Show an alert dialog\n   * @param {string} title - Alert title\n   * @param {string} message - Alert message\n   * @param {string} type - Alert type (success, error, warning, info)\n   * @param {Function} onClose - Callback on close\n   * @returns {Object} Modal control object\n   */\n  alert(title, message, type = 'info', onClose = null) {\n    try {\n      // Determine icon based on type\n      let icon;\n      let iconColor;\n      \n      switch (type) {\n        case 'success': \n          icon = 'fa-check-circle';\n          iconColor = 'text-success';\n          break;\n        case 'error': \n          icon = 'fa-exclamation-circle';\n          iconColor = 'text-danger';\n          break;\n        case 'warning': \n          icon = 'fa-exclamation-triangle';\n          iconColor = 'text-warning';\n          break;\n        default: \n          icon = 'fa-info-circle';\n          iconColor = 'text-info';\n      }\n      \n      return this.showModal(title, `\n        <div class=\"d-flex align-items-start\">\n          <i class=\"fas ${icon} ${iconColor} me-3\" style=\"font-size: 1.5rem;\"></i>\n          <div>${message}</div>\n        </div>\n      `, {\n        size: 'small',\n        onClose,\n        verticalCenter: true,\n        buttons: [\n          {\n            text: 'OK',\n            action: 'ok',\n            primary: true\n          }\n        ]\n      });\n    } catch (error) {\n      console.error(\"Error showing alert dialog:\", error);\n      this.handleError(error, \"alert\");\n      \n      // Execute close callback directly in case of error\n      if (typeof onClose === 'function') {\n        onClose();\n      }\n      \n      return {\n        id: null,\n        hide: () => {},\n        element: null\n      };\n    }\n  },\n\n  /**\n   * Create a prompt dialog\n   * @param {string} title - Prompt title\n   * @param {string} message - Prompt message\n   * @param {Function} onSubmit - Callback on submit\n   * @param {Function} onCancel - Callback on cancel\n   * @param {Object} options - Additional options\n   * @returns {Object} Modal control object\n   */\n  prompt(title, message, onSubmit, onCancel = null, options = {}) {\n    try {\n      const {\n        defaultValue = '',\n        placeholder = '',\n        submitText = 'Submit',\n        cancelText = 'Cancel',\n        inputType = 'text',\n        validator = null,\n        minLength = 0,\n        maxLength = null,\n        required = false,\n        autoFocus = true,\n        multiline = false,\n        rows = 3\n      } = options;\n      \n      const inputId = 'prompt-input-' + Date.now();\n      \n      // Determine if we're using textarea or input\n      const inputHtml = multiline ?\n        `<textarea \n          class=\"form-control\" \n          id=\"${inputId}\" \n          placeholder=\"${placeholder}\" \n          rows=\"${rows}\"\n          ${required ? 'required' : ''}\n          ${maxLength ? `maxlength=\"${maxLength}\"` : ''}\n        >${defaultValue}</textarea>` :\n        `<input \n          type=\"${inputType}\" \n          class=\"form-control\" \n          id=\"${inputId}\" \n          placeholder=\"${placeholder}\" \n          value=\"${defaultValue}\"\n          ${required ? 'required' : ''}\n          ${minLength > 0 ? `minlength=\"${minLength}\"` : ''}\n          ${maxLength ? `maxlength=\"${maxLength}\"` : ''}\n        >`;\n      \n      // Create error message container\n      const errorId = 'prompt-error-' + Date.now();\n      \n      const modal = this.showModal(title, `\n        <div class=\"mb-3\">\n          <label for=\"${inputId}\" class=\"form-label\">${message}</label>\n          ${inputHtml}\n          <div id=\"${errorId}\" class=\"invalid-feedback\"></div>\n        </div>\n      `, {\n        size: 'small',\n        verticalCenter: true,\n        buttons: [\n          {\n            text: cancelText,\n            action: 'cancel',\n            onClick: onCancel || (() => {})\n          },\n          {\n            text: submitText,\n            action: 'submit',\n            primary: true,\n            onClick: () => {\n              const input = document.getElementById(inputId);\n              if (!input) return;\n              \n              const value = input.value;\n              \n              // Handle validation\n              if (required && (!value || value.trim() === '')) {\n                input.classList.add('is-invalid');\n                const errorEl = document.getElementById(errorId);\n                if (errorEl) errorEl.textContent = 'This field is required';\n                return;\n              }\n              \n              if (minLength > 0 && value.length < minLength) {\n                input.classList.add('is-invalid');\n                const errorEl = document.getElementById(errorId);\n                if (errorEl) errorEl.textContent = `Minimum length is ${minLength} characters`;\n                return;\n              }\n              \n              if (maxLength && value.length > maxLength) {\n                input.classList.add('is-invalid');\n                const errorEl = document.getElementById(errorId);\n                if (errorEl) errorEl.textContent = `Maximum length is ${maxLength} characters`;\n                return;\n              }\n              \n              // Custom validator function\n              if (validator) {\n                const validationResult = validator(value);\n                if (validationResult !== true) {\n                  input.classList.add('is-invalid');\n                  const errorEl = document.getElementById(errorId);\n                  if (errorEl) errorEl.textContent = validationResult || 'Invalid input';\n                  return;\n                }\n              }\n              \n              // If we get here, validation passed\n              onSubmit(value);\n            },\n            closeModal: false // Don't close automatically to allow validation\n          }\n        ]\n      });\n      \n      // Focus the input after modal is shown\n      if (autoFocus) {\n        setTimeout(() => {\n          const input = document.getElementById(inputId);\n          if (input) {\n            input.focus();\n            \n            // If there's a default value, position cursor at the end\n            if (defaultValue && input.tagName !== 'TEXTAREA') {\n              input.setSelectionRange(defaultValue.length, defaultValue.length);\n            }\n          }\n        }, 300);\n      }\n      \n      // Add enter key handler if not multiline\n      if (!multiline) {\n        setTimeout(() => {\n          const input = document.getElementById(inputId);\n          if (input) {\n            this._addTrackedEventListener(input, 'keydown', (e) => {\n              if (e.key === 'Enter') {\n                e.preventDefault();\n                const submitBtn = modal.element.querySelector('button[data-action=\"submit\"]');\n                if (submitBtn) submitBtn.click();\n              }\n            });\n          }\n        }, 300);\n      }\n      \n      return modal;\n    } catch (error) {\n      console.error(\"Error showing prompt dialog:\", error);\n      this.handleError(error, \"prompt\");\n      \n      // Execute submit callback directly with default value in case of error\n      if (typeof onSubmit === 'function') {\n        onSubmit(options.defaultValue || '');\n      }\n      \n      return {\n        id: null,\n        hide: () => {},\n        element: null\n      };\n    }\n  },\n\n  /**\n   * Toggle element visibility - uses domUtils.toggleElementVisibility\n   * @param {string} elementId - ID of the element\n   * @param {boolean} visible - Whether to show or hide\n   * @param {string} displayMode - Display mode to use when showing\n   * @returns {boolean} Success status\n   */\n  toggleElementVisibility(elementId, visible, displayMode = 'block') {\n    try {\n      const element = document.getElementById(elementId);\n      if (!element) return false;\n      \n      // Use the imported function when display mode isn't needed or when using default display mode\n      if (displayMode === 'block') {\n        return domToggleElementVisibility(elementId, visible);\n      }\n      \n      // Custom implementation for non-standard display modes\n      if (visible) {\n        // Show element with specified display mode\n        element.style.display = displayMode;\n        \n        // If element has fade class, animate it\n        if (element.classList.contains('fade')) {\n          // First ensure element is visible but transparent\n          element.style.opacity = '0';\n          \n          // Force a reflow to ensure transition works\n          element.offsetHeight;\n          \n          // Now trigger fade in\n          element.style.opacity = '1';\n          element.style.transition = 'opacity 0.15s ease-in';\n        }\n      } else {\n        // If element has fade class, animate before hiding\n        if (element.classList.contains('fade')) {\n          element.style.opacity = '0';\n          element.style.transition = 'opacity 0.15s ease-out';\n          \n          // Hide after animation\n          setTimeout(() => {\n            element.style.display = 'none';\n          }, 150);\n        } else {\n          // Hide immediately\n          element.style.display = 'none';\n        }\n      }\n      \n      return true;\n    } catch (error) {\n      console.error(\"Error toggling element visibility:\", error);\n      this.handleError(error, \"toggleElementVisibility\");\n      return false;\n    }\n  },\n\n  /**\n   * Add or remove a class from an element\n   * @param {string} elementId - ID of the element\n   * @param {string} className - Class to toggle\n   * @param {boolean} add - Whether to add or remove\n   * @returns {boolean} Success status\n   */\n  toggleClass(elementId, className, add) {\n    try {\n      const element = document.getElementById(elementId);\n      if (!element) return false;\n      \n      if (add) {\n        element.classList.add(className);\n      } else {\n        element.classList.remove(className);\n      }\n      \n      return true;\n    } catch (error) {\n      console.error(\"Error toggling class:\", error);\n      this.handleError(error, \"toggleClass\");\n      return false;\n    }\n  },\n\n  /**\n   * Safe way to find elements - first tries by ID, then by selector\n   * @param {string} idOrSelector - ID or CSS selector\n   * @returns {HTMLElement} Found element or null\n   */\n  findElement(idOrSelector) {\n    try {\n      // First try by ID for better performance\n      let element = document.getElementById(idOrSelector);\n\n      // If not found, try as a selector\n      if (!element) {\n        element = document.querySelector(idOrSelector);\n      }\n\n      return element;\n    } catch (error) {\n      console.error(`Error finding element with selector \"${idOrSelector}\":`, error);\n      this.handleError(error, \"findElement\");\n      return null;\n    }\n  },\n\n  /**\n   * Find all elements matching a selector\n   * @param {string} selector - CSS selector\n   * @param {HTMLElement|string} context - Context element or selector\n   * @returns {Array<HTMLElement>} Array of elements\n   */\n  findElements(selector, context = document) {\n    try {\n      let contextElement = context;\n\n      // If context is a string, find the element\n      if (typeof context === 'string') {\n        contextElement = this.findElement(context);\n      }\n\n      // Fall back to document if context not found\n      if (!contextElement) {\n        contextElement = document;\n      }\n\n      // Return as array for consistent handling\n      return Array.from(contextElement.querySelectorAll(selector));\n    } catch (error) {\n      console.error(`Error finding elements with selector \"${selector}\":`, error);\n      this.handleError(error, \"findElements\");\n      return [];\n    }\n  },\n\n  /**\n   * Set error handler for UI module\n   * @param {Function} handler - Error handler function\n   */\n  setErrorHandler(handler) {\n    if (typeof handler === 'function') {\n      const state = getState();\n      state.errorHandler = handler;\n    }\n  },\n\n  /**\n   * Handle errors within the UI module\n   * @param {Error} error - Error object\n   * @param {string} context - Error context\n   */\n  handleError(error, context = 'UI') {\n    console.error(`[${context}]`, error);\n\n    // Use error handler if set\n    const state = getState();\n    if (typeof state.errorHandler === 'function') {\n      state.errorHandler(error, context);\n    }\n\n    // Check if error registry exists\n    if (window.errorHandler && typeof window.errorHandler.logError === 'function') {\n      window.errorHandler.logError(error, {\n        module: 'ui',\n        context,\n        timestamp: new Date().toISOString()\n      });\n    }\n  },\n\n  /**\n   * Enhanced notification system with 4-method delivery (v4.0)\n   * @param {string} message - Notification message\n   * @param {string} type - Notification type (info, success, warning, error)\n   * @param {string} title - Notification title\n   */\n  showNotification(message, type = 'info', title = 'UI Module') {\n    // Method 1: Toast notifications\n    this.showToast(title, message, type);\n    \n    // Method 2: Console logging with styling\n    const styles = {\n      error: 'color: #dc3545; font-weight: bold;',\n      warning: 'color: #fd7e14; font-weight: bold;',\n      success: 'color: #198754; font-weight: bold;',\n      info: 'color: #0d6efd;'\n    };\n    console.log(`%c[${title}] ${message}`, styles[type] || styles.info);\n    \n    // Method 3: System notification (if available)\n    if (window.NeuroGen?.notificationHandler) {\n      window.NeuroGen.notificationHandler.show({\n        title, message, type, module: 'ui'\n      });\n    }\n    \n    // Method 4: Error reporting to centralized handler\n    if (type === 'error' && window.NeuroGen?.errorHandler) {\n      window.NeuroGen.errorHandler.logError({\n        module: 'ui', message, severity: type\n      });\n    }\n  },\n\n  /**\n   * Test backend connectivity for UI module (v4.0)\n   * @returns {Promise<Object>} Backend connectivity status\n   */\n  async testBackendConnectivity() {\n    const results = {\n      overall: false,\n      details: {},\n      timestamp: new Date().toISOString(),\n      errors: []\n    };\n\n    try {\n      // Test main health endpoint\n      const healthResponse = await fetch(UI_MODULE_CONFIG.endpoints.health, {\n        method: 'GET',\n        headers: { 'Content-Type': 'application/json' }\n      });\n\n      results.details.health = {\n        status: healthResponse.status,\n        ok: healthResponse.ok,\n        endpoint: UI_MODULE_CONFIG.endpoints.health\n      };\n\n      if (healthResponse.ok) {\n        results.overall = true;\n        this.showNotification('Backend connectivity verified', 'success', 'UI Module');\n      } else {\n        throw new Error(`Health endpoint returned ${healthResponse.status}`);\n      }\n\n    } catch (error) {\n      results.errors.push({\n        endpoint: UI_MODULE_CONFIG.endpoints.health,\n        error: error.message\n      });\n      this.showNotification(`Backend connectivity failed: ${error.message}`, 'error', 'UI Module');\n    }\n\n    return results;\n  },\n\n  /**\n   * Get UI module health status (v4.0)\n   * @returns {Object} Health status information\n   */\n  getHealthStatus() {\n    const state = getState();\n    \n    return {\n      module: 'ui',\n      version: '4.0.0',\n      status: state.initialized ? 'healthy' : 'initializing',\n      features: {\n        configurationDriven: true,\n        enhancedNotifications: true,\n        backendConnectivity: true,\n        toastSystem: true,\n        modalSystem: true,\n        themeObserver: !!state.themeObserver\n      },\n      configuration: {\n        endpoints: UI_MODULE_CONFIG.endpoints,\n        constants: UI_MODULE_CONFIG.constants,\n        eventsConfigured: Object.keys(UI_MODULE_CONFIG.events).length\n      },\n      statistics: {\n        activeModals: state.modalInstances.size,\n        eventListeners: state.eventListeners.size,\n        toastContainer: !!state.toastContainer\n      }\n    };\n  }\n};\n\n// Update the bridge with the real UI module\nupdateUIBridge(ui);\n\nconsole.log(\"UI module initialized and bridge updated\");  \n\n// Export the module\nexport default ui;\n\n// Named exports for commonly used functions\nexport const showToast = ui.showToast.bind(ui);\nexport const showLoadingSpinner = ui.showLoadingSpinner.bind(ui);\nexport const showModal = ui.showModal.bind(ui);\nexport const hideModal = ui.hideModal.bind(ui);\nexport const updateProgressBar = ui.updateProgressBar.bind(ui);\nexport const confirm = ui.confirm.bind(ui);\nexport const alert = ui.alert.bind(ui);\nexport const prompt = ui.prompt.bind(ui);\nexport const toggleElementVisibility = ui.toggleElementVisibility.bind(ui);\nexport const toggleClass = ui.toggleClass.bind(ui);\nexport const findElement = ui.findElement.bind(ui);\nexport const findElements = ui.findElements.bind(ui);\nexport const createProgressBar = ui.createProgressBar.bind(ui);\n\n// v4.0 Enhanced exports\nexport const showNotification = ui.showNotification.bind(ui);\nexport const testBackendConnectivity = ui.testBackendConnectivity.bind(ui);\nexport const getHealthStatus = ui.getHealthStatus.bind(ui);","source":"/workspace/modules/static/js/modules/utils/ui.js","title":"ui.js","language":"en"},{"content":"/**\n * Utilities Module\n * \n * General utility functions used throughout the application.\n * Provides reusable helper functions for common operations.\n * \n * Features:\n * - String formatting and manipulation\n * - Date formatting and parsing\n * - Number formatting\n * - Clipboard operations\n * - File utilities\n * - Performance utilities (debounce, throttle)\n * - URL parameter handling\n * - Error handling utilities\n */\n\n/**\n * Utility functions for the application\n */\nconst utils = {\n  /**\n   * Format bytes to human-readable string\n   * @param {number} bytes - Bytes to format\n   * @param {number} decimals - Decimal places\n   * @returns {string} - Formatted string\n   */\n  formatBytes(bytes, decimals = 2) {\n    if (bytes === 0) return '0 B';\n    \n    const k = 1024;\n    const dm = decimals < 0 ? 0 : decimals;\n    const sizes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n    \n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    \n    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];\n  },\n  \n  /**\n   * Format seconds to a duration string\n   * @param {number} seconds - Seconds to format\n   * @returns {string} - Formatted duration\n   */\n  formatDuration(seconds) {\n    if (!seconds) return '0s';\n    \n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    const remainingSeconds = Math.floor(seconds % 60);\n    \n    let result = '';\n    \n    if (hours > 0) {\n      result += `${hours}h `;\n    }\n    \n    if (minutes > 0 || hours > 0) {\n      result += `${minutes}m `;\n    }\n    \n    result += `${remainingSeconds}s`;\n    \n    return result;\n  },\n  \n  /**\n   * Generate a random ID\n   * @param {number} length - The length of the ID\n   * @returns {string} - Random ID\n   */\n  generateId(length = 8) {\n    const characters = 'abcdefghijklmnopqrstuvwxyz0123456789';\n    let result = '';\n    \n    for (let i = 0; i < length; i++) {\n      result += characters.charAt(Math.floor(Math.random() * characters.length));\n    }\n    \n    return result;\n  },\n  \n  /**\n   * Create a delay using a Promise\n   * @param {number} ms - Milliseconds to delay\n   * @returns {Promise} - Promise that resolves after the delay\n   */\n  delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  },\n  \n  /**\n   * Debounce a function\n   * @param {Function} func - Function to debounce\n   * @param {number} wait - Milliseconds to wait\n   * @returns {Function} - Debounced function\n   */\n  debounce(func, wait = 300) {\n    let timeout;\n    \n    return function(...args) {\n      const context = this;\n      \n      clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        func.apply(context, args);\n      }, wait);\n    };\n  },\n  \n  /**\n   * Throttle a function\n   * @param {Function} func - Function to throttle\n   * @param {number} limit - Milliseconds between function calls\n   * @returns {Function} - Throttled function\n   */\n  throttle(func, limit = 300) {\n    let lastCalled;\n    let lastArgs;\n    let timeout;\n    \n    return function(...args) {\n      const context = this;\n      const now = Date.now();\n      \n      if (!lastCalled || (now - lastCalled) >= limit) {\n        // If it's been longer than the limit, call immediately\n        lastCalled = now;\n        return func.apply(context, args);\n      }\n      \n      // Otherwise, schedule a call after the remaining time\n      lastArgs = args;\n      \n      if (!timeout) {\n        timeout = setTimeout(() => {\n          timeout = null;\n          lastCalled = Date.now();\n          func.apply(context, lastArgs);\n        }, limit - (now - lastCalled));\n      }\n    };\n  },\n  \n  /**\n   * Escape HTML to prevent XSS\n   * @param {string} text - Text to escape\n   * @returns {string} - Escaped HTML\n   */\n  escapeHtml(text) {\n    if (!text) return '';\n    \n    return String(text)\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&#039;');\n  },\n  \n  /**\n   * Format a date for display\n   * @param {Date|string|number} date - Date to format\n   * @param {boolean} includeTime - Whether to include time\n   * @returns {string} - Formatted date string\n   */\n  formatDate(date, includeTime = false) {\n    if (!date) return 'N/A';\n    \n    try {\n      const dateObj = date instanceof Date ? date : new Date(date);\n      \n      const options = {\n        year: 'numeric',\n        month: 'short',\n        day: 'numeric'\n      };\n      \n      if (includeTime) {\n        options.hour = '2-digit';\n        options.minute = '2-digit';\n      }\n      \n      return dateObj.toLocaleDateString(undefined, options);\n    } catch (error) {\n      console.error(\"Error formatting date:\", error);\n      return 'Invalid date';\n    }\n  },\n  \n  /**\n   * Format a relative time (e.g., \"2 hours ago\")\n   * @param {Date|string|number} date - Date to format\n   * @returns {string} - Relative time string\n   */\n  formatRelativeTime(date) {\n    if (!date) return 'N/A';\n    \n    try {\n      const dateObj = date instanceof Date ? date : new Date(date);\n      const now = new Date();\n      \n      const seconds = Math.floor((now - dateObj) / 1000);\n      const minutes = Math.floor(seconds / 60);\n      const hours = Math.floor(minutes / 60);\n      const days = Math.floor(hours / 24);\n      \n      if (seconds < 60) {\n        return 'just now';\n      } else if (minutes === 1) {\n        return '1 minute ago';\n      } else if (minutes < 60) {\n        return `${minutes} minutes ago`;\n      } else if (hours === 1) {\n        return '1 hour ago';\n      } else if (hours < 24) {\n        return `${hours} hours ago`;\n      } else if (days === 1) {\n        return 'yesterday';\n      } else if (days < 7) {\n        return `${days} days ago`;\n      } else {\n        return this.formatDate(dateObj);\n      }\n    } catch (error) {\n      console.error(\"Error formatting relative time:\", error);\n      return 'Invalid date';\n    }\n  },\n  \n  /**\n   * Copy text to clipboard\n   * @param {string} text - Text to copy\n   * @returns {Promise<boolean>} - Whether copy was successful\n   */\n  async copyToClipboard(text) {\n    try {\n      // Use the modern clipboard API if available\n      if (navigator.clipboard && navigator.clipboard.writeText) {\n        await navigator.clipboard.writeText(text);\n        return true;\n      }\n      \n      // Fall back to older approach\n      const textArea = document.createElement('textarea');\n      textArea.value = text;\n      textArea.style.position = 'fixed';\n      textArea.style.left = '-999999px';\n      textArea.style.top = '-999999px';\n      document.body.appendChild(textArea);\n      textArea.focus();\n      textArea.select();\n      \n      const success = document.execCommand('copy');\n      document.body.removeChild(textArea);\n      \n      return success;\n    } catch (error) {\n      console.error(\"Error copying to clipboard:\", error);\n      return false;\n    }\n  },\n  \n  /**\n   * Truncate text with ellipsis\n   * @param {string} text - Text to truncate\n   * @param {number} maxLength - Maximum length\n   * @returns {string} - Truncated text\n   */\n  truncateText(text, maxLength = 100) {\n    if (!text || text.length <= maxLength) return text;\n    \n    return text.substring(0, maxLength - 3) + '...';\n  },\n  \n  /**\n   * Get filename from path\n   * @param {string} path - File path\n   * @returns {string} - Filename\n   */\n  getFilenameFromPath(path) {\n    if (!path) return '';\n    \n    // Split by path separators and get the last part\n    const parts = path.split(/[/\\\\]/);\n    return parts[parts.length - 1] || '';\n  },\n  \n  /**\n   * Format JSON for display\n   * @param {Object} json - JSON object\n   * @param {number} indent - Indentation level\n   * @returns {string} - Formatted JSON string\n   */\n  formatJsonForDisplay(json, indent = 2) {\n    try {\n      if (typeof json === 'string') {\n        // Try to parse string as JSON\n        try {\n          json = JSON.parse(json);\n        } catch (e) {\n          // If it fails, return the original string\n          return json;\n        }\n      }\n      \n      return JSON.stringify(json, null, indent);\n    } catch (error) {\n      console.error(\"Error formatting JSON:\", error);\n      return String(json);\n    }\n  },\n  \n  /**\n   * Sanitize a filename by removing invalid characters\n   * @param {string} filename - Filename to sanitize\n   * @returns {string} - Sanitized filename\n   */\n  sanitizeFilename(filename) {\n    if (!filename) return '';\n    \n    // Replace invalid characters with underscores\n    return filename\n      .replace(/[<>:\"/\\\\|?*]+/g, '_') // Invalid characters in Windows\n      .replace(/\\s+/g, '_')          // Spaces to underscores\n      .substring(0, 100);            // Limit length\n  },\n  \n  /**\n   * Parse query parameters from URL\n   * @returns {Object} - Object with query params\n   */\n  parseQueryParams() {\n    const params = {};\n    const queryString = window.location.search.substring(1);\n    \n    if (!queryString) return params;\n    \n    const pairs = queryString.split('&');\n    \n    for (let i = 0; i < pairs.length; i++) {\n      const pair = pairs[i].split('=');\n      params[decodeURIComponent(pair[0])] = pair[1] ? decodeURIComponent(pair[1]) : '';\n    }\n    \n    return params;\n  },\n  \n  /**\n   * Convert an object to query string\n   * @param {Object} params - Parameters to convert\n   * @returns {string} - Query string\n   */\n  toQueryString(params) {\n    return Object.keys(params)\n      .filter(key => params[key] !== undefined && params[key] !== null)\n      .map(key => encodeURIComponent(key) + '=' + encodeURIComponent(params[key]))\n      .join('&');\n  },\n  \n  /**\n   * Detect file type from extension\n   * @param {string} filename - Filename to check\n   * @returns {string} - File type description\n   */\n  getFileType(filename) {\n    if (!filename) return 'Unknown';\n    \n    const extension = filename.split('.').pop().toLowerCase();\n    \n    const fileTypes = {\n      // Text files\n      'txt': 'Text File',\n      'md': 'Markdown Document',\n      'csv': 'CSV Spreadsheet',\n      'json': 'JSON Data',\n      'xml': 'XML Document',\n      'html': 'HTML Document',\n      'css': 'CSS Stylesheet',\n      'js': 'JavaScript File',\n      'py': 'Python Script',\n      'java': 'Java Source File',\n      'c': 'C Source File',\n      'cpp': 'C++ Source File',\n      'h': 'C/C++ Header File',\n      'rb': 'Ruby Script',\n      'php': 'PHP Script',\n      \n      // Document files\n      'pdf': 'PDF Document',\n      'doc': 'Word Document',\n      'docx': 'Word Document',\n      'xls': 'Excel Spreadsheet',\n      'xlsx': 'Excel Spreadsheet',\n      'ppt': 'PowerPoint Presentation',\n      'pptx': 'PowerPoint Presentation',\n      'odt': 'OpenDocument Text',\n      'ods': 'OpenDocument Spreadsheet',\n      'odp': 'OpenDocument Presentation',\n      \n      // Image files\n      'jpg': 'JPEG Image',\n      'jpeg': 'JPEG Image',\n      'png': 'PNG Image',\n      'gif': 'GIF Image',\n      'bmp': 'Bitmap Image',\n      'svg': 'SVG Image',\n      'webp': 'WebP Image',\n      'tif': 'TIFF Image',\n      'tiff': 'TIFF Image',\n      \n      // Audio files\n      'mp3': 'MP3 Audio',\n      'wav': 'WAV Audio',\n      'ogg': 'OGG Audio',\n      'flac': 'FLAC Audio',\n      'm4a': 'M4A Audio',\n      \n      // Video files\n      'mp4': 'MP4 Video',\n      'avi': 'AVI Video',\n      'mov': 'MOV Video',\n      'wmv': 'Windows Media Video',\n      'mkv': 'MKV Video',\n      'webm': 'WebM Video',\n      \n      // Archive files\n      'zip': 'ZIP Archive',\n      'rar': 'RAR Archive',\n      'tar': 'TAR Archive',\n      'gz': 'GZIP Archive',\n      '7z': '7-Zip Archive',\n      \n      // Other files\n      'exe': 'Windows Executable',\n      'dmg': 'macOS Disk Image',\n      'iso': 'Disk Image',\n      'db': 'Database File'\n    };\n    \n    return fileTypes[extension] || 'Unknown';\n  },\n  \n  /**\n   * Check if a file type is supported by the application\n   * @param {string} filename - Filename to check\n   * @returns {boolean} - Whether the file is supported\n   */\n  isSupportedFileType(filename) {\n    if (!filename) return false;\n    \n    const extension = filename.split('.').pop().toLowerCase();\n    \n    // List of supported extensions\n    const supportedExtensions = [\n      // Text files\n      'txt', 'md', 'csv', 'json', 'xml', 'html', 'css', 'js', 'py', 'java', 'c', 'cpp', 'h',\n      \n      // Document files\n      'pdf', 'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'odt',\n      \n      // Image files\n      'jpg', 'jpeg', 'png', 'gif'\n    ];\n    \n    return supportedExtensions.includes(extension);\n  },\n  \n  /**\n   * Get a readable file size\n   * @param {File|Object} file - File object or {size: number}\n   * @returns {string} - Readable file size\n   */\n  getReadableFileSize(file) {\n    if (!file || (typeof file.size !== 'number')) return 'Unknown size';\n    \n    return this.formatBytes(file.size);\n  },\n  \n  /**\n   * Try to execute a function safely with error handling\n   * @param {Function} fn - Function to execute\n   * @param {*} fallbackValue - Value to return if execution fails\n   * @param {Array} args - Arguments to pass to the function\n   * @returns {*} - Function result or fallback value\n   */\n  trySafe(fn, fallbackValue, ...args) {\n    try {\n      return fn(...args);\n    } catch (error) {\n      console.error(\"Error in trySafe execution:\", error);\n      return fallbackValue;\n    }\n  },\n  \n  /**\n   * Check if a value is empty (null, undefined, empty string, empty array, empty object)\n   * @param {*} value - Value to check\n   * @returns {boolean} - Whether the value is empty\n   */\n  isEmpty(value) {\n    if (value === null || value === undefined) return true;\n    if (typeof value === 'string') return value.trim() === '';\n    if (Array.isArray(value)) return value.length === 0;\n    if (typeof value === 'object') return Object.keys(value).length === 0;\n    return false;\n  },\n  \n  /**\n   * Get a value from a nested object safely\n   * @param {Object} obj - Object to get value from\n   * @param {string} path - Path to the value (e.g., \"user.profile.name\")\n   * @param {*} defaultValue - Default value if path doesn't exist\n   * @returns {*} - Value at path or default value\n   */\n  getNestedValue(obj, path, defaultValue = undefined) {\n    if (!obj || !path) return defaultValue;\n    \n    const keys = path.split('.');\n    let result = obj;\n    \n    for (const key of keys) {\n      if (result === null || result === undefined || typeof result !== 'object') {\n        return defaultValue;\n      }\n      \n      result = result[key];\n    }\n    \n    return result === undefined ? defaultValue : result;\n  },\n  \n  /**\n   * Validate an email address\n   * @param {string} email - Email address to validate\n   * @returns {boolean} - Whether the email is valid\n   */\n  isValidEmail(email) {\n    if (!email) return false;\n    \n    // Basic email validation regex\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  },\n  \n  /**\n   * Check if the current environment is development\n   * @returns {boolean} - Whether the current environment is development\n   */\n  isDevelopment() {\n    return window.location.hostname === 'localhost' || \n           window.location.hostname === '127.0.0.1' || \n           window.location.hostname.includes('dev.') ||\n           window.location.hostname.includes('.local');\n  }\n};\n\n// Export the module\nexport default utils;\n\n// Also export named functions for direct imports\nexport const {\n  formatBytes,\n  formatDuration,\n  generateId,\n  delay,\n  debounce,\n  throttle,\n  escapeHtml,\n  formatDate,\n  formatRelativeTime,\n  copyToClipboard,\n  truncateText,\n  getFilenameFromPath,\n  formatJsonForDisplay,\n  sanitizeFilename,\n  parseQueryParams,\n  toQueryString,\n  getFileType,\n  isSupportedFileType,\n  getReadableFileSize,\n  trySafe,\n  isEmpty,\n  getNestedValue,\n  isValidEmail,\n  isDevelopment\n} = utils;","source":"/workspace/modules/static/js/modules/utils/utils.js","title":"utils.js","language":"en"}]}}